/*!
  * mapfre : Angular Parent Mapfre
  * @version v5.4.0
  * @author Marcos Peralta <marcos.peralta@konecta.com.py>
  * @date 2019-08-06
  */

if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('./sw.js')
    .then(function(){
      console.log('Registro de SW exitoso', reg)
    })
    .catch(function(){
      console.warn('Error al tratar de registrar el sw', err)
  })
}
;/*! jQuery v3.4.1 | (c) JS Foundation and other contributors | jquery.org/license */
!function(e,t){"use strict";"object"==typeof module&&"object"==typeof module.exports?module.exports=e.document?t(e,!0):function(e){if(!e.document)throw new Error("jQuery requires a window with a document");return t(e)}:t(e)}("undefined"!=typeof window?window:this,function(C,e){"use strict";var t=[],E=C.document,r=Object.getPrototypeOf,s=t.slice,g=t.concat,u=t.push,i=t.indexOf,n={},o=n.toString,v=n.hasOwnProperty,a=v.toString,l=a.call(Object),y={},m=function(e){return"function"==typeof e&&"number"!=typeof e.nodeType},x=function(e){return null!=e&&e===e.window},c={type:!0,src:!0,nonce:!0,noModule:!0};function b(e,t,n){var r,i,o=(n=n||E).createElement("script");if(o.text=e,t)for(r in c)(i=t[r]||t.getAttribute&&t.getAttribute(r))&&o.setAttribute(r,i);n.head.appendChild(o).parentNode.removeChild(o)}function w(e){return null==e?e+"":"object"==typeof e||"function"==typeof e?n[o.call(e)]||"object":typeof e}var f="3.4.1",k=function(e,t){return new k.fn.init(e,t)},p=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;function d(e){var t=!!e&&"length"in e&&e.length,n=w(e);return!m(e)&&!x(e)&&("array"===n||0===t||"number"==typeof t&&0<t&&t-1 in e)}k.fn=k.prototype={jquery:f,constructor:k,length:0,toArray:function(){return s.call(this)},get:function(e){return null==e?s.call(this):e<0?this[e+this.length]:this[e]},pushStack:function(e){var t=k.merge(this.constructor(),e);return t.prevObject=this,t},each:function(e){return k.each(this,e)},map:function(n){return this.pushStack(k.map(this,function(e,t){return n.call(e,t,e)}))},slice:function(){return this.pushStack(s.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(e){var t=this.length,n=+e+(e<0?t:0);return this.pushStack(0<=n&&n<t?[this[n]]:[])},end:function(){return this.prevObject||this.constructor()},push:u,sort:t.sort,splice:t.splice},k.extend=k.fn.extend=function(){var e,t,n,r,i,o,a=arguments[0]||{},s=1,u=arguments.length,l=!1;for("boolean"==typeof a&&(l=a,a=arguments[s]||{},s++),"object"==typeof a||m(a)||(a={}),s===u&&(a=this,s--);s<u;s++)if(null!=(e=arguments[s]))for(t in e)r=e[t],"__proto__"!==t&&a!==r&&(l&&r&&(k.isPlainObject(r)||(i=Array.isArray(r)))?(n=a[t],o=i&&!Array.isArray(n)?[]:i||k.isPlainObject(n)?n:{},i=!1,a[t]=k.extend(l,o,r)):void 0!==r&&(a[t]=r));return a},k.extend({expando:"jQuery"+(f+Math.random()).replace(/\D/g,""),isReady:!0,error:function(e){throw new Error(e)},noop:function(){},isPlainObject:function(e){var t,n;return!(!e||"[object Object]"!==o.call(e))&&(!(t=r(e))||"function"==typeof(n=v.call(t,"constructor")&&t.constructor)&&a.call(n)===l)},isEmptyObject:function(e){var t;for(t in e)return!1;return!0},globalEval:function(e,t){b(e,{nonce:t&&t.nonce})},each:function(e,t){var n,r=0;if(d(e)){for(n=e.length;r<n;r++)if(!1===t.call(e[r],r,e[r]))break}else for(r in e)if(!1===t.call(e[r],r,e[r]))break;return e},trim:function(e){return null==e?"":(e+"").replace(p,"")},makeArray:function(e,t){var n=t||[];return null!=e&&(d(Object(e))?k.merge(n,"string"==typeof e?[e]:e):u.call(n,e)),n},inArray:function(e,t,n){return null==t?-1:i.call(t,e,n)},merge:function(e,t){for(var n=+t.length,r=0,i=e.length;r<n;r++)e[i++]=t[r];return e.length=i,e},grep:function(e,t,n){for(var r=[],i=0,o=e.length,a=!n;i<o;i++)!t(e[i],i)!==a&&r.push(e[i]);return r},map:function(e,t,n){var r,i,o=0,a=[];if(d(e))for(r=e.length;o<r;o++)null!=(i=t(e[o],o,n))&&a.push(i);else for(o in e)null!=(i=t(e[o],o,n))&&a.push(i);return g.apply([],a)},guid:1,support:y}),"function"==typeof Symbol&&(k.fn[Symbol.iterator]=t[Symbol.iterator]),k.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),function(e,t){n["[object "+t+"]"]=t.toLowerCase()});var h=function(n){var e,d,b,o,i,h,f,g,w,u,l,T,C,a,E,v,s,c,y,k="sizzle"+1*new Date,m=n.document,S=0,r=0,p=ue(),x=ue(),N=ue(),A=ue(),D=function(e,t){return e===t&&(l=!0),0},j={}.hasOwnProperty,t=[],q=t.pop,L=t.push,H=t.push,O=t.slice,P=function(e,t){for(var n=0,r=e.length;n<r;n++)if(e[n]===t)return n;return-1},R="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",M="[\\x20\\t\\r\\n\\f]",I="(?:\\\\.|[\\w-]|[^\0-\\xa0])+",W="\\["+M+"*("+I+")(?:"+M+"*([*^$|!~]?=)"+M+"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|("+I+"))|)"+M+"*\\]",$=":("+I+")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|"+W+")*)|.*)\\)|)",F=new RegExp(M+"+","g"),B=new RegExp("^"+M+"+|((?:^|[^\\\\])(?:\\\\.)*)"+M+"+$","g"),_=new RegExp("^"+M+"*,"+M+"*"),z=new RegExp("^"+M+"*([>+~]|"+M+")"+M+"*"),U=new RegExp(M+"|>"),X=new RegExp($),V=new RegExp("^"+I+"$"),G={ID:new RegExp("^#("+I+")"),CLASS:new RegExp("^\\.("+I+")"),TAG:new RegExp("^("+I+"|[*])"),ATTR:new RegExp("^"+W),PSEUDO:new RegExp("^"+$),CHILD:new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+M+"*(even|odd|(([+-]|)(\\d*)n|)"+M+"*(?:([+-]|)"+M+"*(\\d+)|))"+M+"*\\)|)","i"),bool:new RegExp("^(?:"+R+")$","i"),needsContext:new RegExp("^"+M+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+M+"*((?:-\\d)?\\d*)"+M+"*\\)|)(?=[^-]|$)","i")},Y=/HTML$/i,Q=/^(?:input|select|textarea|button)$/i,J=/^h\d$/i,K=/^[^{]+\{\s*\[native \w/,Z=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,ee=/[+~]/,te=new RegExp("\\\\([\\da-f]{1,6}"+M+"?|("+M+")|.)","ig"),ne=function(e,t,n){var r="0x"+t-65536;return r!=r||n?t:r<0?String.fromCharCode(r+65536):String.fromCharCode(r>>10|55296,1023&r|56320)},re=/([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,ie=function(e,t){return t?"\0"===e?"\ufffd":e.slice(0,-1)+"\\"+e.charCodeAt(e.length-1).toString(16)+" ":"\\"+e},oe=function(){T()},ae=be(function(e){return!0===e.disabled&&"fieldset"===e.nodeName.toLowerCase()},{dir:"parentNode",next:"legend"});try{H.apply(t=O.call(m.childNodes),m.childNodes),t[m.childNodes.length].nodeType}catch(e){H={apply:t.length?function(e,t){L.apply(e,O.call(t))}:function(e,t){var n=e.length,r=0;while(e[n++]=t[r++]);e.length=n-1}}}function se(t,e,n,r){var i,o,a,s,u,l,c,f=e&&e.ownerDocument,p=e?e.nodeType:9;if(n=n||[],"string"!=typeof t||!t||1!==p&&9!==p&&11!==p)return n;if(!r&&((e?e.ownerDocument||e:m)!==C&&T(e),e=e||C,E)){if(11!==p&&(u=Z.exec(t)))if(i=u[1]){if(9===p){if(!(a=e.getElementById(i)))return n;if(a.id===i)return n.push(a),n}else if(f&&(a=f.getElementById(i))&&y(e,a)&&a.id===i)return n.push(a),n}else{if(u[2])return H.apply(n,e.getElementsByTagName(t)),n;if((i=u[3])&&d.getElementsByClassName&&e.getElementsByClassName)return H.apply(n,e.getElementsByClassName(i)),n}if(d.qsa&&!A[t+" "]&&(!v||!v.test(t))&&(1!==p||"object"!==e.nodeName.toLowerCase())){if(c=t,f=e,1===p&&U.test(t)){(s=e.getAttribute("id"))?s=s.replace(re,ie):e.setAttribute("id",s=k),o=(l=h(t)).length;while(o--)l[o]="#"+s+" "+xe(l[o]);c=l.join(","),f=ee.test(t)&&ye(e.parentNode)||e}try{return H.apply(n,f.querySelectorAll(c)),n}catch(e){A(t,!0)}finally{s===k&&e.removeAttribute("id")}}}return g(t.replace(B,"$1"),e,n,r)}function ue(){var r=[];return function e(t,n){return r.push(t+" ")>b.cacheLength&&delete e[r.shift()],e[t+" "]=n}}function le(e){return e[k]=!0,e}function ce(e){var t=C.createElement("fieldset");try{return!!e(t)}catch(e){return!1}finally{t.parentNode&&t.parentNode.removeChild(t),t=null}}function fe(e,t){var n=e.split("|"),r=n.length;while(r--)b.attrHandle[n[r]]=t}function pe(e,t){var n=t&&e,r=n&&1===e.nodeType&&1===t.nodeType&&e.sourceIndex-t.sourceIndex;if(r)return r;if(n)while(n=n.nextSibling)if(n===t)return-1;return e?1:-1}function de(t){return function(e){return"input"===e.nodeName.toLowerCase()&&e.type===t}}function he(n){return function(e){var t=e.nodeName.toLowerCase();return("input"===t||"button"===t)&&e.type===n}}function ge(t){return function(e){return"form"in e?e.parentNode&&!1===e.disabled?"label"in e?"label"in e.parentNode?e.parentNode.disabled===t:e.disabled===t:e.isDisabled===t||e.isDisabled!==!t&&ae(e)===t:e.disabled===t:"label"in e&&e.disabled===t}}function ve(a){return le(function(o){return o=+o,le(function(e,t){var n,r=a([],e.length,o),i=r.length;while(i--)e[n=r[i]]&&(e[n]=!(t[n]=e[n]))})})}function ye(e){return e&&"undefined"!=typeof e.getElementsByTagName&&e}for(e in d=se.support={},i=se.isXML=function(e){var t=e.namespaceURI,n=(e.ownerDocument||e).documentElement;return!Y.test(t||n&&n.nodeName||"HTML")},T=se.setDocument=function(e){var t,n,r=e?e.ownerDocument||e:m;return r!==C&&9===r.nodeType&&r.documentElement&&(a=(C=r).documentElement,E=!i(C),m!==C&&(n=C.defaultView)&&n.top!==n&&(n.addEventListener?n.addEventListener("unload",oe,!1):n.attachEvent&&n.attachEvent("onunload",oe)),d.attributes=ce(function(e){return e.className="i",!e.getAttribute("className")}),d.getElementsByTagName=ce(function(e){return e.appendChild(C.createComment("")),!e.getElementsByTagName("*").length}),d.getElementsByClassName=K.test(C.getElementsByClassName),d.getById=ce(function(e){return a.appendChild(e).id=k,!C.getElementsByName||!C.getElementsByName(k).length}),d.getById?(b.filter.ID=function(e){var t=e.replace(te,ne);return function(e){return e.getAttribute("id")===t}},b.find.ID=function(e,t){if("undefined"!=typeof t.getElementById&&E){var n=t.getElementById(e);return n?[n]:[]}}):(b.filter.ID=function(e){var n=e.replace(te,ne);return function(e){var t="undefined"!=typeof e.getAttributeNode&&e.getAttributeNode("id");return t&&t.value===n}},b.find.ID=function(e,t){if("undefined"!=typeof t.getElementById&&E){var n,r,i,o=t.getElementById(e);if(o){if((n=o.getAttributeNode("id"))&&n.value===e)return[o];i=t.getElementsByName(e),r=0;while(o=i[r++])if((n=o.getAttributeNode("id"))&&n.value===e)return[o]}return[]}}),b.find.TAG=d.getElementsByTagName?function(e,t){return"undefined"!=typeof t.getElementsByTagName?t.getElementsByTagName(e):d.qsa?t.querySelectorAll(e):void 0}:function(e,t){var n,r=[],i=0,o=t.getElementsByTagName(e);if("*"===e){while(n=o[i++])1===n.nodeType&&r.push(n);return r}return o},b.find.CLASS=d.getElementsByClassName&&function(e,t){if("undefined"!=typeof t.getElementsByClassName&&E)return t.getElementsByClassName(e)},s=[],v=[],(d.qsa=K.test(C.querySelectorAll))&&(ce(function(e){a.appendChild(e).innerHTML="<a id='"+k+"'></a><select id='"+k+"-\r\\' msallowcapture=''><option selected=''></option></select>",e.querySelectorAll("[msallowcapture^='']").length&&v.push("[*^$]="+M+"*(?:''|\"\")"),e.querySelectorAll("[selected]").length||v.push("\\["+M+"*(?:value|"+R+")"),e.querySelectorAll("[id~="+k+"-]").length||v.push("~="),e.querySelectorAll(":checked").length||v.push(":checked"),e.querySelectorAll("a#"+k+"+*").length||v.push(".#.+[+~]")}),ce(function(e){e.innerHTML="<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";var t=C.createElement("input");t.setAttribute("type","hidden"),e.appendChild(t).setAttribute("name","D"),e.querySelectorAll("[name=d]").length&&v.push("name"+M+"*[*^$|!~]?="),2!==e.querySelectorAll(":enabled").length&&v.push(":enabled",":disabled"),a.appendChild(e).disabled=!0,2!==e.querySelectorAll(":disabled").length&&v.push(":enabled",":disabled"),e.querySelectorAll("*,:x"),v.push(",.*:")})),(d.matchesSelector=K.test(c=a.matches||a.webkitMatchesSelector||a.mozMatchesSelector||a.oMatchesSelector||a.msMatchesSelector))&&ce(function(e){d.disconnectedMatch=c.call(e,"*"),c.call(e,"[s!='']:x"),s.push("!=",$)}),v=v.length&&new RegExp(v.join("|")),s=s.length&&new RegExp(s.join("|")),t=K.test(a.compareDocumentPosition),y=t||K.test(a.contains)?function(e,t){var n=9===e.nodeType?e.documentElement:e,r=t&&t.parentNode;return e===r||!(!r||1!==r.nodeType||!(n.contains?n.contains(r):e.compareDocumentPosition&&16&e.compareDocumentPosition(r)))}:function(e,t){if(t)while(t=t.parentNode)if(t===e)return!0;return!1},D=t?function(e,t){if(e===t)return l=!0,0;var n=!e.compareDocumentPosition-!t.compareDocumentPosition;return n||(1&(n=(e.ownerDocument||e)===(t.ownerDocument||t)?e.compareDocumentPosition(t):1)||!d.sortDetached&&t.compareDocumentPosition(e)===n?e===C||e.ownerDocument===m&&y(m,e)?-1:t===C||t.ownerDocument===m&&y(m,t)?1:u?P(u,e)-P(u,t):0:4&n?-1:1)}:function(e,t){if(e===t)return l=!0,0;var n,r=0,i=e.parentNode,o=t.parentNode,a=[e],s=[t];if(!i||!o)return e===C?-1:t===C?1:i?-1:o?1:u?P(u,e)-P(u,t):0;if(i===o)return pe(e,t);n=e;while(n=n.parentNode)a.unshift(n);n=t;while(n=n.parentNode)s.unshift(n);while(a[r]===s[r])r++;return r?pe(a[r],s[r]):a[r]===m?-1:s[r]===m?1:0}),C},se.matches=function(e,t){return se(e,null,null,t)},se.matchesSelector=function(e,t){if((e.ownerDocument||e)!==C&&T(e),d.matchesSelector&&E&&!A[t+" "]&&(!s||!s.test(t))&&(!v||!v.test(t)))try{var n=c.call(e,t);if(n||d.disconnectedMatch||e.document&&11!==e.document.nodeType)return n}catch(e){A(t,!0)}return 0<se(t,C,null,[e]).length},se.contains=function(e,t){return(e.ownerDocument||e)!==C&&T(e),y(e,t)},se.attr=function(e,t){(e.ownerDocument||e)!==C&&T(e);var n=b.attrHandle[t.toLowerCase()],r=n&&j.call(b.attrHandle,t.toLowerCase())?n(e,t,!E):void 0;return void 0!==r?r:d.attributes||!E?e.getAttribute(t):(r=e.getAttributeNode(t))&&r.specified?r.value:null},se.escape=function(e){return(e+"").replace(re,ie)},se.error=function(e){throw new Error("Syntax error, unrecognized expression: "+e)},se.uniqueSort=function(e){var t,n=[],r=0,i=0;if(l=!d.detectDuplicates,u=!d.sortStable&&e.slice(0),e.sort(D),l){while(t=e[i++])t===e[i]&&(r=n.push(i));while(r--)e.splice(n[r],1)}return u=null,e},o=se.getText=function(e){var t,n="",r=0,i=e.nodeType;if(i){if(1===i||9===i||11===i){if("string"==typeof e.textContent)return e.textContent;for(e=e.firstChild;e;e=e.nextSibling)n+=o(e)}else if(3===i||4===i)return e.nodeValue}else while(t=e[r++])n+=o(t);return n},(b=se.selectors={cacheLength:50,createPseudo:le,match:G,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(e){return e[1]=e[1].replace(te,ne),e[3]=(e[3]||e[4]||e[5]||"").replace(te,ne),"~="===e[2]&&(e[3]=" "+e[3]+" "),e.slice(0,4)},CHILD:function(e){return e[1]=e[1].toLowerCase(),"nth"===e[1].slice(0,3)?(e[3]||se.error(e[0]),e[4]=+(e[4]?e[5]+(e[6]||1):2*("even"===e[3]||"odd"===e[3])),e[5]=+(e[7]+e[8]||"odd"===e[3])):e[3]&&se.error(e[0]),e},PSEUDO:function(e){var t,n=!e[6]&&e[2];return G.CHILD.test(e[0])?null:(e[3]?e[2]=e[4]||e[5]||"":n&&X.test(n)&&(t=h(n,!0))&&(t=n.indexOf(")",n.length-t)-n.length)&&(e[0]=e[0].slice(0,t),e[2]=n.slice(0,t)),e.slice(0,3))}},filter:{TAG:function(e){var t=e.replace(te,ne).toLowerCase();return"*"===e?function(){return!0}:function(e){return e.nodeName&&e.nodeName.toLowerCase()===t}},CLASS:function(e){var t=p[e+" "];return t||(t=new RegExp("(^|"+M+")"+e+"("+M+"|$)"))&&p(e,function(e){return t.test("string"==typeof e.className&&e.className||"undefined"!=typeof e.getAttribute&&e.getAttribute("class")||"")})},ATTR:function(n,r,i){return function(e){var t=se.attr(e,n);return null==t?"!="===r:!r||(t+="","="===r?t===i:"!="===r?t!==i:"^="===r?i&&0===t.indexOf(i):"*="===r?i&&-1<t.indexOf(i):"$="===r?i&&t.slice(-i.length)===i:"~="===r?-1<(" "+t.replace(F," ")+" ").indexOf(i):"|="===r&&(t===i||t.slice(0,i.length+1)===i+"-"))}},CHILD:function(h,e,t,g,v){var y="nth"!==h.slice(0,3),m="last"!==h.slice(-4),x="of-type"===e;return 1===g&&0===v?function(e){return!!e.parentNode}:function(e,t,n){var r,i,o,a,s,u,l=y!==m?"nextSibling":"previousSibling",c=e.parentNode,f=x&&e.nodeName.toLowerCase(),p=!n&&!x,d=!1;if(c){if(y){while(l){a=e;while(a=a[l])if(x?a.nodeName.toLowerCase()===f:1===a.nodeType)return!1;u=l="only"===h&&!u&&"nextSibling"}return!0}if(u=[m?c.firstChild:c.lastChild],m&&p){d=(s=(r=(i=(o=(a=c)[k]||(a[k]={}))[a.uniqueID]||(o[a.uniqueID]={}))[h]||[])[0]===S&&r[1])&&r[2],a=s&&c.childNodes[s];while(a=++s&&a&&a[l]||(d=s=0)||u.pop())if(1===a.nodeType&&++d&&a===e){i[h]=[S,s,d];break}}else if(p&&(d=s=(r=(i=(o=(a=e)[k]||(a[k]={}))[a.uniqueID]||(o[a.uniqueID]={}))[h]||[])[0]===S&&r[1]),!1===d)while(a=++s&&a&&a[l]||(d=s=0)||u.pop())if((x?a.nodeName.toLowerCase()===f:1===a.nodeType)&&++d&&(p&&((i=(o=a[k]||(a[k]={}))[a.uniqueID]||(o[a.uniqueID]={}))[h]=[S,d]),a===e))break;return(d-=v)===g||d%g==0&&0<=d/g}}},PSEUDO:function(e,o){var t,a=b.pseudos[e]||b.setFilters[e.toLowerCase()]||se.error("unsupported pseudo: "+e);return a[k]?a(o):1<a.length?(t=[e,e,"",o],b.setFilters.hasOwnProperty(e.toLowerCase())?le(function(e,t){var n,r=a(e,o),i=r.length;while(i--)e[n=P(e,r[i])]=!(t[n]=r[i])}):function(e){return a(e,0,t)}):a}},pseudos:{not:le(function(e){var r=[],i=[],s=f(e.replace(B,"$1"));return s[k]?le(function(e,t,n,r){var i,o=s(e,null,r,[]),a=e.length;while(a--)(i=o[a])&&(e[a]=!(t[a]=i))}):function(e,t,n){return r[0]=e,s(r,null,n,i),r[0]=null,!i.pop()}}),has:le(function(t){return function(e){return 0<se(t,e).length}}),contains:le(function(t){return t=t.replace(te,ne),function(e){return-1<(e.textContent||o(e)).indexOf(t)}}),lang:le(function(n){return V.test(n||"")||se.error("unsupported lang: "+n),n=n.replace(te,ne).toLowerCase(),function(e){var t;do{if(t=E?e.lang:e.getAttribute("xml:lang")||e.getAttribute("lang"))return(t=t.toLowerCase())===n||0===t.indexOf(n+"-")}while((e=e.parentNode)&&1===e.nodeType);return!1}}),target:function(e){var t=n.location&&n.location.hash;return t&&t.slice(1)===e.id},root:function(e){return e===a},focus:function(e){return e===C.activeElement&&(!C.hasFocus||C.hasFocus())&&!!(e.type||e.href||~e.tabIndex)},enabled:ge(!1),disabled:ge(!0),checked:function(e){var t=e.nodeName.toLowerCase();return"input"===t&&!!e.checked||"option"===t&&!!e.selected},selected:function(e){return e.parentNode&&e.parentNode.selectedIndex,!0===e.selected},empty:function(e){for(e=e.firstChild;e;e=e.nextSibling)if(e.nodeType<6)return!1;return!0},parent:function(e){return!b.pseudos.empty(e)},header:function(e){return J.test(e.nodeName)},input:function(e){return Q.test(e.nodeName)},button:function(e){var t=e.nodeName.toLowerCase();return"input"===t&&"button"===e.type||"button"===t},text:function(e){var t;return"input"===e.nodeName.toLowerCase()&&"text"===e.type&&(null==(t=e.getAttribute("type"))||"text"===t.toLowerCase())},first:ve(function(){return[0]}),last:ve(function(e,t){return[t-1]}),eq:ve(function(e,t,n){return[n<0?n+t:n]}),even:ve(function(e,t){for(var n=0;n<t;n+=2)e.push(n);return e}),odd:ve(function(e,t){for(var n=1;n<t;n+=2)e.push(n);return e}),lt:ve(function(e,t,n){for(var r=n<0?n+t:t<n?t:n;0<=--r;)e.push(r);return e}),gt:ve(function(e,t,n){for(var r=n<0?n+t:n;++r<t;)e.push(r);return e})}}).pseudos.nth=b.pseudos.eq,{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})b.pseudos[e]=de(e);for(e in{submit:!0,reset:!0})b.pseudos[e]=he(e);function me(){}function xe(e){for(var t=0,n=e.length,r="";t<n;t++)r+=e[t].value;return r}function be(s,e,t){var u=e.dir,l=e.next,c=l||u,f=t&&"parentNode"===c,p=r++;return e.first?function(e,t,n){while(e=e[u])if(1===e.nodeType||f)return s(e,t,n);return!1}:function(e,t,n){var r,i,o,a=[S,p];if(n){while(e=e[u])if((1===e.nodeType||f)&&s(e,t,n))return!0}else while(e=e[u])if(1===e.nodeType||f)if(i=(o=e[k]||(e[k]={}))[e.uniqueID]||(o[e.uniqueID]={}),l&&l===e.nodeName.toLowerCase())e=e[u]||e;else{if((r=i[c])&&r[0]===S&&r[1]===p)return a[2]=r[2];if((i[c]=a)[2]=s(e,t,n))return!0}return!1}}function we(i){return 1<i.length?function(e,t,n){var r=i.length;while(r--)if(!i[r](e,t,n))return!1;return!0}:i[0]}function Te(e,t,n,r,i){for(var o,a=[],s=0,u=e.length,l=null!=t;s<u;s++)(o=e[s])&&(n&&!n(o,r,i)||(a.push(o),l&&t.push(s)));return a}function Ce(d,h,g,v,y,e){return v&&!v[k]&&(v=Ce(v)),y&&!y[k]&&(y=Ce(y,e)),le(function(e,t,n,r){var i,o,a,s=[],u=[],l=t.length,c=e||function(e,t,n){for(var r=0,i=t.length;r<i;r++)se(e,t[r],n);return n}(h||"*",n.nodeType?[n]:n,[]),f=!d||!e&&h?c:Te(c,s,d,n,r),p=g?y||(e?d:l||v)?[]:t:f;if(g&&g(f,p,n,r),v){i=Te(p,u),v(i,[],n,r),o=i.length;while(o--)(a=i[o])&&(p[u[o]]=!(f[u[o]]=a))}if(e){if(y||d){if(y){i=[],o=p.length;while(o--)(a=p[o])&&i.push(f[o]=a);y(null,p=[],i,r)}o=p.length;while(o--)(a=p[o])&&-1<(i=y?P(e,a):s[o])&&(e[i]=!(t[i]=a))}}else p=Te(p===t?p.splice(l,p.length):p),y?y(null,t,p,r):H.apply(t,p)})}function Ee(e){for(var i,t,n,r=e.length,o=b.relative[e[0].type],a=o||b.relative[" "],s=o?1:0,u=be(function(e){return e===i},a,!0),l=be(function(e){return-1<P(i,e)},a,!0),c=[function(e,t,n){var r=!o&&(n||t!==w)||((i=t).nodeType?u(e,t,n):l(e,t,n));return i=null,r}];s<r;s++)if(t=b.relative[e[s].type])c=[be(we(c),t)];else{if((t=b.filter[e[s].type].apply(null,e[s].matches))[k]){for(n=++s;n<r;n++)if(b.relative[e[n].type])break;return Ce(1<s&&we(c),1<s&&xe(e.slice(0,s-1).concat({value:" "===e[s-2].type?"*":""})).replace(B,"$1"),t,s<n&&Ee(e.slice(s,n)),n<r&&Ee(e=e.slice(n)),n<r&&xe(e))}c.push(t)}return we(c)}return me.prototype=b.filters=b.pseudos,b.setFilters=new me,h=se.tokenize=function(e,t){var n,r,i,o,a,s,u,l=x[e+" "];if(l)return t?0:l.slice(0);a=e,s=[],u=b.preFilter;while(a){for(o in n&&!(r=_.exec(a))||(r&&(a=a.slice(r[0].length)||a),s.push(i=[])),n=!1,(r=z.exec(a))&&(n=r.shift(),i.push({value:n,type:r[0].replace(B," ")}),a=a.slice(n.length)),b.filter)!(r=G[o].exec(a))||u[o]&&!(r=u[o](r))||(n=r.shift(),i.push({value:n,type:o,matches:r}),a=a.slice(n.length));if(!n)break}return t?a.length:a?se.error(e):x(e,s).slice(0)},f=se.compile=function(e,t){var n,v,y,m,x,r,i=[],o=[],a=N[e+" "];if(!a){t||(t=h(e)),n=t.length;while(n--)(a=Ee(t[n]))[k]?i.push(a):o.push(a);(a=N(e,(v=o,m=0<(y=i).length,x=0<v.length,r=function(e,t,n,r,i){var o,a,s,u=0,l="0",c=e&&[],f=[],p=w,d=e||x&&b.find.TAG("*",i),h=S+=null==p?1:Math.random()||.1,g=d.length;for(i&&(w=t===C||t||i);l!==g&&null!=(o=d[l]);l++){if(x&&o){a=0,t||o.ownerDocument===C||(T(o),n=!E);while(s=v[a++])if(s(o,t||C,n)){r.push(o);break}i&&(S=h)}m&&((o=!s&&o)&&u--,e&&c.push(o))}if(u+=l,m&&l!==u){a=0;while(s=y[a++])s(c,f,t,n);if(e){if(0<u)while(l--)c[l]||f[l]||(f[l]=q.call(r));f=Te(f)}H.apply(r,f),i&&!e&&0<f.length&&1<u+y.length&&se.uniqueSort(r)}return i&&(S=h,w=p),c},m?le(r):r))).selector=e}return a},g=se.select=function(e,t,n,r){var i,o,a,s,u,l="function"==typeof e&&e,c=!r&&h(e=l.selector||e);if(n=n||[],1===c.length){if(2<(o=c[0]=c[0].slice(0)).length&&"ID"===(a=o[0]).type&&9===t.nodeType&&E&&b.relative[o[1].type]){if(!(t=(b.find.ID(a.matches[0].replace(te,ne),t)||[])[0]))return n;l&&(t=t.parentNode),e=e.slice(o.shift().value.length)}i=G.needsContext.test(e)?0:o.length;while(i--){if(a=o[i],b.relative[s=a.type])break;if((u=b.find[s])&&(r=u(a.matches[0].replace(te,ne),ee.test(o[0].type)&&ye(t.parentNode)||t))){if(o.splice(i,1),!(e=r.length&&xe(o)))return H.apply(n,r),n;break}}}return(l||f(e,c))(r,t,!E,n,!t||ee.test(e)&&ye(t.parentNode)||t),n},d.sortStable=k.split("").sort(D).join("")===k,d.detectDuplicates=!!l,T(),d.sortDetached=ce(function(e){return 1&e.compareDocumentPosition(C.createElement("fieldset"))}),ce(function(e){return e.innerHTML="<a href='#'></a>","#"===e.firstChild.getAttribute("href")})||fe("type|href|height|width",function(e,t,n){if(!n)return e.getAttribute(t,"type"===t.toLowerCase()?1:2)}),d.attributes&&ce(function(e){return e.innerHTML="<input/>",e.firstChild.setAttribute("value",""),""===e.firstChild.getAttribute("value")})||fe("value",function(e,t,n){if(!n&&"input"===e.nodeName.toLowerCase())return e.defaultValue}),ce(function(e){return null==e.getAttribute("disabled")})||fe(R,function(e,t,n){var r;if(!n)return!0===e[t]?t.toLowerCase():(r=e.getAttributeNode(t))&&r.specified?r.value:null}),se}(C);k.find=h,k.expr=h.selectors,k.expr[":"]=k.expr.pseudos,k.uniqueSort=k.unique=h.uniqueSort,k.text=h.getText,k.isXMLDoc=h.isXML,k.contains=h.contains,k.escapeSelector=h.escape;var T=function(e,t,n){var r=[],i=void 0!==n;while((e=e[t])&&9!==e.nodeType)if(1===e.nodeType){if(i&&k(e).is(n))break;r.push(e)}return r},S=function(e,t){for(var n=[];e;e=e.nextSibling)1===e.nodeType&&e!==t&&n.push(e);return n},N=k.expr.match.needsContext;function A(e,t){return e.nodeName&&e.nodeName.toLowerCase()===t.toLowerCase()}var D=/^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;function j(e,n,r){return m(n)?k.grep(e,function(e,t){return!!n.call(e,t,e)!==r}):n.nodeType?k.grep(e,function(e){return e===n!==r}):"string"!=typeof n?k.grep(e,function(e){return-1<i.call(n,e)!==r}):k.filter(n,e,r)}k.filter=function(e,t,n){var r=t[0];return n&&(e=":not("+e+")"),1===t.length&&1===r.nodeType?k.find.matchesSelector(r,e)?[r]:[]:k.find.matches(e,k.grep(t,function(e){return 1===e.nodeType}))},k.fn.extend({find:function(e){var t,n,r=this.length,i=this;if("string"!=typeof e)return this.pushStack(k(e).filter(function(){for(t=0;t<r;t++)if(k.contains(i[t],this))return!0}));for(n=this.pushStack([]),t=0;t<r;t++)k.find(e,i[t],n);return 1<r?k.uniqueSort(n):n},filter:function(e){return this.pushStack(j(this,e||[],!1))},not:function(e){return this.pushStack(j(this,e||[],!0))},is:function(e){return!!j(this,"string"==typeof e&&N.test(e)?k(e):e||[],!1).length}});var q,L=/^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/;(k.fn.init=function(e,t,n){var r,i;if(!e)return this;if(n=n||q,"string"==typeof e){if(!(r="<"===e[0]&&">"===e[e.length-1]&&3<=e.length?[null,e,null]:L.exec(e))||!r[1]&&t)return!t||t.jquery?(t||n).find(e):this.constructor(t).find(e);if(r[1]){if(t=t instanceof k?t[0]:t,k.merge(this,k.parseHTML(r[1],t&&t.nodeType?t.ownerDocument||t:E,!0)),D.test(r[1])&&k.isPlainObject(t))for(r in t)m(this[r])?this[r](t[r]):this.attr(r,t[r]);return this}return(i=E.getElementById(r[2]))&&(this[0]=i,this.length=1),this}return e.nodeType?(this[0]=e,this.length=1,this):m(e)?void 0!==n.ready?n.ready(e):e(k):k.makeArray(e,this)}).prototype=k.fn,q=k(E);var H=/^(?:parents|prev(?:Until|All))/,O={children:!0,contents:!0,next:!0,prev:!0};function P(e,t){while((e=e[t])&&1!==e.nodeType);return e}k.fn.extend({has:function(e){var t=k(e,this),n=t.length;return this.filter(function(){for(var e=0;e<n;e++)if(k.contains(this,t[e]))return!0})},closest:function(e,t){var n,r=0,i=this.length,o=[],a="string"!=typeof e&&k(e);if(!N.test(e))for(;r<i;r++)for(n=this[r];n&&n!==t;n=n.parentNode)if(n.nodeType<11&&(a?-1<a.index(n):1===n.nodeType&&k.find.matchesSelector(n,e))){o.push(n);break}return this.pushStack(1<o.length?k.uniqueSort(o):o)},index:function(e){return e?"string"==typeof e?i.call(k(e),this[0]):i.call(this,e.jquery?e[0]:e):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(e,t){return this.pushStack(k.uniqueSort(k.merge(this.get(),k(e,t))))},addBack:function(e){return this.add(null==e?this.prevObject:this.prevObject.filter(e))}}),k.each({parent:function(e){var t=e.parentNode;return t&&11!==t.nodeType?t:null},parents:function(e){return T(e,"parentNode")},parentsUntil:function(e,t,n){return T(e,"parentNode",n)},next:function(e){return P(e,"nextSibling")},prev:function(e){return P(e,"previousSibling")},nextAll:function(e){return T(e,"nextSibling")},prevAll:function(e){return T(e,"previousSibling")},nextUntil:function(e,t,n){return T(e,"nextSibling",n)},prevUntil:function(e,t,n){return T(e,"previousSibling",n)},siblings:function(e){return S((e.parentNode||{}).firstChild,e)},children:function(e){return S(e.firstChild)},contents:function(e){return"undefined"!=typeof e.contentDocument?e.contentDocument:(A(e,"template")&&(e=e.content||e),k.merge([],e.childNodes))}},function(r,i){k.fn[r]=function(e,t){var n=k.map(this,i,e);return"Until"!==r.slice(-5)&&(t=e),t&&"string"==typeof t&&(n=k.filter(t,n)),1<this.length&&(O[r]||k.uniqueSort(n),H.test(r)&&n.reverse()),this.pushStack(n)}});var R=/[^\x20\t\r\n\f]+/g;function M(e){return e}function I(e){throw e}function W(e,t,n,r){var i;try{e&&m(i=e.promise)?i.call(e).done(t).fail(n):e&&m(i=e.then)?i.call(e,t,n):t.apply(void 0,[e].slice(r))}catch(e){n.apply(void 0,[e])}}k.Callbacks=function(r){var e,n;r="string"==typeof r?(e=r,n={},k.each(e.match(R)||[],function(e,t){n[t]=!0}),n):k.extend({},r);var i,t,o,a,s=[],u=[],l=-1,c=function(){for(a=a||r.once,o=i=!0;u.length;l=-1){t=u.shift();while(++l<s.length)!1===s[l].apply(t[0],t[1])&&r.stopOnFalse&&(l=s.length,t=!1)}r.memory||(t=!1),i=!1,a&&(s=t?[]:"")},f={add:function(){return s&&(t&&!i&&(l=s.length-1,u.push(t)),function n(e){k.each(e,function(e,t){m(t)?r.unique&&f.has(t)||s.push(t):t&&t.length&&"string"!==w(t)&&n(t)})}(arguments),t&&!i&&c()),this},remove:function(){return k.each(arguments,function(e,t){var n;while(-1<(n=k.inArray(t,s,n)))s.splice(n,1),n<=l&&l--}),this},has:function(e){return e?-1<k.inArray(e,s):0<s.length},empty:function(){return s&&(s=[]),this},disable:function(){return a=u=[],s=t="",this},disabled:function(){return!s},lock:function(){return a=u=[],t||i||(s=t=""),this},locked:function(){return!!a},fireWith:function(e,t){return a||(t=[e,(t=t||[]).slice?t.slice():t],u.push(t),i||c()),this},fire:function(){return f.fireWith(this,arguments),this},fired:function(){return!!o}};return f},k.extend({Deferred:function(e){var o=[["notify","progress",k.Callbacks("memory"),k.Callbacks("memory"),2],["resolve","done",k.Callbacks("once memory"),k.Callbacks("once memory"),0,"resolved"],["reject","fail",k.Callbacks("once memory"),k.Callbacks("once memory"),1,"rejected"]],i="pending",a={state:function(){return i},always:function(){return s.done(arguments).fail(arguments),this},"catch":function(e){return a.then(null,e)},pipe:function(){var i=arguments;return k.Deferred(function(r){k.each(o,function(e,t){var n=m(i[t[4]])&&i[t[4]];s[t[1]](function(){var e=n&&n.apply(this,arguments);e&&m(e.promise)?e.promise().progress(r.notify).done(r.resolve).fail(r.reject):r[t[0]+"With"](this,n?[e]:arguments)})}),i=null}).promise()},then:function(t,n,r){var u=0;function l(i,o,a,s){return function(){var n=this,r=arguments,e=function(){var e,t;if(!(i<u)){if((e=a.apply(n,r))===o.promise())throw new TypeError("Thenable self-resolution");t=e&&("object"==typeof e||"function"==typeof e)&&e.then,m(t)?s?t.call(e,l(u,o,M,s),l(u,o,I,s)):(u++,t.call(e,l(u,o,M,s),l(u,o,I,s),l(u,o,M,o.notifyWith))):(a!==M&&(n=void 0,r=[e]),(s||o.resolveWith)(n,r))}},t=s?e:function(){try{e()}catch(e){k.Deferred.exceptionHook&&k.Deferred.exceptionHook(e,t.stackTrace),u<=i+1&&(a!==I&&(n=void 0,r=[e]),o.rejectWith(n,r))}};i?t():(k.Deferred.getStackHook&&(t.stackTrace=k.Deferred.getStackHook()),C.setTimeout(t))}}return k.Deferred(function(e){o[0][3].add(l(0,e,m(r)?r:M,e.notifyWith)),o[1][3].add(l(0,e,m(t)?t:M)),o[2][3].add(l(0,e,m(n)?n:I))}).promise()},promise:function(e){return null!=e?k.extend(e,a):a}},s={};return k.each(o,function(e,t){var n=t[2],r=t[5];a[t[1]]=n.add,r&&n.add(function(){i=r},o[3-e][2].disable,o[3-e][3].disable,o[0][2].lock,o[0][3].lock),n.add(t[3].fire),s[t[0]]=function(){return s[t[0]+"With"](this===s?void 0:this,arguments),this},s[t[0]+"With"]=n.fireWith}),a.promise(s),e&&e.call(s,s),s},when:function(e){var n=arguments.length,t=n,r=Array(t),i=s.call(arguments),o=k.Deferred(),a=function(t){return function(e){r[t]=this,i[t]=1<arguments.length?s.call(arguments):e,--n||o.resolveWith(r,i)}};if(n<=1&&(W(e,o.done(a(t)).resolve,o.reject,!n),"pending"===o.state()||m(i[t]&&i[t].then)))return o.then();while(t--)W(i[t],a(t),o.reject);return o.promise()}});var $=/^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;k.Deferred.exceptionHook=function(e,t){C.console&&C.console.warn&&e&&$.test(e.name)&&C.console.warn("jQuery.Deferred exception: "+e.message,e.stack,t)},k.readyException=function(e){C.setTimeout(function(){throw e})};var F=k.Deferred();function B(){E.removeEventListener("DOMContentLoaded",B),C.removeEventListener("load",B),k.ready()}k.fn.ready=function(e){return F.then(e)["catch"](function(e){k.readyException(e)}),this},k.extend({isReady:!1,readyWait:1,ready:function(e){(!0===e?--k.readyWait:k.isReady)||(k.isReady=!0)!==e&&0<--k.readyWait||F.resolveWith(E,[k])}}),k.ready.then=F.then,"complete"===E.readyState||"loading"!==E.readyState&&!E.documentElement.doScroll?C.setTimeout(k.ready):(E.addEventListener("DOMContentLoaded",B),C.addEventListener("load",B));var _=function(e,t,n,r,i,o,a){var s=0,u=e.length,l=null==n;if("object"===w(n))for(s in i=!0,n)_(e,t,s,n[s],!0,o,a);else if(void 0!==r&&(i=!0,m(r)||(a=!0),l&&(a?(t.call(e,r),t=null):(l=t,t=function(e,t,n){return l.call(k(e),n)})),t))for(;s<u;s++)t(e[s],n,a?r:r.call(e[s],s,t(e[s],n)));return i?e:l?t.call(e):u?t(e[0],n):o},z=/^-ms-/,U=/-([a-z])/g;function X(e,t){return t.toUpperCase()}function V(e){return e.replace(z,"ms-").replace(U,X)}var G=function(e){return 1===e.nodeType||9===e.nodeType||!+e.nodeType};function Y(){this.expando=k.expando+Y.uid++}Y.uid=1,Y.prototype={cache:function(e){var t=e[this.expando];return t||(t={},G(e)&&(e.nodeType?e[this.expando]=t:Object.defineProperty(e,this.expando,{value:t,configurable:!0}))),t},set:function(e,t,n){var r,i=this.cache(e);if("string"==typeof t)i[V(t)]=n;else for(r in t)i[V(r)]=t[r];return i},get:function(e,t){return void 0===t?this.cache(e):e[this.expando]&&e[this.expando][V(t)]},access:function(e,t,n){return void 0===t||t&&"string"==typeof t&&void 0===n?this.get(e,t):(this.set(e,t,n),void 0!==n?n:t)},remove:function(e,t){var n,r=e[this.expando];if(void 0!==r){if(void 0!==t){n=(t=Array.isArray(t)?t.map(V):(t=V(t))in r?[t]:t.match(R)||[]).length;while(n--)delete r[t[n]]}(void 0===t||k.isEmptyObject(r))&&(e.nodeType?e[this.expando]=void 0:delete e[this.expando])}},hasData:function(e){var t=e[this.expando];return void 0!==t&&!k.isEmptyObject(t)}};var Q=new Y,J=new Y,K=/^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,Z=/[A-Z]/g;function ee(e,t,n){var r,i;if(void 0===n&&1===e.nodeType)if(r="data-"+t.replace(Z,"-$&").toLowerCase(),"string"==typeof(n=e.getAttribute(r))){try{n="true"===(i=n)||"false"!==i&&("null"===i?null:i===+i+""?+i:K.test(i)?JSON.parse(i):i)}catch(e){}J.set(e,t,n)}else n=void 0;return n}k.extend({hasData:function(e){return J.hasData(e)||Q.hasData(e)},data:function(e,t,n){return J.access(e,t,n)},removeData:function(e,t){J.remove(e,t)},_data:function(e,t,n){return Q.access(e,t,n)},_removeData:function(e,t){Q.remove(e,t)}}),k.fn.extend({data:function(n,e){var t,r,i,o=this[0],a=o&&o.attributes;if(void 0===n){if(this.length&&(i=J.get(o),1===o.nodeType&&!Q.get(o,"hasDataAttrs"))){t=a.length;while(t--)a[t]&&0===(r=a[t].name).indexOf("data-")&&(r=V(r.slice(5)),ee(o,r,i[r]));Q.set(o,"hasDataAttrs",!0)}return i}return"object"==typeof n?this.each(function(){J.set(this,n)}):_(this,function(e){var t;if(o&&void 0===e)return void 0!==(t=J.get(o,n))?t:void 0!==(t=ee(o,n))?t:void 0;this.each(function(){J.set(this,n,e)})},null,e,1<arguments.length,null,!0)},removeData:function(e){return this.each(function(){J.remove(this,e)})}}),k.extend({queue:function(e,t,n){var r;if(e)return t=(t||"fx")+"queue",r=Q.get(e,t),n&&(!r||Array.isArray(n)?r=Q.access(e,t,k.makeArray(n)):r.push(n)),r||[]},dequeue:function(e,t){t=t||"fx";var n=k.queue(e,t),r=n.length,i=n.shift(),o=k._queueHooks(e,t);"inprogress"===i&&(i=n.shift(),r--),i&&("fx"===t&&n.unshift("inprogress"),delete o.stop,i.call(e,function(){k.dequeue(e,t)},o)),!r&&o&&o.empty.fire()},_queueHooks:function(e,t){var n=t+"queueHooks";return Q.get(e,n)||Q.access(e,n,{empty:k.Callbacks("once memory").add(function(){Q.remove(e,[t+"queue",n])})})}}),k.fn.extend({queue:function(t,n){var e=2;return"string"!=typeof t&&(n=t,t="fx",e--),arguments.length<e?k.queue(this[0],t):void 0===n?this:this.each(function(){var e=k.queue(this,t,n);k._queueHooks(this,t),"fx"===t&&"inprogress"!==e[0]&&k.dequeue(this,t)})},dequeue:function(e){return this.each(function(){k.dequeue(this,e)})},clearQueue:function(e){return this.queue(e||"fx",[])},promise:function(e,t){var n,r=1,i=k.Deferred(),o=this,a=this.length,s=function(){--r||i.resolveWith(o,[o])};"string"!=typeof e&&(t=e,e=void 0),e=e||"fx";while(a--)(n=Q.get(o[a],e+"queueHooks"))&&n.empty&&(r++,n.empty.add(s));return s(),i.promise(t)}});var te=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,ne=new RegExp("^(?:([+-])=|)("+te+")([a-z%]*)$","i"),re=["Top","Right","Bottom","Left"],ie=E.documentElement,oe=function(e){return k.contains(e.ownerDocument,e)},ae={composed:!0};ie.getRootNode&&(oe=function(e){return k.contains(e.ownerDocument,e)||e.getRootNode(ae)===e.ownerDocument});var se=function(e,t){return"none"===(e=t||e).style.display||""===e.style.display&&oe(e)&&"none"===k.css(e,"display")},ue=function(e,t,n,r){var i,o,a={};for(o in t)a[o]=e.style[o],e.style[o]=t[o];for(o in i=n.apply(e,r||[]),t)e.style[o]=a[o];return i};function le(e,t,n,r){var i,o,a=20,s=r?function(){return r.cur()}:function(){return k.css(e,t,"")},u=s(),l=n&&n[3]||(k.cssNumber[t]?"":"px"),c=e.nodeType&&(k.cssNumber[t]||"px"!==l&&+u)&&ne.exec(k.css(e,t));if(c&&c[3]!==l){u/=2,l=l||c[3],c=+u||1;while(a--)k.style(e,t,c+l),(1-o)*(1-(o=s()/u||.5))<=0&&(a=0),c/=o;c*=2,k.style(e,t,c+l),n=n||[]}return n&&(c=+c||+u||0,i=n[1]?c+(n[1]+1)*n[2]:+n[2],r&&(r.unit=l,r.start=c,r.end=i)),i}var ce={};function fe(e,t){for(var n,r,i,o,a,s,u,l=[],c=0,f=e.length;c<f;c++)(r=e[c]).style&&(n=r.style.display,t?("none"===n&&(l[c]=Q.get(r,"display")||null,l[c]||(r.style.display="")),""===r.style.display&&se(r)&&(l[c]=(u=a=o=void 0,a=(i=r).ownerDocument,s=i.nodeName,(u=ce[s])||(o=a.body.appendChild(a.createElement(s)),u=k.css(o,"display"),o.parentNode.removeChild(o),"none"===u&&(u="block"),ce[s]=u)))):"none"!==n&&(l[c]="none",Q.set(r,"display",n)));for(c=0;c<f;c++)null!=l[c]&&(e[c].style.display=l[c]);return e}k.fn.extend({show:function(){return fe(this,!0)},hide:function(){return fe(this)},toggle:function(e){return"boolean"==typeof e?e?this.show():this.hide():this.each(function(){se(this)?k(this).show():k(this).hide()})}});var pe=/^(?:checkbox|radio)$/i,de=/<([a-z][^\/\0>\x20\t\r\n\f]*)/i,he=/^$|^module$|\/(?:java|ecma)script/i,ge={option:[1,"<select multiple='multiple'>","</select>"],thead:[1,"<table>","</table>"],col:[2,"<table><colgroup>","</colgroup></table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:[0,"",""]};function ve(e,t){var n;return n="undefined"!=typeof e.getElementsByTagName?e.getElementsByTagName(t||"*"):"undefined"!=typeof e.querySelectorAll?e.querySelectorAll(t||"*"):[],void 0===t||t&&A(e,t)?k.merge([e],n):n}function ye(e,t){for(var n=0,r=e.length;n<r;n++)Q.set(e[n],"globalEval",!t||Q.get(t[n],"globalEval"))}ge.optgroup=ge.option,ge.tbody=ge.tfoot=ge.colgroup=ge.caption=ge.thead,ge.th=ge.td;var me,xe,be=/<|&#?\w+;/;function we(e,t,n,r,i){for(var o,a,s,u,l,c,f=t.createDocumentFragment(),p=[],d=0,h=e.length;d<h;d++)if((o=e[d])||0===o)if("object"===w(o))k.merge(p,o.nodeType?[o]:o);else if(be.test(o)){a=a||f.appendChild(t.createElement("div")),s=(de.exec(o)||["",""])[1].toLowerCase(),u=ge[s]||ge._default,a.innerHTML=u[1]+k.htmlPrefilter(o)+u[2],c=u[0];while(c--)a=a.lastChild;k.merge(p,a.childNodes),(a=f.firstChild).textContent=""}else p.push(t.createTextNode(o));f.textContent="",d=0;while(o=p[d++])if(r&&-1<k.inArray(o,r))i&&i.push(o);else if(l=oe(o),a=ve(f.appendChild(o),"script"),l&&ye(a),n){c=0;while(o=a[c++])he.test(o.type||"")&&n.push(o)}return f}me=E.createDocumentFragment().appendChild(E.createElement("div")),(xe=E.createElement("input")).setAttribute("type","radio"),xe.setAttribute("checked","checked"),xe.setAttribute("name","t"),me.appendChild(xe),y.checkClone=me.cloneNode(!0).cloneNode(!0).lastChild.checked,me.innerHTML="<textarea>x</textarea>",y.noCloneChecked=!!me.cloneNode(!0).lastChild.defaultValue;var Te=/^key/,Ce=/^(?:mouse|pointer|contextmenu|drag|drop)|click/,Ee=/^([^.]*)(?:\.(.+)|)/;function ke(){return!0}function Se(){return!1}function Ne(e,t){return e===function(){try{return E.activeElement}catch(e){}}()==("focus"===t)}function Ae(e,t,n,r,i,o){var a,s;if("object"==typeof t){for(s in"string"!=typeof n&&(r=r||n,n=void 0),t)Ae(e,s,n,r,t[s],o);return e}if(null==r&&null==i?(i=n,r=n=void 0):null==i&&("string"==typeof n?(i=r,r=void 0):(i=r,r=n,n=void 0)),!1===i)i=Se;else if(!i)return e;return 1===o&&(a=i,(i=function(e){return k().off(e),a.apply(this,arguments)}).guid=a.guid||(a.guid=k.guid++)),e.each(function(){k.event.add(this,t,i,r,n)})}function De(e,i,o){o?(Q.set(e,i,!1),k.event.add(e,i,{namespace:!1,handler:function(e){var t,n,r=Q.get(this,i);if(1&e.isTrigger&&this[i]){if(r.length)(k.event.special[i]||{}).delegateType&&e.stopPropagation();else if(r=s.call(arguments),Q.set(this,i,r),t=o(this,i),this[i](),r!==(n=Q.get(this,i))||t?Q.set(this,i,!1):n={},r!==n)return e.stopImmediatePropagation(),e.preventDefault(),n.value}else r.length&&(Q.set(this,i,{value:k.event.trigger(k.extend(r[0],k.Event.prototype),r.slice(1),this)}),e.stopImmediatePropagation())}})):void 0===Q.get(e,i)&&k.event.add(e,i,ke)}k.event={global:{},add:function(t,e,n,r,i){var o,a,s,u,l,c,f,p,d,h,g,v=Q.get(t);if(v){n.handler&&(n=(o=n).handler,i=o.selector),i&&k.find.matchesSelector(ie,i),n.guid||(n.guid=k.guid++),(u=v.events)||(u=v.events={}),(a=v.handle)||(a=v.handle=function(e){return"undefined"!=typeof k&&k.event.triggered!==e.type?k.event.dispatch.apply(t,arguments):void 0}),l=(e=(e||"").match(R)||[""]).length;while(l--)d=g=(s=Ee.exec(e[l])||[])[1],h=(s[2]||"").split(".").sort(),d&&(f=k.event.special[d]||{},d=(i?f.delegateType:f.bindType)||d,f=k.event.special[d]||{},c=k.extend({type:d,origType:g,data:r,handler:n,guid:n.guid,selector:i,needsContext:i&&k.expr.match.needsContext.test(i),namespace:h.join(".")},o),(p=u[d])||((p=u[d]=[]).delegateCount=0,f.setup&&!1!==f.setup.call(t,r,h,a)||t.addEventListener&&t.addEventListener(d,a)),f.add&&(f.add.call(t,c),c.handler.guid||(c.handler.guid=n.guid)),i?p.splice(p.delegateCount++,0,c):p.push(c),k.event.global[d]=!0)}},remove:function(e,t,n,r,i){var o,a,s,u,l,c,f,p,d,h,g,v=Q.hasData(e)&&Q.get(e);if(v&&(u=v.events)){l=(t=(t||"").match(R)||[""]).length;while(l--)if(d=g=(s=Ee.exec(t[l])||[])[1],h=(s[2]||"").split(".").sort(),d){f=k.event.special[d]||{},p=u[d=(r?f.delegateType:f.bindType)||d]||[],s=s[2]&&new RegExp("(^|\\.)"+h.join("\\.(?:.*\\.|)")+"(\\.|$)"),a=o=p.length;while(o--)c=p[o],!i&&g!==c.origType||n&&n.guid!==c.guid||s&&!s.test(c.namespace)||r&&r!==c.selector&&("**"!==r||!c.selector)||(p.splice(o,1),c.selector&&p.delegateCount--,f.remove&&f.remove.call(e,c));a&&!p.length&&(f.teardown&&!1!==f.teardown.call(e,h,v.handle)||k.removeEvent(e,d,v.handle),delete u[d])}else for(d in u)k.event.remove(e,d+t[l],n,r,!0);k.isEmptyObject(u)&&Q.remove(e,"handle events")}},dispatch:function(e){var t,n,r,i,o,a,s=k.event.fix(e),u=new Array(arguments.length),l=(Q.get(this,"events")||{})[s.type]||[],c=k.event.special[s.type]||{};for(u[0]=s,t=1;t<arguments.length;t++)u[t]=arguments[t];if(s.delegateTarget=this,!c.preDispatch||!1!==c.preDispatch.call(this,s)){a=k.event.handlers.call(this,s,l),t=0;while((i=a[t++])&&!s.isPropagationStopped()){s.currentTarget=i.elem,n=0;while((o=i.handlers[n++])&&!s.isImmediatePropagationStopped())s.rnamespace&&!1!==o.namespace&&!s.rnamespace.test(o.namespace)||(s.handleObj=o,s.data=o.data,void 0!==(r=((k.event.special[o.origType]||{}).handle||o.handler).apply(i.elem,u))&&!1===(s.result=r)&&(s.preventDefault(),s.stopPropagation()))}return c.postDispatch&&c.postDispatch.call(this,s),s.result}},handlers:function(e,t){var n,r,i,o,a,s=[],u=t.delegateCount,l=e.target;if(u&&l.nodeType&&!("click"===e.type&&1<=e.button))for(;l!==this;l=l.parentNode||this)if(1===l.nodeType&&("click"!==e.type||!0!==l.disabled)){for(o=[],a={},n=0;n<u;n++)void 0===a[i=(r=t[n]).selector+" "]&&(a[i]=r.needsContext?-1<k(i,this).index(l):k.find(i,this,null,[l]).length),a[i]&&o.push(r);o.length&&s.push({elem:l,handlers:o})}return l=this,u<t.length&&s.push({elem:l,handlers:t.slice(u)}),s},addProp:function(t,e){Object.defineProperty(k.Event.prototype,t,{enumerable:!0,configurable:!0,get:m(e)?function(){if(this.originalEvent)return e(this.originalEvent)}:function(){if(this.originalEvent)return this.originalEvent[t]},set:function(e){Object.defineProperty(this,t,{enumerable:!0,configurable:!0,writable:!0,value:e})}})},fix:function(e){return e[k.expando]?e:new k.Event(e)},special:{load:{noBubble:!0},click:{setup:function(e){var t=this||e;return pe.test(t.type)&&t.click&&A(t,"input")&&De(t,"click",ke),!1},trigger:function(e){var t=this||e;return pe.test(t.type)&&t.click&&A(t,"input")&&De(t,"click"),!0},_default:function(e){var t=e.target;return pe.test(t.type)&&t.click&&A(t,"input")&&Q.get(t,"click")||A(t,"a")}},beforeunload:{postDispatch:function(e){void 0!==e.result&&e.originalEvent&&(e.originalEvent.returnValue=e.result)}}}},k.removeEvent=function(e,t,n){e.removeEventListener&&e.removeEventListener(t,n)},k.Event=function(e,t){if(!(this instanceof k.Event))return new k.Event(e,t);e&&e.type?(this.originalEvent=e,this.type=e.type,this.isDefaultPrevented=e.defaultPrevented||void 0===e.defaultPrevented&&!1===e.returnValue?ke:Se,this.target=e.target&&3===e.target.nodeType?e.target.parentNode:e.target,this.currentTarget=e.currentTarget,this.relatedTarget=e.relatedTarget):this.type=e,t&&k.extend(this,t),this.timeStamp=e&&e.timeStamp||Date.now(),this[k.expando]=!0},k.Event.prototype={constructor:k.Event,isDefaultPrevented:Se,isPropagationStopped:Se,isImmediatePropagationStopped:Se,isSimulated:!1,preventDefault:function(){var e=this.originalEvent;this.isDefaultPrevented=ke,e&&!this.isSimulated&&e.preventDefault()},stopPropagation:function(){var e=this.originalEvent;this.isPropagationStopped=ke,e&&!this.isSimulated&&e.stopPropagation()},stopImmediatePropagation:function(){var e=this.originalEvent;this.isImmediatePropagationStopped=ke,e&&!this.isSimulated&&e.stopImmediatePropagation(),this.stopPropagation()}},k.each({altKey:!0,bubbles:!0,cancelable:!0,changedTouches:!0,ctrlKey:!0,detail:!0,eventPhase:!0,metaKey:!0,pageX:!0,pageY:!0,shiftKey:!0,view:!0,"char":!0,code:!0,charCode:!0,key:!0,keyCode:!0,button:!0,buttons:!0,clientX:!0,clientY:!0,offsetX:!0,offsetY:!0,pointerId:!0,pointerType:!0,screenX:!0,screenY:!0,targetTouches:!0,toElement:!0,touches:!0,which:function(e){var t=e.button;return null==e.which&&Te.test(e.type)?null!=e.charCode?e.charCode:e.keyCode:!e.which&&void 0!==t&&Ce.test(e.type)?1&t?1:2&t?3:4&t?2:0:e.which}},k.event.addProp),k.each({focus:"focusin",blur:"focusout"},function(e,t){k.event.special[e]={setup:function(){return De(this,e,Ne),!1},trigger:function(){return De(this,e),!0},delegateType:t}}),k.each({mouseenter:"mouseover",mouseleave:"mouseout",pointerenter:"pointerover",pointerleave:"pointerout"},function(e,i){k.event.special[e]={delegateType:i,bindType:i,handle:function(e){var t,n=e.relatedTarget,r=e.handleObj;return n&&(n===this||k.contains(this,n))||(e.type=r.origType,t=r.handler.apply(this,arguments),e.type=i),t}}}),k.fn.extend({on:function(e,t,n,r){return Ae(this,e,t,n,r)},one:function(e,t,n,r){return Ae(this,e,t,n,r,1)},off:function(e,t,n){var r,i;if(e&&e.preventDefault&&e.handleObj)return r=e.handleObj,k(e.delegateTarget).off(r.namespace?r.origType+"."+r.namespace:r.origType,r.selector,r.handler),this;if("object"==typeof e){for(i in e)this.off(i,t,e[i]);return this}return!1!==t&&"function"!=typeof t||(n=t,t=void 0),!1===n&&(n=Se),this.each(function(){k.event.remove(this,e,n,t)})}});var je=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,qe=/<script|<style|<link/i,Le=/checked\s*(?:[^=]|=\s*.checked.)/i,He=/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;function Oe(e,t){return A(e,"table")&&A(11!==t.nodeType?t:t.firstChild,"tr")&&k(e).children("tbody")[0]||e}function Pe(e){return e.type=(null!==e.getAttribute("type"))+"/"+e.type,e}function Re(e){return"true/"===(e.type||"").slice(0,5)?e.type=e.type.slice(5):e.removeAttribute("type"),e}function Me(e,t){var n,r,i,o,a,s,u,l;if(1===t.nodeType){if(Q.hasData(e)&&(o=Q.access(e),a=Q.set(t,o),l=o.events))for(i in delete a.handle,a.events={},l)for(n=0,r=l[i].length;n<r;n++)k.event.add(t,i,l[i][n]);J.hasData(e)&&(s=J.access(e),u=k.extend({},s),J.set(t,u))}}function Ie(n,r,i,o){r=g.apply([],r);var e,t,a,s,u,l,c=0,f=n.length,p=f-1,d=r[0],h=m(d);if(h||1<f&&"string"==typeof d&&!y.checkClone&&Le.test(d))return n.each(function(e){var t=n.eq(e);h&&(r[0]=d.call(this,e,t.html())),Ie(t,r,i,o)});if(f&&(t=(e=we(r,n[0].ownerDocument,!1,n,o)).firstChild,1===e.childNodes.length&&(e=t),t||o)){for(s=(a=k.map(ve(e,"script"),Pe)).length;c<f;c++)u=e,c!==p&&(u=k.clone(u,!0,!0),s&&k.merge(a,ve(u,"script"))),i.call(n[c],u,c);if(s)for(l=a[a.length-1].ownerDocument,k.map(a,Re),c=0;c<s;c++)u=a[c],he.test(u.type||"")&&!Q.access(u,"globalEval")&&k.contains(l,u)&&(u.src&&"module"!==(u.type||"").toLowerCase()?k._evalUrl&&!u.noModule&&k._evalUrl(u.src,{nonce:u.nonce||u.getAttribute("nonce")}):b(u.textContent.replace(He,""),u,l))}return n}function We(e,t,n){for(var r,i=t?k.filter(t,e):e,o=0;null!=(r=i[o]);o++)n||1!==r.nodeType||k.cleanData(ve(r)),r.parentNode&&(n&&oe(r)&&ye(ve(r,"script")),r.parentNode.removeChild(r));return e}k.extend({htmlPrefilter:function(e){return e.replace(je,"<$1></$2>")},clone:function(e,t,n){var r,i,o,a,s,u,l,c=e.cloneNode(!0),f=oe(e);if(!(y.noCloneChecked||1!==e.nodeType&&11!==e.nodeType||k.isXMLDoc(e)))for(a=ve(c),r=0,i=(o=ve(e)).length;r<i;r++)s=o[r],u=a[r],void 0,"input"===(l=u.nodeName.toLowerCase())&&pe.test(s.type)?u.checked=s.checked:"input"!==l&&"textarea"!==l||(u.defaultValue=s.defaultValue);if(t)if(n)for(o=o||ve(e),a=a||ve(c),r=0,i=o.length;r<i;r++)Me(o[r],a[r]);else Me(e,c);return 0<(a=ve(c,"script")).length&&ye(a,!f&&ve(e,"script")),c},cleanData:function(e){for(var t,n,r,i=k.event.special,o=0;void 0!==(n=e[o]);o++)if(G(n)){if(t=n[Q.expando]){if(t.events)for(r in t.events)i[r]?k.event.remove(n,r):k.removeEvent(n,r,t.handle);n[Q.expando]=void 0}n[J.expando]&&(n[J.expando]=void 0)}}}),k.fn.extend({detach:function(e){return We(this,e,!0)},remove:function(e){return We(this,e)},text:function(e){return _(this,function(e){return void 0===e?k.text(this):this.empty().each(function(){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||(this.textContent=e)})},null,e,arguments.length)},append:function(){return Ie(this,arguments,function(e){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||Oe(this,e).appendChild(e)})},prepend:function(){return Ie(this,arguments,function(e){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var t=Oe(this,e);t.insertBefore(e,t.firstChild)}})},before:function(){return Ie(this,arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this)})},after:function(){return Ie(this,arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this.nextSibling)})},empty:function(){for(var e,t=0;null!=(e=this[t]);t++)1===e.nodeType&&(k.cleanData(ve(e,!1)),e.textContent="");return this},clone:function(e,t){return e=null!=e&&e,t=null==t?e:t,this.map(function(){return k.clone(this,e,t)})},html:function(e){return _(this,function(e){var t=this[0]||{},n=0,r=this.length;if(void 0===e&&1===t.nodeType)return t.innerHTML;if("string"==typeof e&&!qe.test(e)&&!ge[(de.exec(e)||["",""])[1].toLowerCase()]){e=k.htmlPrefilter(e);try{for(;n<r;n++)1===(t=this[n]||{}).nodeType&&(k.cleanData(ve(t,!1)),t.innerHTML=e);t=0}catch(e){}}t&&this.empty().append(e)},null,e,arguments.length)},replaceWith:function(){var n=[];return Ie(this,arguments,function(e){var t=this.parentNode;k.inArray(this,n)<0&&(k.cleanData(ve(this)),t&&t.replaceChild(e,this))},n)}}),k.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(e,a){k.fn[e]=function(e){for(var t,n=[],r=k(e),i=r.length-1,o=0;o<=i;o++)t=o===i?this:this.clone(!0),k(r[o])[a](t),u.apply(n,t.get());return this.pushStack(n)}});var $e=new RegExp("^("+te+")(?!px)[a-z%]+$","i"),Fe=function(e){var t=e.ownerDocument.defaultView;return t&&t.opener||(t=C),t.getComputedStyle(e)},Be=new RegExp(re.join("|"),"i");function _e(e,t,n){var r,i,o,a,s=e.style;return(n=n||Fe(e))&&(""!==(a=n.getPropertyValue(t)||n[t])||oe(e)||(a=k.style(e,t)),!y.pixelBoxStyles()&&$e.test(a)&&Be.test(t)&&(r=s.width,i=s.minWidth,o=s.maxWidth,s.minWidth=s.maxWidth=s.width=a,a=n.width,s.width=r,s.minWidth=i,s.maxWidth=o)),void 0!==a?a+"":a}function ze(e,t){return{get:function(){if(!e())return(this.get=t).apply(this,arguments);delete this.get}}}!function(){function e(){if(u){s.style.cssText="position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0",u.style.cssText="position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%",ie.appendChild(s).appendChild(u);var e=C.getComputedStyle(u);n="1%"!==e.top,a=12===t(e.marginLeft),u.style.right="60%",o=36===t(e.right),r=36===t(e.width),u.style.position="absolute",i=12===t(u.offsetWidth/3),ie.removeChild(s),u=null}}function t(e){return Math.round(parseFloat(e))}var n,r,i,o,a,s=E.createElement("div"),u=E.createElement("div");u.style&&(u.style.backgroundClip="content-box",u.cloneNode(!0).style.backgroundClip="",y.clearCloneStyle="content-box"===u.style.backgroundClip,k.extend(y,{boxSizingReliable:function(){return e(),r},pixelBoxStyles:function(){return e(),o},pixelPosition:function(){return e(),n},reliableMarginLeft:function(){return e(),a},scrollboxSize:function(){return e(),i}}))}();var Ue=["Webkit","Moz","ms"],Xe=E.createElement("div").style,Ve={};function Ge(e){var t=k.cssProps[e]||Ve[e];return t||(e in Xe?e:Ve[e]=function(e){var t=e[0].toUpperCase()+e.slice(1),n=Ue.length;while(n--)if((e=Ue[n]+t)in Xe)return e}(e)||e)}var Ye=/^(none|table(?!-c[ea]).+)/,Qe=/^--/,Je={position:"absolute",visibility:"hidden",display:"block"},Ke={letterSpacing:"0",fontWeight:"400"};function Ze(e,t,n){var r=ne.exec(t);return r?Math.max(0,r[2]-(n||0))+(r[3]||"px"):t}function et(e,t,n,r,i,o){var a="width"===t?1:0,s=0,u=0;if(n===(r?"border":"content"))return 0;for(;a<4;a+=2)"margin"===n&&(u+=k.css(e,n+re[a],!0,i)),r?("content"===n&&(u-=k.css(e,"padding"+re[a],!0,i)),"margin"!==n&&(u-=k.css(e,"border"+re[a]+"Width",!0,i))):(u+=k.css(e,"padding"+re[a],!0,i),"padding"!==n?u+=k.css(e,"border"+re[a]+"Width",!0,i):s+=k.css(e,"border"+re[a]+"Width",!0,i));return!r&&0<=o&&(u+=Math.max(0,Math.ceil(e["offset"+t[0].toUpperCase()+t.slice(1)]-o-u-s-.5))||0),u}function tt(e,t,n){var r=Fe(e),i=(!y.boxSizingReliable()||n)&&"border-box"===k.css(e,"boxSizing",!1,r),o=i,a=_e(e,t,r),s="offset"+t[0].toUpperCase()+t.slice(1);if($e.test(a)){if(!n)return a;a="auto"}return(!y.boxSizingReliable()&&i||"auto"===a||!parseFloat(a)&&"inline"===k.css(e,"display",!1,r))&&e.getClientRects().length&&(i="border-box"===k.css(e,"boxSizing",!1,r),(o=s in e)&&(a=e[s])),(a=parseFloat(a)||0)+et(e,t,n||(i?"border":"content"),o,r,a)+"px"}function nt(e,t,n,r,i){return new nt.prototype.init(e,t,n,r,i)}k.extend({cssHooks:{opacity:{get:function(e,t){if(t){var n=_e(e,"opacity");return""===n?"1":n}}}},cssNumber:{animationIterationCount:!0,columnCount:!0,fillOpacity:!0,flexGrow:!0,flexShrink:!0,fontWeight:!0,gridArea:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnStart:!0,gridRow:!0,gridRowEnd:!0,gridRowStart:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{},style:function(e,t,n,r){if(e&&3!==e.nodeType&&8!==e.nodeType&&e.style){var i,o,a,s=V(t),u=Qe.test(t),l=e.style;if(u||(t=Ge(s)),a=k.cssHooks[t]||k.cssHooks[s],void 0===n)return a&&"get"in a&&void 0!==(i=a.get(e,!1,r))?i:l[t];"string"===(o=typeof n)&&(i=ne.exec(n))&&i[1]&&(n=le(e,t,i),o="number"),null!=n&&n==n&&("number"!==o||u||(n+=i&&i[3]||(k.cssNumber[s]?"":"px")),y.clearCloneStyle||""!==n||0!==t.indexOf("background")||(l[t]="inherit"),a&&"set"in a&&void 0===(n=a.set(e,n,r))||(u?l.setProperty(t,n):l[t]=n))}},css:function(e,t,n,r){var i,o,a,s=V(t);return Qe.test(t)||(t=Ge(s)),(a=k.cssHooks[t]||k.cssHooks[s])&&"get"in a&&(i=a.get(e,!0,n)),void 0===i&&(i=_e(e,t,r)),"normal"===i&&t in Ke&&(i=Ke[t]),""===n||n?(o=parseFloat(i),!0===n||isFinite(o)?o||0:i):i}}),k.each(["height","width"],function(e,u){k.cssHooks[u]={get:function(e,t,n){if(t)return!Ye.test(k.css(e,"display"))||e.getClientRects().length&&e.getBoundingClientRect().width?tt(e,u,n):ue(e,Je,function(){return tt(e,u,n)})},set:function(e,t,n){var r,i=Fe(e),o=!y.scrollboxSize()&&"absolute"===i.position,a=(o||n)&&"border-box"===k.css(e,"boxSizing",!1,i),s=n?et(e,u,n,a,i):0;return a&&o&&(s-=Math.ceil(e["offset"+u[0].toUpperCase()+u.slice(1)]-parseFloat(i[u])-et(e,u,"border",!1,i)-.5)),s&&(r=ne.exec(t))&&"px"!==(r[3]||"px")&&(e.style[u]=t,t=k.css(e,u)),Ze(0,t,s)}}}),k.cssHooks.marginLeft=ze(y.reliableMarginLeft,function(e,t){if(t)return(parseFloat(_e(e,"marginLeft"))||e.getBoundingClientRect().left-ue(e,{marginLeft:0},function(){return e.getBoundingClientRect().left}))+"px"}),k.each({margin:"",padding:"",border:"Width"},function(i,o){k.cssHooks[i+o]={expand:function(e){for(var t=0,n={},r="string"==typeof e?e.split(" "):[e];t<4;t++)n[i+re[t]+o]=r[t]||r[t-2]||r[0];return n}},"margin"!==i&&(k.cssHooks[i+o].set=Ze)}),k.fn.extend({css:function(e,t){return _(this,function(e,t,n){var r,i,o={},a=0;if(Array.isArray(t)){for(r=Fe(e),i=t.length;a<i;a++)o[t[a]]=k.css(e,t[a],!1,r);return o}return void 0!==n?k.style(e,t,n):k.css(e,t)},e,t,1<arguments.length)}}),((k.Tween=nt).prototype={constructor:nt,init:function(e,t,n,r,i,o){this.elem=e,this.prop=n,this.easing=i||k.easing._default,this.options=t,this.start=this.now=this.cur(),this.end=r,this.unit=o||(k.cssNumber[n]?"":"px")},cur:function(){var e=nt.propHooks[this.prop];return e&&e.get?e.get(this):nt.propHooks._default.get(this)},run:function(e){var t,n=nt.propHooks[this.prop];return this.options.duration?this.pos=t=k.easing[this.easing](e,this.options.duration*e,0,1,this.options.duration):this.pos=t=e,this.now=(this.end-this.start)*t+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),n&&n.set?n.set(this):nt.propHooks._default.set(this),this}}).init.prototype=nt.prototype,(nt.propHooks={_default:{get:function(e){var t;return 1!==e.elem.nodeType||null!=e.elem[e.prop]&&null==e.elem.style[e.prop]?e.elem[e.prop]:(t=k.css(e.elem,e.prop,""))&&"auto"!==t?t:0},set:function(e){k.fx.step[e.prop]?k.fx.step[e.prop](e):1!==e.elem.nodeType||!k.cssHooks[e.prop]&&null==e.elem.style[Ge(e.prop)]?e.elem[e.prop]=e.now:k.style(e.elem,e.prop,e.now+e.unit)}}}).scrollTop=nt.propHooks.scrollLeft={set:function(e){e.elem.nodeType&&e.elem.parentNode&&(e.elem[e.prop]=e.now)}},k.easing={linear:function(e){return e},swing:function(e){return.5-Math.cos(e*Math.PI)/2},_default:"swing"},k.fx=nt.prototype.init,k.fx.step={};var rt,it,ot,at,st=/^(?:toggle|show|hide)$/,ut=/queueHooks$/;function lt(){it&&(!1===E.hidden&&C.requestAnimationFrame?C.requestAnimationFrame(lt):C.setTimeout(lt,k.fx.interval),k.fx.tick())}function ct(){return C.setTimeout(function(){rt=void 0}),rt=Date.now()}function ft(e,t){var n,r=0,i={height:e};for(t=t?1:0;r<4;r+=2-t)i["margin"+(n=re[r])]=i["padding"+n]=e;return t&&(i.opacity=i.width=e),i}function pt(e,t,n){for(var r,i=(dt.tweeners[t]||[]).concat(dt.tweeners["*"]),o=0,a=i.length;o<a;o++)if(r=i[o].call(n,t,e))return r}function dt(o,e,t){var n,a,r=0,i=dt.prefilters.length,s=k.Deferred().always(function(){delete u.elem}),u=function(){if(a)return!1;for(var e=rt||ct(),t=Math.max(0,l.startTime+l.duration-e),n=1-(t/l.duration||0),r=0,i=l.tweens.length;r<i;r++)l.tweens[r].run(n);return s.notifyWith(o,[l,n,t]),n<1&&i?t:(i||s.notifyWith(o,[l,1,0]),s.resolveWith(o,[l]),!1)},l=s.promise({elem:o,props:k.extend({},e),opts:k.extend(!0,{specialEasing:{},easing:k.easing._default},t),originalProperties:e,originalOptions:t,startTime:rt||ct(),duration:t.duration,tweens:[],createTween:function(e,t){var n=k.Tween(o,l.opts,e,t,l.opts.specialEasing[e]||l.opts.easing);return l.tweens.push(n),n},stop:function(e){var t=0,n=e?l.tweens.length:0;if(a)return this;for(a=!0;t<n;t++)l.tweens[t].run(1);return e?(s.notifyWith(o,[l,1,0]),s.resolveWith(o,[l,e])):s.rejectWith(o,[l,e]),this}}),c=l.props;for(!function(e,t){var n,r,i,o,a;for(n in e)if(i=t[r=V(n)],o=e[n],Array.isArray(o)&&(i=o[1],o=e[n]=o[0]),n!==r&&(e[r]=o,delete e[n]),(a=k.cssHooks[r])&&"expand"in a)for(n in o=a.expand(o),delete e[r],o)n in e||(e[n]=o[n],t[n]=i);else t[r]=i}(c,l.opts.specialEasing);r<i;r++)if(n=dt.prefilters[r].call(l,o,c,l.opts))return m(n.stop)&&(k._queueHooks(l.elem,l.opts.queue).stop=n.stop.bind(n)),n;return k.map(c,pt,l),m(l.opts.start)&&l.opts.start.call(o,l),l.progress(l.opts.progress).done(l.opts.done,l.opts.complete).fail(l.opts.fail).always(l.opts.always),k.fx.timer(k.extend(u,{elem:o,anim:l,queue:l.opts.queue})),l}k.Animation=k.extend(dt,{tweeners:{"*":[function(e,t){var n=this.createTween(e,t);return le(n.elem,e,ne.exec(t),n),n}]},tweener:function(e,t){m(e)?(t=e,e=["*"]):e=e.match(R);for(var n,r=0,i=e.length;r<i;r++)n=e[r],dt.tweeners[n]=dt.tweeners[n]||[],dt.tweeners[n].unshift(t)},prefilters:[function(e,t,n){var r,i,o,a,s,u,l,c,f="width"in t||"height"in t,p=this,d={},h=e.style,g=e.nodeType&&se(e),v=Q.get(e,"fxshow");for(r in n.queue||(null==(a=k._queueHooks(e,"fx")).unqueued&&(a.unqueued=0,s=a.empty.fire,a.empty.fire=function(){a.unqueued||s()}),a.unqueued++,p.always(function(){p.always(function(){a.unqueued--,k.queue(e,"fx").length||a.empty.fire()})})),t)if(i=t[r],st.test(i)){if(delete t[r],o=o||"toggle"===i,i===(g?"hide":"show")){if("show"!==i||!v||void 0===v[r])continue;g=!0}d[r]=v&&v[r]||k.style(e,r)}if((u=!k.isEmptyObject(t))||!k.isEmptyObject(d))for(r in f&&1===e.nodeType&&(n.overflow=[h.overflow,h.overflowX,h.overflowY],null==(l=v&&v.display)&&(l=Q.get(e,"display")),"none"===(c=k.css(e,"display"))&&(l?c=l:(fe([e],!0),l=e.style.display||l,c=k.css(e,"display"),fe([e]))),("inline"===c||"inline-block"===c&&null!=l)&&"none"===k.css(e,"float")&&(u||(p.done(function(){h.display=l}),null==l&&(c=h.display,l="none"===c?"":c)),h.display="inline-block")),n.overflow&&(h.overflow="hidden",p.always(function(){h.overflow=n.overflow[0],h.overflowX=n.overflow[1],h.overflowY=n.overflow[2]})),u=!1,d)u||(v?"hidden"in v&&(g=v.hidden):v=Q.access(e,"fxshow",{display:l}),o&&(v.hidden=!g),g&&fe([e],!0),p.done(function(){for(r in g||fe([e]),Q.remove(e,"fxshow"),d)k.style(e,r,d[r])})),u=pt(g?v[r]:0,r,p),r in v||(v[r]=u.start,g&&(u.end=u.start,u.start=0))}],prefilter:function(e,t){t?dt.prefilters.unshift(e):dt.prefilters.push(e)}}),k.speed=function(e,t,n){var r=e&&"object"==typeof e?k.extend({},e):{complete:n||!n&&t||m(e)&&e,duration:e,easing:n&&t||t&&!m(t)&&t};return k.fx.off?r.duration=0:"number"!=typeof r.duration&&(r.duration in k.fx.speeds?r.duration=k.fx.speeds[r.duration]:r.duration=k.fx.speeds._default),null!=r.queue&&!0!==r.queue||(r.queue="fx"),r.old=r.complete,r.complete=function(){m(r.old)&&r.old.call(this),r.queue&&k.dequeue(this,r.queue)},r},k.fn.extend({fadeTo:function(e,t,n,r){return this.filter(se).css("opacity",0).show().end().animate({opacity:t},e,n,r)},animate:function(t,e,n,r){var i=k.isEmptyObject(t),o=k.speed(e,n,r),a=function(){var e=dt(this,k.extend({},t),o);(i||Q.get(this,"finish"))&&e.stop(!0)};return a.finish=a,i||!1===o.queue?this.each(a):this.queue(o.queue,a)},stop:function(i,e,o){var a=function(e){var t=e.stop;delete e.stop,t(o)};return"string"!=typeof i&&(o=e,e=i,i=void 0),e&&!1!==i&&this.queue(i||"fx",[]),this.each(function(){var e=!0,t=null!=i&&i+"queueHooks",n=k.timers,r=Q.get(this);if(t)r[t]&&r[t].stop&&a(r[t]);else for(t in r)r[t]&&r[t].stop&&ut.test(t)&&a(r[t]);for(t=n.length;t--;)n[t].elem!==this||null!=i&&n[t].queue!==i||(n[t].anim.stop(o),e=!1,n.splice(t,1));!e&&o||k.dequeue(this,i)})},finish:function(a){return!1!==a&&(a=a||"fx"),this.each(function(){var e,t=Q.get(this),n=t[a+"queue"],r=t[a+"queueHooks"],i=k.timers,o=n?n.length:0;for(t.finish=!0,k.queue(this,a,[]),r&&r.stop&&r.stop.call(this,!0),e=i.length;e--;)i[e].elem===this&&i[e].queue===a&&(i[e].anim.stop(!0),i.splice(e,1));for(e=0;e<o;e++)n[e]&&n[e].finish&&n[e].finish.call(this);delete t.finish})}}),k.each(["toggle","show","hide"],function(e,r){var i=k.fn[r];k.fn[r]=function(e,t,n){return null==e||"boolean"==typeof e?i.apply(this,arguments):this.animate(ft(r,!0),e,t,n)}}),k.each({slideDown:ft("show"),slideUp:ft("hide"),slideToggle:ft("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(e,r){k.fn[e]=function(e,t,n){return this.animate(r,e,t,n)}}),k.timers=[],k.fx.tick=function(){var e,t=0,n=k.timers;for(rt=Date.now();t<n.length;t++)(e=n[t])()||n[t]!==e||n.splice(t--,1);n.length||k.fx.stop(),rt=void 0},k.fx.timer=function(e){k.timers.push(e),k.fx.start()},k.fx.interval=13,k.fx.start=function(){it||(it=!0,lt())},k.fx.stop=function(){it=null},k.fx.speeds={slow:600,fast:200,_default:400},k.fn.delay=function(r,e){return r=k.fx&&k.fx.speeds[r]||r,e=e||"fx",this.queue(e,function(e,t){var n=C.setTimeout(e,r);t.stop=function(){C.clearTimeout(n)}})},ot=E.createElement("input"),at=E.createElement("select").appendChild(E.createElement("option")),ot.type="checkbox",y.checkOn=""!==ot.value,y.optSelected=at.selected,(ot=E.createElement("input")).value="t",ot.type="radio",y.radioValue="t"===ot.value;var ht,gt=k.expr.attrHandle;k.fn.extend({attr:function(e,t){return _(this,k.attr,e,t,1<arguments.length)},removeAttr:function(e){return this.each(function(){k.removeAttr(this,e)})}}),k.extend({attr:function(e,t,n){var r,i,o=e.nodeType;if(3!==o&&8!==o&&2!==o)return"undefined"==typeof e.getAttribute?k.prop(e,t,n):(1===o&&k.isXMLDoc(e)||(i=k.attrHooks[t.toLowerCase()]||(k.expr.match.bool.test(t)?ht:void 0)),void 0!==n?null===n?void k.removeAttr(e,t):i&&"set"in i&&void 0!==(r=i.set(e,n,t))?r:(e.setAttribute(t,n+""),n):i&&"get"in i&&null!==(r=i.get(e,t))?r:null==(r=k.find.attr(e,t))?void 0:r)},attrHooks:{type:{set:function(e,t){if(!y.radioValue&&"radio"===t&&A(e,"input")){var n=e.value;return e.setAttribute("type",t),n&&(e.value=n),t}}}},removeAttr:function(e,t){var n,r=0,i=t&&t.match(R);if(i&&1===e.nodeType)while(n=i[r++])e.removeAttribute(n)}}),ht={set:function(e,t,n){return!1===t?k.removeAttr(e,n):e.setAttribute(n,n),n}},k.each(k.expr.match.bool.source.match(/\w+/g),function(e,t){var a=gt[t]||k.find.attr;gt[t]=function(e,t,n){var r,i,o=t.toLowerCase();return n||(i=gt[o],gt[o]=r,r=null!=a(e,t,n)?o:null,gt[o]=i),r}});var vt=/^(?:input|select|textarea|button)$/i,yt=/^(?:a|area)$/i;function mt(e){return(e.match(R)||[]).join(" ")}function xt(e){return e.getAttribute&&e.getAttribute("class")||""}function bt(e){return Array.isArray(e)?e:"string"==typeof e&&e.match(R)||[]}k.fn.extend({prop:function(e,t){return _(this,k.prop,e,t,1<arguments.length)},removeProp:function(e){return this.each(function(){delete this[k.propFix[e]||e]})}}),k.extend({prop:function(e,t,n){var r,i,o=e.nodeType;if(3!==o&&8!==o&&2!==o)return 1===o&&k.isXMLDoc(e)||(t=k.propFix[t]||t,i=k.propHooks[t]),void 0!==n?i&&"set"in i&&void 0!==(r=i.set(e,n,t))?r:e[t]=n:i&&"get"in i&&null!==(r=i.get(e,t))?r:e[t]},propHooks:{tabIndex:{get:function(e){var t=k.find.attr(e,"tabindex");return t?parseInt(t,10):vt.test(e.nodeName)||yt.test(e.nodeName)&&e.href?0:-1}}},propFix:{"for":"htmlFor","class":"className"}}),y.optSelected||(k.propHooks.selected={get:function(e){var t=e.parentNode;return t&&t.parentNode&&t.parentNode.selectedIndex,null},set:function(e){var t=e.parentNode;t&&(t.selectedIndex,t.parentNode&&t.parentNode.selectedIndex)}}),k.each(["tabIndex","readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable"],function(){k.propFix[this.toLowerCase()]=this}),k.fn.extend({addClass:function(t){var e,n,r,i,o,a,s,u=0;if(m(t))return this.each(function(e){k(this).addClass(t.call(this,e,xt(this)))});if((e=bt(t)).length)while(n=this[u++])if(i=xt(n),r=1===n.nodeType&&" "+mt(i)+" "){a=0;while(o=e[a++])r.indexOf(" "+o+" ")<0&&(r+=o+" ");i!==(s=mt(r))&&n.setAttribute("class",s)}return this},removeClass:function(t){var e,n,r,i,o,a,s,u=0;if(m(t))return this.each(function(e){k(this).removeClass(t.call(this,e,xt(this)))});if(!arguments.length)return this.attr("class","");if((e=bt(t)).length)while(n=this[u++])if(i=xt(n),r=1===n.nodeType&&" "+mt(i)+" "){a=0;while(o=e[a++])while(-1<r.indexOf(" "+o+" "))r=r.replace(" "+o+" "," ");i!==(s=mt(r))&&n.setAttribute("class",s)}return this},toggleClass:function(i,t){var o=typeof i,a="string"===o||Array.isArray(i);return"boolean"==typeof t&&a?t?this.addClass(i):this.removeClass(i):m(i)?this.each(function(e){k(this).toggleClass(i.call(this,e,xt(this),t),t)}):this.each(function(){var e,t,n,r;if(a){t=0,n=k(this),r=bt(i);while(e=r[t++])n.hasClass(e)?n.removeClass(e):n.addClass(e)}else void 0!==i&&"boolean"!==o||((e=xt(this))&&Q.set(this,"__className__",e),this.setAttribute&&this.setAttribute("class",e||!1===i?"":Q.get(this,"__className__")||""))})},hasClass:function(e){var t,n,r=0;t=" "+e+" ";while(n=this[r++])if(1===n.nodeType&&-1<(" "+mt(xt(n))+" ").indexOf(t))return!0;return!1}});var wt=/\r/g;k.fn.extend({val:function(n){var r,e,i,t=this[0];return arguments.length?(i=m(n),this.each(function(e){var t;1===this.nodeType&&(null==(t=i?n.call(this,e,k(this).val()):n)?t="":"number"==typeof t?t+="":Array.isArray(t)&&(t=k.map(t,function(e){return null==e?"":e+""})),(r=k.valHooks[this.type]||k.valHooks[this.nodeName.toLowerCase()])&&"set"in r&&void 0!==r.set(this,t,"value")||(this.value=t))})):t?(r=k.valHooks[t.type]||k.valHooks[t.nodeName.toLowerCase()])&&"get"in r&&void 0!==(e=r.get(t,"value"))?e:"string"==typeof(e=t.value)?e.replace(wt,""):null==e?"":e:void 0}}),k.extend({valHooks:{option:{get:function(e){var t=k.find.attr(e,"value");return null!=t?t:mt(k.text(e))}},select:{get:function(e){var t,n,r,i=e.options,o=e.selectedIndex,a="select-one"===e.type,s=a?null:[],u=a?o+1:i.length;for(r=o<0?u:a?o:0;r<u;r++)if(((n=i[r]).selected||r===o)&&!n.disabled&&(!n.parentNode.disabled||!A(n.parentNode,"optgroup"))){if(t=k(n).val(),a)return t;s.push(t)}return s},set:function(e,t){var n,r,i=e.options,o=k.makeArray(t),a=i.length;while(a--)((r=i[a]).selected=-1<k.inArray(k.valHooks.option.get(r),o))&&(n=!0);return n||(e.selectedIndex=-1),o}}}}),k.each(["radio","checkbox"],function(){k.valHooks[this]={set:function(e,t){if(Array.isArray(t))return e.checked=-1<k.inArray(k(e).val(),t)}},y.checkOn||(k.valHooks[this].get=function(e){return null===e.getAttribute("value")?"on":e.value})}),y.focusin="onfocusin"in C;var Tt=/^(?:focusinfocus|focusoutblur)$/,Ct=function(e){e.stopPropagation()};k.extend(k.event,{trigger:function(e,t,n,r){var i,o,a,s,u,l,c,f,p=[n||E],d=v.call(e,"type")?e.type:e,h=v.call(e,"namespace")?e.namespace.split("."):[];if(o=f=a=n=n||E,3!==n.nodeType&&8!==n.nodeType&&!Tt.test(d+k.event.triggered)&&(-1<d.indexOf(".")&&(d=(h=d.split(".")).shift(),h.sort()),u=d.indexOf(":")<0&&"on"+d,(e=e[k.expando]?e:new k.Event(d,"object"==typeof e&&e)).isTrigger=r?2:3,e.namespace=h.join("."),e.rnamespace=e.namespace?new RegExp("(^|\\.)"+h.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,e.result=void 0,e.target||(e.target=n),t=null==t?[e]:k.makeArray(t,[e]),c=k.event.special[d]||{},r||!c.trigger||!1!==c.trigger.apply(n,t))){if(!r&&!c.noBubble&&!x(n)){for(s=c.delegateType||d,Tt.test(s+d)||(o=o.parentNode);o;o=o.parentNode)p.push(o),a=o;a===(n.ownerDocument||E)&&p.push(a.defaultView||a.parentWindow||C)}i=0;while((o=p[i++])&&!e.isPropagationStopped())f=o,e.type=1<i?s:c.bindType||d,(l=(Q.get(o,"events")||{})[e.type]&&Q.get(o,"handle"))&&l.apply(o,t),(l=u&&o[u])&&l.apply&&G(o)&&(e.result=l.apply(o,t),!1===e.result&&e.preventDefault());return e.type=d,r||e.isDefaultPrevented()||c._default&&!1!==c._default.apply(p.pop(),t)||!G(n)||u&&m(n[d])&&!x(n)&&((a=n[u])&&(n[u]=null),k.event.triggered=d,e.isPropagationStopped()&&f.addEventListener(d,Ct),n[d](),e.isPropagationStopped()&&f.removeEventListener(d,Ct),k.event.triggered=void 0,a&&(n[u]=a)),e.result}},simulate:function(e,t,n){var r=k.extend(new k.Event,n,{type:e,isSimulated:!0});k.event.trigger(r,null,t)}}),k.fn.extend({trigger:function(e,t){return this.each(function(){k.event.trigger(e,t,this)})},triggerHandler:function(e,t){var n=this[0];if(n)return k.event.trigger(e,t,n,!0)}}),y.focusin||k.each({focus:"focusin",blur:"focusout"},function(n,r){var i=function(e){k.event.simulate(r,e.target,k.event.fix(e))};k.event.special[r]={setup:function(){var e=this.ownerDocument||this,t=Q.access(e,r);t||e.addEventListener(n,i,!0),Q.access(e,r,(t||0)+1)},teardown:function(){var e=this.ownerDocument||this,t=Q.access(e,r)-1;t?Q.access(e,r,t):(e.removeEventListener(n,i,!0),Q.remove(e,r))}}});var Et=C.location,kt=Date.now(),St=/\?/;k.parseXML=function(e){var t;if(!e||"string"!=typeof e)return null;try{t=(new C.DOMParser).parseFromString(e,"text/xml")}catch(e){t=void 0}return t&&!t.getElementsByTagName("parsererror").length||k.error("Invalid XML: "+e),t};var Nt=/\[\]$/,At=/\r?\n/g,Dt=/^(?:submit|button|image|reset|file)$/i,jt=/^(?:input|select|textarea|keygen)/i;function qt(n,e,r,i){var t;if(Array.isArray(e))k.each(e,function(e,t){r||Nt.test(n)?i(n,t):qt(n+"["+("object"==typeof t&&null!=t?e:"")+"]",t,r,i)});else if(r||"object"!==w(e))i(n,e);else for(t in e)qt(n+"["+t+"]",e[t],r,i)}k.param=function(e,t){var n,r=[],i=function(e,t){var n=m(t)?t():t;r[r.length]=encodeURIComponent(e)+"="+encodeURIComponent(null==n?"":n)};if(null==e)return"";if(Array.isArray(e)||e.jquery&&!k.isPlainObject(e))k.each(e,function(){i(this.name,this.value)});else for(n in e)qt(n,e[n],t,i);return r.join("&")},k.fn.extend({serialize:function(){return k.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var e=k.prop(this,"elements");return e?k.makeArray(e):this}).filter(function(){var e=this.type;return this.name&&!k(this).is(":disabled")&&jt.test(this.nodeName)&&!Dt.test(e)&&(this.checked||!pe.test(e))}).map(function(e,t){var n=k(this).val();return null==n?null:Array.isArray(n)?k.map(n,function(e){return{name:t.name,value:e.replace(At,"\r\n")}}):{name:t.name,value:n.replace(At,"\r\n")}}).get()}});var Lt=/%20/g,Ht=/#.*$/,Ot=/([?&])_=[^&]*/,Pt=/^(.*?):[ \t]*([^\r\n]*)$/gm,Rt=/^(?:GET|HEAD)$/,Mt=/^\/\//,It={},Wt={},$t="*/".concat("*"),Ft=E.createElement("a");function Bt(o){return function(e,t){"string"!=typeof e&&(t=e,e="*");var n,r=0,i=e.toLowerCase().match(R)||[];if(m(t))while(n=i[r++])"+"===n[0]?(n=n.slice(1)||"*",(o[n]=o[n]||[]).unshift(t)):(o[n]=o[n]||[]).push(t)}}function _t(t,i,o,a){var s={},u=t===Wt;function l(e){var r;return s[e]=!0,k.each(t[e]||[],function(e,t){var n=t(i,o,a);return"string"!=typeof n||u||s[n]?u?!(r=n):void 0:(i.dataTypes.unshift(n),l(n),!1)}),r}return l(i.dataTypes[0])||!s["*"]&&l("*")}function zt(e,t){var n,r,i=k.ajaxSettings.flatOptions||{};for(n in t)void 0!==t[n]&&((i[n]?e:r||(r={}))[n]=t[n]);return r&&k.extend(!0,e,r),e}Ft.href=Et.href,k.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:Et.href,type:"GET",isLocal:/^(?:about|app|app-storage|.+-extension|file|res|widget):$/.test(Et.protocol),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":$t,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/\bxml\b/,html:/\bhtml/,json:/\bjson\b/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"},converters:{"* text":String,"text html":!0,"text json":JSON.parse,"text xml":k.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(e,t){return t?zt(zt(e,k.ajaxSettings),t):zt(k.ajaxSettings,e)},ajaxPrefilter:Bt(It),ajaxTransport:Bt(Wt),ajax:function(e,t){"object"==typeof e&&(t=e,e=void 0),t=t||{};var c,f,p,n,d,r,h,g,i,o,v=k.ajaxSetup({},t),y=v.context||v,m=v.context&&(y.nodeType||y.jquery)?k(y):k.event,x=k.Deferred(),b=k.Callbacks("once memory"),w=v.statusCode||{},a={},s={},u="canceled",T={readyState:0,getResponseHeader:function(e){var t;if(h){if(!n){n={};while(t=Pt.exec(p))n[t[1].toLowerCase()+" "]=(n[t[1].toLowerCase()+" "]||[]).concat(t[2])}t=n[e.toLowerCase()+" "]}return null==t?null:t.join(", ")},getAllResponseHeaders:function(){return h?p:null},setRequestHeader:function(e,t){return null==h&&(e=s[e.toLowerCase()]=s[e.toLowerCase()]||e,a[e]=t),this},overrideMimeType:function(e){return null==h&&(v.mimeType=e),this},statusCode:function(e){var t;if(e)if(h)T.always(e[T.status]);else for(t in e)w[t]=[w[t],e[t]];return this},abort:function(e){var t=e||u;return c&&c.abort(t),l(0,t),this}};if(x.promise(T),v.url=((e||v.url||Et.href)+"").replace(Mt,Et.protocol+"//"),v.type=t.method||t.type||v.method||v.type,v.dataTypes=(v.dataType||"*").toLowerCase().match(R)||[""],null==v.crossDomain){r=E.createElement("a");try{r.href=v.url,r.href=r.href,v.crossDomain=Ft.protocol+"//"+Ft.host!=r.protocol+"//"+r.host}catch(e){v.crossDomain=!0}}if(v.data&&v.processData&&"string"!=typeof v.data&&(v.data=k.param(v.data,v.traditional)),_t(It,v,t,T),h)return T;for(i in(g=k.event&&v.global)&&0==k.active++&&k.event.trigger("ajaxStart"),v.type=v.type.toUpperCase(),v.hasContent=!Rt.test(v.type),f=v.url.replace(Ht,""),v.hasContent?v.data&&v.processData&&0===(v.contentType||"").indexOf("application/x-www-form-urlencoded")&&(v.data=v.data.replace(Lt,"+")):(o=v.url.slice(f.length),v.data&&(v.processData||"string"==typeof v.data)&&(f+=(St.test(f)?"&":"?")+v.data,delete v.data),!1===v.cache&&(f=f.replace(Ot,"$1"),o=(St.test(f)?"&":"?")+"_="+kt+++o),v.url=f+o),v.ifModified&&(k.lastModified[f]&&T.setRequestHeader("If-Modified-Since",k.lastModified[f]),k.etag[f]&&T.setRequestHeader("If-None-Match",k.etag[f])),(v.data&&v.hasContent&&!1!==v.contentType||t.contentType)&&T.setRequestHeader("Content-Type",v.contentType),T.setRequestHeader("Accept",v.dataTypes[0]&&v.accepts[v.dataTypes[0]]?v.accepts[v.dataTypes[0]]+("*"!==v.dataTypes[0]?", "+$t+"; q=0.01":""):v.accepts["*"]),v.headers)T.setRequestHeader(i,v.headers[i]);if(v.beforeSend&&(!1===v.beforeSend.call(y,T,v)||h))return T.abort();if(u="abort",b.add(v.complete),T.done(v.success),T.fail(v.error),c=_t(Wt,v,t,T)){if(T.readyState=1,g&&m.trigger("ajaxSend",[T,v]),h)return T;v.async&&0<v.timeout&&(d=C.setTimeout(function(){T.abort("timeout")},v.timeout));try{h=!1,c.send(a,l)}catch(e){if(h)throw e;l(-1,e)}}else l(-1,"No Transport");function l(e,t,n,r){var i,o,a,s,u,l=t;h||(h=!0,d&&C.clearTimeout(d),c=void 0,p=r||"",T.readyState=0<e?4:0,i=200<=e&&e<300||304===e,n&&(s=function(e,t,n){var r,i,o,a,s=e.contents,u=e.dataTypes;while("*"===u[0])u.shift(),void 0===r&&(r=e.mimeType||t.getResponseHeader("Content-Type"));if(r)for(i in s)if(s[i]&&s[i].test(r)){u.unshift(i);break}if(u[0]in n)o=u[0];else{for(i in n){if(!u[0]||e.converters[i+" "+u[0]]){o=i;break}a||(a=i)}o=o||a}if(o)return o!==u[0]&&u.unshift(o),n[o]}(v,T,n)),s=function(e,t,n,r){var i,o,a,s,u,l={},c=e.dataTypes.slice();if(c[1])for(a in e.converters)l[a.toLowerCase()]=e.converters[a];o=c.shift();while(o)if(e.responseFields[o]&&(n[e.responseFields[o]]=t),!u&&r&&e.dataFilter&&(t=e.dataFilter(t,e.dataType)),u=o,o=c.shift())if("*"===o)o=u;else if("*"!==u&&u!==o){if(!(a=l[u+" "+o]||l["* "+o]))for(i in l)if((s=i.split(" "))[1]===o&&(a=l[u+" "+s[0]]||l["* "+s[0]])){!0===a?a=l[i]:!0!==l[i]&&(o=s[0],c.unshift(s[1]));break}if(!0!==a)if(a&&e["throws"])t=a(t);else try{t=a(t)}catch(e){return{state:"parsererror",error:a?e:"No conversion from "+u+" to "+o}}}return{state:"success",data:t}}(v,s,T,i),i?(v.ifModified&&((u=T.getResponseHeader("Last-Modified"))&&(k.lastModified[f]=u),(u=T.getResponseHeader("etag"))&&(k.etag[f]=u)),204===e||"HEAD"===v.type?l="nocontent":304===e?l="notmodified":(l=s.state,o=s.data,i=!(a=s.error))):(a=l,!e&&l||(l="error",e<0&&(e=0))),T.status=e,T.statusText=(t||l)+"",i?x.resolveWith(y,[o,l,T]):x.rejectWith(y,[T,l,a]),T.statusCode(w),w=void 0,g&&m.trigger(i?"ajaxSuccess":"ajaxError",[T,v,i?o:a]),b.fireWith(y,[T,l]),g&&(m.trigger("ajaxComplete",[T,v]),--k.active||k.event.trigger("ajaxStop")))}return T},getJSON:function(e,t,n){return k.get(e,t,n,"json")},getScript:function(e,t){return k.get(e,void 0,t,"script")}}),k.each(["get","post"],function(e,i){k[i]=function(e,t,n,r){return m(t)&&(r=r||n,n=t,t=void 0),k.ajax(k.extend({url:e,type:i,dataType:r,data:t,success:n},k.isPlainObject(e)&&e))}}),k._evalUrl=function(e,t){return k.ajax({url:e,type:"GET",dataType:"script",cache:!0,async:!1,global:!1,converters:{"text script":function(){}},dataFilter:function(e){k.globalEval(e,t)}})},k.fn.extend({wrapAll:function(e){var t;return this[0]&&(m(e)&&(e=e.call(this[0])),t=k(e,this[0].ownerDocument).eq(0).clone(!0),this[0].parentNode&&t.insertBefore(this[0]),t.map(function(){var e=this;while(e.firstElementChild)e=e.firstElementChild;return e}).append(this)),this},wrapInner:function(n){return m(n)?this.each(function(e){k(this).wrapInner(n.call(this,e))}):this.each(function(){var e=k(this),t=e.contents();t.length?t.wrapAll(n):e.append(n)})},wrap:function(t){var n=m(t);return this.each(function(e){k(this).wrapAll(n?t.call(this,e):t)})},unwrap:function(e){return this.parent(e).not("body").each(function(){k(this).replaceWith(this.childNodes)}),this}}),k.expr.pseudos.hidden=function(e){return!k.expr.pseudos.visible(e)},k.expr.pseudos.visible=function(e){return!!(e.offsetWidth||e.offsetHeight||e.getClientRects().length)},k.ajaxSettings.xhr=function(){try{return new C.XMLHttpRequest}catch(e){}};var Ut={0:200,1223:204},Xt=k.ajaxSettings.xhr();y.cors=!!Xt&&"withCredentials"in Xt,y.ajax=Xt=!!Xt,k.ajaxTransport(function(i){var o,a;if(y.cors||Xt&&!i.crossDomain)return{send:function(e,t){var n,r=i.xhr();if(r.open(i.type,i.url,i.async,i.username,i.password),i.xhrFields)for(n in i.xhrFields)r[n]=i.xhrFields[n];for(n in i.mimeType&&r.overrideMimeType&&r.overrideMimeType(i.mimeType),i.crossDomain||e["X-Requested-With"]||(e["X-Requested-With"]="XMLHttpRequest"),e)r.setRequestHeader(n,e[n]);o=function(e){return function(){o&&(o=a=r.onload=r.onerror=r.onabort=r.ontimeout=r.onreadystatechange=null,"abort"===e?r.abort():"error"===e?"number"!=typeof r.status?t(0,"error"):t(r.status,r.statusText):t(Ut[r.status]||r.status,r.statusText,"text"!==(r.responseType||"text")||"string"!=typeof r.responseText?{binary:r.response}:{text:r.responseText},r.getAllResponseHeaders()))}},r.onload=o(),a=r.onerror=r.ontimeout=o("error"),void 0!==r.onabort?r.onabort=a:r.onreadystatechange=function(){4===r.readyState&&C.setTimeout(function(){o&&a()})},o=o("abort");try{r.send(i.hasContent&&i.data||null)}catch(e){if(o)throw e}},abort:function(){o&&o()}}}),k.ajaxPrefilter(function(e){e.crossDomain&&(e.contents.script=!1)}),k.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/\b(?:java|ecma)script\b/},converters:{"text script":function(e){return k.globalEval(e),e}}}),k.ajaxPrefilter("script",function(e){void 0===e.cache&&(e.cache=!1),e.crossDomain&&(e.type="GET")}),k.ajaxTransport("script",function(n){var r,i;if(n.crossDomain||n.scriptAttrs)return{send:function(e,t){r=k("<script>").attr(n.scriptAttrs||{}).prop({charset:n.scriptCharset,src:n.url}).on("load error",i=function(e){r.remove(),i=null,e&&t("error"===e.type?404:200,e.type)}),E.head.appendChild(r[0])},abort:function(){i&&i()}}});var Vt,Gt=[],Yt=/(=)\?(?=&|$)|\?\?/;k.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var e=Gt.pop()||k.expando+"_"+kt++;return this[e]=!0,e}}),k.ajaxPrefilter("json jsonp",function(e,t,n){var r,i,o,a=!1!==e.jsonp&&(Yt.test(e.url)?"url":"string"==typeof e.data&&0===(e.contentType||"").indexOf("application/x-www-form-urlencoded")&&Yt.test(e.data)&&"data");if(a||"jsonp"===e.dataTypes[0])return r=e.jsonpCallback=m(e.jsonpCallback)?e.jsonpCallback():e.jsonpCallback,a?e[a]=e[a].replace(Yt,"$1"+r):!1!==e.jsonp&&(e.url+=(St.test(e.url)?"&":"?")+e.jsonp+"="+r),e.converters["script json"]=function(){return o||k.error(r+" was not called"),o[0]},e.dataTypes[0]="json",i=C[r],C[r]=function(){o=arguments},n.always(function(){void 0===i?k(C).removeProp(r):C[r]=i,e[r]&&(e.jsonpCallback=t.jsonpCallback,Gt.push(r)),o&&m(i)&&i(o[0]),o=i=void 0}),"script"}),y.createHTMLDocument=((Vt=E.implementation.createHTMLDocument("").body).innerHTML="<form></form><form></form>",2===Vt.childNodes.length),k.parseHTML=function(e,t,n){return"string"!=typeof e?[]:("boolean"==typeof t&&(n=t,t=!1),t||(y.createHTMLDocument?((r=(t=E.implementation.createHTMLDocument("")).createElement("base")).href=E.location.href,t.head.appendChild(r)):t=E),o=!n&&[],(i=D.exec(e))?[t.createElement(i[1])]:(i=we([e],t,o),o&&o.length&&k(o).remove(),k.merge([],i.childNodes)));var r,i,o},k.fn.load=function(e,t,n){var r,i,o,a=this,s=e.indexOf(" ");return-1<s&&(r=mt(e.slice(s)),e=e.slice(0,s)),m(t)?(n=t,t=void 0):t&&"object"==typeof t&&(i="POST"),0<a.length&&k.ajax({url:e,type:i||"GET",dataType:"html",data:t}).done(function(e){o=arguments,a.html(r?k("<div>").append(k.parseHTML(e)).find(r):e)}).always(n&&function(e,t){a.each(function(){n.apply(this,o||[e.responseText,t,e])})}),this},k.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(e,t){k.fn[t]=function(e){return this.on(t,e)}}),k.expr.pseudos.animated=function(t){return k.grep(k.timers,function(e){return t===e.elem}).length},k.offset={setOffset:function(e,t,n){var r,i,o,a,s,u,l=k.css(e,"position"),c=k(e),f={};"static"===l&&(e.style.position="relative"),s=c.offset(),o=k.css(e,"top"),u=k.css(e,"left"),("absolute"===l||"fixed"===l)&&-1<(o+u).indexOf("auto")?(a=(r=c.position()).top,i=r.left):(a=parseFloat(o)||0,i=parseFloat(u)||0),m(t)&&(t=t.call(e,n,k.extend({},s))),null!=t.top&&(f.top=t.top-s.top+a),null!=t.left&&(f.left=t.left-s.left+i),"using"in t?t.using.call(e,f):c.css(f)}},k.fn.extend({offset:function(t){if(arguments.length)return void 0===t?this:this.each(function(e){k.offset.setOffset(this,t,e)});var e,n,r=this[0];return r?r.getClientRects().length?(e=r.getBoundingClientRect(),n=r.ownerDocument.defaultView,{top:e.top+n.pageYOffset,left:e.left+n.pageXOffset}):{top:0,left:0}:void 0},position:function(){if(this[0]){var e,t,n,r=this[0],i={top:0,left:0};if("fixed"===k.css(r,"position"))t=r.getBoundingClientRect();else{t=this.offset(),n=r.ownerDocument,e=r.offsetParent||n.documentElement;while(e&&(e===n.body||e===n.documentElement)&&"static"===k.css(e,"position"))e=e.parentNode;e&&e!==r&&1===e.nodeType&&((i=k(e).offset()).top+=k.css(e,"borderTopWidth",!0),i.left+=k.css(e,"borderLeftWidth",!0))}return{top:t.top-i.top-k.css(r,"marginTop",!0),left:t.left-i.left-k.css(r,"marginLeft",!0)}}},offsetParent:function(){return this.map(function(){var e=this.offsetParent;while(e&&"static"===k.css(e,"position"))e=e.offsetParent;return e||ie})}}),k.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(t,i){var o="pageYOffset"===i;k.fn[t]=function(e){return _(this,function(e,t,n){var r;if(x(e)?r=e:9===e.nodeType&&(r=e.defaultView),void 0===n)return r?r[i]:e[t];r?r.scrollTo(o?r.pageXOffset:n,o?n:r.pageYOffset):e[t]=n},t,e,arguments.length)}}),k.each(["top","left"],function(e,n){k.cssHooks[n]=ze(y.pixelPosition,function(e,t){if(t)return t=_e(e,n),$e.test(t)?k(e).position()[n]+"px":t})}),k.each({Height:"height",Width:"width"},function(a,s){k.each({padding:"inner"+a,content:s,"":"outer"+a},function(r,o){k.fn[o]=function(e,t){var n=arguments.length&&(r||"boolean"!=typeof e),i=r||(!0===e||!0===t?"margin":"border");return _(this,function(e,t,n){var r;return x(e)?0===o.indexOf("outer")?e["inner"+a]:e.document.documentElement["client"+a]:9===e.nodeType?(r=e.documentElement,Math.max(e.body["scroll"+a],r["scroll"+a],e.body["offset"+a],r["offset"+a],r["client"+a])):void 0===n?k.css(e,t,i):k.style(e,t,n,i)},s,n?e:void 0,n)}})}),k.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "),function(e,n){k.fn[n]=function(e,t){return 0<arguments.length?this.on(n,null,e,t):this.trigger(n)}}),k.fn.extend({hover:function(e,t){return this.mouseenter(e).mouseleave(t||e)}}),k.fn.extend({bind:function(e,t,n){return this.on(e,null,t,n)},unbind:function(e,t){return this.off(e,null,t)},delegate:function(e,t,n,r){return this.on(t,e,n,r)},undelegate:function(e,t,n){return 1===arguments.length?this.off(e,"**"):this.off(t,e||"**",n)}}),k.proxy=function(e,t){var n,r,i;if("string"==typeof t&&(n=e[t],t=e,e=n),m(e))return r=s.call(arguments,2),(i=function(){return e.apply(t||this,r.concat(s.call(arguments)))}).guid=e.guid=e.guid||k.guid++,i},k.holdReady=function(e){e?k.readyWait++:k.ready(!0)},k.isArray=Array.isArray,k.parseJSON=JSON.parse,k.nodeName=A,k.isFunction=m,k.isWindow=x,k.camelCase=V,k.type=w,k.now=Date.now,k.isNumeric=function(e){var t=k.type(e);return("number"===t||"string"===t)&&!isNaN(e-parseFloat(e))},"function"==typeof define&&define.amd&&define("jquery",[],function(){return k});var Qt=C.jQuery,Jt=C.$;return k.noConflict=function(e){return C.$===k&&(C.$=Jt),e&&C.jQuery===k&&(C.jQuery=Qt),k},e||(C.jQuery=C.$=k),k});
;/*!
 * Bootstrap v3.4.1 (https://getbootstrap.com/)
 * Copyright 2011-2019 Twitter, Inc.
 * Licensed under the MIT license
 */
if("undefined"==typeof jQuery)throw new Error("Bootstrap's JavaScript requires jQuery");!function(t){"use strict";var e=jQuery.fn.jquery.split(" ")[0].split(".");if(e[0]<2&&e[1]<9||1==e[0]&&9==e[1]&&e[2]<1||3<e[0])throw new Error("Bootstrap's JavaScript requires jQuery version 1.9.1 or higher, but lower than version 4")}(),function(n){"use strict";n.fn.emulateTransitionEnd=function(t){var e=!1,i=this;n(this).one("bsTransitionEnd",function(){e=!0});return setTimeout(function(){e||n(i).trigger(n.support.transition.end)},t),this},n(function(){n.support.transition=function o(){var t=document.createElement("bootstrap"),e={WebkitTransition:"webkitTransitionEnd",MozTransition:"transitionend",OTransition:"oTransitionEnd otransitionend",transition:"transitionend"};for(var i in e)if(t.style[i]!==undefined)return{end:e[i]};return!1}(),n.support.transition&&(n.event.special.bsTransitionEnd={bindType:n.support.transition.end,delegateType:n.support.transition.end,handle:function(t){if(n(t.target).is(this))return t.handleObj.handler.apply(this,arguments)}})})}(jQuery),function(s){"use strict";var e='[data-dismiss="alert"]',a=function(t){s(t).on("click",e,this.close)};a.VERSION="3.4.1",a.TRANSITION_DURATION=150,a.prototype.close=function(t){var e=s(this),i=e.attr("data-target");i||(i=(i=e.attr("href"))&&i.replace(/.*(?=#[^\s]*$)/,"")),i="#"===i?[]:i;var o=s(document).find(i);function n(){o.detach().trigger("closed.bs.alert").remove()}t&&t.preventDefault(),o.length||(o=e.closest(".alert")),o.trigger(t=s.Event("close.bs.alert")),t.isDefaultPrevented()||(o.removeClass("in"),s.support.transition&&o.hasClass("fade")?o.one("bsTransitionEnd",n).emulateTransitionEnd(a.TRANSITION_DURATION):n())};var t=s.fn.alert;s.fn.alert=function o(i){return this.each(function(){var t=s(this),e=t.data("bs.alert");e||t.data("bs.alert",e=new a(this)),"string"==typeof i&&e[i].call(t)})},s.fn.alert.Constructor=a,s.fn.alert.noConflict=function(){return s.fn.alert=t,this},s(document).on("click.bs.alert.data-api",e,a.prototype.close)}(jQuery),function(s){"use strict";var n=function(t,e){this.$element=s(t),this.options=s.extend({},n.DEFAULTS,e),this.isLoading=!1};function i(o){return this.each(function(){var t=s(this),e=t.data("bs.button"),i="object"==typeof o&&o;e||t.data("bs.button",e=new n(this,i)),"toggle"==o?e.toggle():o&&e.setState(o)})}n.VERSION="3.4.1",n.DEFAULTS={loadingText:"loading..."},n.prototype.setState=function(t){var e="disabled",i=this.$element,o=i.is("input")?"val":"html",n=i.data();t+="Text",null==n.resetText&&i.data("resetText",i[o]()),setTimeout(s.proxy(function(){i[o](null==n[t]?this.options[t]:n[t]),"loadingText"==t?(this.isLoading=!0,i.addClass(e).attr(e,e).prop(e,!0)):this.isLoading&&(this.isLoading=!1,i.removeClass(e).removeAttr(e).prop(e,!1))},this),0)},n.prototype.toggle=function(){var t=!0,e=this.$element.closest('[data-toggle="buttons"]');if(e.length){var i=this.$element.find("input");"radio"==i.prop("type")?(i.prop("checked")&&(t=!1),e.find(".active").removeClass("active"),this.$element.addClass("active")):"checkbox"==i.prop("type")&&(i.prop("checked")!==this.$element.hasClass("active")&&(t=!1),this.$element.toggleClass("active")),i.prop("checked",this.$element.hasClass("active")),t&&i.trigger("change")}else this.$element.attr("aria-pressed",!this.$element.hasClass("active")),this.$element.toggleClass("active")};var t=s.fn.button;s.fn.button=i,s.fn.button.Constructor=n,s.fn.button.noConflict=function(){return s.fn.button=t,this},s(document).on("click.bs.button.data-api",'[data-toggle^="button"]',function(t){var e=s(t.target).closest(".btn");i.call(e,"toggle"),s(t.target).is('input[type="radio"], input[type="checkbox"]')||(t.preventDefault(),e.is("input,button")?e.trigger("focus"):e.find("input:visible,button:visible").first().trigger("focus"))}).on("focus.bs.button.data-api blur.bs.button.data-api",'[data-toggle^="button"]',function(t){s(t.target).closest(".btn").toggleClass("focus",/^focus(in)?$/.test(t.type))})}(jQuery),function(p){"use strict";var c=function(t,e){this.$element=p(t),this.$indicators=this.$element.find(".carousel-indicators"),this.options=e,this.paused=null,this.sliding=null,this.interval=null,this.$active=null,this.$items=null,this.options.keyboard&&this.$element.on("keydown.bs.carousel",p.proxy(this.keydown,this)),"hover"==this.options.pause&&!("ontouchstart"in document.documentElement)&&this.$element.on("mouseenter.bs.carousel",p.proxy(this.pause,this)).on("mouseleave.bs.carousel",p.proxy(this.cycle,this))};function r(n){return this.each(function(){var t=p(this),e=t.data("bs.carousel"),i=p.extend({},c.DEFAULTS,t.data(),"object"==typeof n&&n),o="string"==typeof n?n:i.slide;e||t.data("bs.carousel",e=new c(this,i)),"number"==typeof n?e.to(n):o?e[o]():i.interval&&e.pause().cycle()})}c.VERSION="3.4.1",c.TRANSITION_DURATION=600,c.DEFAULTS={interval:5e3,pause:"hover",wrap:!0,keyboard:!0},c.prototype.keydown=function(t){if(!/input|textarea/i.test(t.target.tagName)){switch(t.which){case 37:this.prev();break;case 39:this.next();break;default:return}t.preventDefault()}},c.prototype.cycle=function(t){return t||(this.paused=!1),this.interval&&clearInterval(this.interval),this.options.interval&&!this.paused&&(this.interval=setInterval(p.proxy(this.next,this),this.options.interval)),this},c.prototype.getItemIndex=function(t){return this.$items=t.parent().children(".item"),this.$items.index(t||this.$active)},c.prototype.getItemForDirection=function(t,e){var i=this.getItemIndex(e);if(("prev"==t&&0===i||"next"==t&&i==this.$items.length-1)&&!this.options.wrap)return e;var o=(i+("prev"==t?-1:1))%this.$items.length;return this.$items.eq(o)},c.prototype.to=function(t){var e=this,i=this.getItemIndex(this.$active=this.$element.find(".item.active"));if(!(t>this.$items.length-1||t<0))return this.sliding?this.$element.one("slid.bs.carousel",function(){e.to(t)}):i==t?this.pause().cycle():this.slide(i<t?"next":"prev",this.$items.eq(t))},c.prototype.pause=function(t){return t||(this.paused=!0),this.$element.find(".next, .prev").length&&p.support.transition&&(this.$element.trigger(p.support.transition.end),this.cycle(!0)),this.interval=clearInterval(this.interval),this},c.prototype.next=function(){if(!this.sliding)return this.slide("next")},c.prototype.prev=function(){if(!this.sliding)return this.slide("prev")},c.prototype.slide=function(t,e){var i=this.$element.find(".item.active"),o=e||this.getItemForDirection(t,i),n=this.interval,s="next"==t?"left":"right",a=this;if(o.hasClass("active"))return this.sliding=!1;var r=o[0],l=p.Event("slide.bs.carousel",{relatedTarget:r,direction:s});if(this.$element.trigger(l),!l.isDefaultPrevented()){if(this.sliding=!0,n&&this.pause(),this.$indicators.length){this.$indicators.find(".active").removeClass("active");var h=p(this.$indicators.children()[this.getItemIndex(o)]);h&&h.addClass("active")}var d=p.Event("slid.bs.carousel",{relatedTarget:r,direction:s});return p.support.transition&&this.$element.hasClass("slide")?(o.addClass(t),"object"==typeof o&&o.length&&o[0].offsetWidth,i.addClass(s),o.addClass(s),i.one("bsTransitionEnd",function(){o.removeClass([t,s].join(" ")).addClass("active"),i.removeClass(["active",s].join(" ")),a.sliding=!1,setTimeout(function(){a.$element.trigger(d)},0)}).emulateTransitionEnd(c.TRANSITION_DURATION)):(i.removeClass("active"),o.addClass("active"),this.sliding=!1,this.$element.trigger(d)),n&&this.cycle(),this}};var t=p.fn.carousel;p.fn.carousel=r,p.fn.carousel.Constructor=c,p.fn.carousel.noConflict=function(){return p.fn.carousel=t,this};var e=function(t){var e=p(this),i=e.attr("href");i&&(i=i.replace(/.*(?=#[^\s]+$)/,""));var o=e.attr("data-target")||i,n=p(document).find(o);if(n.hasClass("carousel")){var s=p.extend({},n.data(),e.data()),a=e.attr("data-slide-to");a&&(s.interval=!1),r.call(n,s),a&&n.data("bs.carousel").to(a),t.preventDefault()}};p(document).on("click.bs.carousel.data-api","[data-slide]",e).on("click.bs.carousel.data-api","[data-slide-to]",e),p(window).on("load",function(){p('[data-ride="carousel"]').each(function(){var t=p(this);r.call(t,t.data())})})}(jQuery),function(a){"use strict";var r=function(t,e){this.$element=a(t),this.options=a.extend({},r.DEFAULTS,e),this.$trigger=a('[data-toggle="collapse"][href="#'+t.id+'"],[data-toggle="collapse"][data-target="#'+t.id+'"]'),this.transitioning=null,this.options.parent?this.$parent=this.getParent():this.addAriaAndCollapsedClass(this.$element,this.$trigger),this.options.toggle&&this.toggle()};function n(t){var e,i=t.attr("data-target")||(e=t.attr("href"))&&e.replace(/.*(?=#[^\s]+$)/,"");return a(document).find(i)}function l(o){return this.each(function(){var t=a(this),e=t.data("bs.collapse"),i=a.extend({},r.DEFAULTS,t.data(),"object"==typeof o&&o);!e&&i.toggle&&/show|hide/.test(o)&&(i.toggle=!1),e||t.data("bs.collapse",e=new r(this,i)),"string"==typeof o&&e[o]()})}r.VERSION="3.4.1",r.TRANSITION_DURATION=350,r.DEFAULTS={toggle:!0},r.prototype.dimension=function(){return this.$element.hasClass("width")?"width":"height"},r.prototype.show=function(){if(!this.transitioning&&!this.$element.hasClass("in")){var t,e=this.$parent&&this.$parent.children(".panel").children(".in, .collapsing");if(!(e&&e.length&&(t=e.data("bs.collapse"))&&t.transitioning)){var i=a.Event("show.bs.collapse");if(this.$element.trigger(i),!i.isDefaultPrevented()){e&&e.length&&(l.call(e,"hide"),t||e.data("bs.collapse",null));var o=this.dimension();this.$element.removeClass("collapse").addClass("collapsing")[o](0).attr("aria-expanded",!0),this.$trigger.removeClass("collapsed").attr("aria-expanded",!0),this.transitioning=1;var n=function(){this.$element.removeClass("collapsing").addClass("collapse in")[o](""),this.transitioning=0,this.$element.trigger("shown.bs.collapse")};if(!a.support.transition)return n.call(this);var s=a.camelCase(["scroll",o].join("-"));this.$element.one("bsTransitionEnd",a.proxy(n,this)).emulateTransitionEnd(r.TRANSITION_DURATION)[o](this.$element[0][s])}}}},r.prototype.hide=function(){if(!this.transitioning&&this.$element.hasClass("in")){var t=a.Event("hide.bs.collapse");if(this.$element.trigger(t),!t.isDefaultPrevented()){var e=this.dimension();this.$element[e](this.$element[e]())[0].offsetHeight,this.$element.addClass("collapsing").removeClass("collapse in").attr("aria-expanded",!1),this.$trigger.addClass("collapsed").attr("aria-expanded",!1),this.transitioning=1;var i=function(){this.transitioning=0,this.$element.removeClass("collapsing").addClass("collapse").trigger("hidden.bs.collapse")};if(!a.support.transition)return i.call(this);this.$element[e](0).one("bsTransitionEnd",a.proxy(i,this)).emulateTransitionEnd(r.TRANSITION_DURATION)}}},r.prototype.toggle=function(){this[this.$element.hasClass("in")?"hide":"show"]()},r.prototype.getParent=function(){return a(document).find(this.options.parent).find('[data-toggle="collapse"][data-parent="'+this.options.parent+'"]').each(a.proxy(function(t,e){var i=a(e);this.addAriaAndCollapsedClass(n(i),i)},this)).end()},r.prototype.addAriaAndCollapsedClass=function(t,e){var i=t.hasClass("in");t.attr("aria-expanded",i),e.toggleClass("collapsed",!i).attr("aria-expanded",i)};var t=a.fn.collapse;a.fn.collapse=l,a.fn.collapse.Constructor=r,a.fn.collapse.noConflict=function(){return a.fn.collapse=t,this},a(document).on("click.bs.collapse.data-api",'[data-toggle="collapse"]',function(t){var e=a(this);e.attr("data-target")||t.preventDefault();var i=n(e),o=i.data("bs.collapse")?"toggle":e.data();l.call(i,o)})}(jQuery),function(a){"use strict";var r='[data-toggle="dropdown"]',o=function(t){a(t).on("click.bs.dropdown",this.toggle)};function l(t){var e=t.attr("data-target");e||(e=(e=t.attr("href"))&&/#[A-Za-z]/.test(e)&&e.replace(/.*(?=#[^\s]*$)/,""));var i="#"!==e?a(document).find(e):null;return i&&i.length?i:t.parent()}function s(o){o&&3===o.which||(a(".dropdown-backdrop").remove(),a(r).each(function(){var t=a(this),e=l(t),i={relatedTarget:this};e.hasClass("open")&&(o&&"click"==o.type&&/input|textarea/i.test(o.target.tagName)&&a.contains(e[0],o.target)||(e.trigger(o=a.Event("hide.bs.dropdown",i)),o.isDefaultPrevented()||(t.attr("aria-expanded","false"),e.removeClass("open").trigger(a.Event("hidden.bs.dropdown",i)))))}))}o.VERSION="3.4.1",o.prototype.toggle=function(t){var e=a(this);if(!e.is(".disabled, :disabled")){var i=l(e),o=i.hasClass("open");if(s(),!o){"ontouchstart"in document.documentElement&&!i.closest(".navbar-nav").length&&a(document.createElement("div")).addClass("dropdown-backdrop").insertAfter(a(this)).on("click",s);var n={relatedTarget:this};if(i.trigger(t=a.Event("show.bs.dropdown",n)),t.isDefaultPrevented())return;e.trigger("focus").attr("aria-expanded","true"),i.toggleClass("open").trigger(a.Event("shown.bs.dropdown",n))}return!1}},o.prototype.keydown=function(t){if(/(38|40|27|32)/.test(t.which)&&!/input|textarea/i.test(t.target.tagName)){var e=a(this);if(t.preventDefault(),t.stopPropagation(),!e.is(".disabled, :disabled")){var i=l(e),o=i.hasClass("open");if(!o&&27!=t.which||o&&27==t.which)return 27==t.which&&i.find(r).trigger("focus"),e.trigger("click");var n=i.find(".dropdown-menu li:not(.disabled):visible a");if(n.length){var s=n.index(t.target);38==t.which&&0<s&&s--,40==t.which&&s<n.length-1&&s++,~s||(s=0),n.eq(s).trigger("focus")}}}};var t=a.fn.dropdown;a.fn.dropdown=function e(i){return this.each(function(){var t=a(this),e=t.data("bs.dropdown");e||t.data("bs.dropdown",e=new o(this)),"string"==typeof i&&e[i].call(t)})},a.fn.dropdown.Constructor=o,a.fn.dropdown.noConflict=function(){return a.fn.dropdown=t,this},a(document).on("click.bs.dropdown.data-api",s).on("click.bs.dropdown.data-api",".dropdown form",function(t){t.stopPropagation()}).on("click.bs.dropdown.data-api",r,o.prototype.toggle).on("keydown.bs.dropdown.data-api",r,o.prototype.keydown).on("keydown.bs.dropdown.data-api",".dropdown-menu",o.prototype.keydown)}(jQuery),function(a){"use strict";var s=function(t,e){this.options=e,this.$body=a(document.body),this.$element=a(t),this.$dialog=this.$element.find(".modal-dialog"),this.$backdrop=null,this.isShown=null,this.originalBodyPad=null,this.scrollbarWidth=0,this.ignoreBackdropClick=!1,this.fixedContent=".navbar-fixed-top, .navbar-fixed-bottom",this.options.remote&&this.$element.find(".modal-content").load(this.options.remote,a.proxy(function(){this.$element.trigger("loaded.bs.modal")},this))};function r(o,n){return this.each(function(){var t=a(this),e=t.data("bs.modal"),i=a.extend({},s.DEFAULTS,t.data(),"object"==typeof o&&o);e||t.data("bs.modal",e=new s(this,i)),"string"==typeof o?e[o](n):i.show&&e.show(n)})}s.VERSION="3.4.1",s.TRANSITION_DURATION=300,s.BACKDROP_TRANSITION_DURATION=150,s.DEFAULTS={backdrop:!0,keyboard:!0,show:!0},s.prototype.toggle=function(t){return this.isShown?this.hide():this.show(t)},s.prototype.show=function(i){var o=this,t=a.Event("show.bs.modal",{relatedTarget:i});this.$element.trigger(t),this.isShown||t.isDefaultPrevented()||(this.isShown=!0,this.checkScrollbar(),this.setScrollbar(),this.$body.addClass("modal-open"),this.escape(),this.resize(),this.$element.on("click.dismiss.bs.modal",'[data-dismiss="modal"]',a.proxy(this.hide,this)),this.$dialog.on("mousedown.dismiss.bs.modal",function(){o.$element.one("mouseup.dismiss.bs.modal",function(t){a(t.target).is(o.$element)&&(o.ignoreBackdropClick=!0)})}),this.backdrop(function(){var t=a.support.transition&&o.$element.hasClass("fade");o.$element.parent().length||o.$element.appendTo(o.$body),o.$element.show().scrollTop(0),o.adjustDialog(),t&&o.$element[0].offsetWidth,o.$element.addClass("in"),o.enforceFocus();var e=a.Event("shown.bs.modal",{relatedTarget:i});t?o.$dialog.one("bsTransitionEnd",function(){o.$element.trigger("focus").trigger(e)}).emulateTransitionEnd(s.TRANSITION_DURATION):o.$element.trigger("focus").trigger(e)}))},s.prototype.hide=function(t){t&&t.preventDefault(),t=a.Event("hide.bs.modal"),this.$element.trigger(t),this.isShown&&!t.isDefaultPrevented()&&(this.isShown=!1,this.escape(),this.resize(),a(document).off("focusin.bs.modal"),this.$element.removeClass("in").off("click.dismiss.bs.modal").off("mouseup.dismiss.bs.modal"),this.$dialog.off("mousedown.dismiss.bs.modal"),a.support.transition&&this.$element.hasClass("fade")?this.$element.one("bsTransitionEnd",a.proxy(this.hideModal,this)).emulateTransitionEnd(s.TRANSITION_DURATION):this.hideModal())},s.prototype.enforceFocus=function(){a(document).off("focusin.bs.modal").on("focusin.bs.modal",a.proxy(function(t){document===t.target||this.$element[0]===t.target||this.$element.has(t.target).length||this.$element.trigger("focus")},this))},s.prototype.escape=function(){this.isShown&&this.options.keyboard?this.$element.on("keydown.dismiss.bs.modal",a.proxy(function(t){27==t.which&&this.hide()},this)):this.isShown||this.$element.off("keydown.dismiss.bs.modal")},s.prototype.resize=function(){this.isShown?a(window).on("resize.bs.modal",a.proxy(this.handleUpdate,this)):a(window).off("resize.bs.modal")},s.prototype.hideModal=function(){var t=this;this.$element.hide(),this.backdrop(function(){t.$body.removeClass("modal-open"),t.resetAdjustments(),t.resetScrollbar(),t.$element.trigger("hidden.bs.modal")})},s.prototype.removeBackdrop=function(){this.$backdrop&&this.$backdrop.remove(),this.$backdrop=null},s.prototype.backdrop=function(t){var e=this,i=this.$element.hasClass("fade")?"fade":"";if(this.isShown&&this.options.backdrop){var o=a.support.transition&&i;if(this.$backdrop=a(document.createElement("div")).addClass("modal-backdrop "+i).appendTo(this.$body),this.$element.on("click.dismiss.bs.modal",a.proxy(function(t){this.ignoreBackdropClick?this.ignoreBackdropClick=!1:t.target===t.currentTarget&&("static"==this.options.backdrop?this.$element[0].focus():this.hide())},this)),o&&this.$backdrop[0].offsetWidth,this.$backdrop.addClass("in"),!t)return;o?this.$backdrop.one("bsTransitionEnd",t).emulateTransitionEnd(s.BACKDROP_TRANSITION_DURATION):t()}else if(!this.isShown&&this.$backdrop){this.$backdrop.removeClass("in");var n=function(){e.removeBackdrop(),t&&t()};a.support.transition&&this.$element.hasClass("fade")?this.$backdrop.one("bsTransitionEnd",n).emulateTransitionEnd(s.BACKDROP_TRANSITION_DURATION):n()}else t&&t()},s.prototype.handleUpdate=function(){this.adjustDialog()},s.prototype.adjustDialog=function(){var t=this.$element[0].scrollHeight>document.documentElement.clientHeight;this.$element.css({paddingLeft:!this.bodyIsOverflowing&&t?this.scrollbarWidth:"",paddingRight:this.bodyIsOverflowing&&!t?this.scrollbarWidth:""})},s.prototype.resetAdjustments=function(){this.$element.css({paddingLeft:"",paddingRight:""})},s.prototype.checkScrollbar=function(){var t=window.innerWidth;if(!t){var e=document.documentElement.getBoundingClientRect();t=e.right-Math.abs(e.left)}this.bodyIsOverflowing=document.body.clientWidth<t,this.scrollbarWidth=this.measureScrollbar()},s.prototype.setScrollbar=function(){var t=parseInt(this.$body.css("padding-right")||0,10);this.originalBodyPad=document.body.style.paddingRight||"";var n=this.scrollbarWidth;this.bodyIsOverflowing&&(this.$body.css("padding-right",t+n),a(this.fixedContent).each(function(t,e){var i=e.style.paddingRight,o=a(e).css("padding-right");a(e).data("padding-right",i).css("padding-right",parseFloat(o)+n+"px")}))},s.prototype.resetScrollbar=function(){this.$body.css("padding-right",this.originalBodyPad),a(this.fixedContent).each(function(t,e){var i=a(e).data("padding-right");a(e).removeData("padding-right"),e.style.paddingRight=i||""})},s.prototype.measureScrollbar=function(){var t=document.createElement("div");t.className="modal-scrollbar-measure",this.$body.append(t);var e=t.offsetWidth-t.clientWidth;return this.$body[0].removeChild(t),e};var t=a.fn.modal;a.fn.modal=r,a.fn.modal.Constructor=s,a.fn.modal.noConflict=function(){return a.fn.modal=t,this},a(document).on("click.bs.modal.data-api",'[data-toggle="modal"]',function(t){var e=a(this),i=e.attr("href"),o=e.attr("data-target")||i&&i.replace(/.*(?=#[^\s]+$)/,""),n=a(document).find(o),s=n.data("bs.modal")?"toggle":a.extend({remote:!/#/.test(i)&&i},n.data(),e.data());e.is("a")&&t.preventDefault(),n.one("show.bs.modal",function(t){t.isDefaultPrevented()||n.one("hidden.bs.modal",function(){e.is(":visible")&&e.trigger("focus")})}),r.call(n,s,this)})}(jQuery),function(g){"use strict";var o=["sanitize","whiteList","sanitizeFn"],a=["background","cite","href","itemtype","longdesc","poster","src","xlink:href"],t={"*":["class","dir","id","lang","role",/^aria-[\w-]*$/i],a:["target","href","title","rel"],area:[],b:[],br:[],col:[],code:[],div:[],em:[],hr:[],h1:[],h2:[],h3:[],h4:[],h5:[],h6:[],i:[],img:["src","alt","title","width","height"],li:[],ol:[],p:[],pre:[],s:[],small:[],span:[],sub:[],sup:[],strong:[],u:[],ul:[]},r=/^(?:(?:https?|mailto|ftp|tel|file):|[^&:/?#]*(?:[/?#]|$))/gi,l=/^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+/]+=*$/i;function u(t,e){var i=t.nodeName.toLowerCase();if(-1!==g.inArray(i,e))return-1===g.inArray(i,a)||Boolean(t.nodeValue.match(r)||t.nodeValue.match(l));for(var o=g(e).filter(function(t,e){return e instanceof RegExp}),n=0,s=o.length;n<s;n++)if(i.match(o[n]))return!0;return!1}function n(t,e,i){if(0===t.length)return t;if(i&&"function"==typeof i)return i(t);if(!document.implementation||!document.implementation.createHTMLDocument)return t;var o=document.implementation.createHTMLDocument("sanitization");o.body.innerHTML=t;for(var n=g.map(e,function(t,e){return e}),s=g(o.body).find("*"),a=0,r=s.length;a<r;a++){var l=s[a],h=l.nodeName.toLowerCase();if(-1!==g.inArray(h,n))for(var d=g.map(l.attributes,function(t){return t}),p=[].concat(e["*"]||[],e[h]||[]),c=0,f=d.length;c<f;c++)u(d[c],p)||l.removeAttribute(d[c].nodeName);else l.parentNode.removeChild(l)}return o.body.innerHTML}var m=function(t,e){this.type=null,this.options=null,this.enabled=null,this.timeout=null,this.hoverState=null,this.$element=null,this.inState=null,this.init("tooltip",t,e)};m.VERSION="3.4.1",m.TRANSITION_DURATION=150,m.DEFAULTS={animation:!0,placement:"top",selector:!1,template:'<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',trigger:"hover focus",title:"",delay:0,html:!1,container:!1,viewport:{selector:"body",padding:0},sanitize:!0,sanitizeFn:null,whiteList:t},m.prototype.init=function(t,e,i){if(this.enabled=!0,this.type=t,this.$element=g(e),this.options=this.getOptions(i),this.$viewport=this.options.viewport&&g(document).find(g.isFunction(this.options.viewport)?this.options.viewport.call(this,this.$element):this.options.viewport.selector||this.options.viewport),this.inState={click:!1,hover:!1,focus:!1},this.$element[0]instanceof document.constructor&&!this.options.selector)throw new Error("`selector` option must be specified when initializing "+this.type+" on the window.document object!");for(var o=this.options.trigger.split(" "),n=o.length;n--;){var s=o[n];if("click"==s)this.$element.on("click."+this.type,this.options.selector,g.proxy(this.toggle,this));else if("manual"!=s){var a="hover"==s?"mouseenter":"focusin",r="hover"==s?"mouseleave":"focusout";this.$element.on(a+"."+this.type,this.options.selector,g.proxy(this.enter,this)),this.$element.on(r+"."+this.type,this.options.selector,g.proxy(this.leave,this))}}this.options.selector?this._options=g.extend({},this.options,{trigger:"manual",selector:""}):this.fixTitle()},m.prototype.getDefaults=function(){return m.DEFAULTS},m.prototype.getOptions=function(t){var e=this.$element.data();for(var i in e)e.hasOwnProperty(i)&&-1!==g.inArray(i,o)&&delete e[i];return(t=g.extend({},this.getDefaults(),e,t)).delay&&"number"==typeof t.delay&&(t.delay={show:t.delay,hide:t.delay}),t.sanitize&&(t.template=n(t.template,t.whiteList,t.sanitizeFn)),t},m.prototype.getDelegateOptions=function(){var i={},o=this.getDefaults();return this._options&&g.each(this._options,function(t,e){o[t]!=e&&(i[t]=e)}),i},m.prototype.enter=function(t){var e=t instanceof this.constructor?t:g(t.currentTarget).data("bs."+this.type);if(e||(e=new this.constructor(t.currentTarget,this.getDelegateOptions()),g(t.currentTarget).data("bs."+this.type,e)),t instanceof g.Event&&(e.inState["focusin"==t.type?"focus":"hover"]=!0),e.tip().hasClass("in")||"in"==e.hoverState)e.hoverState="in";else{if(clearTimeout(e.timeout),e.hoverState="in",!e.options.delay||!e.options.delay.show)return e.show();e.timeout=setTimeout(function(){"in"==e.hoverState&&e.show()},e.options.delay.show)}},m.prototype.isInStateTrue=function(){for(var t in this.inState)if(this.inState[t])return!0;return!1},m.prototype.leave=function(t){var e=t instanceof this.constructor?t:g(t.currentTarget).data("bs."+this.type);if(e||(e=new this.constructor(t.currentTarget,this.getDelegateOptions()),g(t.currentTarget).data("bs."+this.type,e)),t instanceof g.Event&&(e.inState["focusout"==t.type?"focus":"hover"]=!1),!e.isInStateTrue()){if(clearTimeout(e.timeout),e.hoverState="out",!e.options.delay||!e.options.delay.hide)return e.hide();e.timeout=setTimeout(function(){"out"==e.hoverState&&e.hide()},e.options.delay.hide)}},m.prototype.show=function(){var t=g.Event("show.bs."+this.type);if(this.hasContent()&&this.enabled){this.$element.trigger(t);var e=g.contains(this.$element[0].ownerDocument.documentElement,this.$element[0]);if(t.isDefaultPrevented()||!e)return;var i=this,o=this.tip(),n=this.getUID(this.type);this.setContent(),o.attr("id",n),this.$element.attr("aria-describedby",n),this.options.animation&&o.addClass("fade");var s="function"==typeof this.options.placement?this.options.placement.call(this,o[0],this.$element[0]):this.options.placement,a=/\s?auto?\s?/i,r=a.test(s);r&&(s=s.replace(a,"")||"top"),o.detach().css({top:0,left:0,display:"block"}).addClass(s).data("bs."+this.type,this),this.options.container?o.appendTo(g(document).find(this.options.container)):o.insertAfter(this.$element),this.$element.trigger("inserted.bs."+this.type);var l=this.getPosition(),h=o[0].offsetWidth,d=o[0].offsetHeight;if(r){var p=s,c=this.getPosition(this.$viewport);s="bottom"==s&&l.bottom+d>c.bottom?"top":"top"==s&&l.top-d<c.top?"bottom":"right"==s&&l.right+h>c.width?"left":"left"==s&&l.left-h<c.left?"right":s,o.removeClass(p).addClass(s)}var f=this.getCalculatedOffset(s,l,h,d);this.applyPlacement(f,s);var u=function(){var t=i.hoverState;i.$element.trigger("shown.bs."+i.type),i.hoverState=null,"out"==t&&i.leave(i)};g.support.transition&&this.$tip.hasClass("fade")?o.one("bsTransitionEnd",u).emulateTransitionEnd(m.TRANSITION_DURATION):u()}},m.prototype.applyPlacement=function(t,e){var i=this.tip(),o=i[0].offsetWidth,n=i[0].offsetHeight,s=parseInt(i.css("margin-top"),10),a=parseInt(i.css("margin-left"),10);isNaN(s)&&(s=0),isNaN(a)&&(a=0),t.top+=s,t.left+=a,g.offset.setOffset(i[0],g.extend({using:function(t){i.css({top:Math.round(t.top),left:Math.round(t.left)})}},t),0),i.addClass("in");var r=i[0].offsetWidth,l=i[0].offsetHeight;"top"==e&&l!=n&&(t.top=t.top+n-l);var h=this.getViewportAdjustedDelta(e,t,r,l);h.left?t.left+=h.left:t.top+=h.top;var d=/top|bottom/.test(e),p=d?2*h.left-o+r:2*h.top-n+l,c=d?"offsetWidth":"offsetHeight";i.offset(t),this.replaceArrow(p,i[0][c],d)},m.prototype.replaceArrow=function(t,e,i){this.arrow().css(i?"left":"top",50*(1-t/e)+"%").css(i?"top":"left","")},m.prototype.setContent=function(){var t=this.tip(),e=this.getTitle();this.options.html?(this.options.sanitize&&(e=n(e,this.options.whiteList,this.options.sanitizeFn)),t.find(".tooltip-inner").html(e)):t.find(".tooltip-inner").text(e),t.removeClass("fade in top bottom left right")},m.prototype.hide=function(t){var e=this,i=g(this.$tip),o=g.Event("hide.bs."+this.type);function n(){"in"!=e.hoverState&&i.detach(),e.$element&&e.$element.removeAttr("aria-describedby").trigger("hidden.bs."+e.type),t&&t()}if(this.$element.trigger(o),!o.isDefaultPrevented())return i.removeClass("in"),g.support.transition&&i.hasClass("fade")?i.one("bsTransitionEnd",n).emulateTransitionEnd(m.TRANSITION_DURATION):n(),this.hoverState=null,this},m.prototype.fixTitle=function(){var t=this.$element;(t.attr("title")||"string"!=typeof t.attr("data-original-title"))&&t.attr("data-original-title",t.attr("title")||"").attr("title","")},m.prototype.hasContent=function(){return this.getTitle()},m.prototype.getPosition=function(t){var e=(t=t||this.$element)[0],i="BODY"==e.tagName,o=e.getBoundingClientRect();null==o.width&&(o=g.extend({},o,{width:o.right-o.left,height:o.bottom-o.top}));var n=window.SVGElement&&e instanceof window.SVGElement,s=i?{top:0,left:0}:n?null:t.offset(),a={scroll:i?document.documentElement.scrollTop||document.body.scrollTop:t.scrollTop()},r=i?{width:g(window).width(),height:g(window).height()}:null;return g.extend({},o,a,r,s)},m.prototype.getCalculatedOffset=function(t,e,i,o){return"bottom"==t?{top:e.top+e.height,left:e.left+e.width/2-i/2}:"top"==t?{top:e.top-o,left:e.left+e.width/2-i/2}:"left"==t?{top:e.top+e.height/2-o/2,left:e.left-i}:{top:e.top+e.height/2-o/2,left:e.left+e.width}},m.prototype.getViewportAdjustedDelta=function(t,e,i,o){var n={top:0,left:0};if(!this.$viewport)return n;var s=this.options.viewport&&this.options.viewport.padding||0,a=this.getPosition(this.$viewport);if(/right|left/.test(t)){var r=e.top-s-a.scroll,l=e.top+s-a.scroll+o;r<a.top?n.top=a.top-r:l>a.top+a.height&&(n.top=a.top+a.height-l)}else{var h=e.left-s,d=e.left+s+i;h<a.left?n.left=a.left-h:d>a.right&&(n.left=a.left+a.width-d)}return n},m.prototype.getTitle=function(){var t=this.$element,e=this.options;return t.attr("data-original-title")||("function"==typeof e.title?e.title.call(t[0]):e.title)},m.prototype.getUID=function(t){for(;t+=~~(1e6*Math.random()),document.getElementById(t););return t},m.prototype.tip=function(){if(!this.$tip&&(this.$tip=g(this.options.template),1!=this.$tip.length))throw new Error(this.type+" `template` option must consist of exactly 1 top-level element!");return this.$tip},m.prototype.arrow=function(){return this.$arrow=this.$arrow||this.tip().find(".tooltip-arrow")},m.prototype.enable=function(){this.enabled=!0},m.prototype.disable=function(){this.enabled=!1},m.prototype.toggleEnabled=function(){this.enabled=!this.enabled},m.prototype.toggle=function(t){var e=this;t&&((e=g(t.currentTarget).data("bs."+this.type))||(e=new this.constructor(t.currentTarget,this.getDelegateOptions()),g(t.currentTarget).data("bs."+this.type,e))),t?(e.inState.click=!e.inState.click,e.isInStateTrue()?e.enter(e):e.leave(e)):e.tip().hasClass("in")?e.leave(e):e.enter(e)},m.prototype.destroy=function(){var t=this;clearTimeout(this.timeout),this.hide(function(){t.$element.off("."+t.type).removeData("bs."+t.type),t.$tip&&t.$tip.detach(),t.$tip=null,t.$arrow=null,t.$viewport=null,t.$element=null})},m.prototype.sanitizeHtml=function(t){return n(t,this.options.whiteList,this.options.sanitizeFn)};var e=g.fn.tooltip;g.fn.tooltip=function i(o){return this.each(function(){var t=g(this),e=t.data("bs.tooltip"),i="object"==typeof o&&o;!e&&/destroy|hide/.test(o)||(e||t.data("bs.tooltip",e=new m(this,i)),"string"==typeof o&&e[o]())})},g.fn.tooltip.Constructor=m,g.fn.tooltip.noConflict=function(){return g.fn.tooltip=e,this}}(jQuery),function(n){"use strict";var s=function(t,e){this.init("popover",t,e)};if(!n.fn.tooltip)throw new Error("Popover requires tooltip.js");s.VERSION="3.4.1",s.DEFAULTS=n.extend({},n.fn.tooltip.Constructor.DEFAULTS,{placement:"right",trigger:"click",content:"",template:'<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'}),((s.prototype=n.extend({},n.fn.tooltip.Constructor.prototype)).constructor=s).prototype.getDefaults=function(){return s.DEFAULTS},s.prototype.setContent=function(){var t=this.tip(),e=this.getTitle(),i=this.getContent();if(this.options.html){var o=typeof i;this.options.sanitize&&(e=this.sanitizeHtml(e),"string"===o&&(i=this.sanitizeHtml(i))),t.find(".popover-title").html(e),t.find(".popover-content").children().detach().end()["string"===o?"html":"append"](i)}else t.find(".popover-title").text(e),t.find(".popover-content").children().detach().end().text(i);t.removeClass("fade top bottom left right in"),t.find(".popover-title").html()||t.find(".popover-title").hide()},s.prototype.hasContent=function(){return this.getTitle()||this.getContent()},s.prototype.getContent=function(){var t=this.$element,e=this.options;return t.attr("data-content")||("function"==typeof e.content?e.content.call(t[0]):e.content)},s.prototype.arrow=function(){return this.$arrow=this.$arrow||this.tip().find(".arrow")};var t=n.fn.popover;n.fn.popover=function e(o){return this.each(function(){var t=n(this),e=t.data("bs.popover"),i="object"==typeof o&&o;!e&&/destroy|hide/.test(o)||(e||t.data("bs.popover",e=new s(this,i)),"string"==typeof o&&e[o]())})},n.fn.popover.Constructor=s,n.fn.popover.noConflict=function(){return n.fn.popover=t,this}}(jQuery),function(s){"use strict";function n(t,e){this.$body=s(document.body),this.$scrollElement=s(t).is(document.body)?s(window):s(t),this.options=s.extend({},n.DEFAULTS,e),this.selector=(this.options.target||"")+" .nav li > a",this.offsets=[],this.targets=[],this.activeTarget=null,this.scrollHeight=0,this.$scrollElement.on("scroll.bs.scrollspy",s.proxy(this.process,this)),this.refresh(),this.process()}function e(o){return this.each(function(){var t=s(this),e=t.data("bs.scrollspy"),i="object"==typeof o&&o;e||t.data("bs.scrollspy",e=new n(this,i)),"string"==typeof o&&e[o]()})}n.VERSION="3.4.1",n.DEFAULTS={offset:10},n.prototype.getScrollHeight=function(){return this.$scrollElement[0].scrollHeight||Math.max(this.$body[0].scrollHeight,document.documentElement.scrollHeight)},n.prototype.refresh=function(){var t=this,o="offset",n=0;this.offsets=[],this.targets=[],this.scrollHeight=this.getScrollHeight(),s.isWindow(this.$scrollElement[0])||(o="position",n=this.$scrollElement.scrollTop()),this.$body.find(this.selector).map(function(){var t=s(this),e=t.data("target")||t.attr("href"),i=/^#./.test(e)&&s(e);return i&&i.length&&i.is(":visible")&&[[i[o]().top+n,e]]||null}).sort(function(t,e){return t[0]-e[0]}).each(function(){t.offsets.push(this[0]),t.targets.push(this[1])})},n.prototype.process=function(){var t,e=this.$scrollElement.scrollTop()+this.options.offset,i=this.getScrollHeight(),o=this.options.offset+i-this.$scrollElement.height(),n=this.offsets,s=this.targets,a=this.activeTarget;if(this.scrollHeight!=i&&this.refresh(),o<=e)return a!=(t=s[s.length-1])&&this.activate(t);if(a&&e<n[0])return this.activeTarget=null,this.clear();for(t=n.length;t--;)a!=s[t]&&e>=n[t]&&(n[t+1]===undefined||e<n[t+1])&&this.activate(s[t])},n.prototype.activate=function(t){this.activeTarget=t,this.clear();var e=this.selector+'[data-target="'+t+'"],'+this.selector+'[href="'+t+'"]',i=s(e).parents("li").addClass("active");i.parent(".dropdown-menu").length&&(i=i.closest("li.dropdown").addClass("active")),i.trigger("activate.bs.scrollspy")},n.prototype.clear=function(){s(this.selector).parentsUntil(this.options.target,".active").removeClass("active")};var t=s.fn.scrollspy;s.fn.scrollspy=e,s.fn.scrollspy.Constructor=n,s.fn.scrollspy.noConflict=function(){return s.fn.scrollspy=t,this},s(window).on("load.bs.scrollspy.data-api",function(){s('[data-spy="scroll"]').each(function(){var t=s(this);e.call(t,t.data())})})}(jQuery),function(r){"use strict";var a=function(t){this.element=r(t)};function e(i){return this.each(function(){var t=r(this),e=t.data("bs.tab");e||t.data("bs.tab",e=new a(this)),"string"==typeof i&&e[i]()})}a.VERSION="3.4.1",a.TRANSITION_DURATION=150,a.prototype.show=function(){var t=this.element,e=t.closest("ul:not(.dropdown-menu)"),i=t.data("target");if(i||(i=(i=t.attr("href"))&&i.replace(/.*(?=#[^\s]*$)/,"")),!t.parent("li").hasClass("active")){var o=e.find(".active:last a"),n=r.Event("hide.bs.tab",{relatedTarget:t[0]}),s=r.Event("show.bs.tab",{relatedTarget:o[0]});if(o.trigger(n),t.trigger(s),!s.isDefaultPrevented()&&!n.isDefaultPrevented()){var a=r(document).find(i);this.activate(t.closest("li"),e),this.activate(a,a.parent(),function(){o.trigger({type:"hidden.bs.tab",relatedTarget:t[0]}),t.trigger({type:"shown.bs.tab",relatedTarget:o[0]})})}}},a.prototype.activate=function(t,e,i){var o=e.find("> .active"),n=i&&r.support.transition&&(o.length&&o.hasClass("fade")||!!e.find("> .fade").length);function s(){o.removeClass("active").find("> .dropdown-menu > .active").removeClass("active").end().find('[data-toggle="tab"]').attr("aria-expanded",!1),t.addClass("active").find('[data-toggle="tab"]').attr("aria-expanded",!0),n?(t[0].offsetWidth,t.addClass("in")):t.removeClass("fade"),t.parent(".dropdown-menu").length&&t.closest("li.dropdown").addClass("active").end().find('[data-toggle="tab"]').attr("aria-expanded",!0),i&&i()}o.length&&n?o.one("bsTransitionEnd",s).emulateTransitionEnd(a.TRANSITION_DURATION):s(),o.removeClass("in")};var t=r.fn.tab;r.fn.tab=e,r.fn.tab.Constructor=a,r.fn.tab.noConflict=function(){return r.fn.tab=t,this};var i=function(t){t.preventDefault(),e.call(r(this),"show")};r(document).on("click.bs.tab.data-api",'[data-toggle="tab"]',i).on("click.bs.tab.data-api",'[data-toggle="pill"]',i)}(jQuery),function(l){"use strict";var h=function(t,e){this.options=l.extend({},h.DEFAULTS,e);var i=this.options.target===h.DEFAULTS.target?l(this.options.target):l(document).find(this.options.target);this.$target=i.on("scroll.bs.affix.data-api",l.proxy(this.checkPosition,this)).on("click.bs.affix.data-api",l.proxy(this.checkPositionWithEventLoop,this)),this.$element=l(t),this.affixed=null,this.unpin=null,this.pinnedOffset=null,this.checkPosition()};function i(o){return this.each(function(){var t=l(this),e=t.data("bs.affix"),i="object"==typeof o&&o;e||t.data("bs.affix",e=new h(this,i)),"string"==typeof o&&e[o]()})}h.VERSION="3.4.1",h.RESET="affix affix-top affix-bottom",h.DEFAULTS={offset:0,target:window},h.prototype.getState=function(t,e,i,o){var n=this.$target.scrollTop(),s=this.$element.offset(),a=this.$target.height();if(null!=i&&"top"==this.affixed)return n<i&&"top";if("bottom"==this.affixed)return null!=i?!(n+this.unpin<=s.top)&&"bottom":!(n+a<=t-o)&&"bottom";var r=null==this.affixed,l=r?n:s.top;return null!=i&&n<=i?"top":null!=o&&t-o<=l+(r?a:e)&&"bottom"},h.prototype.getPinnedOffset=function(){if(this.pinnedOffset)return this.pinnedOffset;this.$element.removeClass(h.RESET).addClass("affix");var t=this.$target.scrollTop(),e=this.$element.offset();return this.pinnedOffset=e.top-t},h.prototype.checkPositionWithEventLoop=function(){setTimeout(l.proxy(this.checkPosition,this),1)},h.prototype.checkPosition=function(){if(this.$element.is(":visible")){var t=this.$element.height(),e=this.options.offset,i=e.top,o=e.bottom,n=Math.max(l(document).height(),l(document.body).height());"object"!=typeof e&&(o=i=e),"function"==typeof i&&(i=e.top(this.$element)),"function"==typeof o&&(o=e.bottom(this.$element));var s=this.getState(n,t,i,o);if(this.affixed!=s){null!=this.unpin&&this.$element.css("top","");var a="affix"+(s?"-"+s:""),r=l.Event(a+".bs.affix");if(this.$element.trigger(r),r.isDefaultPrevented())return;this.affixed=s,this.unpin="bottom"==s?this.getPinnedOffset():null,this.$element.removeClass(h.RESET).addClass(a).trigger(a.replace("affix","affixed")+".bs.affix")}"bottom"==s&&this.$element.offset({top:n-t-o})}};var t=l.fn.affix;l.fn.affix=i,l.fn.affix.Constructor=h,l.fn.affix.noConflict=function(){return l.fn.affix=t,this},l(window).on("load",function(){l('[data-spy="affix"]').each(function(){var t=l(this),e=t.data();e.offset=e.offset||{},null!=e.offsetBottom&&(e.offset.bottom=e.offsetBottom),null!=e.offsetTop&&(e.offset.top=e.offsetTop),i.call(t,e)})})}(jQuery);;/*
 AngularJS v1.6.10
 (c) 2010-2018 Google, Inc. http://angularjs.org
 License: MIT
*/
(function(y){'use strict';function qe(a){if(G(a))u(a.objectMaxDepth)&&(Oc.objectMaxDepth=Wb(a.objectMaxDepth)?a.objectMaxDepth:NaN);else return Oc}function Wb(a){return Y(a)&&0<a}function M(a,b){b=b||Error;return function(){var d=arguments[0],c;c="["+(a?a+":":"")+d+"] http://errors.angularjs.org/1.6.10/"+(a?a+"/":"")+d;for(d=1;d<arguments.length;d++){c=c+(1==d?"?":"&")+"p"+(d-1)+"=";var e=encodeURIComponent,f;f=arguments[d];f="function"==typeof f?f.toString().replace(/ \{[\s\S]*$/,""):"undefined"==
typeof f?"undefined":"string"!=typeof f?JSON.stringify(f):f;c+=e(f)}return new b(c)}}function ja(a){if(null==a||Za(a))return!1;if(I(a)||F(a)||z&&a instanceof z)return!0;var b="length"in Object(a)&&a.length;return Y(b)&&(0<=b&&(b-1 in a||a instanceof Array)||"function"===typeof a.item)}function q(a,b,d){var c,e;if(a)if(C(a))for(c in a)"prototype"!==c&&"length"!==c&&"name"!==c&&a.hasOwnProperty(c)&&b.call(d,a[c],c,a);else if(I(a)||ja(a)){var f="object"!==typeof a;c=0;for(e=a.length;c<e;c++)(f||c in
a)&&b.call(d,a[c],c,a)}else if(a.forEach&&a.forEach!==q)a.forEach(b,d,a);else if(Pc(a))for(c in a)b.call(d,a[c],c,a);else if("function"===typeof a.hasOwnProperty)for(c in a)a.hasOwnProperty(c)&&b.call(d,a[c],c,a);else for(c in a)ra.call(a,c)&&b.call(d,a[c],c,a);return a}function Qc(a,b,d){for(var c=Object.keys(a).sort(),e=0;e<c.length;e++)b.call(d,a[c[e]],c[e]);return c}function Xb(a){return function(b,d){a(d,b)}}function re(){return++qb}function Yb(a,b,d){for(var c=a.$$hashKey,e=0,f=b.length;e<f;++e){var g=
b[e];if(G(g)||C(g))for(var k=Object.keys(g),h=0,l=k.length;h<l;h++){var m=k[h],p=g[m];d&&G(p)?da(p)?a[m]=new Date(p.valueOf()):$a(p)?a[m]=new RegExp(p):p.nodeName?a[m]=p.cloneNode(!0):Zb(p)?a[m]=p.clone():(G(a[m])||(a[m]=I(p)?[]:{}),Yb(a[m],[p],!0)):a[m]=p}}c?a.$$hashKey=c:delete a.$$hashKey;return a}function P(a){return Yb(a,xa.call(arguments,1),!1)}function se(a){return Yb(a,xa.call(arguments,1),!0)}function Z(a){return parseInt(a,10)}function $b(a,b){return P(Object.create(a),b)}function D(){}
function ab(a){return a}function ka(a){return function(){return a}}function ac(a){return C(a.toString)&&a.toString!==ha}function x(a){return"undefined"===typeof a}function u(a){return"undefined"!==typeof a}function G(a){return null!==a&&"object"===typeof a}function Pc(a){return null!==a&&"object"===typeof a&&!Rc(a)}function F(a){return"string"===typeof a}function Y(a){return"number"===typeof a}function da(a){return"[object Date]"===ha.call(a)}function bc(a){switch(ha.call(a)){case "[object Error]":return!0;
case "[object Exception]":return!0;case "[object DOMException]":return!0;default:return a instanceof Error}}function C(a){return"function"===typeof a}function $a(a){return"[object RegExp]"===ha.call(a)}function Za(a){return a&&a.window===a}function bb(a){return a&&a.$evalAsync&&a.$watch}function La(a){return"boolean"===typeof a}function te(a){return a&&Y(a.length)&&ue.test(ha.call(a))}function Zb(a){return!(!a||!(a.nodeName||a.prop&&a.attr&&a.find))}function ve(a){var b={};a=a.split(",");var d;for(d=
0;d<a.length;d++)b[a[d]]=!0;return b}function ya(a){return N(a.nodeName||a[0]&&a[0].nodeName)}function cb(a,b){var d=a.indexOf(b);0<=d&&a.splice(d,1);return d}function na(a,b,d){function c(a,b,c){c--;if(0>c)return"...";var d=b.$$hashKey,g;if(I(a)){g=0;for(var f=a.length;g<f;g++)b.push(e(a[g],c))}else if(Pc(a))for(g in a)b[g]=e(a[g],c);else if(a&&"function"===typeof a.hasOwnProperty)for(g in a)a.hasOwnProperty(g)&&(b[g]=e(a[g],c));else for(g in a)ra.call(a,g)&&(b[g]=e(a[g],c));d?b.$$hashKey=d:delete b.$$hashKey;
return b}function e(a,b){if(!G(a))return a;var d=g.indexOf(a);if(-1!==d)return k[d];if(Za(a)||bb(a))throw oa("cpws");var d=!1,e=f(a);void 0===e&&(e=I(a)?[]:Object.create(Rc(a)),d=!0);g.push(a);k.push(e);return d?c(a,e,b):e}function f(a){switch(ha.call(a)){case "[object Int8Array]":case "[object Int16Array]":case "[object Int32Array]":case "[object Float32Array]":case "[object Float64Array]":case "[object Uint8Array]":case "[object Uint8ClampedArray]":case "[object Uint16Array]":case "[object Uint32Array]":return new a.constructor(e(a.buffer),
a.byteOffset,a.length);case "[object ArrayBuffer]":if(!a.slice){var b=new ArrayBuffer(a.byteLength);(new Uint8Array(b)).set(new Uint8Array(a));return b}return a.slice(0);case "[object Boolean]":case "[object Number]":case "[object String]":case "[object Date]":return new a.constructor(a.valueOf());case "[object RegExp]":return b=new RegExp(a.source,a.toString().match(/[^/]*$/)[0]),b.lastIndex=a.lastIndex,b;case "[object Blob]":return new a.constructor([a],{type:a.type})}if(C(a.cloneNode))return a.cloneNode(!0)}
var g=[],k=[];d=Wb(d)?d:NaN;if(b){if(te(b)||"[object ArrayBuffer]"===ha.call(b))throw oa("cpta");if(a===b)throw oa("cpi");I(b)?b.length=0:q(b,function(a,c){"$$hashKey"!==c&&delete b[c]});g.push(a);k.push(b);return c(a,b,d)}return e(a,d)}function cc(a,b){return a===b||a!==a&&b!==b}function sa(a,b){if(a===b)return!0;if(null===a||null===b)return!1;if(a!==a&&b!==b)return!0;var d=typeof a,c;if(d===typeof b&&"object"===d)if(I(a)){if(!I(b))return!1;if((d=a.length)===b.length){for(c=0;c<d;c++)if(!sa(a[c],
b[c]))return!1;return!0}}else{if(da(a))return da(b)?cc(a.getTime(),b.getTime()):!1;if($a(a))return $a(b)?a.toString()===b.toString():!1;if(bb(a)||bb(b)||Za(a)||Za(b)||I(b)||da(b)||$a(b))return!1;d=R();for(c in a)if("$"!==c.charAt(0)&&!C(a[c])){if(!sa(a[c],b[c]))return!1;d[c]=!0}for(c in b)if(!(c in d)&&"$"!==c.charAt(0)&&u(b[c])&&!C(b[c]))return!1;return!0}return!1}function db(a,b,d){return a.concat(xa.call(b,d))}function Ta(a,b){var d=2<arguments.length?xa.call(arguments,2):[];return!C(b)||b instanceof
RegExp?b:d.length?function(){return arguments.length?b.apply(a,db(d,arguments,0)):b.apply(a,d)}:function(){return arguments.length?b.apply(a,arguments):b.call(a)}}function Sc(a,b){var d=b;"string"===typeof a&&"$"===a.charAt(0)&&"$"===a.charAt(1)?d=void 0:Za(b)?d="$WINDOW":b&&y.document===b?d="$DOCUMENT":bb(b)&&(d="$SCOPE");return d}function eb(a,b){if(!x(a))return Y(b)||(b=b?2:null),JSON.stringify(a,Sc,b)}function Tc(a){return F(a)?JSON.parse(a):a}function dc(a,b){a=a.replace(we,"");var d=Date.parse("Jan 01, 1970 00:00:00 "+
a)/6E4;return X(d)?b:d}function Uc(a,b){a=new Date(a.getTime());a.setMinutes(a.getMinutes()+b);return a}function ec(a,b,d){d=d?-1:1;var c=a.getTimezoneOffset();b=dc(b,c);return Uc(a,d*(b-c))}function za(a){a=z(a).clone().empty();var b=z("<div></div>").append(a).html();try{return a[0].nodeType===Ma?N(b):b.match(/^(<[^>]+>)/)[1].replace(/^<([\w-]+)/,function(a,b){return"<"+N(b)})}catch(d){return N(b)}}function Vc(a){try{return decodeURIComponent(a)}catch(b){}}function fc(a){var b={};q((a||"").split("&"),
function(a){var c,e,f;a&&(e=a=a.replace(/\+/g,"%20"),c=a.indexOf("="),-1!==c&&(e=a.substring(0,c),f=a.substring(c+1)),e=Vc(e),u(e)&&(f=u(f)?Vc(f):!0,ra.call(b,e)?I(b[e])?b[e].push(f):b[e]=[b[e],f]:b[e]=f))});return b}function gc(a){var b=[];q(a,function(a,c){I(a)?q(a,function(a){b.push(ia(c,!0)+(!0===a?"":"="+ia(a,!0)))}):b.push(ia(c,!0)+(!0===a?"":"="+ia(a,!0)))});return b.length?b.join("&"):""}function fb(a){return ia(a,!0).replace(/%26/gi,"&").replace(/%3D/gi,"=").replace(/%2B/gi,"+")}function ia(a,
b){return encodeURIComponent(a).replace(/%40/gi,"@").replace(/%3A/gi,":").replace(/%24/g,"$").replace(/%2C/gi,",").replace(/%3B/gi,";").replace(/%20/g,b?"%20":"+")}function xe(a,b){var d,c,e=Ga.length;for(c=0;c<e;++c)if(d=Ga[c]+b,F(d=a.getAttribute(d)))return d;return null}function ye(a,b){var d,c,e={};q(Ga,function(b){b+="app";!d&&a.hasAttribute&&a.hasAttribute(b)&&(d=a,c=a.getAttribute(b))});q(Ga,function(b){b+="app";var e;!d&&(e=a.querySelector("["+b.replace(":","\\:")+"]"))&&(d=e,c=e.getAttribute(b))});
d&&(ze?(e.strictDi=null!==xe(d,"strict-di"),b(d,c?[c]:[],e)):y.console.error("AngularJS: disabling automatic bootstrap. <script> protocol indicates an extension, document.location.href does not match."))}function Wc(a,b,d){G(d)||(d={});d=P({strictDi:!1},d);var c=function(){a=z(a);if(a.injector()){var c=a[0]===y.document?"document":za(a);throw oa("btstrpd",c.replace(/</,"&lt;").replace(/>/,"&gt;"));}b=b||[];b.unshift(["$provide",function(b){b.value("$rootElement",a)}]);d.debugInfoEnabled&&b.push(["$compileProvider",
function(a){a.debugInfoEnabled(!0)}]);b.unshift("ng");c=gb(b,d.strictDi);c.invoke(["$rootScope","$rootElement","$compile","$injector",function(a,b,c,d){a.$apply(function(){b.data("$injector",d);c(b)(a)})}]);return c},e=/^NG_ENABLE_DEBUG_INFO!/,f=/^NG_DEFER_BOOTSTRAP!/;y&&e.test(y.name)&&(d.debugInfoEnabled=!0,y.name=y.name.replace(e,""));if(y&&!f.test(y.name))return c();y.name=y.name.replace(f,"");ea.resumeBootstrap=function(a){q(a,function(a){b.push(a)});return c()};C(ea.resumeDeferredBootstrap)&&
ea.resumeDeferredBootstrap()}function Ae(){y.name="NG_ENABLE_DEBUG_INFO!"+y.name;y.location.reload()}function Be(a){a=ea.element(a).injector();if(!a)throw oa("test");return a.get("$$testability")}function Xc(a,b){b=b||"_";return a.replace(Ce,function(a,c){return(c?b:"")+a.toLowerCase()})}function De(){var a;if(!Yc){var b=rb();(ta=x(b)?y.jQuery:b?y[b]:void 0)&&ta.fn.on?(z=ta,P(ta.fn,{scope:Ua.scope,isolateScope:Ua.isolateScope,controller:Ua.controller,injector:Ua.injector,inheritedData:Ua.inheritedData}),
a=ta.cleanData,ta.cleanData=function(b){for(var c,e=0,f;null!=(f=b[e]);e++)(c=ta._data(f,"events"))&&c.$destroy&&ta(f).triggerHandler("$destroy");a(b)}):z=S;ea.element=z;Yc=!0}}function hb(a,b,d){if(!a)throw oa("areq",b||"?",d||"required");return a}function sb(a,b,d){d&&I(a)&&(a=a[a.length-1]);hb(C(a),b,"not a function, got "+(a&&"object"===typeof a?a.constructor.name||"Object":typeof a));return a}function Ha(a,b){if("hasOwnProperty"===a)throw oa("badname",b);}function Zc(a,b,d){if(!b)return a;b=
b.split(".");for(var c,e=a,f=b.length,g=0;g<f;g++)c=b[g],a&&(a=(e=a)[c]);return!d&&C(a)?Ta(e,a):a}function tb(a){for(var b=a[0],d=a[a.length-1],c,e=1;b!==d&&(b=b.nextSibling);e++)if(c||a[e]!==b)c||(c=z(xa.call(a,0,e))),c.push(b);return c||a}function R(){return Object.create(null)}function hc(a){if(null==a)return"";switch(typeof a){case "string":break;case "number":a=""+a;break;default:a=!ac(a)||I(a)||da(a)?eb(a):a.toString()}return a}function Ee(a){function b(a,b,c){return a[b]||(a[b]=c())}var d=
M("$injector"),c=M("ng");a=b(a,"angular",Object);a.$$minErr=a.$$minErr||M;return b(a,"module",function(){var a={};return function(f,g,k){var h={};if("hasOwnProperty"===f)throw c("badname","module");g&&a.hasOwnProperty(f)&&(a[f]=null);return b(a,f,function(){function a(b,c,d,g){g||(g=e);return function(){g[d||"push"]([b,c,arguments]);return E}}function b(a,c,d){d||(d=e);return function(b,e){e&&C(e)&&(e.$$moduleName=f);d.push([a,c,arguments]);return E}}if(!g)throw d("nomod",f);var e=[],n=[],B=[],v=
a("$injector","invoke","push",n),E={_invokeQueue:e,_configBlocks:n,_runBlocks:B,info:function(a){if(u(a)){if(!G(a))throw c("aobj","value");h=a;return this}return h},requires:g,name:f,provider:b("$provide","provider"),factory:b("$provide","factory"),service:b("$provide","service"),value:a("$provide","value"),constant:a("$provide","constant","unshift"),decorator:b("$provide","decorator",n),animation:b("$animateProvider","register"),filter:b("$filterProvider","register"),controller:b("$controllerProvider",
"register"),directive:b("$compileProvider","directive"),component:b("$compileProvider","component"),config:v,run:function(a){B.push(a);return this}};k&&v(k);return E})}})}function pa(a,b){if(I(a)){b=b||[];for(var d=0,c=a.length;d<c;d++)b[d]=a[d]}else if(G(a))for(d in b=b||{},a)if("$"!==d.charAt(0)||"$"!==d.charAt(1))b[d]=a[d];return b||a}function Fe(a,b){var d=[];Wb(b)&&(a=ea.copy(a,null,b));return JSON.stringify(a,function(a,b){b=Sc(a,b);if(G(b)){if(0<=d.indexOf(b))return"...";d.push(b)}return b})}
function Ge(a){P(a,{errorHandlingConfig:qe,bootstrap:Wc,copy:na,extend:P,merge:se,equals:sa,element:z,forEach:q,injector:gb,noop:D,bind:Ta,toJson:eb,fromJson:Tc,identity:ab,isUndefined:x,isDefined:u,isString:F,isFunction:C,isObject:G,isNumber:Y,isElement:Zb,isArray:I,version:He,isDate:da,lowercase:N,uppercase:ub,callbacks:{$$counter:0},getTestability:Be,reloadWithDebugInfo:Ae,$$minErr:M,$$csp:Ia,$$encodeUriSegment:fb,$$encodeUriQuery:ia,$$stringify:hc});jc=Ee(y);jc("ng",["ngLocale"],["$provide",function(a){a.provider({$$sanitizeUri:Ie});
a.provider("$compile",$c).directive({a:Je,input:ad,textarea:ad,form:Ke,script:Le,select:Me,option:Ne,ngBind:Oe,ngBindHtml:Pe,ngBindTemplate:Qe,ngClass:Re,ngClassEven:Se,ngClassOdd:Te,ngCloak:Ue,ngController:Ve,ngForm:We,ngHide:Xe,ngIf:Ye,ngInclude:Ze,ngInit:$e,ngNonBindable:af,ngPluralize:bf,ngRepeat:cf,ngShow:df,ngStyle:ef,ngSwitch:ff,ngSwitchWhen:gf,ngSwitchDefault:hf,ngOptions:jf,ngTransclude:kf,ngModel:lf,ngList:mf,ngChange:nf,pattern:bd,ngPattern:bd,required:cd,ngRequired:cd,minlength:dd,ngMinlength:dd,
maxlength:ed,ngMaxlength:ed,ngValue:of,ngModelOptions:pf}).directive({ngInclude:qf}).directive(vb).directive(fd);a.provider({$anchorScroll:rf,$animate:sf,$animateCss:tf,$$animateJs:uf,$$animateQueue:vf,$$AnimateRunner:wf,$$animateAsyncRun:xf,$browser:yf,$cacheFactory:zf,$controller:Af,$document:Bf,$$isDocumentHidden:Cf,$exceptionHandler:Df,$filter:gd,$$forceReflow:Ef,$interpolate:Ff,$interval:Gf,$http:Hf,$httpParamSerializer:If,$httpParamSerializerJQLike:Jf,$httpBackend:Kf,$xhrFactory:Lf,$jsonpCallbacks:Mf,
$location:Nf,$log:Of,$parse:Pf,$rootScope:Qf,$q:Rf,$$q:Sf,$sce:Tf,$sceDelegate:Uf,$sniffer:Vf,$templateCache:Wf,$templateRequest:Xf,$$testability:Yf,$timeout:Zf,$window:$f,$$rAF:ag,$$jqLite:bg,$$Map:cg,$$cookieReader:dg})}]).info({angularVersion:"1.6.10"})}function wb(a,b){return b.toUpperCase()}function xb(a){return a.replace(eg,wb)}function kc(a){a=a.nodeType;return 1===a||!a||9===a}function hd(a,b){var d,c,e=b.createDocumentFragment(),f=[];if(lc.test(a)){d=e.appendChild(b.createElement("div"));
c=(fg.exec(a)||["",""])[1].toLowerCase();c=$[c]||$._default;d.innerHTML=c[1]+a.replace(gg,"<$1></$2>")+c[2];for(c=c[0];c--;)d=d.lastChild;f=db(f,d.childNodes);d=e.firstChild;d.textContent=""}else f.push(b.createTextNode(a));e.textContent="";e.innerHTML="";q(f,function(a){e.appendChild(a)});return e}function S(a){if(a instanceof S)return a;var b;F(a)&&(a=Q(a),b=!0);if(!(this instanceof S)){if(b&&"<"!==a.charAt(0))throw mc("nosel");return new S(a)}if(b){b=y.document;var d;a=(d=hg.exec(a))?[b.createElement(d[1])]:
(d=hd(a,b))?d.childNodes:[];nc(this,a)}else C(a)?id(a):nc(this,a)}function oc(a){return a.cloneNode(!0)}function yb(a,b){!b&&kc(a)&&z.cleanData([a]);a.querySelectorAll&&z.cleanData(a.querySelectorAll("*"))}function jd(a,b,d,c){if(u(c))throw mc("offargs");var e=(c=zb(a))&&c.events,f=c&&c.handle;if(f)if(b){var g=function(b){var c=e[b];u(d)&&cb(c||[],d);u(d)&&c&&0<c.length||(a.removeEventListener(b,f),delete e[b])};q(b.split(" "),function(a){g(a);Ab[a]&&g(Ab[a])})}else for(b in e)"$destroy"!==b&&a.removeEventListener(b,
f),delete e[b]}function pc(a,b){var d=a.ng339,c=d&&ib[d];c&&(b?delete c.data[b]:(c.handle&&(c.events.$destroy&&c.handle({},"$destroy"),jd(a)),delete ib[d],a.ng339=void 0))}function zb(a,b){var d=a.ng339,d=d&&ib[d];b&&!d&&(a.ng339=d=++ig,d=ib[d]={events:{},data:{},handle:void 0});return d}function qc(a,b,d){if(kc(a)){var c,e=u(d),f=!e&&b&&!G(b),g=!b;a=(a=zb(a,!f))&&a.data;if(e)a[xb(b)]=d;else{if(g)return a;if(f)return a&&a[xb(b)];for(c in b)a[xb(c)]=b[c]}}}function Bb(a,b){return a.getAttribute?-1<
(" "+(a.getAttribute("class")||"")+" ").replace(/[\n\t]/g," ").indexOf(" "+b+" "):!1}function Cb(a,b){if(b&&a.setAttribute){var d=(" "+(a.getAttribute("class")||"")+" ").replace(/[\n\t]/g," "),c=d;q(b.split(" "),function(a){a=Q(a);c=c.replace(" "+a+" "," ")});c!==d&&a.setAttribute("class",Q(c))}}function Db(a,b){if(b&&a.setAttribute){var d=(" "+(a.getAttribute("class")||"")+" ").replace(/[\n\t]/g," "),c=d;q(b.split(" "),function(a){a=Q(a);-1===c.indexOf(" "+a+" ")&&(c+=a+" ")});c!==d&&a.setAttribute("class",
Q(c))}}function nc(a,b){if(b)if(b.nodeType)a[a.length++]=b;else{var d=b.length;if("number"===typeof d&&b.window!==b){if(d)for(var c=0;c<d;c++)a[a.length++]=b[c]}else a[a.length++]=b}}function kd(a,b){return Eb(a,"$"+(b||"ngController")+"Controller")}function Eb(a,b,d){9===a.nodeType&&(a=a.documentElement);for(b=I(b)?b:[b];a;){for(var c=0,e=b.length;c<e;c++)if(u(d=z.data(a,b[c])))return d;a=a.parentNode||11===a.nodeType&&a.host}}function ld(a){for(yb(a,!0);a.firstChild;)a.removeChild(a.firstChild)}
function Fb(a,b){b||yb(a);var d=a.parentNode;d&&d.removeChild(a)}function jg(a,b){b=b||y;if("complete"===b.document.readyState)b.setTimeout(a);else z(b).on("load",a)}function id(a){function b(){y.document.removeEventListener("DOMContentLoaded",b);y.removeEventListener("load",b);a()}"complete"===y.document.readyState?y.setTimeout(a):(y.document.addEventListener("DOMContentLoaded",b),y.addEventListener("load",b))}function md(a,b){var d=Gb[b.toLowerCase()];return d&&nd[ya(a)]&&d}function kg(a,b){var d=
function(c,d){c.isDefaultPrevented=function(){return c.defaultPrevented};var f=b[d||c.type],g=f?f.length:0;if(g){if(x(c.immediatePropagationStopped)){var k=c.stopImmediatePropagation;c.stopImmediatePropagation=function(){c.immediatePropagationStopped=!0;c.stopPropagation&&c.stopPropagation();k&&k.call(c)}}c.isImmediatePropagationStopped=function(){return!0===c.immediatePropagationStopped};var h=f.specialHandlerWrapper||lg;1<g&&(f=pa(f));for(var l=0;l<g;l++)c.isImmediatePropagationStopped()||h(a,c,
f[l])}};d.elem=a;return d}function lg(a,b,d){d.call(a,b)}function mg(a,b,d){var c=b.relatedTarget;c&&(c===a||ng.call(a,c))||d.call(a,b)}function bg(){this.$get=function(){return P(S,{hasClass:function(a,b){a.attr&&(a=a[0]);return Bb(a,b)},addClass:function(a,b){a.attr&&(a=a[0]);return Db(a,b)},removeClass:function(a,b){a.attr&&(a=a[0]);return Cb(a,b)}})}}function Na(a,b){var d=a&&a.$$hashKey;if(d)return"function"===typeof d&&(d=a.$$hashKey()),d;d=typeof a;return d="function"===d||"object"===d&&null!==
a?a.$$hashKey=d+":"+(b||re)():d+":"+a}function od(){this._keys=[];this._values=[];this._lastKey=NaN;this._lastIndex=-1}function pd(a){a=Function.prototype.toString.call(a).replace(og,"");return a.match(pg)||a.match(qg)}function rg(a){return(a=pd(a))?"function("+(a[1]||"").replace(/[\s\r\n]+/," ")+")":"fn"}function gb(a,b){function d(a){return function(b,c){if(G(b))q(b,Xb(a));else return a(b,c)}}function c(a,b){Ha(a,"service");if(C(b)||I(b))b=n.instantiate(b);if(!b.$get)throw Aa("pget",a);return p[a+
"Provider"]=b}function e(a,b){return function(){var c=E.invoke(b,this);if(x(c))throw Aa("undef",a);return c}}function f(a,b,d){return c(a,{$get:!1!==d?e(a,b):b})}function g(a){hb(x(a)||I(a),"modulesToLoad","not an array");var b=[],c;q(a,function(a){function d(a){var b,c;b=0;for(c=a.length;b<c;b++){var e=a[b],g=n.get(e[0]);g[e[1]].apply(g,e[2])}}if(!m.get(a)){m.set(a,!0);try{F(a)?(c=jc(a),E.modules[a]=c,b=b.concat(g(c.requires)).concat(c._runBlocks),d(c._invokeQueue),d(c._configBlocks)):C(a)?b.push(n.invoke(a)):
I(a)?b.push(n.invoke(a)):sb(a,"module")}catch(e){throw I(a)&&(a=a[a.length-1]),e.message&&e.stack&&-1===e.stack.indexOf(e.message)&&(e=e.message+"\n"+e.stack),Aa("modulerr",a,e.stack||e.message||e);}}});return b}function k(a,c){function d(b,e){if(a.hasOwnProperty(b)){if(a[b]===h)throw Aa("cdep",b+" <- "+l.join(" <- "));return a[b]}try{return l.unshift(b),a[b]=h,a[b]=c(b,e),a[b]}catch(g){throw a[b]===h&&delete a[b],g;}finally{l.shift()}}function e(a,c,g){var f=[];a=gb.$$annotate(a,b,g);for(var h=0,
k=a.length;h<k;h++){var l=a[h];if("string"!==typeof l)throw Aa("itkn",l);f.push(c&&c.hasOwnProperty(l)?c[l]:d(l,g))}return f}return{invoke:function(a,b,c,d){"string"===typeof c&&(d=c,c=null);c=e(a,c,d);I(a)&&(a=a[a.length-1]);d=a;if(Ba||"function"!==typeof d)d=!1;else{var g=d.$$ngIsClass;La(g)||(g=d.$$ngIsClass=/^(?:class\b|constructor\()/.test(Function.prototype.toString.call(d)));d=g}return d?(c.unshift(null),new (Function.prototype.bind.apply(a,c))):a.apply(b,c)},instantiate:function(a,b,c){var d=
I(a)?a[a.length-1]:a;a=e(a,b,c);a.unshift(null);return new (Function.prototype.bind.apply(d,a))},get:d,annotate:gb.$$annotate,has:function(b){return p.hasOwnProperty(b+"Provider")||a.hasOwnProperty(b)}}}b=!0===b;var h={},l=[],m=new Hb,p={$provide:{provider:d(c),factory:d(f),service:d(function(a,b){return f(a,["$injector",function(a){return a.instantiate(b)}])}),value:d(function(a,b){return f(a,ka(b),!1)}),constant:d(function(a,b){Ha(a,"constant");p[a]=b;B[a]=b}),decorator:function(a,b){var c=n.get(a+
"Provider"),d=c.$get;c.$get=function(){var a=E.invoke(d,c);return E.invoke(b,null,{$delegate:a})}}}},n=p.$injector=k(p,function(a,b){ea.isString(b)&&l.push(b);throw Aa("unpr",l.join(" <- "));}),B={},v=k(B,function(a,b){var c=n.get(a+"Provider",b);return E.invoke(c.$get,c,void 0,a)}),E=v;p.$injectorProvider={$get:ka(v)};E.modules=n.modules=R();var A=g(a),E=v.get("$injector");E.strictDi=b;q(A,function(a){a&&E.invoke(a)});E.loadNewModules=function(a){q(g(a),function(a){a&&E.invoke(a)})};return E}function rf(){var a=
!0;this.disableAutoScrolling=function(){a=!1};this.$get=["$window","$location","$rootScope",function(b,d,c){function e(a){var b=null;Array.prototype.some.call(a,function(a){if("a"===ya(a))return b=a,!0});return b}function f(a){if(a){a.scrollIntoView();var c;c=g.yOffset;C(c)?c=c():Zb(c)?(c=c[0],c="fixed"!==b.getComputedStyle(c).position?0:c.getBoundingClientRect().bottom):Y(c)||(c=0);c&&(a=a.getBoundingClientRect().top,b.scrollBy(0,a-c))}else b.scrollTo(0,0)}function g(a){a=F(a)?a:Y(a)?a.toString():
d.hash();var b;a?(b=k.getElementById(a))?f(b):(b=e(k.getElementsByName(a)))?f(b):"top"===a&&f(null):f(null)}var k=b.document;a&&c.$watch(function(){return d.hash()},function(a,b){a===b&&""===a||jg(function(){c.$evalAsync(g)})});return g}]}function jb(a,b){if(!a&&!b)return"";if(!a)return b;if(!b)return a;I(a)&&(a=a.join(" "));I(b)&&(b=b.join(" "));return a+" "+b}function sg(a){F(a)&&(a=a.split(" "));var b=R();q(a,function(a){a.length&&(b[a]=!0)});return b}function Ja(a){return G(a)?a:{}}function tg(a,
b,d,c){function e(a){try{a.apply(null,xa.call(arguments,1))}finally{if(v--,0===v)for(;E.length;)try{E.pop()()}catch(b){d.error(b)}}}function f(){w=null;k()}function g(){A=H();A=x(A)?null:A;sa(A,t)&&(A=t);s=t=A}function k(){var a=s;g();if(J!==h.url()||a!==A)J=h.url(),s=A,q(K,function(a){a(h.url(),A)})}var h=this,l=a.location,m=a.history,p=a.setTimeout,n=a.clearTimeout,B={};h.isMock=!1;var v=0,E=[];h.$$completeOutstandingRequest=e;h.$$incOutstandingRequestCount=function(){v++};h.notifyWhenNoOutstandingRequests=
function(a){0===v?a():E.push(a)};var A,s,J=l.href,ic=b.find("base"),w=null,H=c.history?function(){try{return m.state}catch(a){}}:D;g();h.url=function(b,d,e){x(e)&&(e=null);l!==a.location&&(l=a.location);m!==a.history&&(m=a.history);if(b){var f=s===e;if(J===b&&(!c.history||f))return h;var k=J&&Ka(J)===Ka(b);J=b;s=e;!c.history||k&&f?(k||(w=b),d?l.replace(b):k?(d=l,e=b.indexOf("#"),e=-1===e?"":b.substr(e),d.hash=e):l.href=b,l.href!==b&&(w=b)):(m[d?"replaceState":"pushState"](e,"",b),g());w&&(w=b);return h}return w||
l.href.replace(/%27/g,"'")};h.state=function(){return A};var K=[],T=!1,t=null;h.onUrlChange=function(b){if(!T){if(c.history)z(a).on("popstate",f);z(a).on("hashchange",f);T=!0}K.push(b);return b};h.$$applicationDestroyed=function(){z(a).off("hashchange popstate",f)};h.$$checkUrlChange=k;h.baseHref=function(){var a=ic.attr("href");return a?a.replace(/^(https?:)?\/\/[^/]*/,""):""};h.defer=function(a,b){var c;v++;c=p(function(){delete B[c];e(a)},b||0);B[c]=!0;return c};h.defer.cancel=function(a){return B[a]?
(delete B[a],n(a),e(D),!0):!1}}function yf(){this.$get=["$window","$log","$sniffer","$document",function(a,b,d,c){return new tg(a,c,b,d)}]}function zf(){this.$get=function(){function a(a,c){function e(a){a!==p&&(n?n===a&&(n=a.n):n=a,f(a.n,a.p),f(a,p),p=a,p.n=null)}function f(a,b){a!==b&&(a&&(a.p=b),b&&(b.n=a))}if(a in b)throw M("$cacheFactory")("iid",a);var g=0,k=P({},c,{id:a}),h=R(),l=c&&c.capacity||Number.MAX_VALUE,m=R(),p=null,n=null;return b[a]={put:function(a,b){if(!x(b)){if(l<Number.MAX_VALUE){var c=
m[a]||(m[a]={key:a});e(c)}a in h||g++;h[a]=b;g>l&&this.remove(n.key);return b}},get:function(a){if(l<Number.MAX_VALUE){var b=m[a];if(!b)return;e(b)}return h[a]},remove:function(a){if(l<Number.MAX_VALUE){var b=m[a];if(!b)return;b===p&&(p=b.p);b===n&&(n=b.n);f(b.n,b.p);delete m[a]}a in h&&(delete h[a],g--)},removeAll:function(){h=R();g=0;m=R();p=n=null},destroy:function(){m=k=h=null;delete b[a]},info:function(){return P({},k,{size:g})}}}var b={};a.info=function(){var a={};q(b,function(b,e){a[e]=b.info()});
return a};a.get=function(a){return b[a]};return a}}function Wf(){this.$get=["$cacheFactory",function(a){return a("templates")}]}function $c(a,b){function d(a,b,c){var d=/^([@&<]|=(\*?))(\??)\s*([\w$]*)$/,e=R();q(a,function(a,g){a=a.trim();if(a in p)e[g]=p[a];else{var f=a.match(d);if(!f)throw aa("iscp",b,g,a,c?"controller bindings definition":"isolate scope definition");e[g]={mode:f[1][0],collection:"*"===f[2],optional:"?"===f[3],attrName:f[4]||g};f[4]&&(p[a]=e[g])}});return e}function c(a){var b=
a.charAt(0);if(!b||b!==N(b))throw aa("baddir",a);if(a!==a.trim())throw aa("baddir",a);}function e(a){var b=a.require||a.controller&&a.name;!I(b)&&G(b)&&q(b,function(a,c){var d=a.match(l);a.substring(d[0].length)||(b[c]=d[0]+c)});return b}var f={},g=/^\s*directive:\s*([\w-]+)\s+(.*)$/,k=/(([\w-]+)(?::([^;]+))?;?)/,h=ve("ngSrc,ngSrcset,src,srcset"),l=/^(?:(\^\^?)?(\?)?(\^\^?)?)?/,m=/^(on[a-z]+|formaction)$/,p=R();this.directive=function ic(b,d){hb(b,"name");Ha(b,"directive");F(b)?(c(b),hb(d,"directiveFactory"),
f.hasOwnProperty(b)||(f[b]=[],a.factory(b+"Directive",["$injector","$exceptionHandler",function(a,c){var d=[];q(f[b],function(g,f){try{var h=a.invoke(g);C(h)?h={compile:ka(h)}:!h.compile&&h.link&&(h.compile=ka(h.link));h.priority=h.priority||0;h.index=f;h.name=h.name||b;h.require=e(h);var k=h,l=h.restrict;if(l&&(!F(l)||!/[EACM]/.test(l)))throw aa("badrestrict",l,b);k.restrict=l||"EA";h.$$moduleName=g.$$moduleName;d.push(h)}catch(m){c(m)}});return d}])),f[b].push(d)):q(b,Xb(ic));return this};this.component=
function w(a,b){function c(a){function e(b){return C(b)||I(b)?function(c,d){return a.invoke(b,this,{$element:c,$attrs:d})}:b}var g=b.template||b.templateUrl?b.template:"",f={controller:d,controllerAs:ug(b.controller)||b.controllerAs||"$ctrl",template:e(g),templateUrl:e(b.templateUrl),transclude:b.transclude,scope:{},bindToController:b.bindings||{},restrict:"E",require:b.require};q(b,function(a,b){"$"===b.charAt(0)&&(f[b]=a)});return f}if(!F(a))return q(a,Xb(Ta(this,w))),this;var d=b.controller||function(){};
q(b,function(a,b){"$"===b.charAt(0)&&(c[b]=a,C(d)&&(d[b]=a))});c.$inject=["$injector"];return this.directive(a,c)};this.aHrefSanitizationWhitelist=function(a){return u(a)?(b.aHrefSanitizationWhitelist(a),this):b.aHrefSanitizationWhitelist()};this.imgSrcSanitizationWhitelist=function(a){return u(a)?(b.imgSrcSanitizationWhitelist(a),this):b.imgSrcSanitizationWhitelist()};var n=!0;this.debugInfoEnabled=function(a){return u(a)?(n=a,this):n};var B=!1;this.preAssignBindingsEnabled=function(a){return u(a)?
(B=a,this):B};var v=!1;this.strictComponentBindingsEnabled=function(a){return u(a)?(v=a,this):v};var E=10;this.onChangesTtl=function(a){return arguments.length?(E=a,this):E};var A=!0;this.commentDirectivesEnabled=function(a){return arguments.length?(A=a,this):A};var s=!0;this.cssClassDirectivesEnabled=function(a){return arguments.length?(s=a,this):s};this.$get=["$injector","$interpolate","$exceptionHandler","$templateRequest","$parse","$controller","$rootScope","$sce","$animate","$$sanitizeUri",function(a,
b,c,e,p,V,O,qa,L,r){function la(){try{if(!--Ea)throw ga=void 0,aa("infchng",E);O.$apply(function(){for(var a=0,b=ga.length;a<b;++a)try{ga[a]()}catch(d){c(d)}ga=void 0})}finally{Ea++}}function rc(a,b){if(b){var c=Object.keys(b),d,e,g;d=0;for(e=c.length;d<e;d++)g=c[d],this[g]=b[g]}else this.$attr={};this.$$element=a}function Oa(a,b,c){Aa.innerHTML="<span "+b+">";b=Aa.firstChild.attributes;var d=b[0];b.removeNamedItem(d.name);d.value=c;a.attributes.setNamedItem(d)}function Pa(a,b){try{a.addClass(b)}catch(c){}}
function ba(a,b,c,d,e){a instanceof z||(a=z(a));var g=Sa(a,b,a,c,d,e);ba.$$addScopeClass(a);var f=null;return function(b,c,d){if(!a)throw aa("multilink");hb(b,"scope");e&&e.needsNewScope&&(b=b.$parent.$new());d=d||{};var h=d.parentBoundTranscludeFn,k=d.transcludeControllers;d=d.futureParentElement;h&&h.$$boundTransclude&&(h=h.$$boundTransclude);f||(f=(d=d&&d[0])?"foreignobject"!==ya(d)&&ha.call(d).match(/SVG/)?"svg":"html":"html");d="html"!==f?z(fa(f,z("<div></div>").append(a).html())):c?Ua.clone.call(a):
a;if(k)for(var l in k)d.data("$"+l+"Controller",k[l].instance);ba.$$addScopeInfo(d,b);c&&c(d,b);g&&g(b,d,d,h);c||(a=g=null);return d}}function Sa(a,b,c,d,e,g){function f(a,c,d,e){var g,k,l,m,p,n,H;if(K)for(H=Array(c.length),m=0;m<h.length;m+=3)g=h[m],H[g]=c[g];else H=c;m=0;for(p=h.length;m<p;)k=H[h[m++]],c=h[m++],g=h[m++],c?(c.scope?(l=a.$new(),ba.$$addScopeInfo(z(k),l)):l=a,n=c.transcludeOnThisElement?Qa(a,c.transclude,e):!c.templateOnThisElement&&e?e:!e&&b?Qa(a,b):null,c(g,l,k,d,n)):g&&g(a,k.childNodes,
void 0,e)}for(var h=[],k=I(a)||a instanceof z,l,m,p,n,K,H=0;H<a.length;H++){l=new rc;11===Ba&&Ca(a,H,k);m=sc(a[H],[],l,0===H?d:void 0,e);(g=m.length?Y(m,a[H],l,b,c,null,[],[],g):null)&&g.scope&&ba.$$addScopeClass(l.$$element);l=g&&g.terminal||!(p=a[H].childNodes)||!p.length?null:Sa(p,g?(g.transcludeOnThisElement||!g.templateOnThisElement)&&g.transclude:b);if(g||l)h.push(H,g,l),n=!0,K=K||g;g=null}return n?f:null}function Ca(a,b,c){var d=a[b],e=d.parentNode,g;if(d.nodeType===Ma)for(;;){g=e?d.nextSibling:
a[b+1];if(!g||g.nodeType!==Ma)break;d.nodeValue+=g.nodeValue;g.parentNode&&g.parentNode.removeChild(g);c&&g===a[b+1]&&a.splice(b+1,1)}}function Qa(a,b,c){function d(e,g,f,h,k){e||(e=a.$new(!1,k),e.$$transcluded=!0);return b(e,g,{parentBoundTranscludeFn:c,transcludeControllers:f,futureParentElement:h})}var e=d.$$slots=R(),g;for(g in b.$$slots)e[g]=b.$$slots[g]?Qa(a,b.$$slots[g],c):null;return d}function sc(a,b,c,d,e){var g=c.$attr,f;switch(a.nodeType){case 1:f=ya(a);X(b,Da(f),"E",d,e);for(var h,l,
m,p,n=a.attributes,K=0,H=n&&n.length;K<H;K++){var B=!1,w=!1;h=n[K];l=h.name;m=h.value;h=Da(l);(p=Na.test(h))&&(l=l.replace(qd,"").substr(8).replace(/_(.)/g,function(a,b){return b.toUpperCase()}));(h=h.match(Ra))&&ea(h[1])&&(B=l,w=l.substr(0,l.length-5)+"end",l=l.substr(0,l.length-6));h=Da(l.toLowerCase());g[h]=l;if(p||!c.hasOwnProperty(h))c[h]=m,md(a,h)&&(c[h]=!0);va(a,b,m,h,p);X(b,h,"A",d,e,B,w)}"input"===f&&"hidden"===a.getAttribute("type")&&a.setAttribute("autocomplete","off");if(!Ka)break;g=a.className;
G(g)&&(g=g.animVal);if(F(g)&&""!==g)for(;a=k.exec(g);)h=Da(a[2]),X(b,h,"C",d,e)&&(c[h]=Q(a[3])),g=g.substr(a.index+a[0].length);break;case Ma:ma(b,a.nodeValue);break;case 8:if(!Ja)break;M(a,b,c,d,e)}b.sort(ka);return b}function M(a,b,c,d,e){try{var f=g.exec(a.nodeValue);if(f){var h=Da(f[1]);X(b,h,"M",d,e)&&(c[h]=Q(f[2]))}}catch(k){}}function rd(a,b,c){var d=[],e=0;if(b&&a.hasAttribute&&a.hasAttribute(b)){do{if(!a)throw aa("uterdir",b,c);1===a.nodeType&&(a.hasAttribute(b)&&e++,a.hasAttribute(c)&&e--);
d.push(a);a=a.nextSibling}while(0<e)}else d.push(a);return z(d)}function S(a,b,c){return function(d,e,g,f,h){e=rd(e[0],b,c);return a(d,e,g,f,h)}}function U(a,b,c,d,e,g){var f;return a?ba(b,c,d,e,g):function(){f||(f=ba(b,c,d,e,g),b=c=g=null);return f.apply(this,arguments)}}function Y(a,b,d,e,g,f,h,k,l){function m(a,b,c,d){if(a){c&&(a=S(a,c,d));a.require=t.require;a.directiveName=L;if(O===t||t.$$isolateScope)a=ta(a,{isolateScope:!0});h.push(a)}if(b){c&&(b=S(b,c,d));b.require=t.require;b.directiveName=
L;if(O===t||t.$$isolateScope)b=ta(b,{isolateScope:!0});k.push(b)}}function p(a,e,g,f,l){function m(a,b,c,d){var e;bb(a)||(d=c,c=b,b=a,a=void 0);qa&&(e=E);c||(c=qa?L.parent():L);if(d){var g=l.$$slots[d];if(g)return g(a,b,e,c,ua);if(x(g))throw aa("noslot",d,za(L));}else return l(a,b,e,c,ua)}var n,t,v,s,T,E,V,L;b===g?(f=d,L=d.$$element):(L=z(g),f=new rc(L,d));T=e;O?s=e.$new(!0):H&&(T=e.$parent);l&&(V=m,V.$$boundTransclude=l,V.isSlotFilled=function(a){return!!l.$$slots[a]});w&&(E=ca(L,f,V,w,s,e,O));O&&
(ba.$$addScopeInfo(L,s,!0,!(A&&(A===O||A===O.$$originalDirective))),ba.$$addScopeClass(L,!0),s.$$isolateBindings=O.$$isolateBindings,t=oa(e,f,s,s.$$isolateBindings,O),t.removeWatches&&s.$on("$destroy",t.removeWatches));for(n in E){t=w[n];v=E[n];var Ib=t.$$bindings.bindToController;if(B){v.bindingInfo=Ib?oa(T,f,v.instance,Ib,t):{};var r=v();r!==v.instance&&(v.instance=r,L.data("$"+t.name+"Controller",r),v.bindingInfo.removeWatches&&v.bindingInfo.removeWatches(),v.bindingInfo=oa(T,f,v.instance,Ib,t))}else v.instance=
v(),L.data("$"+t.name+"Controller",v.instance),v.bindingInfo=oa(T,f,v.instance,Ib,t)}q(w,function(a,b){var c=a.require;a.bindToController&&!I(c)&&G(c)&&P(E[b].instance,W(b,c,L,E))});q(E,function(a){var b=a.instance;if(C(b.$onChanges))try{b.$onChanges(a.bindingInfo.initialChanges)}catch(d){c(d)}if(C(b.$onInit))try{b.$onInit()}catch(e){c(e)}C(b.$doCheck)&&(T.$watch(function(){b.$doCheck()}),b.$doCheck());C(b.$onDestroy)&&T.$on("$destroy",function(){b.$onDestroy()})});n=0;for(t=h.length;n<t;n++)v=h[n],
wa(v,v.isolateScope?s:e,L,f,v.require&&W(v.directiveName,v.require,L,E),V);var ua=e;O&&(O.template||null===O.templateUrl)&&(ua=s);a&&a(ua,g.childNodes,void 0,l);for(n=k.length-1;0<=n;n--)v=k[n],wa(v,v.isolateScope?s:e,L,f,v.require&&W(v.directiveName,v.require,L,E),V);q(E,function(a){a=a.instance;C(a.$postLink)&&a.$postLink()})}l=l||{};for(var n=-Number.MAX_VALUE,H=l.newScopeDirective,w=l.controllerDirectives,O=l.newIsolateScopeDirective,A=l.templateDirective,s=l.nonTlbTranscludeDirective,T=!1,E=
!1,qa=l.hasElementTranscludeDirective,v=d.$$element=z(b),t,L,V,r=e,ua,la=!1,u=!1,y,Ca=0,Oa=a.length;Ca<Oa;Ca++){t=a[Ca];var Pa=t.$$start,D=t.$$end;Pa&&(v=rd(b,Pa,D));V=void 0;if(n>t.priority)break;if(y=t.scope)t.templateUrl||(G(y)?($("new/isolated scope",O||H,t,v),O=t):$("new/isolated scope",O,t,v)),H=H||t;L=t.name;if(!la&&(t.replace&&(t.templateUrl||t.template)||t.transclude&&!t.$$tlb)){for(y=Ca+1;la=a[y++];)if(la.transclude&&!la.$$tlb||la.replace&&(la.templateUrl||la.template)){u=!0;break}la=!0}!t.templateUrl&&
t.controller&&(w=w||R(),$("'"+L+"' controller",w[L],t,v),w[L]=t);if(y=t.transclude)if(T=!0,t.$$tlb||($("transclusion",s,t,v),s=t),"element"===y)qa=!0,n=t.priority,V=v,v=d.$$element=z(ba.$$createComment(L,d[L])),b=v[0],ja(g,xa.call(V,0),b),V[0].$$parentNode=V[0].parentNode,r=U(u,V,e,n,f&&f.name,{nonTlbTranscludeDirective:s});else{var F=R();if(G(y)){V=[];var Qa=R(),M=R();q(y,function(a,b){var c="?"===a.charAt(0);a=c?a.substring(1):a;Qa[a]=b;F[b]=null;M[b]=c});q(v.contents(),function(a){var b=Qa[Da(ya(a))];
b?(M[b]=!0,F[b]=F[b]||[],F[b].push(a)):V.push(a)});q(M,function(a,b){if(!a)throw aa("reqslot",b);});for(var Sa in F)F[Sa]&&(F[Sa]=U(u,F[Sa],e))}else V=z(oc(b)).contents();v.empty();r=U(u,V,e,void 0,void 0,{needsNewScope:t.$$isolateScope||t.$$newScope});r.$$slots=F}if(t.template)if(E=!0,$("template",A,t,v),A=t,y=C(t.template)?t.template(v,d):t.template,y=Ha(y),t.replace){f=t;V=lc.test(y)?sd(fa(t.templateNamespace,Q(y))):[];b=V[0];if(1!==V.length||1!==b.nodeType)throw aa("tplrt",L,"");ja(g,v,b);Oa=
{$attr:{}};y=sc(b,[],Oa);var N=a.splice(Ca+1,a.length-(Ca+1));(O||H)&&Z(y,O,H);a=a.concat(y).concat(N);da(d,Oa);Oa=a.length}else v.html(y);if(t.templateUrl)E=!0,$("template",A,t,v),A=t,t.replace&&(f=t),p=ia(a.splice(Ca,a.length-Ca),v,d,g,T&&r,h,k,{controllerDirectives:w,newScopeDirective:H!==t&&H,newIsolateScopeDirective:O,templateDirective:A,nonTlbTranscludeDirective:s}),Oa=a.length;else if(t.compile)try{ua=t.compile(v,d,r);var tc=t.$$originalDirective||t;C(ua)?m(null,Ta(tc,ua),Pa,D):ua&&m(Ta(tc,
ua.pre),Ta(tc,ua.post),Pa,D)}catch(X){c(X,za(v))}t.terminal&&(p.terminal=!0,n=Math.max(n,t.priority))}p.scope=H&&!0===H.scope;p.transcludeOnThisElement=T;p.templateOnThisElement=E;p.transclude=r;l.hasElementTranscludeDirective=qa;return p}function W(a,b,c,d){var e;if(F(b)){var g=b.match(l);b=b.substring(g[0].length);var f=g[1]||g[3],g="?"===g[2];"^^"===f?c=c.parent():e=(e=d&&d[b])&&e.instance;if(!e){var h="$"+b+"Controller";e=f?c.inheritedData(h):c.data(h)}if(!e&&!g)throw aa("ctreq",b,a);}else if(I(b))for(e=
[],f=0,g=b.length;f<g;f++)e[f]=W(a,b[f],c,d);else G(b)&&(e={},q(b,function(b,g){e[g]=W(a,b,c,d)}));return e||null}function ca(a,b,c,d,e,g,f){var h=R(),k;for(k in d){var l=d[k],m={$scope:l===f||l.$$isolateScope?e:g,$element:a,$attrs:b,$transclude:c},p=l.controller;"@"===p&&(p=b[l.name]);m=V(p,m,!0,l.controllerAs);h[l.name]=m;a.data("$"+l.name+"Controller",m.instance)}return h}function Z(a,b,c){for(var d=0,e=a.length;d<e;d++)a[d]=$b(a[d],{$$isolateScope:b,$$newScope:c})}function X(b,c,e,g,h,k,l){if(c===
h)return null;var m=null;if(f.hasOwnProperty(c)){h=a.get(c+"Directive");for(var p=0,n=h.length;p<n;p++)if(c=h[p],(x(g)||g>c.priority)&&-1!==c.restrict.indexOf(e)){k&&(c=$b(c,{$$start:k,$$end:l}));if(!c.$$bindings){var H=m=c,K=c.name,t={isolateScope:null,bindToController:null};G(H.scope)&&(!0===H.bindToController?(t.bindToController=d(H.scope,K,!0),t.isolateScope={}):t.isolateScope=d(H.scope,K,!1));G(H.bindToController)&&(t.bindToController=d(H.bindToController,K,!0));if(t.bindToController&&!H.controller)throw aa("noctrl",
K);m=m.$$bindings=t;G(m.isolateScope)&&(c.$$isolateBindings=m.isolateScope)}b.push(c);m=c}}return m}function ea(b){if(f.hasOwnProperty(b))for(var c=a.get(b+"Directive"),d=0,e=c.length;d<e;d++)if(b=c[d],b.multiElement)return!0;return!1}function da(a,b){var c=b.$attr,d=a.$attr;q(a,function(d,e){"$"!==e.charAt(0)&&(b[e]&&b[e]!==d&&(d=d.length?d+(("style"===e?";":" ")+b[e]):b[e]),a.$set(e,d,!0,c[e]))});q(b,function(b,e){a.hasOwnProperty(e)||"$"===e.charAt(0)||(a[e]=b,"class"!==e&&"style"!==e&&(d[e]=c[e]))})}
function ia(a,b,d,g,f,h,k,l){var m=[],p,n,H=b[0],t=a.shift(),B=$b(t,{templateUrl:null,transclude:null,replace:null,$$originalDirective:t}),v=C(t.templateUrl)?t.templateUrl(b,d):t.templateUrl,O=t.templateNamespace;b.empty();e(v).then(function(c){var e,K;c=Ha(c);if(t.replace){c=lc.test(c)?sd(fa(O,Q(c))):[];e=c[0];if(1!==c.length||1!==e.nodeType)throw aa("tplrt",t.name,v);c={$attr:{}};ja(g,b,e);var w=sc(e,[],c);G(t.scope)&&Z(w,!0);a=w.concat(a);da(d,c)}else e=H,b.html(c);a.unshift(B);p=Y(a,e,d,f,b,t,
h,k,l);q(g,function(a,c){a===e&&(g[c]=b[0])});for(n=Sa(b[0].childNodes,f);m.length;){c=m.shift();K=m.shift();var s=m.shift(),A=m.shift(),w=b[0];if(!c.$$destroyed){if(K!==H){var T=K.className;l.hasElementTranscludeDirective&&t.replace||(w=oc(e));ja(s,z(K),w);Pa(z(w),T)}K=p.transcludeOnThisElement?Qa(c,p.transclude,A):A;p(n,c,w,g,K)}}m=null}).catch(function(a){bc(a)&&c(a)});return function(a,b,c,d,e){a=e;b.$$destroyed||(m?m.push(b,c,d,a):(p.transcludeOnThisElement&&(a=Qa(b,p.transclude,e)),p(n,b,c,
d,a)))}}function ka(a,b){var c=b.priority-a.priority;return 0!==c?c:a.name!==b.name?a.name<b.name?-1:1:a.index-b.index}function $(a,b,c,d){function e(a){return a?" (module: "+a+")":""}if(b)throw aa("multidir",b.name,e(b.$$moduleName),c.name,e(c.$$moduleName),a,za(d));}function ma(a,c){var d=b(c,!0);d&&a.push({priority:0,compile:function(a){a=a.parent();var b=!!a.length;b&&ba.$$addBindingClass(a);return function(a,c){var e=c.parent();b||ba.$$addBindingClass(e);ba.$$addBindingInfo(e,d.expressions);
a.$watch(d,function(a){c[0].nodeValue=a})}}})}function fa(a,b){a=N(a||"html");switch(a){case "svg":case "math":var c=y.document.createElement("div");c.innerHTML="<"+a+">"+b+"</"+a+">";return c.childNodes[0].childNodes;default:return b}}function pa(a,b){if("srcdoc"===b)return qa.HTML;var c=ya(a);if("src"===b||"ngSrc"===b){if(-1===["img","video","audio","source","track"].indexOf(c))return qa.RESOURCE_URL}else if("xlinkHref"===b||"form"===c&&"action"===b||"link"===c&&"href"===b)return qa.RESOURCE_URL}
function va(a,c,d,e,g){var f=pa(a,e),k=h[e]||g,l=b(d,!g,f,k);if(l){if("multiple"===e&&"select"===ya(a))throw aa("selmulti",za(a));if(m.test(e))throw aa("nodomevents");c.push({priority:100,compile:function(){return{pre:function(a,c,g){c=g.$$observers||(g.$$observers=R());var h=g[e];h!==d&&(l=h&&b(h,!0,f,k),d=h);l&&(g[e]=l(a),(c[e]||(c[e]=[])).$$inter=!0,(g.$$observers&&g.$$observers[e].$$scope||a).$watch(l,function(a,b){"class"===e&&a!==b?g.$updateClass(a,b):g.$set(e,a)}))}}}})}}function ja(a,b,c){var d=
b[0],e=b.length,g=d.parentNode,f,h;if(a)for(f=0,h=a.length;f<h;f++)if(a[f]===d){a[f++]=c;h=f+e-1;for(var k=a.length;f<k;f++,h++)h<k?a[f]=a[h]:delete a[f];a.length-=e-1;a.context===d&&(a.context=c);break}g&&g.replaceChild(c,d);a=y.document.createDocumentFragment();for(f=0;f<e;f++)a.appendChild(b[f]);z.hasData(d)&&(z.data(c,z.data(d)),z(d).off("$destroy"));z.cleanData(a.querySelectorAll("*"));for(f=1;f<e;f++)delete b[f];b[0]=c;b.length=1}function ta(a,b){return P(function(){return a.apply(null,arguments)},
a,b)}function wa(a,b,d,e,g,f){try{a(b,d,e,g,f)}catch(h){c(h,za(d))}}function na(a,b){if(v)throw aa("missingattr",a,b);}function oa(a,c,d,e,g){function f(b,c,e){C(d.$onChanges)&&!cc(c,e)&&(ga||(a.$$postDigest(la),ga=[]),m||(m={},ga.push(h)),m[b]&&(e=m[b].previousValue),m[b]=new Jb(e,c))}function h(){d.$onChanges(m);m=void 0}var k=[],l={},m;q(e,function(e,h){var m=e.attrName,n=e.optional,K,B,w,v;switch(e.mode){case "@":n||ra.call(c,m)||(na(m,g.name),d[h]=c[m]=void 0);n=c.$observe(m,function(a){if(F(a)||
La(a))f(h,a,d[h]),d[h]=a});c.$$observers[m].$$scope=a;K=c[m];F(K)?d[h]=b(K)(a):La(K)&&(d[h]=K);l[h]=new Jb(uc,d[h]);k.push(n);break;case "=":if(!ra.call(c,m)){if(n)break;na(m,g.name);c[m]=void 0}if(n&&!c[m])break;B=p(c[m]);v=B.literal?sa:cc;w=B.assign||function(){K=d[h]=B(a);throw aa("nonassign",c[m],m,g.name);};K=d[h]=B(a);n=function(b){v(b,d[h])||(v(b,K)?w(a,b=d[h]):d[h]=b);return K=b};n.$stateful=!0;n=e.collection?a.$watchCollection(c[m],n):a.$watch(p(c[m],n),null,B.literal);k.push(n);break;case "<":if(!ra.call(c,
m)){if(n)break;na(m,g.name);c[m]=void 0}if(n&&!c[m])break;B=p(c[m]);var O=B.literal,s=d[h]=B(a);l[h]=new Jb(uc,d[h]);n=a.$watch(B,function(a,b){if(b===a){if(b===s||O&&sa(b,s))return;b=s}f(h,a,b);d[h]=a},O);k.push(n);break;case "&":n||ra.call(c,m)||na(m,g.name);B=c.hasOwnProperty(m)?p(c[m]):D;if(B===D&&n)break;d[h]=function(b){return B(a,b)}}});return{initialChanges:l,removeWatches:k.length&&function(){for(var a=0,b=k.length;a<b;++a)k[a]()}}}var Ia=/^\w/,Aa=y.document.createElement("div"),Ja=A,Ka=
s,Ea=E,ga;rc.prototype={$normalize:Da,$addClass:function(a){a&&0<a.length&&L.addClass(this.$$element,a)},$removeClass:function(a){a&&0<a.length&&L.removeClass(this.$$element,a)},$updateClass:function(a,b){var c=td(a,b);c&&c.length&&L.addClass(this.$$element,c);(c=td(b,a))&&c.length&&L.removeClass(this.$$element,c)},$set:function(a,b,d,e){var g=md(this.$$element[0],a),f=ud[a],h=a;g?(this.$$element.prop(a,b),e=g):f&&(this[f]=b,h=f);this[a]=b;e?this.$attr[a]=e:(e=this.$attr[a])||(this.$attr[a]=e=Xc(a,
"-"));g=ya(this.$$element);if("a"===g&&("href"===a||"xlinkHref"===a)||"img"===g&&"src"===a)this[a]=b=null==b?b:r(b,"src"===a);else if("img"===g&&"srcset"===a&&u(b)){for(var g="",f=Q(b),k=/(\s+\d+x\s*,|\s+\d+w\s*,|\s+,|,\s+)/,k=/\s/.test(f)?k:/(,)/,f=f.split(k),k=Math.floor(f.length/2),l=0;l<k;l++)var m=2*l,g=g+r(Q(f[m]),!0),g=g+(" "+Q(f[m+1]));f=Q(f[2*l]).split(/\s/);g+=r(Q(f[0]),!0);2===f.length&&(g+=" "+Q(f[1]));this[a]=b=g}!1!==d&&(null==b?this.$$element.removeAttr(e):Ia.test(e)?this.$$element.attr(e,
b):Oa(this.$$element[0],e,b));(a=this.$$observers)&&q(a[h],function(a){try{a(b)}catch(d){c(d)}})},$observe:function(a,b){var c=this,d=c.$$observers||(c.$$observers=R()),e=d[a]||(d[a]=[]);e.push(b);O.$evalAsync(function(){e.$$inter||!c.hasOwnProperty(a)||x(c[a])||b(c[a])});return function(){cb(e,b)}}};var Fa=b.startSymbol(),Ga=b.endSymbol(),Ha="{{"===Fa&&"}}"===Ga?ab:function(a){return a.replace(/\{\{/g,Fa).replace(/}}/g,Ga)},Na=/^ngAttr[A-Z]/,Ra=/^(.+)Start$/;ba.$$addBindingInfo=n?function(a,b){var c=
a.data("$binding")||[];I(b)?c=c.concat(b):c.push(b);a.data("$binding",c)}:D;ba.$$addBindingClass=n?function(a){Pa(a,"ng-binding")}:D;ba.$$addScopeInfo=n?function(a,b,c,d){a.data(c?d?"$isolateScopeNoTemplate":"$isolateScope":"$scope",b)}:D;ba.$$addScopeClass=n?function(a,b){Pa(a,b?"ng-isolate-scope":"ng-scope")}:D;ba.$$createComment=function(a,b){var c="";n&&(c=" "+(a||"")+": ",b&&(c+=b+" "));return y.document.createComment(c)};return ba}]}function Jb(a,b){this.previousValue=a;this.currentValue=b}
function Da(a){return a.replace(qd,"").replace(vg,function(a,d,c){return c?d.toUpperCase():d})}function td(a,b){var d="",c=a.split(/\s+/),e=b.split(/\s+/),f=0;a:for(;f<c.length;f++){for(var g=c[f],k=0;k<e.length;k++)if(g===e[k])continue a;d+=(0<d.length?" ":"")+g}return d}function sd(a){a=z(a);var b=a.length;if(1>=b)return a;for(;b--;){var d=a[b];(8===d.nodeType||d.nodeType===Ma&&""===d.nodeValue.trim())&&wg.call(a,b,1)}return a}function ug(a,b){if(b&&F(b))return b;if(F(a)){var d=vd.exec(a);if(d)return d[3]}}
function Af(){var a={},b=!1;this.has=function(b){return a.hasOwnProperty(b)};this.register=function(b,c){Ha(b,"controller");G(b)?P(a,b):a[b]=c};this.allowGlobals=function(){b=!0};this.$get=["$injector","$window",function(d,c){function e(a,b,c,d){if(!a||!G(a.$scope))throw M("$controller")("noscp",d,b);a.$scope[b]=c}return function(f,g,k,h){var l,m,p;k=!0===k;h&&F(h)&&(p=h);if(F(f)){h=f.match(vd);if(!h)throw wd("ctrlfmt",f);m=h[1];p=p||h[3];f=a.hasOwnProperty(m)?a[m]:Zc(g.$scope,m,!0)||(b?Zc(c,m,!0):
void 0);if(!f)throw wd("ctrlreg",m);sb(f,m,!0)}if(k)return k=(I(f)?f[f.length-1]:f).prototype,l=Object.create(k||null),p&&e(g,p,l,m||f.name),P(function(){var a=d.invoke(f,l,g,m);a!==l&&(G(a)||C(a))&&(l=a,p&&e(g,p,l,m||f.name));return l},{instance:l,identifier:p});l=d.instantiate(f,g,m);p&&e(g,p,l,m||f.name);return l}}]}function Bf(){this.$get=["$window",function(a){return z(a.document)}]}function Cf(){this.$get=["$document","$rootScope",function(a,b){function d(){e=c.hidden}var c=a[0],e=c&&c.hidden;
a.on("visibilitychange",d);b.$on("$destroy",function(){a.off("visibilitychange",d)});return function(){return e}}]}function Df(){this.$get=["$log",function(a){return function(b,d){a.error.apply(a,arguments)}}]}function vc(a){return G(a)?da(a)?a.toISOString():eb(a):a}function If(){this.$get=function(){return function(a){if(!a)return"";var b=[];Qc(a,function(a,c){null===a||x(a)||C(a)||(I(a)?q(a,function(a){b.push(ia(c)+"="+ia(vc(a)))}):b.push(ia(c)+"="+ia(vc(a))))});return b.join("&")}}}function Jf(){this.$get=
function(){return function(a){function b(a,e,f){null===a||x(a)||(I(a)?q(a,function(a,c){b(a,e+"["+(G(a)?c:"")+"]")}):G(a)&&!da(a)?Qc(a,function(a,c){b(a,e+(f?"":"[")+c+(f?"":"]"))}):d.push(ia(e)+"="+ia(vc(a))))}if(!a)return"";var d=[];b(a,"",!0);return d.join("&")}}}function wc(a,b){if(F(a)){var d=a.replace(xg,"").trim();if(d){var c=b("Content-Type"),c=c&&0===c.indexOf(xd),e;(e=c)||(e=(e=d.match(yg))&&zg[e[0]].test(d));if(e)try{a=Tc(d)}catch(f){if(!c)return a;throw Kb("baddata",a,f);}}}return a}function yd(a){var b=
R(),d;F(a)?q(a.split("\n"),function(a){d=a.indexOf(":");var e=N(Q(a.substr(0,d)));a=Q(a.substr(d+1));e&&(b[e]=b[e]?b[e]+", "+a:a)}):G(a)&&q(a,function(a,d){var f=N(d),g=Q(a);f&&(b[f]=b[f]?b[f]+", "+g:g)});return b}function zd(a){var b;return function(d){b||(b=yd(a));return d?(d=b[N(d)],void 0===d&&(d=null),d):b}}function Ad(a,b,d,c){if(C(c))return c(a,b,d);q(c,function(c){a=c(a,b,d)});return a}function Hf(){var a=this.defaults={transformResponse:[wc],transformRequest:[function(a){return G(a)&&"[object File]"!==
ha.call(a)&&"[object Blob]"!==ha.call(a)&&"[object FormData]"!==ha.call(a)?eb(a):a}],headers:{common:{Accept:"application/json, text/plain, */*"},post:pa(xc),put:pa(xc),patch:pa(xc)},xsrfCookieName:"XSRF-TOKEN",xsrfHeaderName:"X-XSRF-TOKEN",paramSerializer:"$httpParamSerializer",jsonpCallbackParam:"callback"},b=!1;this.useApplyAsync=function(a){return u(a)?(b=!!a,this):b};var d=this.interceptors=[],c=this.xsrfWhitelistedOrigins=[];this.$get=["$browser","$httpBackend","$$cookieReader","$cacheFactory",
"$rootScope","$q","$injector","$sce",function(e,f,g,k,h,l,m,p){function n(b){function c(a,b){for(var d=0,e=b.length;d<e;){var g=b[d++],f=b[d++];a=a.then(g,f)}b.length=0;return a}function d(a,b){var c,e={};q(a,function(a,d){C(a)?(c=a(b),null!=c&&(e[d]=c)):e[d]=a});return e}function g(a){var b=P({},a);b.data=Ad(a.data,a.headers,a.status,f.transformResponse);a=a.status;return 200<=a&&300>a?b:l.reject(b)}if(!G(b))throw M("$http")("badreq",b);if(!F(p.valueOf(b.url)))throw M("$http")("badreq",b.url);var f=
P({method:"get",transformRequest:a.transformRequest,transformResponse:a.transformResponse,paramSerializer:a.paramSerializer,jsonpCallbackParam:a.jsonpCallbackParam},b);f.headers=function(b){var c=a.headers,e=P({},b.headers),g,f,h,c=P({},c.common,c[N(b.method)]);a:for(g in c){f=N(g);for(h in e)if(N(h)===f)continue a;e[g]=c[g]}return d(e,pa(b))}(b);f.method=ub(f.method);f.paramSerializer=F(f.paramSerializer)?m.get(f.paramSerializer):f.paramSerializer;e.$$incOutstandingRequestCount();var h=[],k=[];b=
l.resolve(f);q(s,function(a){(a.request||a.requestError)&&h.unshift(a.request,a.requestError);(a.response||a.responseError)&&k.push(a.response,a.responseError)});b=c(b,h);b=b.then(function(b){var c=b.headers,d=Ad(b.data,zd(c),void 0,b.transformRequest);x(d)&&q(c,function(a,b){"content-type"===N(b)&&delete c[b]});x(b.withCredentials)&&!x(a.withCredentials)&&(b.withCredentials=a.withCredentials);return B(b,d).then(g,g)});b=c(b,k);return b=b.finally(function(){e.$$completeOutstandingRequest(D)})}function B(c,
d){function e(a){if(a){var c={};q(a,function(a,d){c[d]=function(c){function d(){a(c)}b?h.$applyAsync(d):h.$$phase?d():h.$apply(d)}});return c}}function k(a,c,d,e,g){function f(){m(c,a,d,e,g)}L&&(200<=a&&300>a?L.put(z,[a,c,yd(d),e,g]):L.remove(z));b?h.$applyAsync(f):(f(),h.$$phase||h.$apply())}function m(a,b,d,e,g){b=-1<=b?b:0;(200<=b&&300>b?s.resolve:s.reject)({data:a,status:b,headers:zd(d),config:c,statusText:e,xhrStatus:g})}function t(a){m(a.data,a.status,pa(a.headers()),a.statusText,a.xhrStatus)}
function B(){var a=n.pendingRequests.indexOf(c);-1!==a&&n.pendingRequests.splice(a,1)}var s=l.defer(),qa=s.promise,L,r,la=c.headers,y="jsonp"===N(c.method),z=c.url;y?z=p.getTrustedResourceUrl(z):F(z)||(z=p.valueOf(z));z=v(z,c.paramSerializer(c.params));y&&(z=E(z,c.jsonpCallbackParam));n.pendingRequests.push(c);qa.then(B,B);!c.cache&&!a.cache||!1===c.cache||"GET"!==c.method&&"JSONP"!==c.method||(L=G(c.cache)?c.cache:G(a.cache)?a.cache:A);L&&(r=L.get(z),u(r)?r&&C(r.then)?r.then(t,t):I(r)?m(r[1],r[0],
pa(r[2]),r[3],r[4]):m(r,200,{},"OK","complete"):L.put(z,qa));x(r)&&((r=J(c.url)?g()[c.xsrfCookieName||a.xsrfCookieName]:void 0)&&(la[c.xsrfHeaderName||a.xsrfHeaderName]=r),f(c.method,z,d,k,la,c.timeout,c.withCredentials,c.responseType,e(c.eventHandlers),e(c.uploadEventHandlers)));return qa}function v(a,b){0<b.length&&(a+=(-1===a.indexOf("?")?"?":"&")+b);return a}function E(a,b){var c=a.split("?");if(2<c.length)throw Kb("badjsonp",a);c=fc(c[1]);q(c,function(c,d){if("JSON_CALLBACK"===c)throw Kb("badjsonp",
a);if(d===b)throw Kb("badjsonp",b,a);});return a+=(-1===a.indexOf("?")?"?":"&")+b+"=JSON_CALLBACK"}var A=k("$http");a.paramSerializer=F(a.paramSerializer)?m.get(a.paramSerializer):a.paramSerializer;var s=[];q(d,function(a){s.unshift(F(a)?m.get(a):m.invoke(a))});var J=Ag(c);n.pendingRequests=[];(function(a){q(arguments,function(a){n[a]=function(b,c){return n(P({},c||{},{method:a,url:b}))}})})("get","delete","head","jsonp");(function(a){q(arguments,function(a){n[a]=function(b,c,d){return n(P({},d||
{},{method:a,url:b,data:c}))}})})("post","put","patch");n.defaults=a;return n}]}function Lf(){this.$get=function(){return function(){return new y.XMLHttpRequest}}}function Kf(){this.$get=["$browser","$jsonpCallbacks","$document","$xhrFactory",function(a,b,d,c){return Bg(a,c,a.defer,b,d[0])}]}function Bg(a,b,d,c,e){function f(a,b,d){a=a.replace("JSON_CALLBACK",b);var f=e.createElement("script"),m=null;f.type="text/javascript";f.src=a;f.async=!0;m=function(a){f.removeEventListener("load",m);f.removeEventListener("error",
m);e.body.removeChild(f);f=null;var g=-1,B="unknown";a&&("load"!==a.type||c.wasCalled(b)||(a={type:"error"}),B=a.type,g="error"===a.type?404:200);d&&d(g,B)};f.addEventListener("load",m);f.addEventListener("error",m);e.body.appendChild(f);return m}return function(e,k,h,l,m,p,n,B,v,E){function A(a){H="timeout"===a;r&&r();w&&w.abort()}function s(a,b,c,e,g,f){u(T)&&d.cancel(T);r=w=null;a(b,c,e,g,f)}k=k||a.url();if("jsonp"===N(e))var J=c.createCallback(k),r=f(k,J,function(a,b){var d=200===a&&c.getResponse(J);
s(l,a,d,"",b,"complete");c.removeCallback(J)});else{var w=b(e,k),H=!1;w.open(e,k,!0);q(m,function(a,b){u(a)&&w.setRequestHeader(b,a)});w.onload=function(){var a=w.statusText||"",b="response"in w?w.response:w.responseText,c=1223===w.status?204:w.status;0===c&&(c=b?200:"file"===ma(k).protocol?404:0);s(l,c,b,w.getAllResponseHeaders(),a,"complete")};w.onerror=function(){s(l,-1,null,null,"","error")};w.ontimeout=function(){s(l,-1,null,null,"","timeout")};w.onabort=function(){s(l,-1,null,null,"",H?"timeout":
"abort")};q(v,function(a,b){w.addEventListener(b,a)});q(E,function(a,b){w.upload.addEventListener(b,a)});n&&(w.withCredentials=!0);if(B)try{w.responseType=B}catch(K){if("json"!==B)throw K;}w.send(x(h)?null:h)}if(0<p)var T=d(function(){A("timeout")},p);else p&&C(p.then)&&p.then(function(){A(u(p.$$timeoutId)?"timeout":"abort")})}}function Ff(){var a="{{",b="}}";this.startSymbol=function(b){return b?(a=b,this):a};this.endSymbol=function(a){return a?(b=a,this):b};this.$get=["$parse","$exceptionHandler",
"$sce",function(d,c,e){function f(a){return"\\\\\\"+a}function g(c){return c.replace(p,a).replace(n,b)}function k(a,b,c,d){var e=a.$watch(function(a){e();return d(a)},b,c);return e}function h(f,h,p,n){function s(a){try{var b=a;a=p?e.getTrusted(p,b):e.valueOf(b);return n&&!u(a)?a:hc(a)}catch(d){c(Ea.interr(f,d))}}if(!f.length||-1===f.indexOf(a)){var J;h||(h=g(f),J=ka(h),J.exp=f,J.expressions=[],J.$$watchDelegate=k);return J}n=!!n;var q,w,H=0,K=[],T=[];J=f.length;for(var t=[],r=[];H<J;)if(-1!==(q=f.indexOf(a,
H))&&-1!==(w=f.indexOf(b,q+l)))H!==q&&t.push(g(f.substring(H,q))),H=f.substring(q+l,w),K.push(H),T.push(d(H,s)),H=w+m,r.push(t.length),t.push("");else{H!==J&&t.push(g(f.substring(H)));break}p&&1<t.length&&Ea.throwNoconcat(f);if(!h||K.length){var O=function(a){for(var b=0,c=K.length;b<c;b++){if(n&&x(a[b]))return;t[r[b]]=a[b]}return t.join("")};return P(function(a){var b=0,d=K.length,e=Array(d);try{for(;b<d;b++)e[b]=T[b](a);return O(e)}catch(g){c(Ea.interr(f,g))}},{exp:f,expressions:K,$$watchDelegate:function(a,
b){var c;return a.$watchGroup(T,function(d,e){var g=O(d);b.call(this,g,d!==e?c:g,a);c=g})}})}}var l=a.length,m=b.length,p=new RegExp(a.replace(/./g,f),"g"),n=new RegExp(b.replace(/./g,f),"g");h.startSymbol=function(){return a};h.endSymbol=function(){return b};return h}]}function Gf(){this.$get=["$rootScope","$window","$q","$$q","$browser",function(a,b,d,c,e){function f(f,h,l,m){function p(){n?f.apply(null,B):f(A)}var n=4<arguments.length,B=n?xa.call(arguments,4):[],v=b.setInterval,E=b.clearInterval,
A=0,s=u(m)&&!m,J=(s?c:d).defer(),q=J.promise;l=u(l)?l:0;q.$$intervalId=v(function(){s?e.defer(p):a.$evalAsync(p);J.notify(A++);0<l&&A>=l&&(J.resolve(A),E(q.$$intervalId),delete g[q.$$intervalId]);s||a.$apply()},h);g[q.$$intervalId]=J;return q}var g={};f.cancel=function(a){return a&&a.$$intervalId in g?(g[a.$$intervalId].promise.$$state.pur=!0,g[a.$$intervalId].reject("canceled"),b.clearInterval(a.$$intervalId),delete g[a.$$intervalId],!0):!1};return f}]}function yc(a){a=a.split("/");for(var b=a.length;b--;)a[b]=
fb(a[b].replace(/%2F/g,"/"));return a.join("/")}function Bd(a,b){var d=ma(a);b.$$protocol=d.protocol;b.$$host=d.hostname;b.$$port=Z(d.port)||Cg[d.protocol]||null}function Cd(a,b,d){if(Dg.test(a))throw kb("badpath",a);var c="/"!==a.charAt(0);c&&(a="/"+a);a=ma(a);for(var c=(c&&"/"===a.pathname.charAt(0)?a.pathname.substring(1):a.pathname).split("/"),e=c.length;e--;)c[e]=decodeURIComponent(c[e]),d&&(c[e]=c[e].replace(/\//g,"%2F"));d=c.join("/");b.$$path=d;b.$$search=fc(a.search);b.$$hash=decodeURIComponent(a.hash);
b.$$path&&"/"!==b.$$path.charAt(0)&&(b.$$path="/"+b.$$path)}function zc(a,b){return a.slice(0,b.length)===b}function va(a,b){if(zc(b,a))return b.substr(a.length)}function Ka(a){var b=a.indexOf("#");return-1===b?a:a.substr(0,b)}function lb(a){return a.replace(/(#.+)|#$/,"$1")}function Ac(a,b,d){this.$$html5=!0;d=d||"";Bd(a,this);this.$$parse=function(a){var d=va(b,a);if(!F(d))throw kb("ipthprfx",a,b);Cd(d,this,!0);this.$$path||(this.$$path="/");this.$$compose()};this.$$compose=function(){var a=gc(this.$$search),
d=this.$$hash?"#"+fb(this.$$hash):"";this.$$url=yc(this.$$path)+(a?"?"+a:"")+d;this.$$absUrl=b+this.$$url.substr(1);this.$$urlUpdatedByLocation=!0};this.$$parseLinkUrl=function(c,e){if(e&&"#"===e[0])return this.hash(e.slice(1)),!0;var f,g;u(f=va(a,c))?(g=f,g=d&&u(f=va(d,f))?b+(va("/",f)||f):a+g):u(f=va(b,c))?g=b+f:b===c+"/"&&(g=b);g&&this.$$parse(g);return!!g}}function Bc(a,b,d){Bd(a,this);this.$$parse=function(c){var e=va(a,c)||va(b,c),f;x(e)||"#"!==e.charAt(0)?this.$$html5?f=e:(f="",x(e)&&(a=c,
this.replace())):(f=va(d,e),x(f)&&(f=e));Cd(f,this,!1);c=this.$$path;var e=a,g=/^\/[A-Z]:(\/.*)/;zc(f,e)&&(f=f.replace(e,""));g.exec(f)||(c=(f=g.exec(c))?f[1]:c);this.$$path=c;this.$$compose()};this.$$compose=function(){var b=gc(this.$$search),e=this.$$hash?"#"+fb(this.$$hash):"";this.$$url=yc(this.$$path)+(b?"?"+b:"")+e;this.$$absUrl=a+(this.$$url?d+this.$$url:"");this.$$urlUpdatedByLocation=!0};this.$$parseLinkUrl=function(b,d){return Ka(a)===Ka(b)?(this.$$parse(b),!0):!1}}function Dd(a,b,d){this.$$html5=
!0;Bc.apply(this,arguments);this.$$parseLinkUrl=function(c,e){if(e&&"#"===e[0])return this.hash(e.slice(1)),!0;var f,g;a===Ka(c)?f=c:(g=va(b,c))?f=a+d+g:b===c+"/"&&(f=b);f&&this.$$parse(f);return!!f};this.$$compose=function(){var b=gc(this.$$search),e=this.$$hash?"#"+fb(this.$$hash):"";this.$$url=yc(this.$$path)+(b?"?"+b:"")+e;this.$$absUrl=a+d+this.$$url;this.$$urlUpdatedByLocation=!0}}function Lb(a){return function(){return this[a]}}function Ed(a,b){return function(d){if(x(d))return this[a];this[a]=
b(d);this.$$compose();return this}}function Nf(){var a="!",b={enabled:!1,requireBase:!0,rewriteLinks:!0};this.hashPrefix=function(b){return u(b)?(a=b,this):a};this.html5Mode=function(a){if(La(a))return b.enabled=a,this;if(G(a)){La(a.enabled)&&(b.enabled=a.enabled);La(a.requireBase)&&(b.requireBase=a.requireBase);if(La(a.rewriteLinks)||F(a.rewriteLinks))b.rewriteLinks=a.rewriteLinks;return this}return b};this.$get=["$rootScope","$browser","$sniffer","$rootElement","$window",function(d,c,e,f,g){function k(a,
b,d){var e=l.url(),g=l.$$state;try{c.url(a,b,d),l.$$state=c.state()}catch(f){throw l.url(e),l.$$state=g,f;}}function h(a,b){d.$broadcast("$locationChangeSuccess",l.absUrl(),a,l.$$state,b)}var l,m;m=c.baseHref();var p=c.url(),n;if(b.enabled){if(!m&&b.requireBase)throw kb("nobase");n=p.substring(0,p.indexOf("/",p.indexOf("//")+2))+(m||"/");m=e.history?Ac:Dd}else n=Ka(p),m=Bc;var B=n.substr(0,Ka(n).lastIndexOf("/")+1);l=new m(n,B,"#"+a);l.$$parseLinkUrl(p,p);l.$$state=c.state();var v=/^\s*(javascript|mailto):/i;
f.on("click",function(a){var e=b.rewriteLinks;if(e&&!a.ctrlKey&&!a.metaKey&&!a.shiftKey&&2!==a.which&&2!==a.button){for(var h=z(a.target);"a"!==ya(h[0]);)if(h[0]===f[0]||!(h=h.parent())[0])return;if(!F(e)||!x(h.attr(e))){var e=h.prop("href"),k=h.attr("href")||h.attr("xlink:href");G(e)&&"[object SVGAnimatedString]"===e.toString()&&(e=ma(e.animVal).href);v.test(e)||!e||h.attr("target")||a.isDefaultPrevented()||!l.$$parseLinkUrl(e,k)||(a.preventDefault(),l.absUrl()!==c.url()&&(d.$apply(),g.angular["ff-684208-preventDefault"]=
!0))}}});lb(l.absUrl())!==lb(p)&&c.url(l.absUrl(),!0);var q=!0;c.onUrlChange(function(a,b){zc(a,B)?(d.$evalAsync(function(){var c=l.absUrl(),e=l.$$state,g;a=lb(a);l.$$parse(a);l.$$state=b;g=d.$broadcast("$locationChangeStart",a,c,b,e).defaultPrevented;l.absUrl()===a&&(g?(l.$$parse(c),l.$$state=e,k(c,!1,e)):(q=!1,h(c,e)))}),d.$$phase||d.$digest()):g.location.href=a});d.$watch(function(){if(q||l.$$urlUpdatedByLocation){l.$$urlUpdatedByLocation=!1;var a=lb(c.url()),b=lb(l.absUrl()),g=c.state(),f=l.$$replace,
m=a!==b||l.$$html5&&e.history&&g!==l.$$state;if(q||m)q=!1,d.$evalAsync(function(){var b=l.absUrl(),c=d.$broadcast("$locationChangeStart",b,a,l.$$state,g).defaultPrevented;l.absUrl()===b&&(c?(l.$$parse(a),l.$$state=g):(m&&k(b,f,g===l.$$state?null:l.$$state),h(a,g)))})}l.$$replace=!1});return l}]}function Of(){var a=!0,b=this;this.debugEnabled=function(b){return u(b)?(a=b,this):a};this.$get=["$window",function(d){function c(a){bc(a)&&(a.stack&&f?a=a.message&&-1===a.stack.indexOf(a.message)?"Error: "+
a.message+"\n"+a.stack:a.stack:a.sourceURL&&(a=a.message+"\n"+a.sourceURL+":"+a.line));return a}function e(a){var b=d.console||{},e=b[a]||b.log||D;return function(){var a=[];q(arguments,function(b){a.push(c(b))});return Function.prototype.apply.call(e,b,a)}}var f=Ba||/\bEdge\//.test(d.navigator&&d.navigator.userAgent);return{log:e("log"),info:e("info"),warn:e("warn"),error:e("error"),debug:function(){var c=e("debug");return function(){a&&c.apply(b,arguments)}}()}}]}function Eg(a){return a+""}function Fg(a,
b){return"undefined"!==typeof a?a:b}function Fd(a,b){return"undefined"===typeof a?b:"undefined"===typeof b?a:a+b}function Gg(a,b){switch(a.type){case r.MemberExpression:if(a.computed)return!1;break;case r.UnaryExpression:return 1;case r.BinaryExpression:return"+"!==a.operator?1:!1;case r.CallExpression:return!1}return void 0===b?Gd:b}function U(a,b,d){var c,e,f=a.isPure=Gg(a,d);switch(a.type){case r.Program:c=!0;q(a.body,function(a){U(a.expression,b,f);c=c&&a.expression.constant});a.constant=c;break;
case r.Literal:a.constant=!0;a.toWatch=[];break;case r.UnaryExpression:U(a.argument,b,f);a.constant=a.argument.constant;a.toWatch=a.argument.toWatch;break;case r.BinaryExpression:U(a.left,b,f);U(a.right,b,f);a.constant=a.left.constant&&a.right.constant;a.toWatch=a.left.toWatch.concat(a.right.toWatch);break;case r.LogicalExpression:U(a.left,b,f);U(a.right,b,f);a.constant=a.left.constant&&a.right.constant;a.toWatch=a.constant?[]:[a];break;case r.ConditionalExpression:U(a.test,b,f);U(a.alternate,b,f);
U(a.consequent,b,f);a.constant=a.test.constant&&a.alternate.constant&&a.consequent.constant;a.toWatch=a.constant?[]:[a];break;case r.Identifier:a.constant=!1;a.toWatch=[a];break;case r.MemberExpression:U(a.object,b,f);a.computed&&U(a.property,b,f);a.constant=a.object.constant&&(!a.computed||a.property.constant);a.toWatch=a.constant?[]:[a];break;case r.CallExpression:c=d=a.filter?!b(a.callee.name).$stateful:!1;e=[];q(a.arguments,function(a){U(a,b,f);c=c&&a.constant;e.push.apply(e,a.toWatch)});a.constant=
c;a.toWatch=d?e:[a];break;case r.AssignmentExpression:U(a.left,b,f);U(a.right,b,f);a.constant=a.left.constant&&a.right.constant;a.toWatch=[a];break;case r.ArrayExpression:c=!0;e=[];q(a.elements,function(a){U(a,b,f);c=c&&a.constant;e.push.apply(e,a.toWatch)});a.constant=c;a.toWatch=e;break;case r.ObjectExpression:c=!0;e=[];q(a.properties,function(a){U(a.value,b,f);c=c&&a.value.constant;e.push.apply(e,a.value.toWatch);a.computed&&(U(a.key,b,!1),c=c&&a.key.constant,e.push.apply(e,a.key.toWatch))});a.constant=
c;a.toWatch=e;break;case r.ThisExpression:a.constant=!1;a.toWatch=[];break;case r.LocalsExpression:a.constant=!1,a.toWatch=[]}}function Hd(a){if(1===a.length){a=a[0].expression;var b=a.toWatch;return 1!==b.length?b:b[0]!==a?b:void 0}}function Id(a){return a.type===r.Identifier||a.type===r.MemberExpression}function Jd(a){if(1===a.body.length&&Id(a.body[0].expression))return{type:r.AssignmentExpression,left:a.body[0].expression,right:{type:r.NGValueParameter},operator:"="}}function Kd(a){this.$filter=
a}function Ld(a){this.$filter=a}function Mb(a,b,d){this.ast=new r(a,d);this.astCompiler=d.csp?new Ld(b):new Kd(b)}function Cc(a){return C(a.valueOf)?a.valueOf():Hg.call(a)}function Pf(){var a=R(),b={"true":!0,"false":!1,"null":null,undefined:void 0},d,c;this.addLiteral=function(a,c){b[a]=c};this.setIdentifierFns=function(a,b){d=a;c=b;return this};this.$get=["$filter",function(e){function f(b,c){var d,g;switch(typeof b){case "string":return g=b=b.trim(),d=a[g],d||(d=new Nb(n),d=(new Mb(d,e,n)).parse(b),
d.constant?d.$$watchDelegate=m:d.oneTime?d.$$watchDelegate=d.literal?l:h:d.inputs&&(d.$$watchDelegate=k),a[g]=d),p(d,c);case "function":return p(b,c);default:return p(D,c)}}function g(a,b,c){return null==a||null==b?a===b:"object"!==typeof a||(a=Cc(a),"object"!==typeof a||c)?a===b||a!==a&&b!==b:!1}function k(a,b,c,d,e){var f=d.inputs,h;if(1===f.length){var k=g,f=f[0];return a.$watch(function(a){var b=f(a);g(b,k,f.isPure)||(h=d(a,void 0,void 0,[b]),k=b&&Cc(b));return h},b,c,e)}for(var l=[],m=[],p=0,
n=f.length;p<n;p++)l[p]=g,m[p]=null;return a.$watch(function(a){for(var b=!1,c=0,e=f.length;c<e;c++){var k=f[c](a);if(b||(b=!g(k,l[c],f[c].isPure)))m[c]=k,l[c]=k&&Cc(k)}b&&(h=d(a,void 0,void 0,m));return h},b,c,e)}function h(a,b,c,d,e){function g(a){return d(a)}function f(a,c,d){l=a;C(b)&&b(a,c,d);u(a)&&d.$$postDigest(function(){u(l)&&h()})}var h,l;return h=d.inputs?k(a,f,c,d,e):a.$watch(g,f,c)}function l(a,b,c,d){function e(a){var b=!0;q(a,function(a){u(a)||(b=!1)});return b}var g,f;return g=a.$watch(function(a){return d(a)},
function(a,c,d){f=a;C(b)&&b(a,c,d);e(a)&&d.$$postDigest(function(){e(f)&&g()})},c)}function m(a,b,c,d){var e=a.$watch(function(a){e();return d(a)},b,c);return e}function p(a,b){if(!b)return a;var c=a.$$watchDelegate,d=!1,e=c!==l&&c!==h?function(c,e,g,f){g=d&&f?f[0]:a(c,e,g,f);return b(g,c,e)}:function(c,d,e,g){e=a(c,d,e,g);c=b(e,c,d);return u(e)?c:e},d=!a.inputs;c&&c!==k?(e.$$watchDelegate=c,e.inputs=a.inputs):b.$stateful||(e.$$watchDelegate=k,e.inputs=a.inputs?a.inputs:[a]);e.inputs&&(e.inputs=e.inputs.map(function(a){return a.isPure===
Gd?function(b){return a(b)}:a}));return e}var n={csp:Ia().noUnsafeEval,literals:na(b),isIdentifierStart:C(d)&&d,isIdentifierContinue:C(c)&&c};f.$$getAst=function(a){var b=new Nb(n);return(new Mb(b,e,n)).getAst(a).ast};return f}]}function Rf(){var a=!0;this.$get=["$rootScope","$exceptionHandler",function(b,d){return Md(function(a){b.$evalAsync(a)},d,a)}];this.errorOnUnhandledRejections=function(b){return u(b)?(a=b,this):a}}function Sf(){var a=!0;this.$get=["$browser","$exceptionHandler",function(b,
d){return Md(function(a){b.defer(a)},d,a)}];this.errorOnUnhandledRejections=function(b){return u(b)?(a=b,this):a}}function Md(a,b,d){function c(){return new e}function e(){var a=this.promise=new f;this.resolve=function(b){h(a,b)};this.reject=function(b){m(a,b)};this.notify=function(b){n(a,b)}}function f(){this.$$state={status:0}}function g(){for(;!J&&u.length;){var a=u.shift();if(!a.pur){a.pur=!0;var c=a.value,c="Possibly unhandled rejection: "+("function"===typeof c?c.toString().replace(/ \{[\s\S]*$/,
""):x(c)?"undefined":"string"!==typeof c?Fe(c,void 0):c);bc(a.value)?b(a.value,c):b(c)}}}function k(c){!d||c.pending||2!==c.status||c.pur||(0===J&&0===u.length&&a(g),u.push(c));!c.processScheduled&&c.pending&&(c.processScheduled=!0,++J,a(function(){var e,f,k;k=c.pending;c.processScheduled=!1;c.pending=void 0;try{for(var l=0,p=k.length;l<p;++l){c.pur=!0;f=k[l][0];e=k[l][c.status];try{C(e)?h(f,e(c.value)):1===c.status?h(f,c.value):m(f,c.value)}catch(n){m(f,n),n&&!0===n.$$passToExceptionHandler&&b(n)}}}finally{--J,
d&&0===J&&a(g)}}))}function h(a,b){a.$$state.status||(b===a?p(a,s("qcycle",b)):l(a,b))}function l(a,b){function c(b){g||(g=!0,l(a,b))}function d(b){g||(g=!0,p(a,b))}function e(b){n(a,b)}var f,g=!1;try{if(G(b)||C(b))f=b.then;C(f)?(a.$$state.status=-1,f.call(b,c,d,e)):(a.$$state.value=b,a.$$state.status=1,k(a.$$state))}catch(h){d(h)}}function m(a,b){a.$$state.status||p(a,b)}function p(a,b){a.$$state.value=b;a.$$state.status=2;k(a.$$state)}function n(c,d){var e=c.$$state.pending;0>=c.$$state.status&&
e&&e.length&&a(function(){for(var a,c,f=0,g=e.length;f<g;f++){c=e[f][0];a=e[f][3];try{n(c,C(a)?a(d):d)}catch(h){b(h)}}})}function B(a){var b=new f;m(b,a);return b}function v(a,b,c){var d=null;try{C(c)&&(d=c())}catch(e){return B(e)}return d&&C(d.then)?d.then(function(){return b(a)},B):b(a)}function r(a,b,c,d){var e=new f;h(e,a);return e.then(b,c,d)}function A(a){if(!C(a))throw s("norslvr",a);var b=new f;a(function(a){h(b,a)},function(a){m(b,a)});return b}var s=M("$q",TypeError),J=0,u=[];P(f.prototype,
{then:function(a,b,c){if(x(a)&&x(b)&&x(c))return this;var d=new f;this.$$state.pending=this.$$state.pending||[];this.$$state.pending.push([d,a,b,c]);0<this.$$state.status&&k(this.$$state);return d},"catch":function(a){return this.then(null,a)},"finally":function(a,b){return this.then(function(b){return v(b,w,a)},function(b){return v(b,B,a)},b)}});var w=r;A.prototype=f.prototype;A.defer=c;A.reject=B;A.when=r;A.resolve=w;A.all=function(a){var b=new f,c=0,d=I(a)?[]:{};q(a,function(a,e){c++;r(a).then(function(a){d[e]=
a;--c||h(b,d)},function(a){m(b,a)})});0===c&&h(b,d);return b};A.race=function(a){var b=c();q(a,function(a){r(a).then(b.resolve,b.reject)});return b.promise};return A}function ag(){this.$get=["$window","$timeout",function(a,b){var d=a.requestAnimationFrame||a.webkitRequestAnimationFrame,c=a.cancelAnimationFrame||a.webkitCancelAnimationFrame||a.webkitCancelRequestAnimationFrame,e=!!d,f=e?function(a){var b=d(a);return function(){c(b)}}:function(a){var c=b(a,16.66,!1);return function(){b.cancel(c)}};
f.supported=e;return f}]}function Qf(){function a(a){function b(){this.$$watchers=this.$$nextSibling=this.$$childHead=this.$$childTail=null;this.$$listeners={};this.$$listenerCount={};this.$$watchersCount=0;this.$id=++qb;this.$$ChildScope=null;this.$$suspended=!1}b.prototype=a;return b}var b=10,d=M("$rootScope"),c=null,e=null;this.digestTtl=function(a){arguments.length&&(b=a);return b};this.$get=["$exceptionHandler","$parse","$browser",function(f,g,k){function h(a){a.currentScope.$$destroyed=!0}function l(a){9===
Ba&&(a.$$childHead&&l(a.$$childHead),a.$$nextSibling&&l(a.$$nextSibling));a.$parent=a.$$nextSibling=a.$$prevSibling=a.$$childHead=a.$$childTail=a.$root=a.$$watchers=null}function m(){this.$id=++qb;this.$$phase=this.$parent=this.$$watchers=this.$$nextSibling=this.$$prevSibling=this.$$childHead=this.$$childTail=null;this.$root=this;this.$$suspended=this.$$destroyed=!1;this.$$listeners={};this.$$listenerCount={};this.$$watchersCount=0;this.$$isolateBindings=null}function p(a){if(s.$$phase)throw d("inprog",
s.$$phase);s.$$phase=a}function n(a,b){do a.$$watchersCount+=b;while(a=a.$parent)}function B(a,b,c){do a.$$listenerCount[c]-=b,0===a.$$listenerCount[c]&&delete a.$$listenerCount[c];while(a=a.$parent)}function v(){}function r(){for(;w.length;)try{w.shift()()}catch(a){f(a)}e=null}function A(){null===e&&(e=k.defer(function(){s.$apply(r)}))}m.prototype={constructor:m,$new:function(b,c){var d;c=c||this;b?(d=new m,d.$root=this.$root):(this.$$ChildScope||(this.$$ChildScope=a(this)),d=new this.$$ChildScope);
d.$parent=c;d.$$prevSibling=c.$$childTail;c.$$childHead?(c.$$childTail.$$nextSibling=d,c.$$childTail=d):c.$$childHead=c.$$childTail=d;(b||c!==this)&&d.$on("$destroy",h);return d},$watch:function(a,b,d,e){var f=g(a);b=C(b)?b:D;if(f.$$watchDelegate)return f.$$watchDelegate(this,b,d,f,a);var h=this,k=h.$$watchers,l={fn:b,last:v,get:f,exp:e||a,eq:!!d};c=null;k||(k=h.$$watchers=[],k.$$digestWatchIndex=-1);k.unshift(l);k.$$digestWatchIndex++;n(this,1);return function(){var a=cb(k,l);0<=a&&(n(h,-1),a<k.$$digestWatchIndex&&
k.$$digestWatchIndex--);c=null}},$watchGroup:function(a,b){function c(){h=!1;k?(k=!1,b(e,e,g)):b(e,d,g)}var d=Array(a.length),e=Array(a.length),f=[],g=this,h=!1,k=!0;if(!a.length){var l=!0;g.$evalAsync(function(){l&&b(e,e,g)});return function(){l=!1}}if(1===a.length)return this.$watch(a[0],function(a,c,f){e[0]=a;d[0]=c;b(e,a===c?e:d,f)});q(a,function(a,b){var k=g.$watch(a,function(a,f){e[b]=a;d[b]=f;h||(h=!0,g.$evalAsync(c))});f.push(k)});return function(){for(;f.length;)f.shift()()}},$watchCollection:function(a,
b){function c(a){e=a;var b,d,g,h;if(!x(e)){if(G(e))if(ja(e))for(f!==p&&(f=p,q=f.length=0,l++),a=e.length,q!==a&&(l++,f.length=q=a),b=0;b<a;b++)h=f[b],g=e[b],d=h!==h&&g!==g,d||h===g||(l++,f[b]=g);else{f!==n&&(f=n={},q=0,l++);a=0;for(b in e)ra.call(e,b)&&(a++,g=e[b],h=f[b],b in f?(d=h!==h&&g!==g,d||h===g||(l++,f[b]=g)):(q++,f[b]=g,l++));if(q>a)for(b in l++,f)ra.call(e,b)||(q--,delete f[b])}else f!==e&&(f=e,l++);return l}}c.$stateful=!0;var d=this,e,f,h,k=1<b.length,l=0,m=g(a,c),p=[],n={},B=!0,q=0;return this.$watch(m,
function(){B?(B=!1,b(e,e,d)):b(e,h,d);if(k)if(G(e))if(ja(e)){h=Array(e.length);for(var a=0;a<e.length;a++)h[a]=e[a]}else for(a in h={},e)ra.call(e,a)&&(h[a]=e[a]);else h=e})},$digest:function(){var a,g,h,l,m,n,q,B=b,w,A=[],z,y;p("$digest");k.$$checkUrlChange();this===s&&null!==e&&(k.defer.cancel(e),r());c=null;do{q=!1;w=this;for(n=0;n<J.length;n++){try{y=J[n],l=y.fn,l(y.scope,y.locals)}catch(x){f(x)}c=null}J.length=0;a:do{if(n=!w.$$suspended&&w.$$watchers)for(n.$$digestWatchIndex=n.length;n.$$digestWatchIndex--;)try{if(a=
n[n.$$digestWatchIndex])if(m=a.get,(g=m(w))!==(h=a.last)&&!(a.eq?sa(g,h):X(g)&&X(h)))q=!0,c=a,a.last=a.eq?na(g,null):g,l=a.fn,l(g,h===v?g:h,w),5>B&&(z=4-B,A[z]||(A[z]=[]),A[z].push({msg:C(a.exp)?"fn: "+(a.exp.name||a.exp.toString()):a.exp,newVal:g,oldVal:h}));else if(a===c){q=!1;break a}}catch(F){f(F)}if(!(n=!w.$$suspended&&w.$$watchersCount&&w.$$childHead||w!==this&&w.$$nextSibling))for(;w!==this&&!(n=w.$$nextSibling);)w=w.$parent}while(w=n);if((q||J.length)&&!B--)throw s.$$phase=null,d("infdig",
b,A);}while(q||J.length);for(s.$$phase=null;H<u.length;)try{u[H++]()}catch(D){f(D)}u.length=H=0;k.$$checkUrlChange()},$suspend:function(){this.$$suspended=!0},$isSuspended:function(){return this.$$suspended},$resume:function(){this.$$suspended=!1},$destroy:function(){if(!this.$$destroyed){var a=this.$parent;this.$broadcast("$destroy");this.$$destroyed=!0;this===s&&k.$$applicationDestroyed();n(this,-this.$$watchersCount);for(var b in this.$$listenerCount)B(this,this.$$listenerCount[b],b);a&&a.$$childHead===
this&&(a.$$childHead=this.$$nextSibling);a&&a.$$childTail===this&&(a.$$childTail=this.$$prevSibling);this.$$prevSibling&&(this.$$prevSibling.$$nextSibling=this.$$nextSibling);this.$$nextSibling&&(this.$$nextSibling.$$prevSibling=this.$$prevSibling);this.$destroy=this.$digest=this.$apply=this.$evalAsync=this.$applyAsync=D;this.$on=this.$watch=this.$watchGroup=function(){return D};this.$$listeners={};this.$$nextSibling=null;l(this)}},$eval:function(a,b){return g(a)(this,b)},$evalAsync:function(a,b){s.$$phase||
J.length||k.defer(function(){J.length&&s.$digest()});J.push({scope:this,fn:g(a),locals:b})},$$postDigest:function(a){u.push(a)},$apply:function(a){try{p("$apply");try{return this.$eval(a)}finally{s.$$phase=null}}catch(b){f(b)}finally{try{s.$digest()}catch(c){throw f(c),c;}}},$applyAsync:function(a){function b(){c.$eval(a)}var c=this;a&&w.push(b);a=g(a);A()},$on:function(a,b){var c=this.$$listeners[a];c||(this.$$listeners[a]=c=[]);c.push(b);var d=this;do d.$$listenerCount[a]||(d.$$listenerCount[a]=
0),d.$$listenerCount[a]++;while(d=d.$parent);var e=this;return function(){var d=c.indexOf(b);-1!==d&&(delete c[d],B(e,1,a))}},$emit:function(a,b){var c=[],d,e=this,g=!1,h={name:a,targetScope:e,stopPropagation:function(){g=!0},preventDefault:function(){h.defaultPrevented=!0},defaultPrevented:!1},k=db([h],arguments,1),l,m;do{d=e.$$listeners[a]||c;h.currentScope=e;l=0;for(m=d.length;l<m;l++)if(d[l])try{d[l].apply(null,k)}catch(n){f(n)}else d.splice(l,1),l--,m--;if(g)break;e=e.$parent}while(e);h.currentScope=
null;return h},$broadcast:function(a,b){var c=this,d=this,e={name:a,targetScope:this,preventDefault:function(){e.defaultPrevented=!0},defaultPrevented:!1};if(!this.$$listenerCount[a])return e;for(var g=db([e],arguments,1),h,k;c=d;){e.currentScope=c;d=c.$$listeners[a]||[];h=0;for(k=d.length;h<k;h++)if(d[h])try{d[h].apply(null,g)}catch(l){f(l)}else d.splice(h,1),h--,k--;if(!(d=c.$$listenerCount[a]&&c.$$childHead||c!==this&&c.$$nextSibling))for(;c!==this&&!(d=c.$$nextSibling);)c=c.$parent}e.currentScope=
null;return e}};var s=new m,J=s.$$asyncQueue=[],u=s.$$postDigestQueue=[],w=s.$$applyAsyncQueue=[],H=0;return s}]}function Ie(){var a=/^\s*(https?|s?ftp|mailto|tel|file):/,b=/^\s*((https?|ftp|file|blob):|data:image\/)/;this.aHrefSanitizationWhitelist=function(b){return u(b)?(a=b,this):a};this.imgSrcSanitizationWhitelist=function(a){return u(a)?(b=a,this):b};this.$get=function(){return function(d,c){var e=c?b:a,f;f=ma(d&&d.trim()).href;return""===f||f.match(e)?d:"unsafe:"+f}}}function Ig(a){if("self"===
a)return a;if(F(a)){if(-1<a.indexOf("***"))throw wa("iwcard",a);a=Nd(a).replace(/\\\*\\\*/g,".*").replace(/\\\*/g,"[^:/.?&;]*");return new RegExp("^"+a+"$")}if($a(a))return new RegExp("^"+a.source+"$");throw wa("imatcher");}function Od(a){var b=[];u(a)&&q(a,function(a){b.push(Ig(a))});return b}function Uf(){this.SCE_CONTEXTS=fa;var a=["self"],b=[];this.resourceUrlWhitelist=function(b){arguments.length&&(a=Od(b));return a};this.resourceUrlBlacklist=function(a){arguments.length&&(b=Od(a));return b};
this.$get=["$injector",function(d){function c(a,b){return"self"===a?Pd(b,Qd):!!a.exec(b.href)}function e(a){var b=function(a){this.$$unwrapTrustedValue=function(){return a}};a&&(b.prototype=new a);b.prototype.valueOf=function(){return this.$$unwrapTrustedValue()};b.prototype.toString=function(){return this.$$unwrapTrustedValue().toString()};return b}var f=function(a){throw wa("unsafe");};d.has("$sanitize")&&(f=d.get("$sanitize"));var g=e(),k={};k[fa.HTML]=e(g);k[fa.CSS]=e(g);k[fa.URL]=e(g);k[fa.JS]=
e(g);k[fa.RESOURCE_URL]=e(k[fa.URL]);return{trustAs:function(a,b){var c=k.hasOwnProperty(a)?k[a]:null;if(!c)throw wa("icontext",a,b);if(null===b||x(b)||""===b)return b;if("string"!==typeof b)throw wa("itype",a);return new c(b)},getTrusted:function(d,e){if(null===e||x(e)||""===e)return e;var g=k.hasOwnProperty(d)?k[d]:null;if(g&&e instanceof g)return e.$$unwrapTrustedValue();if(d===fa.RESOURCE_URL){var g=ma(e.toString()),p,n,q=!1;p=0;for(n=a.length;p<n;p++)if(c(a[p],g)){q=!0;break}if(q)for(p=0,n=b.length;p<
n;p++)if(c(b[p],g)){q=!1;break}if(q)return e;throw wa("insecurl",e.toString());}if(d===fa.HTML)return f(e);throw wa("unsafe");},valueOf:function(a){return a instanceof g?a.$$unwrapTrustedValue():a}}}]}function Tf(){var a=!0;this.enabled=function(b){arguments.length&&(a=!!b);return a};this.$get=["$parse","$sceDelegate",function(b,d){if(a&&8>Ba)throw wa("iequirks");var c=pa(fa);c.isEnabled=function(){return a};c.trustAs=d.trustAs;c.getTrusted=d.getTrusted;c.valueOf=d.valueOf;a||(c.trustAs=c.getTrusted=
function(a,b){return b},c.valueOf=ab);c.parseAs=function(a,d){var e=b(d);return e.literal&&e.constant?e:b(d,function(b){return c.getTrusted(a,b)})};var e=c.parseAs,f=c.getTrusted,g=c.trustAs;q(fa,function(a,b){var d=N(b);c[("parse_as_"+d).replace(Dc,wb)]=function(b){return e(a,b)};c[("get_trusted_"+d).replace(Dc,wb)]=function(b){return f(a,b)};c[("trust_as_"+d).replace(Dc,wb)]=function(b){return g(a,b)}});return c}]}function Vf(){this.$get=["$window","$document",function(a,b){var d={},c=!((!a.nw||
!a.nw.process)&&a.chrome&&(a.chrome.app&&a.chrome.app.runtime||!a.chrome.app&&a.chrome.runtime&&a.chrome.runtime.id))&&a.history&&a.history.pushState,e=Z((/android (\d+)/.exec(N((a.navigator||{}).userAgent))||[])[1]),f=/Boxee/i.test((a.navigator||{}).userAgent),g=b[0]||{},k=g.body&&g.body.style,h=!1,l=!1;k&&(h=!!("transition"in k||"webkitTransition"in k),l=!!("animation"in k||"webkitAnimation"in k));return{history:!(!c||4>e||f),hasEvent:function(a){if("input"===a&&Ba)return!1;if(x(d[a])){var b=g.createElement("div");
d[a]="on"+a in b}return d[a]},csp:Ia(),transitions:h,animations:l,android:e}}]}function Xf(){var a;this.httpOptions=function(b){return b?(a=b,this):a};this.$get=["$exceptionHandler","$templateCache","$http","$q","$sce",function(b,d,c,e,f){function g(k,h){g.totalPendingRequests++;if(!F(k)||x(d.get(k)))k=f.getTrustedResourceUrl(k);var l=c.defaults&&c.defaults.transformResponse;I(l)?l=l.filter(function(a){return a!==wc}):l===wc&&(l=null);return c.get(k,P({cache:d,transformResponse:l},a)).finally(function(){g.totalPendingRequests--}).then(function(a){d.put(k,
a.data);return a.data},function(a){h||(a=Jg("tpload",k,a.status,a.statusText),b(a));return e.reject(a)})}g.totalPendingRequests=0;return g}]}function Yf(){this.$get=["$rootScope","$browser","$location",function(a,b,d){return{findBindings:function(a,b,d){a=a.getElementsByClassName("ng-binding");var g=[];q(a,function(a){var c=ea.element(a).data("$binding");c&&q(c,function(c){d?(new RegExp("(^|\\s)"+Nd(b)+"(\\s|\\||$)")).test(c)&&g.push(a):-1!==c.indexOf(b)&&g.push(a)})});return g},findModels:function(a,
b,d){for(var g=["ng-","data-ng-","ng\\:"],k=0;k<g.length;++k){var h=a.querySelectorAll("["+g[k]+"model"+(d?"=":"*=")+'"'+b+'"]');if(h.length)return h}},getLocation:function(){return d.url()},setLocation:function(b){b!==d.url()&&(d.url(b),a.$digest())},whenStable:function(a){b.notifyWhenNoOutstandingRequests(a)}}}]}function Zf(){this.$get=["$rootScope","$browser","$q","$$q","$exceptionHandler",function(a,b,d,c,e){function f(f,h,l){C(f)||(l=h,h=f,f=D);var m=xa.call(arguments,3),p=u(l)&&!l,n=(p?c:d).defer(),
q=n.promise,v;v=b.defer(function(){try{n.resolve(f.apply(null,m))}catch(b){n.reject(b),e(b)}finally{delete g[q.$$timeoutId]}p||a.$apply()},h);q.$$timeoutId=v;g[v]=n;return q}var g={};f.cancel=function(a){return a&&a.$$timeoutId in g?(g[a.$$timeoutId].promise.$$state.pur=!0,g[a.$$timeoutId].reject("canceled"),delete g[a.$$timeoutId],b.defer.cancel(a.$$timeoutId)):!1};return f}]}function ma(a){if(!F(a))return a;Ba&&(W.setAttribute("href",a),a=W.href);W.setAttribute("href",a);return{href:W.href,protocol:W.protocol?
W.protocol.replace(/:$/,""):"",host:W.host,search:W.search?W.search.replace(/^\?/,""):"",hash:W.hash?W.hash.replace(/^#/,""):"",hostname:W.hostname,port:W.port,pathname:"/"===W.pathname.charAt(0)?W.pathname:"/"+W.pathname}}function Ag(a){var b=[Qd].concat(a.map(ma));return function(a){a=ma(a);return b.some(Pd.bind(null,a))}}function Pd(a,b){a=ma(a);b=ma(b);return a.protocol===b.protocol&&a.host===b.host}function $f(){this.$get=ka(y)}function Rd(a){function b(a){try{return decodeURIComponent(a)}catch(b){return a}}
var d=a[0]||{},c={},e="";return function(){var a,g,k,h,l;try{a=d.cookie||""}catch(m){a=""}if(a!==e)for(e=a,a=e.split("; "),c={},k=0;k<a.length;k++)g=a[k],h=g.indexOf("="),0<h&&(l=b(g.substring(0,h)),x(c[l])&&(c[l]=b(g.substring(h+1))));return c}}function dg(){this.$get=Rd}function gd(a){function b(d,c){if(G(d)){var e={};q(d,function(a,c){e[c]=b(c,a)});return e}return a.factory(d+"Filter",c)}this.register=b;this.$get=["$injector",function(a){return function(b){return a.get(b+"Filter")}}];b("currency",
Sd);b("date",Td);b("filter",Kg);b("json",Lg);b("limitTo",Mg);b("lowercase",Ng);b("number",Ud);b("orderBy",Vd);b("uppercase",Og)}function Kg(){return function(a,b,d,c){if(!ja(a)){if(null==a)return a;throw M("filter")("notarray",a);}c=c||"$";var e;switch(Ec(b)){case "function":break;case "boolean":case "null":case "number":case "string":e=!0;case "object":b=Pg(b,d,c,e);break;default:return a}return Array.prototype.filter.call(a,b)}}function Pg(a,b,d,c){var e=G(a)&&d in a;!0===b?b=sa:C(b)||(b=function(a,
b){if(x(a))return!1;if(null===a||null===b)return a===b;if(G(b)||G(a)&&!ac(a))return!1;a=N(""+a);b=N(""+b);return-1!==a.indexOf(b)});return function(f){return e&&!G(f)?ga(f,a[d],b,d,!1):ga(f,a,b,d,c)}}function ga(a,b,d,c,e,f){var g=Ec(a),k=Ec(b);if("string"===k&&"!"===b.charAt(0))return!ga(a,b.substring(1),d,c,e);if(I(a))return a.some(function(a){return ga(a,b,d,c,e)});switch(g){case "object":var h;if(e){for(h in a)if(h.charAt&&"$"!==h.charAt(0)&&ga(a[h],b,d,c,!0))return!0;return f?!1:ga(a,b,d,c,!1)}if("object"===
k){for(h in b)if(f=b[h],!C(f)&&!x(f)&&(g=h===c,!ga(g?a:a[h],f,d,c,g,g)))return!1;return!0}return d(a,b);case "function":return!1;default:return d(a,b)}}function Ec(a){return null===a?"null":typeof a}function Sd(a){var b=a.NUMBER_FORMATS;return function(a,c,e){x(c)&&(c=b.CURRENCY_SYM);x(e)&&(e=b.PATTERNS[1].maxFrac);var f=c?/\u00A4/g:/\s*\u00A4\s*/g;return null==a?a:Wd(a,b.PATTERNS[1],b.GROUP_SEP,b.DECIMAL_SEP,e).replace(f,c)}}function Ud(a){var b=a.NUMBER_FORMATS;return function(a,c){return null==
a?a:Wd(a,b.PATTERNS[0],b.GROUP_SEP,b.DECIMAL_SEP,c)}}function Qg(a){var b=0,d,c,e,f,g;-1<(c=a.indexOf(Xd))&&(a=a.replace(Xd,""));0<(e=a.search(/e/i))?(0>c&&(c=e),c+=+a.slice(e+1),a=a.substring(0,e)):0>c&&(c=a.length);for(e=0;a.charAt(e)===Fc;e++);if(e===(g=a.length))d=[0],c=1;else{for(g--;a.charAt(g)===Fc;)g--;c-=e;d=[];for(f=0;e<=g;e++,f++)d[f]=+a.charAt(e)}c>Yd&&(d=d.splice(0,Yd-1),b=c-1,c=1);return{d:d,e:b,i:c}}function Rg(a,b,d,c){var e=a.d,f=e.length-a.i;b=x(b)?Math.min(Math.max(d,f),c):+b;d=
b+a.i;c=e[d];if(0<d){e.splice(Math.max(a.i,d));for(var g=d;g<e.length;g++)e[g]=0}else for(f=Math.max(0,f),a.i=1,e.length=Math.max(1,d=b+1),e[0]=0,g=1;g<d;g++)e[g]=0;if(5<=c)if(0>d-1){for(c=0;c>d;c--)e.unshift(0),a.i++;e.unshift(1);a.i++}else e[d-1]++;for(;f<Math.max(0,b);f++)e.push(0);if(b=e.reduceRight(function(a,b,c,d){b+=a;d[c]=b%10;return Math.floor(b/10)},0))e.unshift(b),a.i++}function Wd(a,b,d,c,e){if(!F(a)&&!Y(a)||isNaN(a))return"";var f=!isFinite(a),g=!1,k=Math.abs(a)+"",h="";if(f)h="\u221e";
else{g=Qg(k);Rg(g,e,b.minFrac,b.maxFrac);h=g.d;k=g.i;e=g.e;f=[];for(g=h.reduce(function(a,b){return a&&!b},!0);0>k;)h.unshift(0),k++;0<k?f=h.splice(k,h.length):(f=h,h=[0]);k=[];for(h.length>=b.lgSize&&k.unshift(h.splice(-b.lgSize,h.length).join(""));h.length>b.gSize;)k.unshift(h.splice(-b.gSize,h.length).join(""));h.length&&k.unshift(h.join(""));h=k.join(d);f.length&&(h+=c+f.join(""));e&&(h+="e+"+e)}return 0>a&&!g?b.negPre+h+b.negSuf:b.posPre+h+b.posSuf}function Ob(a,b,d,c){var e="";if(0>a||c&&0>=
a)c?a=-a+1:(a=-a,e="-");for(a=""+a;a.length<b;)a=Fc+a;d&&(a=a.substr(a.length-b));return e+a}function ca(a,b,d,c,e){d=d||0;return function(f){f=f["get"+a]();if(0<d||f>-d)f+=d;0===f&&-12===d&&(f=12);return Ob(f,b,c,e)}}function mb(a,b,d){return function(c,e){var f=c["get"+a](),g=ub((d?"STANDALONE":"")+(b?"SHORT":"")+a);return e[g][f]}}function Zd(a){var b=(new Date(a,0,1)).getDay();return new Date(a,0,(4>=b?5:12)-b)}function $d(a){return function(b){var d=Zd(b.getFullYear());b=+new Date(b.getFullYear(),
b.getMonth(),b.getDate()+(4-b.getDay()))-+d;b=1+Math.round(b/6048E5);return Ob(b,a)}}function Gc(a,b){return 0>=a.getFullYear()?b.ERAS[0]:b.ERAS[1]}function Td(a){function b(a){var b;if(b=a.match(d)){a=new Date(0);var f=0,g=0,k=b[8]?a.setUTCFullYear:a.setFullYear,h=b[8]?a.setUTCHours:a.setHours;b[9]&&(f=Z(b[9]+b[10]),g=Z(b[9]+b[11]));k.call(a,Z(b[1]),Z(b[2])-1,Z(b[3]));f=Z(b[4]||0)-f;g=Z(b[5]||0)-g;k=Z(b[6]||0);b=Math.round(1E3*parseFloat("0."+(b[7]||0)));h.call(a,f,g,k,b)}return a}var d=/^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
return function(c,d,f){var g="",k=[],h,l;d=d||"mediumDate";d=a.DATETIME_FORMATS[d]||d;F(c)&&(c=Sg.test(c)?Z(c):b(c));Y(c)&&(c=new Date(c));if(!da(c)||!isFinite(c.getTime()))return c;for(;d;)(l=Tg.exec(d))?(k=db(k,l,1),d=k.pop()):(k.push(d),d=null);var m=c.getTimezoneOffset();f&&(m=dc(f,m),c=ec(c,f,!0));q(k,function(b){h=Ug[b];g+=h?h(c,a.DATETIME_FORMATS,m):"''"===b?"'":b.replace(/(^'|'$)/g,"").replace(/''/g,"'")});return g}}function Lg(){return function(a,b){x(b)&&(b=2);return eb(a,b)}}function Mg(){return function(a,
b,d){b=Infinity===Math.abs(Number(b))?Number(b):Z(b);if(X(b))return a;Y(a)&&(a=a.toString());if(!ja(a))return a;d=!d||isNaN(d)?0:Z(d);d=0>d?Math.max(0,a.length+d):d;return 0<=b?Hc(a,d,d+b):0===d?Hc(a,b,a.length):Hc(a,Math.max(0,d+b),d)}}function Hc(a,b,d){return F(a)?a.slice(b,d):xa.call(a,b,d)}function Vd(a){function b(b){return b.map(function(b){var c=1,d=ab;if(C(b))d=b;else if(F(b)){if("+"===b.charAt(0)||"-"===b.charAt(0))c="-"===b.charAt(0)?-1:1,b=b.substring(1);if(""!==b&&(d=a(b),d.constant))var e=
d(),d=function(a){return a[e]}}return{get:d,descending:c}})}function d(a){switch(typeof a){case "number":case "boolean":case "string":return!0;default:return!1}}function c(a,b){var c=0,d=a.type,h=b.type;if(d===h){var h=a.value,l=b.value;"string"===d?(h=h.toLowerCase(),l=l.toLowerCase()):"object"===d&&(G(h)&&(h=a.index),G(l)&&(l=b.index));h!==l&&(c=h<l?-1:1)}else c=d<h?-1:1;return c}return function(a,f,g,k){if(null==a)return a;if(!ja(a))throw M("orderBy")("notarray",a);I(f)||(f=[f]);0===f.length&&
(f=["+"]);var h=b(f),l=g?-1:1,m=C(k)?k:c;a=Array.prototype.map.call(a,function(a,b){return{value:a,tieBreaker:{value:b,type:"number",index:b},predicateValues:h.map(function(c){var e=c.get(a);c=typeof e;if(null===e)c="string",e="null";else if("object"===c)a:{if(C(e.valueOf)&&(e=e.valueOf(),d(e)))break a;ac(e)&&(e=e.toString(),d(e))}return{value:e,type:c,index:b}})}});a.sort(function(a,b){for(var d=0,e=h.length;d<e;d++){var g=m(a.predicateValues[d],b.predicateValues[d]);if(g)return g*h[d].descending*
l}return(m(a.tieBreaker,b.tieBreaker)||c(a.tieBreaker,b.tieBreaker))*l});return a=a.map(function(a){return a.value})}}function Ra(a){C(a)&&(a={link:a});a.restrict=a.restrict||"AC";return ka(a)}function Pb(a,b,d,c,e){this.$$controls=[];this.$error={};this.$$success={};this.$pending=void 0;this.$name=e(b.name||b.ngForm||"")(d);this.$dirty=!1;this.$valid=this.$pristine=!0;this.$submitted=this.$invalid=!1;this.$$parentForm=Qb;this.$$element=a;this.$$animate=c;ae(this)}function ae(a){a.$$classCache={};
a.$$classCache[be]=!(a.$$classCache[nb]=a.$$element.hasClass(nb))}function ce(a){function b(a,b,c){c&&!a.$$classCache[b]?(a.$$animate.addClass(a.$$element,b),a.$$classCache[b]=!0):!c&&a.$$classCache[b]&&(a.$$animate.removeClass(a.$$element,b),a.$$classCache[b]=!1)}function d(a,c,d){c=c?"-"+Xc(c,"-"):"";b(a,nb+c,!0===d);b(a,be+c,!1===d)}var c=a.set,e=a.unset;a.clazz.prototype.$setValidity=function(a,g,k){x(g)?(this.$pending||(this.$pending={}),c(this.$pending,a,k)):(this.$pending&&e(this.$pending,
a,k),de(this.$pending)&&(this.$pending=void 0));La(g)?g?(e(this.$error,a,k),c(this.$$success,a,k)):(c(this.$error,a,k),e(this.$$success,a,k)):(e(this.$error,a,k),e(this.$$success,a,k));this.$pending?(b(this,"ng-pending",!0),this.$valid=this.$invalid=void 0,d(this,"",null)):(b(this,"ng-pending",!1),this.$valid=de(this.$error),this.$invalid=!this.$valid,d(this,"",this.$valid));g=this.$pending&&this.$pending[a]?void 0:this.$error[a]?!1:this.$$success[a]?!0:null;d(this,a,g);this.$$parentForm.$setValidity(a,
g,this)}}function de(a){if(a)for(var b in a)if(a.hasOwnProperty(b))return!1;return!0}function Ic(a){a.$formatters.push(function(b){return a.$isEmpty(b)?b:b.toString()})}function Va(a,b,d,c,e,f){var g=N(b[0].type);if(!e.android){var k=!1;b.on("compositionstart",function(){k=!0});b.on("compositionupdate",function(a){if(x(a.data)||""===a.data)k=!1});b.on("compositionend",function(){k=!1;l()})}var h,l=function(a){h&&(f.defer.cancel(h),h=null);if(!k){var e=b.val();a=a&&a.type;"password"===g||d.ngTrim&&
"false"===d.ngTrim||(e=Q(e));(c.$viewValue!==e||""===e&&c.$$hasNativeValidators)&&c.$setViewValue(e,a)}};if(e.hasEvent("input"))b.on("input",l);else{var m=function(a,b,c){h||(h=f.defer(function(){h=null;b&&b.value===c||l(a)}))};b.on("keydown",function(a){var b=a.keyCode;91===b||15<b&&19>b||37<=b&&40>=b||m(a,this,this.value)});if(e.hasEvent("paste"))b.on("paste cut drop",m)}b.on("change",l);if(ee[g]&&c.$$hasNativeValidators&&g===d.type)b.on("keydown wheel mousedown",function(a){if(!h){var b=this.validity,
c=b.badInput,d=b.typeMismatch;h=f.defer(function(){h=null;b.badInput===c&&b.typeMismatch===d||l(a)})}});c.$render=function(){var a=c.$isEmpty(c.$viewValue)?"":c.$viewValue;b.val()!==a&&b.val(a)}}function Rb(a,b){return function(d,c){var e,f;if(da(d))return d;if(F(d)){'"'===d.charAt(0)&&'"'===d.charAt(d.length-1)&&(d=d.substring(1,d.length-1));if(Vg.test(d))return new Date(d);a.lastIndex=0;if(e=a.exec(d))return e.shift(),f=c?{yyyy:c.getFullYear(),MM:c.getMonth()+1,dd:c.getDate(),HH:c.getHours(),mm:c.getMinutes(),
ss:c.getSeconds(),sss:c.getMilliseconds()/1E3}:{yyyy:1970,MM:1,dd:1,HH:0,mm:0,ss:0,sss:0},q(e,function(a,c){c<b.length&&(f[b[c]]=+a)}),new Date(f.yyyy,f.MM-1,f.dd,f.HH,f.mm,f.ss||0,1E3*f.sss||0)}return NaN}}function ob(a,b,d,c){return function(e,f,g,k,h,l,m){function p(a){return a&&!(a.getTime&&a.getTime()!==a.getTime())}function n(a){return u(a)&&!da(a)?q(a)||void 0:a}function q(a,b){var c=k.$options.getOption("timezone");E&&E!==c&&(b=Uc(b,dc(E)));var e=d(a,b);!isNaN(e)&&c&&(e=ec(e,c));return e}
Jc(e,f,g,k);Va(e,f,g,k,h,l);var r,E;k.$$parserName=a;k.$parsers.push(function(a){if(k.$isEmpty(a))return null;if(b.test(a))return q(a,r)});k.$formatters.push(function(a){if(a&&!da(a))throw pb("datefmt",a);if(p(a)){r=a;var b=k.$options.getOption("timezone");b&&(E=b,r=ec(r,b,!0));return m("date")(a,c,b)}E=r=null;return""});if(u(g.min)||g.ngMin){var A;k.$validators.min=function(a){return!p(a)||x(A)||d(a)>=A};g.$observe("min",function(a){A=n(a);k.$validate()})}if(u(g.max)||g.ngMax){var s;k.$validators.max=
function(a){return!p(a)||x(s)||d(a)<=s};g.$observe("max",function(a){s=n(a);k.$validate()})}}}function Jc(a,b,d,c){(c.$$hasNativeValidators=G(b[0].validity))&&c.$parsers.push(function(a){var c=b.prop("validity")||{};return c.badInput||c.typeMismatch?void 0:a})}function fe(a){a.$$parserName="number";a.$parsers.push(function(b){if(a.$isEmpty(b))return null;if(Wg.test(b))return parseFloat(b)});a.$formatters.push(function(b){if(!a.$isEmpty(b)){if(!Y(b))throw pb("numfmt",b);b=b.toString()}return b})}function Wa(a){u(a)&&
!Y(a)&&(a=parseFloat(a));return X(a)?void 0:a}function Kc(a){var b=a.toString(),d=b.indexOf(".");return-1===d?-1<a&&1>a&&(a=/e-(\d+)$/.exec(b))?Number(a[1]):0:b.length-d-1}function ge(a,b,d){a=Number(a);var c=(a|0)!==a,e=(b|0)!==b,f=(d|0)!==d;if(c||e||f){var g=c?Kc(a):0,k=e?Kc(b):0,h=f?Kc(d):0,g=Math.max(g,k,h),g=Math.pow(10,g);a*=g;b*=g;d*=g;c&&(a=Math.round(a));e&&(b=Math.round(b));f&&(d=Math.round(d))}return 0===(a-b)%d}function he(a,b,d,c,e){if(u(c)){a=a(c);if(!a.constant)throw pb("constexpr",
d,c);return a(b)}return e}function Lc(a,b){function d(a,b){if(!a||!a.length)return[];if(!b||!b.length)return a;var c=[],d=0;a:for(;d<a.length;d++){for(var e=a[d],f=0;f<b.length;f++)if(e===b[f])continue a;c.push(e)}return c}function c(a){var b=a;I(a)?b=a.map(c).join(" "):G(a)&&(b=Object.keys(a).filter(function(b){return a[b]}).join(" "));return b}function e(a){var b=a;if(I(a))b=a.map(e);else if(G(a)){var c=!1,b=Object.keys(a).filter(function(b){b=a[b];!c&&x(b)&&(c=!0);return b});c&&b.push(void 0)}return b}
a="ngClass"+a;var f;return["$parse",function(g){return{restrict:"AC",link:function(k,h,l){function m(a,b){var c=[];q(a,function(a){if(0<b||s[a])s[a]=(s[a]||0)+b,s[a]===+(0<b)&&c.push(a)});return c.join(" ")}function p(a){if(a===b){var c=z,c=m(c&&c.split(" "),1);l.$addClass(c)}else c=z,c=m(c&&c.split(" "),-1),l.$removeClass(c);u=a}function n(a){a=c(a);a!==z&&r(a)}function r(a){if(u===b){var c=z&&z.split(" "),e=a&&a.split(" "),g=d(c,e),c=d(e,c),g=m(g,-1),c=m(c,1);l.$addClass(c);l.$removeClass(g)}z=
a}var v=l[a].trim(),E=":"===v.charAt(0)&&":"===v.charAt(1),v=g(v,E?e:c),A=E?n:r,s=h.data("$classCounts"),u=!0,z;s||(s=R(),h.data("$classCounts",s));"ngClass"!==a&&(f||(f=g("$index",function(a){return a&1})),k.$watch(f,p));k.$watch(v,A,E)}}}]}function Sb(a,b,d,c,e,f,g,k,h){this.$modelValue=this.$viewValue=Number.NaN;this.$$rawModelValue=void 0;this.$validators={};this.$asyncValidators={};this.$parsers=[];this.$formatters=[];this.$viewChangeListeners=[];this.$untouched=!0;this.$touched=!1;this.$pristine=
!0;this.$dirty=!1;this.$valid=!0;this.$invalid=!1;this.$error={};this.$$success={};this.$pending=void 0;this.$name=h(d.name||"",!1)(a);this.$$parentForm=Qb;this.$options=Tb;this.$$updateEvents="";this.$$updateEventHandler=this.$$updateEventHandler.bind(this);this.$$parsedNgModel=e(d.ngModel);this.$$parsedNgModelAssign=this.$$parsedNgModel.assign;this.$$ngModelGet=this.$$parsedNgModel;this.$$ngModelSet=this.$$parsedNgModelAssign;this.$$pendingDebounce=null;this.$$parserValid=void 0;this.$$currentValidationRunId=
0;Object.defineProperty(this,"$$scope",{value:a});this.$$attr=d;this.$$element=c;this.$$animate=f;this.$$timeout=g;this.$$parse=e;this.$$q=k;this.$$exceptionHandler=b;ae(this);Xg(this)}function Xg(a){a.$$scope.$watch(function(b){b=a.$$ngModelGet(b);b===a.$modelValue||a.$modelValue!==a.$modelValue&&b!==b||a.$$setModelValue(b);return b})}function Mc(a){this.$$options=a}function ie(a,b){q(b,function(b,c){u(a[c])||(a[c]=b)})}function Fa(a,b){a.prop("selected",b);a.attr("selected",b)}var Oc={objectMaxDepth:5},
Yg=/^\/(.+)\/([a-z]*)$/,ra=Object.prototype.hasOwnProperty,N=function(a){return F(a)?a.toLowerCase():a},ub=function(a){return F(a)?a.toUpperCase():a},Ba,z,ta,xa=[].slice,wg=[].splice,Zg=[].push,ha=Object.prototype.toString,Rc=Object.getPrototypeOf,oa=M("ng"),ea=y.angular||(y.angular={}),jc,qb=0;Ba=y.document.documentMode;var X=Number.isNaN||function(a){return a!==a};D.$inject=[];ab.$inject=[];var I=Array.isArray,ue=/^\[object (?:Uint8|Uint8Clamped|Uint16|Uint32|Int8|Int16|Int32|Float32|Float64)Array]$/,
Q=function(a){return F(a)?a.trim():a},Nd=function(a){return a.replace(/([-()[\]{}+?*.$^|,:#<!\\])/g,"\\$1").replace(/\x08/g,"\\x08")},Ia=function(){if(!u(Ia.rules)){var a=y.document.querySelector("[ng-csp]")||y.document.querySelector("[data-ng-csp]");if(a){var b=a.getAttribute("ng-csp")||a.getAttribute("data-ng-csp");Ia.rules={noUnsafeEval:!b||-1!==b.indexOf("no-unsafe-eval"),noInlineStyle:!b||-1!==b.indexOf("no-inline-style")}}else{a=Ia;try{new Function(""),b=!1}catch(d){b=!0}a.rules={noUnsafeEval:b,
noInlineStyle:!1}}}return Ia.rules},rb=function(){if(u(rb.name_))return rb.name_;var a,b,d=Ga.length,c,e;for(b=0;b<d;++b)if(c=Ga[b],a=y.document.querySelector("["+c.replace(":","\\:")+"jq]")){e=a.getAttribute(c+"jq");break}return rb.name_=e},we=/:/g,Ga=["ng-","data-ng-","ng:","x-ng-"],ze=function(a){var b=a.currentScript;if(!b)return!0;if(!(b instanceof y.HTMLScriptElement||b instanceof y.SVGScriptElement))return!1;b=b.attributes;return[b.getNamedItem("src"),b.getNamedItem("href"),b.getNamedItem("xlink:href")].every(function(b){if(!b)return!0;
if(!b.value)return!1;var c=a.createElement("a");c.href=b.value;if(a.location.origin===c.origin)return!0;switch(c.protocol){case "http:":case "https:":case "ftp:":case "blob:":case "file:":case "data:":return!0;default:return!1}})}(y.document),Ce=/[A-Z]/g,Yc=!1,Ma=3,He={full:"1.6.10",major:1,minor:6,dot:10,codeName:"crystalline-persuasion"};S.expando="ng339";var ib=S.cache={},ig=1;S._data=function(a){return this.cache[a[this.expando]]||{}};var eg=/-([a-z])/g,$g=/^-ms-/,Ab={mouseleave:"mouseout",mouseenter:"mouseover"},
mc=M("jqLite"),hg=/^<([\w-]+)\s*\/?>(?:<\/\1>|)$/,lc=/<|&#?\w+;/,fg=/<([\w:-]+)/,gg=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi,$={option:[1,'<select multiple="multiple">',"</select>"],thead:[1,"<table>","</table>"],col:[2,"<table><colgroup>","</colgroup></table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:[0,"",""]};$.optgroup=$.option;$.tbody=$.tfoot=$.colgroup=$.caption=$.thead;$.th=$.td;var ng=y.Node.prototype.contains||
function(a){return!!(this.compareDocumentPosition(a)&16)},Ua=S.prototype={ready:id,toString:function(){var a=[];q(this,function(b){a.push(""+b)});return"["+a.join(", ")+"]"},eq:function(a){return 0<=a?z(this[a]):z(this[this.length+a])},length:0,push:Zg,sort:[].sort,splice:[].splice},Gb={};q("multiple selected checked disabled readOnly required open".split(" "),function(a){Gb[N(a)]=a});var nd={};q("input select option textarea button form details".split(" "),function(a){nd[a]=!0});var ud={ngMinlength:"minlength",
ngMaxlength:"maxlength",ngMin:"min",ngMax:"max",ngPattern:"pattern",ngStep:"step"};q({data:qc,removeData:pc,hasData:function(a){for(var b in ib[a.ng339])return!0;return!1},cleanData:function(a){for(var b=0,d=a.length;b<d;b++)pc(a[b])}},function(a,b){S[b]=a});q({data:qc,inheritedData:Eb,scope:function(a){return z.data(a,"$scope")||Eb(a.parentNode||a,["$isolateScope","$scope"])},isolateScope:function(a){return z.data(a,"$isolateScope")||z.data(a,"$isolateScopeNoTemplate")},controller:kd,injector:function(a){return Eb(a,
"$injector")},removeAttr:function(a,b){a.removeAttribute(b)},hasClass:Bb,css:function(a,b,d){b=xb(b.replace($g,"ms-"));if(u(d))a.style[b]=d;else return a.style[b]},attr:function(a,b,d){var c=a.nodeType;if(c!==Ma&&2!==c&&8!==c&&a.getAttribute){var c=N(b),e=Gb[c];if(u(d))null===d||!1===d&&e?a.removeAttribute(b):a.setAttribute(b,e?c:d);else return a=a.getAttribute(b),e&&null!==a&&(a=c),null===a?void 0:a}},prop:function(a,b,d){if(u(d))a[b]=d;else return a[b]},text:function(){function a(a,d){if(x(d)){var c=
a.nodeType;return 1===c||c===Ma?a.textContent:""}a.textContent=d}a.$dv="";return a}(),val:function(a,b){if(x(b)){if(a.multiple&&"select"===ya(a)){var d=[];q(a.options,function(a){a.selected&&d.push(a.value||a.text)});return d}return a.value}a.value=b},html:function(a,b){if(x(b))return a.innerHTML;yb(a,!0);a.innerHTML=b},empty:ld},function(a,b){S.prototype[b]=function(b,c){var e,f,g=this.length;if(a!==ld&&x(2===a.length&&a!==Bb&&a!==kd?b:c)){if(G(b)){for(e=0;e<g;e++)if(a===qc)a(this[e],b);else for(f in b)a(this[e],
f,b[f]);return this}e=a.$dv;g=x(e)?Math.min(g,1):g;for(f=0;f<g;f++){var k=a(this[f],b,c);e=e?e+k:k}return e}for(e=0;e<g;e++)a(this[e],b,c);return this}});q({removeData:pc,on:function(a,b,d,c){if(u(c))throw mc("onargs");if(kc(a)){c=zb(a,!0);var e=c.events,f=c.handle;f||(f=c.handle=kg(a,e));c=0<=b.indexOf(" ")?b.split(" "):[b];for(var g=c.length,k=function(b,c,g){var k=e[b];k||(k=e[b]=[],k.specialHandlerWrapper=c,"$destroy"===b||g||a.addEventListener(b,f));k.push(d)};g--;)b=c[g],Ab[b]?(k(Ab[b],mg),
k(b,void 0,!0)):k(b)}},off:jd,one:function(a,b,d){a=z(a);a.on(b,function e(){a.off(b,d);a.off(b,e)});a.on(b,d)},replaceWith:function(a,b){var d,c=a.parentNode;yb(a);q(new S(b),function(b){d?c.insertBefore(b,d.nextSibling):c.replaceChild(b,a);d=b})},children:function(a){var b=[];q(a.childNodes,function(a){1===a.nodeType&&b.push(a)});return b},contents:function(a){return a.contentDocument||a.childNodes||[]},append:function(a,b){var d=a.nodeType;if(1===d||11===d){b=new S(b);for(var d=0,c=b.length;d<
c;d++)a.appendChild(b[d])}},prepend:function(a,b){if(1===a.nodeType){var d=a.firstChild;q(new S(b),function(b){a.insertBefore(b,d)})}},wrap:function(a,b){var d=z(b).eq(0).clone()[0],c=a.parentNode;c&&c.replaceChild(d,a);d.appendChild(a)},remove:Fb,detach:function(a){Fb(a,!0)},after:function(a,b){var d=a,c=a.parentNode;if(c){b=new S(b);for(var e=0,f=b.length;e<f;e++){var g=b[e];c.insertBefore(g,d.nextSibling);d=g}}},addClass:Db,removeClass:Cb,toggleClass:function(a,b,d){b&&q(b.split(" "),function(b){var e=
d;x(e)&&(e=!Bb(a,b));(e?Db:Cb)(a,b)})},parent:function(a){return(a=a.parentNode)&&11!==a.nodeType?a:null},next:function(a){return a.nextElementSibling},find:function(a,b){return a.getElementsByTagName?a.getElementsByTagName(b):[]},clone:oc,triggerHandler:function(a,b,d){var c,e,f=b.type||b,g=zb(a);if(g=(g=g&&g.events)&&g[f])c={preventDefault:function(){this.defaultPrevented=!0},isDefaultPrevented:function(){return!0===this.defaultPrevented},stopImmediatePropagation:function(){this.immediatePropagationStopped=
!0},isImmediatePropagationStopped:function(){return!0===this.immediatePropagationStopped},stopPropagation:D,type:f,target:a},b.type&&(c=P(c,b)),b=pa(g),e=d?[c].concat(d):[c],q(b,function(b){c.isImmediatePropagationStopped()||b.apply(a,e)})}},function(a,b){S.prototype[b]=function(b,c,e){for(var f,g=0,k=this.length;g<k;g++)x(f)?(f=a(this[g],b,c,e),u(f)&&(f=z(f))):nc(f,a(this[g],b,c,e));return u(f)?f:this}});S.prototype.bind=S.prototype.on;S.prototype.unbind=S.prototype.off;var ah=Object.create(null);
od.prototype={_idx:function(a){if(a===this._lastKey)return this._lastIndex;this._lastKey=a;return this._lastIndex=this._keys.indexOf(a)},_transformKey:function(a){return X(a)?ah:a},get:function(a){a=this._transformKey(a);a=this._idx(a);if(-1!==a)return this._values[a]},set:function(a,b){a=this._transformKey(a);var d=this._idx(a);-1===d&&(d=this._lastIndex=this._keys.length);this._keys[d]=a;this._values[d]=b},delete:function(a){a=this._transformKey(a);a=this._idx(a);if(-1===a)return!1;this._keys.splice(a,
1);this._values.splice(a,1);this._lastKey=NaN;this._lastIndex=-1;return!0}};var Hb=od,cg=[function(){this.$get=[function(){return Hb}]}],pg=/^([^(]+?)=>/,qg=/^[^(]*\(\s*([^)]*)\)/m,bh=/,/,ch=/^\s*(_?)(\S+?)\1\s*$/,og=/((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg,Aa=M("$injector");gb.$$annotate=function(a,b,d){var c;if("function"===typeof a){if(!(c=a.$inject)){c=[];if(a.length){if(b)throw F(d)&&d||(d=a.name||rg(a)),Aa("strictdi",d);b=pd(a);q(b[1].split(bh),function(a){a.replace(ch,function(a,b,d){c.push(d)})})}a.$inject=
c}}else I(a)?(b=a.length-1,sb(a[b],"fn"),c=a.slice(0,b)):sb(a,"fn",!0);return c};var je=M("$animate"),uf=function(){this.$get=D},vf=function(){var a=new Hb,b=[];this.$get=["$$AnimateRunner","$rootScope",function(d,c){function e(a,b,c){var d=!1;b&&(b=F(b)?b.split(" "):I(b)?b:[],q(b,function(b){b&&(d=!0,a[b]=c)}));return d}function f(){q(b,function(b){var c=a.get(b);if(c){var d=sg(b.attr("class")),e="",f="";q(c,function(a,b){a!==!!d[b]&&(a?e+=(e.length?" ":"")+b:f+=(f.length?" ":"")+b)});q(b,function(a){e&&
Db(a,e);f&&Cb(a,f)});a.delete(b)}});b.length=0}return{enabled:D,on:D,off:D,pin:D,push:function(g,k,h,l){l&&l();h=h||{};h.from&&g.css(h.from);h.to&&g.css(h.to);if(h.addClass||h.removeClass)if(k=h.addClass,l=h.removeClass,h=a.get(g)||{},k=e(h,k,!0),l=e(h,l,!1),k||l)a.set(g,h),b.push(g),1===b.length&&c.$$postDigest(f);g=new d;g.complete();return g}}}]},sf=["$provide",function(a){var b=this,d=null,c=null;this.$$registeredAnimations=Object.create(null);this.register=function(c,d){if(c&&"."!==c.charAt(0))throw je("notcsel",
c);var g=c+"-animation";b.$$registeredAnimations[c.substr(1)]=g;a.factory(g,d)};this.customFilter=function(a){1===arguments.length&&(c=C(a)?a:null);return c};this.classNameFilter=function(a){if(1===arguments.length&&(d=a instanceof RegExp?a:null)&&/[(\s|\/)]ng-animate[(\s|\/)]/.test(d.toString()))throw d=null,je("nongcls","ng-animate");return d};this.$get=["$$animateQueue",function(a){function b(a,c,d){if(d){var e;a:{for(e=0;e<d.length;e++){var f=d[e];if(1===f.nodeType){e=f;break a}}e=void 0}!e||
e.parentNode||e.previousElementSibling||(d=null)}d?d.after(a):c.prepend(a)}return{on:a.on,off:a.off,pin:a.pin,enabled:a.enabled,cancel:function(a){a.end&&a.end()},enter:function(c,d,h,l){d=d&&z(d);h=h&&z(h);d=d||h.parent();b(c,d,h);return a.push(c,"enter",Ja(l))},move:function(c,d,h,l){d=d&&z(d);h=h&&z(h);d=d||h.parent();b(c,d,h);return a.push(c,"move",Ja(l))},leave:function(b,c){return a.push(b,"leave",Ja(c),function(){b.remove()})},addClass:function(b,c,d){d=Ja(d);d.addClass=jb(d.addclass,c);return a.push(b,
"addClass",d)},removeClass:function(b,c,d){d=Ja(d);d.removeClass=jb(d.removeClass,c);return a.push(b,"removeClass",d)},setClass:function(b,c,d,f){f=Ja(f);f.addClass=jb(f.addClass,c);f.removeClass=jb(f.removeClass,d);return a.push(b,"setClass",f)},animate:function(b,c,d,f,m){m=Ja(m);m.from=m.from?P(m.from,c):c;m.to=m.to?P(m.to,d):d;m.tempClasses=jb(m.tempClasses,f||"ng-inline-animate");return a.push(b,"animate",m)}}}]}],xf=function(){this.$get=["$$rAF",function(a){function b(b){d.push(b);1<d.length||
a(function(){for(var a=0;a<d.length;a++)d[a]();d=[]})}var d=[];return function(){var a=!1;b(function(){a=!0});return function(d){a?d():b(d)}}}]},wf=function(){this.$get=["$q","$sniffer","$$animateAsyncRun","$$isDocumentHidden","$timeout",function(a,b,d,c,e){function f(a){this.setHost(a);var b=d();this._doneCallbacks=[];this._tick=function(a){c()?e(a,0,!1):b(a)};this._state=0}f.chain=function(a,b){function c(){if(d===a.length)b(!0);else a[d](function(a){!1===a?b(!1):(d++,c())})}var d=0;c()};f.all=
function(a,b){function c(f){e=e&&f;++d===a.length&&b(e)}var d=0,e=!0;q(a,function(a){a.done(c)})};f.prototype={setHost:function(a){this.host=a||{}},done:function(a){2===this._state?a():this._doneCallbacks.push(a)},progress:D,getPromise:function(){if(!this.promise){var b=this;this.promise=a(function(a,c){b.done(function(b){!1===b?c():a()})})}return this.promise},then:function(a,b){return this.getPromise().then(a,b)},"catch":function(a){return this.getPromise()["catch"](a)},"finally":function(a){return this.getPromise()["finally"](a)},
pause:function(){this.host.pause&&this.host.pause()},resume:function(){this.host.resume&&this.host.resume()},end:function(){this.host.end&&this.host.end();this._resolve(!0)},cancel:function(){this.host.cancel&&this.host.cancel();this._resolve(!1)},complete:function(a){var b=this;0===b._state&&(b._state=1,b._tick(function(){b._resolve(a)}))},_resolve:function(a){2!==this._state&&(q(this._doneCallbacks,function(b){b(a)}),this._doneCallbacks.length=0,this._state=2)}};return f}]},tf=function(){this.$get=
["$$rAF","$q","$$AnimateRunner",function(a,b,d){return function(b,e){function f(){a(function(){g.addClass&&(b.addClass(g.addClass),g.addClass=null);g.removeClass&&(b.removeClass(g.removeClass),g.removeClass=null);g.to&&(b.css(g.to),g.to=null);k||h.complete();k=!0});return h}var g=e||{};g.$$prepared||(g=na(g));g.cleanupStyles&&(g.from=g.to=null);g.from&&(b.css(g.from),g.from=null);var k,h=new d;return{start:f,end:f}}}]},aa=M("$compile"),uc=new function(){};$c.$inject=["$provide","$$sanitizeUriProvider"];
Jb.prototype.isFirstChange=function(){return this.previousValue===uc};var qd=/^((?:x|data)[:\-_])/i,vg=/[:\-_]+(.)/g,wd=M("$controller"),vd=/^(\S+)(\s+as\s+([\w$]+))?$/,Ef=function(){this.$get=["$document",function(a){return function(b){b?!b.nodeType&&b instanceof z&&(b=b[0]):b=a[0].body;return b.offsetWidth+1}}]},xd="application/json",xc={"Content-Type":xd+";charset=utf-8"},yg=/^\[|^\{(?!\{)/,zg={"[":/]$/,"{":/}$/},xg=/^\)]\}',?\n/,Kb=M("$http"),Ea=ea.$interpolateMinErr=M("$interpolate");Ea.throwNoconcat=
function(a){throw Ea("noconcat",a);};Ea.interr=function(a,b){return Ea("interr",a,b.toString())};var Mf=function(){this.$get=function(){function a(a){var b=function(a){b.data=a;b.called=!0};b.id=a;return b}var b=ea.callbacks,d={};return{createCallback:function(c){c="_"+(b.$$counter++).toString(36);var e="angular.callbacks."+c,f=a(c);d[e]=b[c]=f;return e},wasCalled:function(a){return d[a].called},getResponse:function(a){return d[a].data},removeCallback:function(a){delete b[d[a].id];delete d[a]}}}},
dh=/^([^?#]*)(\?([^#]*))?(#(.*))?$/,Cg={http:80,https:443,ftp:21},kb=M("$location"),Dg=/^\s*[\\/]{2,}/,eh={$$absUrl:"",$$html5:!1,$$replace:!1,absUrl:Lb("$$absUrl"),url:function(a){if(x(a))return this.$$url;var b=dh.exec(a);(b[1]||""===a)&&this.path(decodeURIComponent(b[1]));(b[2]||b[1]||""===a)&&this.search(b[3]||"");this.hash(b[5]||"");return this},protocol:Lb("$$protocol"),host:Lb("$$host"),port:Lb("$$port"),path:Ed("$$path",function(a){a=null!==a?a.toString():"";return"/"===a.charAt(0)?a:"/"+
a}),search:function(a,b){switch(arguments.length){case 0:return this.$$search;case 1:if(F(a)||Y(a))a=a.toString(),this.$$search=fc(a);else if(G(a))a=na(a,{}),q(a,function(b,c){null==b&&delete a[c]}),this.$$search=a;else throw kb("isrcharg");break;default:x(b)||null===b?delete this.$$search[a]:this.$$search[a]=b}this.$$compose();return this},hash:Ed("$$hash",function(a){return null!==a?a.toString():""}),replace:function(){this.$$replace=!0;return this}};q([Dd,Bc,Ac],function(a){a.prototype=Object.create(eh);
a.prototype.state=function(b){if(!arguments.length)return this.$$state;if(a!==Ac||!this.$$html5)throw kb("nostate");this.$$state=x(b)?null:b;this.$$urlUpdatedByLocation=!0;return this}});var Xa=M("$parse"),Hg={}.constructor.prototype.valueOf,Ub=R();q("+ - * / % === !== == != < > <= >= && || ! = |".split(" "),function(a){Ub[a]=!0});var fh={n:"\n",f:"\f",r:"\r",t:"\t",v:"\v","'":"'",'"':'"'},Nb=function(a){this.options=a};Nb.prototype={constructor:Nb,lex:function(a){this.text=a;this.index=0;for(this.tokens=
[];this.index<this.text.length;)if(a=this.text.charAt(this.index),'"'===a||"'"===a)this.readString(a);else if(this.isNumber(a)||"."===a&&this.isNumber(this.peek()))this.readNumber();else if(this.isIdentifierStart(this.peekMultichar()))this.readIdent();else if(this.is(a,"(){}[].,;:?"))this.tokens.push({index:this.index,text:a}),this.index++;else if(this.isWhitespace(a))this.index++;else{var b=a+this.peek(),d=b+this.peek(2),c=Ub[b],e=Ub[d];Ub[a]||c||e?(a=e?d:c?b:a,this.tokens.push({index:this.index,
text:a,operator:!0}),this.index+=a.length):this.throwError("Unexpected next character ",this.index,this.index+1)}return this.tokens},is:function(a,b){return-1!==b.indexOf(a)},peek:function(a){a=a||1;return this.index+a<this.text.length?this.text.charAt(this.index+a):!1},isNumber:function(a){return"0"<=a&&"9">=a&&"string"===typeof a},isWhitespace:function(a){return" "===a||"\r"===a||"\t"===a||"\n"===a||"\v"===a||"\u00a0"===a},isIdentifierStart:function(a){return this.options.isIdentifierStart?this.options.isIdentifierStart(a,
this.codePointAt(a)):this.isValidIdentifierStart(a)},isValidIdentifierStart:function(a){return"a"<=a&&"z">=a||"A"<=a&&"Z">=a||"_"===a||"$"===a},isIdentifierContinue:function(a){return this.options.isIdentifierContinue?this.options.isIdentifierContinue(a,this.codePointAt(a)):this.isValidIdentifierContinue(a)},isValidIdentifierContinue:function(a,b){return this.isValidIdentifierStart(a,b)||this.isNumber(a)},codePointAt:function(a){return 1===a.length?a.charCodeAt(0):(a.charCodeAt(0)<<10)+a.charCodeAt(1)-
56613888},peekMultichar:function(){var a=this.text.charAt(this.index),b=this.peek();if(!b)return a;var d=a.charCodeAt(0),c=b.charCodeAt(0);return 55296<=d&&56319>=d&&56320<=c&&57343>=c?a+b:a},isExpOperator:function(a){return"-"===a||"+"===a||this.isNumber(a)},throwError:function(a,b,d){d=d||this.index;b=u(b)?"s "+b+"-"+this.index+" ["+this.text.substring(b,d)+"]":" "+d;throw Xa("lexerr",a,b,this.text);},readNumber:function(){for(var a="",b=this.index;this.index<this.text.length;){var d=N(this.text.charAt(this.index));
if("."===d||this.isNumber(d))a+=d;else{var c=this.peek();if("e"===d&&this.isExpOperator(c))a+=d;else if(this.isExpOperator(d)&&c&&this.isNumber(c)&&"e"===a.charAt(a.length-1))a+=d;else if(!this.isExpOperator(d)||c&&this.isNumber(c)||"e"!==a.charAt(a.length-1))break;else this.throwError("Invalid exponent")}this.index++}this.tokens.push({index:b,text:a,constant:!0,value:Number(a)})},readIdent:function(){var a=this.index;for(this.index+=this.peekMultichar().length;this.index<this.text.length;){var b=
this.peekMultichar();if(!this.isIdentifierContinue(b))break;this.index+=b.length}this.tokens.push({index:a,text:this.text.slice(a,this.index),identifier:!0})},readString:function(a){var b=this.index;this.index++;for(var d="",c=a,e=!1;this.index<this.text.length;){var f=this.text.charAt(this.index),c=c+f;if(e)"u"===f?(e=this.text.substring(this.index+1,this.index+5),e.match(/[\da-f]{4}/i)||this.throwError("Invalid unicode escape [\\u"+e+"]"),this.index+=4,d+=String.fromCharCode(parseInt(e,16))):d+=
fh[f]||f,e=!1;else if("\\"===f)e=!0;else{if(f===a){this.index++;this.tokens.push({index:b,text:c,constant:!0,value:d});return}d+=f}this.index++}this.throwError("Unterminated quote",b)}};var r=function(a,b){this.lexer=a;this.options=b};r.Program="Program";r.ExpressionStatement="ExpressionStatement";r.AssignmentExpression="AssignmentExpression";r.ConditionalExpression="ConditionalExpression";r.LogicalExpression="LogicalExpression";r.BinaryExpression="BinaryExpression";r.UnaryExpression="UnaryExpression";
r.CallExpression="CallExpression";r.MemberExpression="MemberExpression";r.Identifier="Identifier";r.Literal="Literal";r.ArrayExpression="ArrayExpression";r.Property="Property";r.ObjectExpression="ObjectExpression";r.ThisExpression="ThisExpression";r.LocalsExpression="LocalsExpression";r.NGValueParameter="NGValueParameter";r.prototype={ast:function(a){this.text=a;this.tokens=this.lexer.lex(a);a=this.program();0!==this.tokens.length&&this.throwError("is an unexpected token",this.tokens[0]);return a},
program:function(){for(var a=[];;)if(0<this.tokens.length&&!this.peek("}",")",";","]")&&a.push(this.expressionStatement()),!this.expect(";"))return{type:r.Program,body:a}},expressionStatement:function(){return{type:r.ExpressionStatement,expression:this.filterChain()}},filterChain:function(){for(var a=this.expression();this.expect("|");)a=this.filter(a);return a},expression:function(){return this.assignment()},assignment:function(){var a=this.ternary();if(this.expect("=")){if(!Id(a))throw Xa("lval");
a={type:r.AssignmentExpression,left:a,right:this.assignment(),operator:"="}}return a},ternary:function(){var a=this.logicalOR(),b,d;return this.expect("?")&&(b=this.expression(),this.consume(":"))?(d=this.expression(),{type:r.ConditionalExpression,test:a,alternate:b,consequent:d}):a},logicalOR:function(){for(var a=this.logicalAND();this.expect("||");)a={type:r.LogicalExpression,operator:"||",left:a,right:this.logicalAND()};return a},logicalAND:function(){for(var a=this.equality();this.expect("&&");)a=
{type:r.LogicalExpression,operator:"&&",left:a,right:this.equality()};return a},equality:function(){for(var a=this.relational(),b;b=this.expect("==","!=","===","!==");)a={type:r.BinaryExpression,operator:b.text,left:a,right:this.relational()};return a},relational:function(){for(var a=this.additive(),b;b=this.expect("<",">","<=",">=");)a={type:r.BinaryExpression,operator:b.text,left:a,right:this.additive()};return a},additive:function(){for(var a=this.multiplicative(),b;b=this.expect("+","-");)a={type:r.BinaryExpression,
operator:b.text,left:a,right:this.multiplicative()};return a},multiplicative:function(){for(var a=this.unary(),b;b=this.expect("*","/","%");)a={type:r.BinaryExpression,operator:b.text,left:a,right:this.unary()};return a},unary:function(){var a;return(a=this.expect("+","-","!"))?{type:r.UnaryExpression,operator:a.text,prefix:!0,argument:this.unary()}:this.primary()},primary:function(){var a;this.expect("(")?(a=this.filterChain(),this.consume(")")):this.expect("[")?a=this.arrayDeclaration():this.expect("{")?
a=this.object():this.selfReferential.hasOwnProperty(this.peek().text)?a=na(this.selfReferential[this.consume().text]):this.options.literals.hasOwnProperty(this.peek().text)?a={type:r.Literal,value:this.options.literals[this.consume().text]}:this.peek().identifier?a=this.identifier():this.peek().constant?a=this.constant():this.throwError("not a primary expression",this.peek());for(var b;b=this.expect("(","[",".");)"("===b.text?(a={type:r.CallExpression,callee:a,arguments:this.parseArguments()},this.consume(")")):
"["===b.text?(a={type:r.MemberExpression,object:a,property:this.expression(),computed:!0},this.consume("]")):"."===b.text?a={type:r.MemberExpression,object:a,property:this.identifier(),computed:!1}:this.throwError("IMPOSSIBLE");return a},filter:function(a){a=[a];for(var b={type:r.CallExpression,callee:this.identifier(),arguments:a,filter:!0};this.expect(":");)a.push(this.expression());return b},parseArguments:function(){var a=[];if(")"!==this.peekToken().text){do a.push(this.filterChain());while(this.expect(","))
}return a},identifier:function(){var a=this.consume();a.identifier||this.throwError("is not a valid identifier",a);return{type:r.Identifier,name:a.text}},constant:function(){return{type:r.Literal,value:this.consume().value}},arrayDeclaration:function(){var a=[];if("]"!==this.peekToken().text){do{if(this.peek("]"))break;a.push(this.expression())}while(this.expect(","))}this.consume("]");return{type:r.ArrayExpression,elements:a}},object:function(){var a=[],b;if("}"!==this.peekToken().text){do{if(this.peek("}"))break;
b={type:r.Property,kind:"init"};this.peek().constant?(b.key=this.constant(),b.computed=!1,this.consume(":"),b.value=this.expression()):this.peek().identifier?(b.key=this.identifier(),b.computed=!1,this.peek(":")?(this.consume(":"),b.value=this.expression()):b.value=b.key):this.peek("[")?(this.consume("["),b.key=this.expression(),this.consume("]"),b.computed=!0,this.consume(":"),b.value=this.expression()):this.throwError("invalid key",this.peek());a.push(b)}while(this.expect(","))}this.consume("}");
return{type:r.ObjectExpression,properties:a}},throwError:function(a,b){throw Xa("syntax",b.text,a,b.index+1,this.text,this.text.substring(b.index));},consume:function(a){if(0===this.tokens.length)throw Xa("ueoe",this.text);var b=this.expect(a);b||this.throwError("is unexpected, expecting ["+a+"]",this.peek());return b},peekToken:function(){if(0===this.tokens.length)throw Xa("ueoe",this.text);return this.tokens[0]},peek:function(a,b,d,c){return this.peekAhead(0,a,b,d,c)},peekAhead:function(a,b,d,c,
e){if(this.tokens.length>a){a=this.tokens[a];var f=a.text;if(f===b||f===d||f===c||f===e||!(b||d||c||e))return a}return!1},expect:function(a,b,d,c){return(a=this.peek(a,b,d,c))?(this.tokens.shift(),a):!1},selfReferential:{"this":{type:r.ThisExpression},$locals:{type:r.LocalsExpression}}};var Gd=2;Kd.prototype={compile:function(a){var b=this;this.state={nextId:0,filters:{},fn:{vars:[],body:[],own:{}},assign:{vars:[],body:[],own:{}},inputs:[]};U(a,b.$filter);var d="",c;this.stage="assign";if(c=Jd(a))this.state.computing=
"assign",d=this.nextId(),this.recurse(c,d),this.return_(d),d="fn.assign="+this.generateFunction("assign","s,v,l");c=Hd(a.body);b.stage="inputs";q(c,function(a,c){var d="fn"+c;b.state[d]={vars:[],body:[],own:{}};b.state.computing=d;var k=b.nextId();b.recurse(a,k);b.return_(k);b.state.inputs.push({name:d,isPure:a.isPure});a.watchId=c});this.state.computing="fn";this.stage="main";this.recurse(a);a='"'+this.USE+" "+this.STRICT+'";\n'+this.filterPrefix()+"var fn="+this.generateFunction("fn","s,l,a,i")+
d+this.watchFns()+"return fn;";a=(new Function("$filter","getStringValue","ifDefined","plus",a))(this.$filter,Eg,Fg,Fd);this.state=this.stage=void 0;return a},USE:"use",STRICT:"strict",watchFns:function(){var a=[],b=this.state.inputs,d=this;q(b,function(b){a.push("var "+b.name+"="+d.generateFunction(b.name,"s"));b.isPure&&a.push(b.name,".isPure="+JSON.stringify(b.isPure)+";")});b.length&&a.push("fn.inputs=["+b.map(function(a){return a.name}).join(",")+"];");return a.join("")},generateFunction:function(a,
b){return"function("+b+"){"+this.varsPrefix(a)+this.body(a)+"};"},filterPrefix:function(){var a=[],b=this;q(this.state.filters,function(d,c){a.push(d+"=$filter("+b.escape(c)+")")});return a.length?"var "+a.join(",")+";":""},varsPrefix:function(a){return this.state[a].vars.length?"var "+this.state[a].vars.join(",")+";":""},body:function(a){return this.state[a].body.join("")},recurse:function(a,b,d,c,e,f){var g,k,h=this,l,m,p;c=c||D;if(!f&&u(a.watchId))b=b||this.nextId(),this.if_("i",this.lazyAssign(b,
this.computedMember("i",a.watchId)),this.lazyRecurse(a,b,d,c,e,!0));else switch(a.type){case r.Program:q(a.body,function(b,c){h.recurse(b.expression,void 0,void 0,function(a){k=a});c!==a.body.length-1?h.current().body.push(k,";"):h.return_(k)});break;case r.Literal:m=this.escape(a.value);this.assign(b,m);c(b||m);break;case r.UnaryExpression:this.recurse(a.argument,void 0,void 0,function(a){k=a});m=a.operator+"("+this.ifDefined(k,0)+")";this.assign(b,m);c(m);break;case r.BinaryExpression:this.recurse(a.left,
void 0,void 0,function(a){g=a});this.recurse(a.right,void 0,void 0,function(a){k=a});m="+"===a.operator?this.plus(g,k):"-"===a.operator?this.ifDefined(g,0)+a.operator+this.ifDefined(k,0):"("+g+")"+a.operator+"("+k+")";this.assign(b,m);c(m);break;case r.LogicalExpression:b=b||this.nextId();h.recurse(a.left,b);h.if_("&&"===a.operator?b:h.not(b),h.lazyRecurse(a.right,b));c(b);break;case r.ConditionalExpression:b=b||this.nextId();h.recurse(a.test,b);h.if_(b,h.lazyRecurse(a.alternate,b),h.lazyRecurse(a.consequent,
b));c(b);break;case r.Identifier:b=b||this.nextId();d&&(d.context="inputs"===h.stage?"s":this.assign(this.nextId(),this.getHasOwnProperty("l",a.name)+"?l:s"),d.computed=!1,d.name=a.name);h.if_("inputs"===h.stage||h.not(h.getHasOwnProperty("l",a.name)),function(){h.if_("inputs"===h.stage||"s",function(){e&&1!==e&&h.if_(h.isNull(h.nonComputedMember("s",a.name)),h.lazyAssign(h.nonComputedMember("s",a.name),"{}"));h.assign(b,h.nonComputedMember("s",a.name))})},b&&h.lazyAssign(b,h.nonComputedMember("l",
a.name)));c(b);break;case r.MemberExpression:g=d&&(d.context=this.nextId())||this.nextId();b=b||this.nextId();h.recurse(a.object,g,void 0,function(){h.if_(h.notNull(g),function(){a.computed?(k=h.nextId(),h.recurse(a.property,k),h.getStringValue(k),e&&1!==e&&h.if_(h.not(h.computedMember(g,k)),h.lazyAssign(h.computedMember(g,k),"{}")),m=h.computedMember(g,k),h.assign(b,m),d&&(d.computed=!0,d.name=k)):(e&&1!==e&&h.if_(h.isNull(h.nonComputedMember(g,a.property.name)),h.lazyAssign(h.nonComputedMember(g,
a.property.name),"{}")),m=h.nonComputedMember(g,a.property.name),h.assign(b,m),d&&(d.computed=!1,d.name=a.property.name))},function(){h.assign(b,"undefined")});c(b)},!!e);break;case r.CallExpression:b=b||this.nextId();a.filter?(k=h.filter(a.callee.name),l=[],q(a.arguments,function(a){var b=h.nextId();h.recurse(a,b);l.push(b)}),m=k+"("+l.join(",")+")",h.assign(b,m),c(b)):(k=h.nextId(),g={},l=[],h.recurse(a.callee,k,g,function(){h.if_(h.notNull(k),function(){q(a.arguments,function(b){h.recurse(b,a.constant?
void 0:h.nextId(),void 0,function(a){l.push(a)})});m=g.name?h.member(g.context,g.name,g.computed)+"("+l.join(",")+")":k+"("+l.join(",")+")";h.assign(b,m)},function(){h.assign(b,"undefined")});c(b)}));break;case r.AssignmentExpression:k=this.nextId();g={};this.recurse(a.left,void 0,g,function(){h.if_(h.notNull(g.context),function(){h.recurse(a.right,k);m=h.member(g.context,g.name,g.computed)+a.operator+k;h.assign(b,m);c(b||m)})},1);break;case r.ArrayExpression:l=[];q(a.elements,function(b){h.recurse(b,
a.constant?void 0:h.nextId(),void 0,function(a){l.push(a)})});m="["+l.join(",")+"]";this.assign(b,m);c(b||m);break;case r.ObjectExpression:l=[];p=!1;q(a.properties,function(a){a.computed&&(p=!0)});p?(b=b||this.nextId(),this.assign(b,"{}"),q(a.properties,function(a){a.computed?(g=h.nextId(),h.recurse(a.key,g)):g=a.key.type===r.Identifier?a.key.name:""+a.key.value;k=h.nextId();h.recurse(a.value,k);h.assign(h.member(b,g,a.computed),k)})):(q(a.properties,function(b){h.recurse(b.value,a.constant?void 0:
h.nextId(),void 0,function(a){l.push(h.escape(b.key.type===r.Identifier?b.key.name:""+b.key.value)+":"+a)})}),m="{"+l.join(",")+"}",this.assign(b,m));c(b||m);break;case r.ThisExpression:this.assign(b,"s");c(b||"s");break;case r.LocalsExpression:this.assign(b,"l");c(b||"l");break;case r.NGValueParameter:this.assign(b,"v"),c(b||"v")}},getHasOwnProperty:function(a,b){var d=a+"."+b,c=this.current().own;c.hasOwnProperty(d)||(c[d]=this.nextId(!1,a+"&&("+this.escape(b)+" in "+a+")"));return c[d]},assign:function(a,
b){if(a)return this.current().body.push(a,"=",b,";"),a},filter:function(a){this.state.filters.hasOwnProperty(a)||(this.state.filters[a]=this.nextId(!0));return this.state.filters[a]},ifDefined:function(a,b){return"ifDefined("+a+","+this.escape(b)+")"},plus:function(a,b){return"plus("+a+","+b+")"},return_:function(a){this.current().body.push("return ",a,";")},if_:function(a,b,d){if(!0===a)b();else{var c=this.current().body;c.push("if(",a,"){");b();c.push("}");d&&(c.push("else{"),d(),c.push("}"))}},
not:function(a){return"!("+a+")"},isNull:function(a){return a+"==null"},notNull:function(a){return a+"!=null"},nonComputedMember:function(a,b){var d=/[^$_a-zA-Z0-9]/g;return/^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(b)?a+"."+b:a+'["'+b.replace(d,this.stringEscapeFn)+'"]'},computedMember:function(a,b){return a+"["+b+"]"},member:function(a,b,d){return d?this.computedMember(a,b):this.nonComputedMember(a,b)},getStringValue:function(a){this.assign(a,"getStringValue("+a+")")},lazyRecurse:function(a,b,d,c,e,f){var g=
this;return function(){g.recurse(a,b,d,c,e,f)}},lazyAssign:function(a,b){var d=this;return function(){d.assign(a,b)}},stringEscapeRegex:/[^ a-zA-Z0-9]/g,stringEscapeFn:function(a){return"\\u"+("0000"+a.charCodeAt(0).toString(16)).slice(-4)},escape:function(a){if(F(a))return"'"+a.replace(this.stringEscapeRegex,this.stringEscapeFn)+"'";if(Y(a))return a.toString();if(!0===a)return"true";if(!1===a)return"false";if(null===a)return"null";if("undefined"===typeof a)return"undefined";throw Xa("esc");},nextId:function(a,
b){var d="v"+this.state.nextId++;a||this.current().vars.push(d+(b?"="+b:""));return d},current:function(){return this.state[this.state.computing]}};Ld.prototype={compile:function(a){var b=this;U(a,b.$filter);var d,c;if(d=Jd(a))c=this.recurse(d);d=Hd(a.body);var e;d&&(e=[],q(d,function(a,c){var d=b.recurse(a);d.isPure=a.isPure;a.input=d;e.push(d);a.watchId=c}));var f=[];q(a.body,function(a){f.push(b.recurse(a.expression))});a=0===a.body.length?D:1===a.body.length?f[0]:function(a,b){var c;q(f,function(d){c=
d(a,b)});return c};c&&(a.assign=function(a,b,d){return c(a,d,b)});e&&(a.inputs=e);return a},recurse:function(a,b,d){var c,e,f=this,g;if(a.input)return this.inputs(a.input,a.watchId);switch(a.type){case r.Literal:return this.value(a.value,b);case r.UnaryExpression:return e=this.recurse(a.argument),this["unary"+a.operator](e,b);case r.BinaryExpression:return c=this.recurse(a.left),e=this.recurse(a.right),this["binary"+a.operator](c,e,b);case r.LogicalExpression:return c=this.recurse(a.left),e=this.recurse(a.right),
this["binary"+a.operator](c,e,b);case r.ConditionalExpression:return this["ternary?:"](this.recurse(a.test),this.recurse(a.alternate),this.recurse(a.consequent),b);case r.Identifier:return f.identifier(a.name,b,d);case r.MemberExpression:return c=this.recurse(a.object,!1,!!d),a.computed||(e=a.property.name),a.computed&&(e=this.recurse(a.property)),a.computed?this.computedMember(c,e,b,d):this.nonComputedMember(c,e,b,d);case r.CallExpression:return g=[],q(a.arguments,function(a){g.push(f.recurse(a))}),
a.filter&&(e=this.$filter(a.callee.name)),a.filter||(e=this.recurse(a.callee,!0)),a.filter?function(a,c,d,f){for(var p=[],n=0;n<g.length;++n)p.push(g[n](a,c,d,f));a=e.apply(void 0,p,f);return b?{context:void 0,name:void 0,value:a}:a}:function(a,c,d,f){var p=e(a,c,d,f),n;if(null!=p.value){n=[];for(var q=0;q<g.length;++q)n.push(g[q](a,c,d,f));n=p.value.apply(p.context,n)}return b?{value:n}:n};case r.AssignmentExpression:return c=this.recurse(a.left,!0,1),e=this.recurse(a.right),function(a,d,f,g){var p=
c(a,d,f,g);a=e(a,d,f,g);p.context[p.name]=a;return b?{value:a}:a};case r.ArrayExpression:return g=[],q(a.elements,function(a){g.push(f.recurse(a))}),function(a,c,d,e){for(var f=[],n=0;n<g.length;++n)f.push(g[n](a,c,d,e));return b?{value:f}:f};case r.ObjectExpression:return g=[],q(a.properties,function(a){a.computed?g.push({key:f.recurse(a.key),computed:!0,value:f.recurse(a.value)}):g.push({key:a.key.type===r.Identifier?a.key.name:""+a.key.value,computed:!1,value:f.recurse(a.value)})}),function(a,
c,d,e){for(var f={},n=0;n<g.length;++n)g[n].computed?f[g[n].key(a,c,d,e)]=g[n].value(a,c,d,e):f[g[n].key]=g[n].value(a,c,d,e);return b?{value:f}:f};case r.ThisExpression:return function(a){return b?{value:a}:a};case r.LocalsExpression:return function(a,c){return b?{value:c}:c};case r.NGValueParameter:return function(a,c,d){return b?{value:d}:d}}},"unary+":function(a,b){return function(d,c,e,f){d=a(d,c,e,f);d=u(d)?+d:0;return b?{value:d}:d}},"unary-":function(a,b){return function(d,c,e,f){d=a(d,c,
e,f);d=u(d)?-d:-0;return b?{value:d}:d}},"unary!":function(a,b){return function(d,c,e,f){d=!a(d,c,e,f);return b?{value:d}:d}},"binary+":function(a,b,d){return function(c,e,f,g){var k=a(c,e,f,g);c=b(c,e,f,g);k=Fd(k,c);return d?{value:k}:k}},"binary-":function(a,b,d){return function(c,e,f,g){var k=a(c,e,f,g);c=b(c,e,f,g);k=(u(k)?k:0)-(u(c)?c:0);return d?{value:k}:k}},"binary*":function(a,b,d){return function(c,e,f,g){c=a(c,e,f,g)*b(c,e,f,g);return d?{value:c}:c}},"binary/":function(a,b,d){return function(c,
e,f,g){c=a(c,e,f,g)/b(c,e,f,g);return d?{value:c}:c}},"binary%":function(a,b,d){return function(c,e,f,g){c=a(c,e,f,g)%b(c,e,f,g);return d?{value:c}:c}},"binary===":function(a,b,d){return function(c,e,f,g){c=a(c,e,f,g)===b(c,e,f,g);return d?{value:c}:c}},"binary!==":function(a,b,d){return function(c,e,f,g){c=a(c,e,f,g)!==b(c,e,f,g);return d?{value:c}:c}},"binary==":function(a,b,d){return function(c,e,f,g){c=a(c,e,f,g)==b(c,e,f,g);return d?{value:c}:c}},"binary!=":function(a,b,d){return function(c,
e,f,g){c=a(c,e,f,g)!=b(c,e,f,g);return d?{value:c}:c}},"binary<":function(a,b,d){return function(c,e,f,g){c=a(c,e,f,g)<b(c,e,f,g);return d?{value:c}:c}},"binary>":function(a,b,d){return function(c,e,f,g){c=a(c,e,f,g)>b(c,e,f,g);return d?{value:c}:c}},"binary<=":function(a,b,d){return function(c,e,f,g){c=a(c,e,f,g)<=b(c,e,f,g);return d?{value:c}:c}},"binary>=":function(a,b,d){return function(c,e,f,g){c=a(c,e,f,g)>=b(c,e,f,g);return d?{value:c}:c}},"binary&&":function(a,b,d){return function(c,e,f,g){c=
a(c,e,f,g)&&b(c,e,f,g);return d?{value:c}:c}},"binary||":function(a,b,d){return function(c,e,f,g){c=a(c,e,f,g)||b(c,e,f,g);return d?{value:c}:c}},"ternary?:":function(a,b,d,c){return function(e,f,g,k){e=a(e,f,g,k)?b(e,f,g,k):d(e,f,g,k);return c?{value:e}:e}},value:function(a,b){return function(){return b?{context:void 0,name:void 0,value:a}:a}},identifier:function(a,b,d){return function(c,e,f,g){c=e&&a in e?e:c;d&&1!==d&&c&&null==c[a]&&(c[a]={});e=c?c[a]:void 0;return b?{context:c,name:a,value:e}:
e}},computedMember:function(a,b,d,c){return function(e,f,g,k){var h=a(e,f,g,k),l,m;null!=h&&(l=b(e,f,g,k),l+="",c&&1!==c&&h&&!h[l]&&(h[l]={}),m=h[l]);return d?{context:h,name:l,value:m}:m}},nonComputedMember:function(a,b,d,c){return function(e,f,g,k){e=a(e,f,g,k);c&&1!==c&&e&&null==e[b]&&(e[b]={});f=null!=e?e[b]:void 0;return d?{context:e,name:b,value:f}:f}},inputs:function(a,b){return function(d,c,e,f){return f?f[b]:a(d,c,e)}}};Mb.prototype={constructor:Mb,parse:function(a){a=this.getAst(a);var b=
this.astCompiler.compile(a.ast),d=a.ast;b.literal=0===d.body.length||1===d.body.length&&(d.body[0].expression.type===r.Literal||d.body[0].expression.type===r.ArrayExpression||d.body[0].expression.type===r.ObjectExpression);b.constant=a.ast.constant;b.oneTime=a.oneTime;return b},getAst:function(a){var b=!1;a=a.trim();":"===a.charAt(0)&&":"===a.charAt(1)&&(b=!0,a=a.substring(2));return{ast:this.ast.ast(a),oneTime:b}}};var wa=M("$sce"),fa={HTML:"html",CSS:"css",URL:"url",RESOURCE_URL:"resourceUrl",JS:"js"},
Dc=/_([a-z])/g,Jg=M("$compile"),W=y.document.createElement("a"),Qd=ma(y.location.href);Rd.$inject=["$document"];gd.$inject=["$provide"];var Yd=22,Xd=".",Fc="0";Sd.$inject=["$locale"];Ud.$inject=["$locale"];var Ug={yyyy:ca("FullYear",4,0,!1,!0),yy:ca("FullYear",2,0,!0,!0),y:ca("FullYear",1,0,!1,!0),MMMM:mb("Month"),MMM:mb("Month",!0),MM:ca("Month",2,1),M:ca("Month",1,1),LLLL:mb("Month",!1,!0),dd:ca("Date",2),d:ca("Date",1),HH:ca("Hours",2),H:ca("Hours",1),hh:ca("Hours",2,-12),h:ca("Hours",1,-12),mm:ca("Minutes",
2),m:ca("Minutes",1),ss:ca("Seconds",2),s:ca("Seconds",1),sss:ca("Milliseconds",3),EEEE:mb("Day"),EEE:mb("Day",!0),a:function(a,b){return 12>a.getHours()?b.AMPMS[0]:b.AMPMS[1]},Z:function(a,b,d){a=-1*d;return a=(0<=a?"+":"")+(Ob(Math[0<a?"floor":"ceil"](a/60),2)+Ob(Math.abs(a%60),2))},ww:$d(2),w:$d(1),G:Gc,GG:Gc,GGG:Gc,GGGG:function(a,b){return 0>=a.getFullYear()?b.ERANAMES[0]:b.ERANAMES[1]}},Tg=/((?:[^yMLdHhmsaZEwG']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|L+|d+|H+|h+|m+|s+|a|Z|G+|w+))([\s\S]*)/,Sg=/^-?\d+$/;
Td.$inject=["$locale"];var Ng=ka(N),Og=ka(ub);Vd.$inject=["$parse"];var Je=ka({restrict:"E",compile:function(a,b){if(!b.href&&!b.xlinkHref)return function(a,b){if("a"===b[0].nodeName.toLowerCase()){var e="[object SVGAnimatedString]"===ha.call(b.prop("href"))?"xlink:href":"href";b.on("click",function(a){b.attr(e)||a.preventDefault()})}}}}),vb={};q(Gb,function(a,b){function d(a,d,e){a.$watch(e[c],function(a){e.$set(b,!!a)})}if("multiple"!==a){var c=Da("ng-"+b),e=d;"checked"===a&&(e=function(a,b,e){e.ngModel!==
e[c]&&d(a,b,e)});vb[c]=function(){return{restrict:"A",priority:100,link:e}}}});q(ud,function(a,b){vb[b]=function(){return{priority:100,link:function(a,c,e){if("ngPattern"===b&&"/"===e.ngPattern.charAt(0)&&(c=e.ngPattern.match(Yg))){e.$set("ngPattern",new RegExp(c[1],c[2]));return}a.$watch(e[b],function(a){e.$set(b,a)})}}}});q(["src","srcset","href"],function(a){var b=Da("ng-"+a);vb[b]=function(){return{priority:99,link:function(d,c,e){var f=a,g=a;"href"===a&&"[object SVGAnimatedString]"===ha.call(c.prop("href"))&&
(g="xlinkHref",e.$attr[g]="xlink:href",f=null);e.$observe(b,function(b){b?(e.$set(g,b),Ba&&f&&c.prop(f,e[g])):"href"===a&&e.$set(g,null)})}}}});var Qb={$addControl:D,$$renameControl:function(a,b){a.$name=b},$removeControl:D,$setValidity:D,$setDirty:D,$setPristine:D,$setSubmitted:D};Pb.$inject=["$element","$attrs","$scope","$animate","$interpolate"];Pb.prototype={$rollbackViewValue:function(){q(this.$$controls,function(a){a.$rollbackViewValue()})},$commitViewValue:function(){q(this.$$controls,function(a){a.$commitViewValue()})},
$addControl:function(a){Ha(a.$name,"input");this.$$controls.push(a);a.$name&&(this[a.$name]=a);a.$$parentForm=this},$$renameControl:function(a,b){var d=a.$name;this[d]===a&&delete this[d];this[b]=a;a.$name=b},$removeControl:function(a){a.$name&&this[a.$name]===a&&delete this[a.$name];q(this.$pending,function(b,d){this.$setValidity(d,null,a)},this);q(this.$error,function(b,d){this.$setValidity(d,null,a)},this);q(this.$$success,function(b,d){this.$setValidity(d,null,a)},this);cb(this.$$controls,a);
a.$$parentForm=Qb},$setDirty:function(){this.$$animate.removeClass(this.$$element,Ya);this.$$animate.addClass(this.$$element,Vb);this.$dirty=!0;this.$pristine=!1;this.$$parentForm.$setDirty()},$setPristine:function(){this.$$animate.setClass(this.$$element,Ya,Vb+" ng-submitted");this.$dirty=!1;this.$pristine=!0;this.$submitted=!1;q(this.$$controls,function(a){a.$setPristine()})},$setUntouched:function(){q(this.$$controls,function(a){a.$setUntouched()})},$setSubmitted:function(){this.$$animate.addClass(this.$$element,
"ng-submitted");this.$submitted=!0;this.$$parentForm.$setSubmitted()}};ce({clazz:Pb,set:function(a,b,d){var c=a[b];c?-1===c.indexOf(d)&&c.push(d):a[b]=[d]},unset:function(a,b,d){var c=a[b];c&&(cb(c,d),0===c.length&&delete a[b])}});var ke=function(a){return["$timeout","$parse",function(b,d){function c(a){return""===a?d('this[""]').assign:d(a).assign||D}return{name:"form",restrict:a?"EAC":"E",require:["form","^^?form"],controller:Pb,compile:function(d,f){d.addClass(Ya).addClass(nb);var g=f.name?"name":
a&&f.ngForm?"ngForm":!1;return{pre:function(a,d,e,f){var p=f[0];if(!("action"in e)){var n=function(b){a.$apply(function(){p.$commitViewValue();p.$setSubmitted()});b.preventDefault()};d[0].addEventListener("submit",n);d.on("$destroy",function(){b(function(){d[0].removeEventListener("submit",n)},0,!1)})}(f[1]||p.$$parentForm).$addControl(p);var q=g?c(p.$name):D;g&&(q(a,p),e.$observe(g,function(b){p.$name!==b&&(q(a,void 0),p.$$parentForm.$$renameControl(p,b),q=c(p.$name),q(a,p))}));d.on("$destroy",function(){p.$$parentForm.$removeControl(p);
q(a,void 0);P(p,Qb)})}}}}}]},Ke=ke(),We=ke(!0),Vg=/^\d{4,}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+(?:[+-][0-2]\d:[0-5]\d|Z)$/,gh=/^[a-z][a-z\d.+-]*:\/*(?:[^:@]+(?::[^@]+)?@)?(?:[^\s:/?#]+|\[[a-f\d:]+])(?::\d+)?(?:\/[^?#]*)?(?:\?[^#]*)?(?:#.*)?$/i,hh=/^(?=.{1,254}$)(?=.{1,64}@)[-!#$%&'*+/0-9=?A-Z^_`a-z{|}~]+(\.[-!#$%&'*+/0-9=?A-Z^_`a-z{|}~]+)*@[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?(\.[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?)*$/,Wg=/^\s*(-|\+)?(\d+|(\d*(\.\d*)))([eE][+-]?\d+)?\s*$/,le=/^(\d{4,})-(\d{2})-(\d{2})$/,
me=/^(\d{4,})-(\d\d)-(\d\d)T(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/,Nc=/^(\d{4,})-W(\d\d)$/,ne=/^(\d{4,})-(\d\d)$/,oe=/^(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/,ee=R();q(["date","datetime-local","month","time","week"],function(a){ee[a]=!0});var pe={text:function(a,b,d,c,e,f){Va(a,b,d,c,e,f);Ic(c)},date:ob("date",le,Rb(le,["yyyy","MM","dd"]),"yyyy-MM-dd"),"datetime-local":ob("datetimelocal",me,Rb(me,"yyyy MM dd HH mm ss sss".split(" ")),"yyyy-MM-ddTHH:mm:ss.sss"),time:ob("time",oe,Rb(oe,["HH","mm",
"ss","sss"]),"HH:mm:ss.sss"),week:ob("week",Nc,function(a,b){if(da(a))return a;if(F(a)){Nc.lastIndex=0;var d=Nc.exec(a);if(d){var c=+d[1],e=+d[2],f=d=0,g=0,k=0,h=Zd(c),e=7*(e-1);b&&(d=b.getHours(),f=b.getMinutes(),g=b.getSeconds(),k=b.getMilliseconds());return new Date(c,0,h.getDate()+e,d,f,g,k)}}return NaN},"yyyy-Www"),month:ob("month",ne,Rb(ne,["yyyy","MM"]),"yyyy-MM"),number:function(a,b,d,c,e,f){Jc(a,b,d,c);fe(c);Va(a,b,d,c,e,f);var g,k;if(u(d.min)||d.ngMin)c.$validators.min=function(a){return c.$isEmpty(a)||
x(g)||a>=g},d.$observe("min",function(a){g=Wa(a);c.$validate()});if(u(d.max)||d.ngMax)c.$validators.max=function(a){return c.$isEmpty(a)||x(k)||a<=k},d.$observe("max",function(a){k=Wa(a);c.$validate()});if(u(d.step)||d.ngStep){var h;c.$validators.step=function(a,b){return c.$isEmpty(b)||x(h)||ge(b,g||0,h)};d.$observe("step",function(a){h=Wa(a);c.$validate()})}},url:function(a,b,d,c,e,f){Va(a,b,d,c,e,f);Ic(c);c.$$parserName="url";c.$validators.url=function(a,b){var d=a||b;return c.$isEmpty(d)||gh.test(d)}},
email:function(a,b,d,c,e,f){Va(a,b,d,c,e,f);Ic(c);c.$$parserName="email";c.$validators.email=function(a,b){var d=a||b;return c.$isEmpty(d)||hh.test(d)}},radio:function(a,b,d,c){var e=!d.ngTrim||"false"!==Q(d.ngTrim);x(d.name)&&b.attr("name",++qb);b.on("click",function(a){var g;b[0].checked&&(g=d.value,e&&(g=Q(g)),c.$setViewValue(g,a&&a.type))});c.$render=function(){var a=d.value;e&&(a=Q(a));b[0].checked=a===c.$viewValue};d.$observe("value",c.$render)},range:function(a,b,d,c,e,f){function g(a,c){b.attr(a,
d[a]);d.$observe(a,c)}function k(a){p=Wa(a);X(c.$modelValue)||(m?(a=b.val(),p>a&&(a=p,b.val(a)),c.$setViewValue(a)):c.$validate())}function h(a){n=Wa(a);X(c.$modelValue)||(m?(a=b.val(),n<a&&(b.val(n),a=n<p?p:n),c.$setViewValue(a)):c.$validate())}function l(a){q=Wa(a);X(c.$modelValue)||(m&&c.$viewValue!==b.val()?c.$setViewValue(b.val()):c.$validate())}Jc(a,b,d,c);fe(c);Va(a,b,d,c,e,f);var m=c.$$hasNativeValidators&&"range"===b[0].type,p=m?0:void 0,n=m?100:void 0,q=m?1:void 0,r=b[0].validity;a=u(d.min);
e=u(d.max);f=u(d.step);var E=c.$render;c.$render=m&&u(r.rangeUnderflow)&&u(r.rangeOverflow)?function(){E();c.$setViewValue(b.val())}:E;a&&(c.$validators.min=m?function(){return!0}:function(a,b){return c.$isEmpty(b)||x(p)||b>=p},g("min",k));e&&(c.$validators.max=m?function(){return!0}:function(a,b){return c.$isEmpty(b)||x(n)||b<=n},g("max",h));f&&(c.$validators.step=m?function(){return!r.stepMismatch}:function(a,b){return c.$isEmpty(b)||x(q)||ge(b,p||0,q)},g("step",l))},checkbox:function(a,b,d,c,e,
f,g,k){var h=he(k,a,"ngTrueValue",d.ngTrueValue,!0),l=he(k,a,"ngFalseValue",d.ngFalseValue,!1);b.on("click",function(a){c.$setViewValue(b[0].checked,a&&a.type)});c.$render=function(){b[0].checked=c.$viewValue};c.$isEmpty=function(a){return!1===a};c.$formatters.push(function(a){return sa(a,h)});c.$parsers.push(function(a){return a?h:l})},hidden:D,button:D,submit:D,reset:D,file:D},ad=["$browser","$sniffer","$filter","$parse",function(a,b,d,c){return{restrict:"E",require:["?ngModel"],link:{pre:function(e,
f,g,k){k[0]&&(pe[N(g.type)]||pe.text)(e,f,g,k[0],b,a,d,c)}}}}],ih=/^(true|false|\d+)$/,of=function(){function a(a,d,c){var e=u(c)?c:9===Ba?"":null;a.prop("value",e);d.$set("value",c)}return{restrict:"A",priority:100,compile:function(b,d){return ih.test(d.ngValue)?function(b,d,f){b=b.$eval(f.ngValue);a(d,f,b)}:function(b,d,f){b.$watch(f.ngValue,function(b){a(d,f,b)})}}}},Oe=["$compile",function(a){return{restrict:"AC",compile:function(b){a.$$addBindingClass(b);return function(b,c,e){a.$$addBindingInfo(c,
e.ngBind);c=c[0];b.$watch(e.ngBind,function(a){c.textContent=hc(a)})}}}}],Qe=["$interpolate","$compile",function(a,b){return{compile:function(d){b.$$addBindingClass(d);return function(c,d,f){c=a(d.attr(f.$attr.ngBindTemplate));b.$$addBindingInfo(d,c.expressions);d=d[0];f.$observe("ngBindTemplate",function(a){d.textContent=x(a)?"":a})}}}}],Pe=["$sce","$parse","$compile",function(a,b,d){return{restrict:"A",compile:function(c,e){var f=b(e.ngBindHtml),g=b(e.ngBindHtml,function(b){return a.valueOf(b)});
d.$$addBindingClass(c);return function(b,c,e){d.$$addBindingInfo(c,e.ngBindHtml);b.$watch(g,function(){var d=f(b);c.html(a.getTrustedHtml(d)||"")})}}}}],nf=ka({restrict:"A",require:"ngModel",link:function(a,b,d,c){c.$viewChangeListeners.push(function(){a.$eval(d.ngChange)})}}),Re=Lc("",!0),Te=Lc("Odd",0),Se=Lc("Even",1),Ue=Ra({compile:function(a,b){b.$set("ngCloak",void 0);a.removeClass("ng-cloak")}}),Ve=[function(){return{restrict:"A",scope:!0,controller:"@",priority:500}}],fd={},jh={blur:!0,focus:!0};
q("click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste".split(" "),function(a){var b=Da("ng-"+a);fd[b]=["$parse","$rootScope",function(d,c){return{restrict:"A",compile:function(e,f){var g=d(f[b]);return function(b,d){d.on(a,function(d){var e=function(){g(b,{$event:d})};jh[a]&&c.$$phase?b.$evalAsync(e):b.$apply(e)})}}}}]});var Ye=["$animate","$compile",function(a,b){return{multiElement:!0,transclude:"element",priority:600,
terminal:!0,restrict:"A",$$tlb:!0,link:function(d,c,e,f,g){var k,h,l;d.$watch(e.ngIf,function(d){d?h||g(function(d,f){h=f;d[d.length++]=b.$$createComment("end ngIf",e.ngIf);k={clone:d};a.enter(d,c.parent(),c)}):(l&&(l.remove(),l=null),h&&(h.$destroy(),h=null),k&&(l=tb(k.clone),a.leave(l).done(function(a){!1!==a&&(l=null)}),k=null))})}}}],Ze=["$templateRequest","$anchorScroll","$animate",function(a,b,d){return{restrict:"ECA",priority:400,terminal:!0,transclude:"element",controller:ea.noop,compile:function(c,
e){var f=e.ngInclude||e.src,g=e.onload||"",k=e.autoscroll;return function(c,e,m,p,n){var q=0,r,E,A,s=function(){E&&(E.remove(),E=null);r&&(r.$destroy(),r=null);A&&(d.leave(A).done(function(a){!1!==a&&(E=null)}),E=A,A=null)};c.$watch(f,function(f){var m=function(a){!1===a||!u(k)||k&&!c.$eval(k)||b()},w=++q;f?(a(f,!0).then(function(a){if(!c.$$destroyed&&w===q){var b=c.$new();p.template=a;a=n(b,function(a){s();d.enter(a,null,e).done(m)});r=b;A=a;r.$emit("$includeContentLoaded",f);c.$eval(g)}},function(){c.$$destroyed||
w!==q||(s(),c.$emit("$includeContentError",f))}),c.$emit("$includeContentRequested",f)):(s(),p.template=null)})}}}}],qf=["$compile",function(a){return{restrict:"ECA",priority:-400,require:"ngInclude",link:function(b,d,c,e){ha.call(d[0]).match(/SVG/)?(d.empty(),a(hd(e.template,y.document).childNodes)(b,function(a){d.append(a)},{futureParentElement:d})):(d.html(e.template),a(d.contents())(b))}}}],$e=Ra({priority:450,compile:function(){return{pre:function(a,b,d){a.$eval(d.ngInit)}}}}),mf=function(){return{restrict:"A",
priority:100,require:"ngModel",link:function(a,b,d,c){var e=d.ngList||", ",f="false"!==d.ngTrim,g=f?Q(e):e;c.$parsers.push(function(a){if(!x(a)){var b=[];a&&q(a.split(g),function(a){a&&b.push(f?Q(a):a)});return b}});c.$formatters.push(function(a){if(I(a))return a.join(e)});c.$isEmpty=function(a){return!a||!a.length}}}},nb="ng-valid",be="ng-invalid",Ya="ng-pristine",Vb="ng-dirty",pb=M("ngModel");Sb.$inject="$scope $exceptionHandler $attrs $element $parse $animate $timeout $q $interpolate".split(" ");
Sb.prototype={$$initGetterSetters:function(){if(this.$options.getOption("getterSetter")){var a=this.$$parse(this.$$attr.ngModel+"()"),b=this.$$parse(this.$$attr.ngModel+"($$$p)");this.$$ngModelGet=function(b){var c=this.$$parsedNgModel(b);C(c)&&(c=a(b));return c};this.$$ngModelSet=function(a,c){C(this.$$parsedNgModel(a))?b(a,{$$$p:c}):this.$$parsedNgModelAssign(a,c)}}else if(!this.$$parsedNgModel.assign)throw pb("nonassign",this.$$attr.ngModel,za(this.$$element));},$render:D,$isEmpty:function(a){return x(a)||
""===a||null===a||a!==a},$$updateEmptyClasses:function(a){this.$isEmpty(a)?(this.$$animate.removeClass(this.$$element,"ng-not-empty"),this.$$animate.addClass(this.$$element,"ng-empty")):(this.$$animate.removeClass(this.$$element,"ng-empty"),this.$$animate.addClass(this.$$element,"ng-not-empty"))},$setPristine:function(){this.$dirty=!1;this.$pristine=!0;this.$$animate.removeClass(this.$$element,Vb);this.$$animate.addClass(this.$$element,Ya)},$setDirty:function(){this.$dirty=!0;this.$pristine=!1;this.$$animate.removeClass(this.$$element,
Ya);this.$$animate.addClass(this.$$element,Vb);this.$$parentForm.$setDirty()},$setUntouched:function(){this.$touched=!1;this.$untouched=!0;this.$$animate.setClass(this.$$element,"ng-untouched","ng-touched")},$setTouched:function(){this.$touched=!0;this.$untouched=!1;this.$$animate.setClass(this.$$element,"ng-touched","ng-untouched")},$rollbackViewValue:function(){this.$$timeout.cancel(this.$$pendingDebounce);this.$viewValue=this.$$lastCommittedViewValue;this.$render()},$validate:function(){if(!X(this.$modelValue)){var a=
this.$$lastCommittedViewValue,b=this.$$rawModelValue,d=this.$valid,c=this.$modelValue,e=this.$options.getOption("allowInvalid"),f=this;this.$$runValidators(b,a,function(a){e||d===a||(f.$modelValue=a?b:void 0,f.$modelValue!==c&&f.$$writeModelToScope())})}},$$runValidators:function(a,b,d){function c(){var c=!0;q(h.$validators,function(d,e){var g=Boolean(d(a,b));c=c&&g;f(e,g)});return c?!0:(q(h.$asyncValidators,function(a,b){f(b,null)}),!1)}function e(){var c=[],d=!0;q(h.$asyncValidators,function(e,
g){var h=e(a,b);if(!h||!C(h.then))throw pb("nopromise",h);f(g,void 0);c.push(h.then(function(){f(g,!0)},function(){d=!1;f(g,!1)}))});c.length?h.$$q.all(c).then(function(){g(d)},D):g(!0)}function f(a,b){k===h.$$currentValidationRunId&&h.$setValidity(a,b)}function g(a){k===h.$$currentValidationRunId&&d(a)}this.$$currentValidationRunId++;var k=this.$$currentValidationRunId,h=this;(function(){var a=h.$$parserName||"parse";if(x(h.$$parserValid))f(a,null);else return h.$$parserValid||(q(h.$validators,function(a,
b){f(b,null)}),q(h.$asyncValidators,function(a,b){f(b,null)})),f(a,h.$$parserValid),h.$$parserValid;return!0})()?c()?e():g(!1):g(!1)},$commitViewValue:function(){var a=this.$viewValue;this.$$timeout.cancel(this.$$pendingDebounce);if(this.$$lastCommittedViewValue!==a||""===a&&this.$$hasNativeValidators)this.$$updateEmptyClasses(a),this.$$lastCommittedViewValue=a,this.$pristine&&this.$setDirty(),this.$$parseAndValidate()},$$parseAndValidate:function(){var a=this.$$lastCommittedViewValue,b=this;if(this.$$parserValid=
x(a)?void 0:!0)for(var d=0;d<this.$parsers.length;d++)if(a=this.$parsers[d](a),x(a)){this.$$parserValid=!1;break}X(this.$modelValue)&&(this.$modelValue=this.$$ngModelGet(this.$$scope));var c=this.$modelValue,e=this.$options.getOption("allowInvalid");this.$$rawModelValue=a;e&&(this.$modelValue=a,b.$modelValue!==c&&b.$$writeModelToScope());this.$$runValidators(a,this.$$lastCommittedViewValue,function(d){e||(b.$modelValue=d?a:void 0,b.$modelValue!==c&&b.$$writeModelToScope())})},$$writeModelToScope:function(){this.$$ngModelSet(this.$$scope,
this.$modelValue);q(this.$viewChangeListeners,function(a){try{a()}catch(b){this.$$exceptionHandler(b)}},this)},$setViewValue:function(a,b){this.$viewValue=a;this.$options.getOption("updateOnDefault")&&this.$$debounceViewValueCommit(b)},$$debounceViewValueCommit:function(a){var b=this.$options.getOption("debounce");Y(b[a])?b=b[a]:Y(b["default"])&&(b=b["default"]);this.$$timeout.cancel(this.$$pendingDebounce);var d=this;0<b?this.$$pendingDebounce=this.$$timeout(function(){d.$commitViewValue()},b):this.$$scope.$root.$$phase?
this.$commitViewValue():this.$$scope.$apply(function(){d.$commitViewValue()})},$overrideModelOptions:function(a){this.$options=this.$options.createChild(a);this.$$setUpdateOnEvents()},$processModelValue:function(){var a=this.$$format();this.$viewValue!==a&&(this.$$updateEmptyClasses(a),this.$viewValue=this.$$lastCommittedViewValue=a,this.$render(),this.$$runValidators(this.$modelValue,this.$viewValue,D))},$$format:function(){for(var a=this.$formatters,b=a.length,d=this.$modelValue;b--;)d=a[b](d);
return d},$$setModelValue:function(a){this.$modelValue=this.$$rawModelValue=a;this.$$parserValid=void 0;this.$processModelValue()},$$setUpdateOnEvents:function(){this.$$updateEvents&&this.$$element.off(this.$$updateEvents,this.$$updateEventHandler);if(this.$$updateEvents=this.$options.getOption("updateOn"))this.$$element.on(this.$$updateEvents,this.$$updateEventHandler)},$$updateEventHandler:function(a){this.$$debounceViewValueCommit(a&&a.type)}};ce({clazz:Sb,set:function(a,b){a[b]=!0},unset:function(a,
b){delete a[b]}});var lf=["$rootScope",function(a){return{restrict:"A",require:["ngModel","^?form","^?ngModelOptions"],controller:Sb,priority:1,compile:function(b){b.addClass(Ya).addClass("ng-untouched").addClass(nb);return{pre:function(a,b,e,f){var g=f[0];b=f[1]||g.$$parentForm;if(f=f[2])g.$options=f.$options;g.$$initGetterSetters();b.$addControl(g);e.$observe("name",function(a){g.$name!==a&&g.$$parentForm.$$renameControl(g,a)});a.$on("$destroy",function(){g.$$parentForm.$removeControl(g)})},post:function(b,
c,e,f){function g(){k.$setTouched()}var k=f[0];k.$$setUpdateOnEvents();c.on("blur",function(){k.$touched||(a.$$phase?b.$evalAsync(g):b.$apply(g))})}}}}}],Tb,kh=/(\s+|^)default(\s+|$)/;Mc.prototype={getOption:function(a){return this.$$options[a]},createChild:function(a){var b=!1;a=P({},a);q(a,function(d,c){"$inherit"===d?"*"===c?b=!0:(a[c]=this.$$options[c],"updateOn"===c&&(a.updateOnDefault=this.$$options.updateOnDefault)):"updateOn"===c&&(a.updateOnDefault=!1,a[c]=Q(d.replace(kh,function(){a.updateOnDefault=
!0;return" "})))},this);b&&(delete a["*"],ie(a,this.$$options));ie(a,Tb.$$options);return new Mc(a)}};Tb=new Mc({updateOn:"",updateOnDefault:!0,debounce:0,getterSetter:!1,allowInvalid:!1,timezone:null});var pf=function(){function a(a,d){this.$$attrs=a;this.$$scope=d}a.$inject=["$attrs","$scope"];a.prototype={$onInit:function(){var a=this.parentCtrl?this.parentCtrl.$options:Tb,d=this.$$scope.$eval(this.$$attrs.ngModelOptions);this.$options=a.createChild(d)}};return{restrict:"A",priority:10,require:{parentCtrl:"?^^ngModelOptions"},
bindToController:!0,controller:a}},af=Ra({terminal:!0,priority:1E3}),lh=M("ngOptions"),mh=/^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+group\s+by\s+([\s\S]+?))?(?:\s+disable\s+when\s+([\s\S]+?))?\s+for\s+(?:([$\w][$\w]*)|(?:\(\s*([$\w][$\w]*)\s*,\s*([$\w][$\w]*)\s*\)))\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?$/,jf=["$compile","$document","$parse",function(a,b,d){function c(a,b,c){function e(a,b,c,d,f){this.selectValue=a;this.viewValue=b;this.label=c;this.group=d;this.disabled=f}function f(a){var b;
if(!q&&ja(a))b=a;else{b=[];for(var c in a)a.hasOwnProperty(c)&&"$"!==c.charAt(0)&&b.push(c)}return b}var p=a.match(mh);if(!p)throw lh("iexp",a,za(b));var n=p[5]||p[7],q=p[6];a=/ as /.test(p[0])&&p[1];var r=p[9];b=d(p[2]?p[1]:n);var E=a&&d(a)||b,A=r&&d(r),s=r?function(a,b){return A(c,b)}:function(a){return Na(a)},u=function(a,b){return s(a,t(a,b))},z=d(p[2]||p[1]),w=d(p[3]||""),H=d(p[4]||""),y=d(p[8]),x={},t=q?function(a,b){x[q]=b;x[n]=a;return x}:function(a){x[n]=a;return x};return{trackBy:r,getTrackByValue:u,
getWatchables:d(y,function(a){var b=[];a=a||[];for(var d=f(a),e=d.length,g=0;g<e;g++){var k=a===d?g:d[g],l=a[k],k=t(l,k),l=s(l,k);b.push(l);if(p[2]||p[1])l=z(c,k),b.push(l);p[4]&&(k=H(c,k),b.push(k))}return b}),getOptions:function(){for(var a=[],b={},d=y(c)||[],g=f(d),k=g.length,n=0;n<k;n++){var p=d===g?n:g[n],q=t(d[p],p),B=E(c,q),p=s(B,q),A=z(c,q),x=w(c,q),q=H(c,q),B=new e(p,B,A,x,q);a.push(B);b[p]=B}return{items:a,selectValueMap:b,getOptionFromViewValue:function(a){return b[u(a)]},getViewValueFromOption:function(a){return r?
na(a.viewValue):a.viewValue}}}}}var e=y.document.createElement("option"),f=y.document.createElement("optgroup");return{restrict:"A",terminal:!0,require:["select","ngModel"],link:{pre:function(a,b,c,d){d[0].registerOption=D},post:function(d,k,h,l){function m(a){var b=(a=s.getOptionFromViewValue(a))&&a.element;b&&!b.selected&&(b.selected=!0);return a}function p(a,b){a.element=b;b.disabled=a.disabled;a.label!==b.label&&(b.label=a.label,b.textContent=a.label);b.value=a.selectValue}var n=l[0],r=l[1],v=
h.multiple;l=0;for(var E=k.children(),A=E.length;l<A;l++)if(""===E[l].value){n.hasEmptyOption=!0;n.emptyOption=E.eq(l);break}k.empty();l=!!n.emptyOption;z(e.cloneNode(!1)).val("?");var s,x=c(h.ngOptions,k,d),y=b[0].createDocumentFragment();n.generateUnknownOptionValue=function(a){return"?"};v?(n.writeValue=function(a){if(s){var b=a&&a.map(m)||[];s.items.forEach(function(a){a.element.selected&&-1===Array.prototype.indexOf.call(b,a)&&(a.element.selected=!1)})}},n.readValue=function(){var a=k.val()||
[],b=[];q(a,function(a){(a=s.selectValueMap[a])&&!a.disabled&&b.push(s.getViewValueFromOption(a))});return b},x.trackBy&&d.$watchCollection(function(){if(I(r.$viewValue))return r.$viewValue.map(function(a){return x.getTrackByValue(a)})},function(){r.$render()})):(n.writeValue=function(a){if(s){var b=k[0].options[k[0].selectedIndex],c=s.getOptionFromViewValue(a);b&&b.removeAttribute("selected");c?(k[0].value!==c.selectValue&&(n.removeUnknownOption(),k[0].value=c.selectValue,c.element.selected=!0),
c.element.setAttribute("selected","selected")):n.selectUnknownOrEmptyOption(a)}},n.readValue=function(){var a=s.selectValueMap[k.val()];return a&&!a.disabled?(n.unselectEmptyOption(),n.removeUnknownOption(),s.getViewValueFromOption(a)):null},x.trackBy&&d.$watch(function(){return x.getTrackByValue(r.$viewValue)},function(){r.$render()}));l&&(a(n.emptyOption)(d),k.prepend(n.emptyOption),8===n.emptyOption[0].nodeType?(n.hasEmptyOption=!1,n.registerOption=function(a,b){""===b.val()&&(n.hasEmptyOption=
!0,n.emptyOption=b,n.emptyOption.removeClass("ng-scope"),r.$render(),b.on("$destroy",function(){var a=n.$isEmptyOptionSelected();n.hasEmptyOption=!1;n.emptyOption=void 0;a&&r.$render()}))}):n.emptyOption.removeClass("ng-scope"));d.$watchCollection(x.getWatchables,function(){var a=s&&n.readValue();if(s)for(var b=s.items.length-1;0<=b;b--){var c=s.items[b];u(c.group)?Fb(c.element.parentNode):Fb(c.element)}s=x.getOptions();var d={};s.items.forEach(function(a){var b;if(u(a.group)){b=d[a.group];b||(b=
f.cloneNode(!1),y.appendChild(b),b.label=null===a.group?"null":a.group,d[a.group]=b);var c=e.cloneNode(!1);b.appendChild(c);p(a,c)}else b=e.cloneNode(!1),y.appendChild(b),p(a,b)});k[0].appendChild(y);r.$render();r.$isEmpty(a)||(b=n.readValue(),(x.trackBy||v?sa(a,b):a===b)||(r.$setViewValue(b),r.$render()))})}}}}],bf=["$locale","$interpolate","$log",function(a,b,d){var c=/{}/g,e=/^when(Minus)?(.+)$/;return{link:function(f,g,k){function h(a){g.text(a||"")}var l=k.count,m=k.$attr.when&&g.attr(k.$attr.when),
p=k.offset||0,n=f.$eval(m)||{},r={},v=b.startSymbol(),E=b.endSymbol(),A=v+l+"-"+p+E,s=ea.noop,u;q(k,function(a,b){var c=e.exec(b);c&&(c=(c[1]?"-":"")+N(c[2]),n[c]=g.attr(k.$attr[b]))});q(n,function(a,d){r[d]=b(a.replace(c,A))});f.$watch(l,function(b){var c=parseFloat(b),e=X(c);e||c in n||(c=a.pluralCat(c-p));c===u||e&&X(u)||(s(),e=r[c],x(e)?(null!=b&&d.debug("ngPluralize: no rule defined for '"+c+"' in "+m),s=D,h()):s=f.$watch(e,h),u=c)})}}}],cf=["$parse","$animate","$compile",function(a,b,d){var c=
M("ngRepeat"),e=function(a,b,c,d,e,m,p){a[c]=d;e&&(a[e]=m);a.$index=b;a.$first=0===b;a.$last=b===p-1;a.$middle=!(a.$first||a.$last);a.$odd=!(a.$even=0===(b&1))};return{restrict:"A",multiElement:!0,transclude:"element",priority:1E3,terminal:!0,$$tlb:!0,compile:function(f,g){var k=g.ngRepeat,h=d.$$createComment("end ngRepeat",k),l=k.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+track\s+by\s+([\s\S]+?))?\s*$/);if(!l)throw c("iexp",k);var m=l[1],p=l[2],n=l[3],r=l[4],l=m.match(/^(?:(\s*[$\w]+)|\(\s*([$\w]+)\s*,\s*([$\w]+)\s*\))$/);
if(!l)throw c("iidexp",m);var v=l[3]||l[1],u=l[2];if(n&&(!/^[$a-zA-Z_][$a-zA-Z0-9_]*$/.test(n)||/^(null|undefined|this|\$index|\$first|\$middle|\$last|\$even|\$odd|\$parent|\$root|\$id)$/.test(n)))throw c("badident",n);var A,s,x,z,w={$id:Na};r?A=a(r):(x=function(a,b){return Na(b)},z=function(a){return a});return function(a,d,f,g,l){A&&(s=function(b,c,d){u&&(w[u]=b);w[v]=c;w.$index=d;return A(a,w)});var m=R();a.$watchCollection(p,function(f){var g,p,r=d[0],t,A=R(),w,B,y,C,F,D,G;n&&(a[n]=f);if(ja(f))F=
f,p=s||x;else for(G in p=s||z,F=[],f)ra.call(f,G)&&"$"!==G.charAt(0)&&F.push(G);w=F.length;G=Array(w);for(g=0;g<w;g++)if(B=f===F?g:F[g],y=f[B],C=p(B,y,g),m[C])D=m[C],delete m[C],A[C]=D,G[g]=D;else{if(A[C])throw q(G,function(a){a&&a.scope&&(m[a.id]=a)}),c("dupes",k,C,y);G[g]={id:C,scope:void 0,clone:void 0};A[C]=!0}for(t in m){D=m[t];C=tb(D.clone);b.leave(C);if(C[0].parentNode)for(g=0,p=C.length;g<p;g++)C[g].$$NG_REMOVED=!0;D.scope.$destroy()}for(g=0;g<w;g++)if(B=f===F?g:F[g],y=f[B],D=G[g],D.scope){t=
r;do t=t.nextSibling;while(t&&t.$$NG_REMOVED);D.clone[0]!==t&&b.move(tb(D.clone),null,r);r=D.clone[D.clone.length-1];e(D.scope,g,v,y,u,B,w)}else l(function(a,c){D.scope=c;var d=h.cloneNode(!1);a[a.length++]=d;b.enter(a,null,r);r=d;D.clone=a;A[D.id]=D;e(D.scope,g,v,y,u,B,w)});m=A})}}}}],df=["$animate",function(a){return{restrict:"A",multiElement:!0,link:function(b,d,c){b.$watch(c.ngShow,function(b){a[b?"removeClass":"addClass"](d,"ng-hide",{tempClasses:"ng-hide-animate"})})}}}],Xe=["$animate",function(a){return{restrict:"A",
multiElement:!0,link:function(b,d,c){b.$watch(c.ngHide,function(b){a[b?"addClass":"removeClass"](d,"ng-hide",{tempClasses:"ng-hide-animate"})})}}}],ef=Ra(function(a,b,d){a.$watch(d.ngStyle,function(a,d){d&&a!==d&&q(d,function(a,c){b.css(c,"")});a&&b.css(a)},!0)}),ff=["$animate","$compile",function(a,b){return{require:"ngSwitch",controller:["$scope",function(){this.cases={}}],link:function(d,c,e,f){var g=[],k=[],h=[],l=[],m=function(a,b){return function(c){!1!==c&&a.splice(b,1)}};d.$watch(e.ngSwitch||
e.on,function(c){for(var d,e;h.length;)a.cancel(h.pop());d=0;for(e=l.length;d<e;++d){var r=tb(k[d].clone);l[d].$destroy();(h[d]=a.leave(r)).done(m(h,d))}k.length=0;l.length=0;(g=f.cases["!"+c]||f.cases["?"])&&q(g,function(c){c.transclude(function(d,e){l.push(e);var f=c.element;d[d.length++]=b.$$createComment("end ngSwitchWhen");k.push({clone:d});a.enter(d,f.parent(),f)})})})}}}],gf=Ra({transclude:"element",priority:1200,require:"^ngSwitch",multiElement:!0,link:function(a,b,d,c,e){a=d.ngSwitchWhen.split(d.ngSwitchWhenSeparator).sort().filter(function(a,
b,c){return c[b-1]!==a});q(a,function(a){c.cases["!"+a]=c.cases["!"+a]||[];c.cases["!"+a].push({transclude:e,element:b})})}}),hf=Ra({transclude:"element",priority:1200,require:"^ngSwitch",multiElement:!0,link:function(a,b,d,c,e){c.cases["?"]=c.cases["?"]||[];c.cases["?"].push({transclude:e,element:b})}}),nh=M("ngTransclude"),kf=["$compile",function(a){return{restrict:"EAC",compile:function(b){var d=a(b.contents());b.empty();return function(a,b,f,g,k){function h(){d(a,function(a){b.append(a)})}if(!k)throw nh("orphan",
za(b));f.ngTransclude===f.$attr.ngTransclude&&(f.ngTransclude="");f=f.ngTransclude||f.ngTranscludeSlot;k(function(a,c){var d;if(d=a.length)a:{d=0;for(var f=a.length;d<f;d++){var g=a[d];if(g.nodeType!==Ma||g.nodeValue.trim()){d=!0;break a}}d=void 0}d?b.append(a):(h(),c.$destroy())},null,f);f&&!k.isSlotFilled(f)&&h()}}}}],Le=["$templateCache",function(a){return{restrict:"E",terminal:!0,compile:function(b,d){"text/ng-template"===d.type&&a.put(d.id,b[0].text)}}}],oh={$setViewValue:D,$render:D},ph=["$element",
"$scope",function(a,b){function d(){g||(g=!0,b.$$postDigest(function(){g=!1;e.ngModelCtrl.$render()}))}function c(a){k||(k=!0,b.$$postDigest(function(){b.$$destroyed||(k=!1,e.ngModelCtrl.$setViewValue(e.readValue()),a&&e.ngModelCtrl.$render())}))}var e=this,f=new Hb;e.selectValueMap={};e.ngModelCtrl=oh;e.multiple=!1;e.unknownOption=z(y.document.createElement("option"));e.hasEmptyOption=!1;e.emptyOption=void 0;e.renderUnknownOption=function(b){b=e.generateUnknownOptionValue(b);e.unknownOption.val(b);
a.prepend(e.unknownOption);Fa(e.unknownOption,!0);a.val(b)};e.updateUnknownOption=function(b){b=e.generateUnknownOptionValue(b);e.unknownOption.val(b);Fa(e.unknownOption,!0);a.val(b)};e.generateUnknownOptionValue=function(a){return"? "+Na(a)+" ?"};e.removeUnknownOption=function(){e.unknownOption.parent()&&e.unknownOption.remove()};e.selectEmptyOption=function(){e.emptyOption&&(a.val(""),Fa(e.emptyOption,!0))};e.unselectEmptyOption=function(){e.hasEmptyOption&&Fa(e.emptyOption,!1)};b.$on("$destroy",
function(){e.renderUnknownOption=D});e.readValue=function(){var b=a.val(),b=b in e.selectValueMap?e.selectValueMap[b]:b;return e.hasOption(b)?b:null};e.writeValue=function(b){var c=a[0].options[a[0].selectedIndex];c&&Fa(z(c),!1);e.hasOption(b)?(e.removeUnknownOption(),c=Na(b),a.val(c in e.selectValueMap?c:b),Fa(z(a[0].options[a[0].selectedIndex]),!0)):e.selectUnknownOrEmptyOption(b)};e.addOption=function(a,b){if(8!==b[0].nodeType){Ha(a,'"option value"');""===a&&(e.hasEmptyOption=!0,e.emptyOption=
b);var c=f.get(a)||0;f.set(a,c+1);d()}};e.removeOption=function(a){var b=f.get(a);b&&(1===b?(f.delete(a),""===a&&(e.hasEmptyOption=!1,e.emptyOption=void 0)):f.set(a,b-1))};e.hasOption=function(a){return!!f.get(a)};e.$hasEmptyOption=function(){return e.hasEmptyOption};e.$isUnknownOptionSelected=function(){return a[0].options[0]===e.unknownOption[0]};e.$isEmptyOptionSelected=function(){return e.hasEmptyOption&&a[0].options[a[0].selectedIndex]===e.emptyOption[0]};e.selectUnknownOrEmptyOption=function(a){null==
a&&e.emptyOption?(e.removeUnknownOption(),e.selectEmptyOption()):e.unknownOption.parent().length?e.updateUnknownOption(a):e.renderUnknownOption(a)};var g=!1,k=!1;e.registerOption=function(a,b,f,g,k){if(f.$attr.ngValue){var q,r=NaN;f.$observe("value",function(a){var d,f=b.prop("selected");u(r)&&(e.removeOption(q),delete e.selectValueMap[r],d=!0);r=Na(a);q=a;e.selectValueMap[r]=a;e.addOption(a,b);b.attr("value",r);d&&f&&c()})}else g?f.$observe("value",function(a){e.readValue();var d,f=b.prop("selected");
u(q)&&(e.removeOption(q),d=!0);q=a;e.addOption(a,b);d&&f&&c()}):k?a.$watch(k,function(a,d){f.$set("value",a);var g=b.prop("selected");d!==a&&e.removeOption(d);e.addOption(a,b);d&&g&&c()}):e.addOption(f.value,b);f.$observe("disabled",function(a){if("true"===a||a&&b.prop("selected"))e.multiple?c(!0):(e.ngModelCtrl.$setViewValue(null),e.ngModelCtrl.$render())});b.on("$destroy",function(){var a=e.readValue(),b=f.value;e.removeOption(b);d();(e.multiple&&a&&-1!==a.indexOf(b)||a===b)&&c(!0)})}}],Me=function(){return{restrict:"E",
require:["select","?ngModel"],controller:ph,priority:1,link:{pre:function(a,b,d,c){var e=c[0],f=c[1];if(f){if(e.ngModelCtrl=f,b.on("change",function(){e.removeUnknownOption();a.$apply(function(){f.$setViewValue(e.readValue())})}),d.multiple){e.multiple=!0;e.readValue=function(){var a=[];q(b.find("option"),function(b){b.selected&&!b.disabled&&(b=b.value,a.push(b in e.selectValueMap?e.selectValueMap[b]:b))});return a};e.writeValue=function(a){q(b.find("option"),function(b){var c=!!a&&(-1!==Array.prototype.indexOf.call(a,
b.value)||-1!==Array.prototype.indexOf.call(a,e.selectValueMap[b.value]));c!==b.selected&&Fa(z(b),c)})};var g,k=NaN;a.$watch(function(){k!==f.$viewValue||sa(g,f.$viewValue)||(g=pa(f.$viewValue),f.$render());k=f.$viewValue});f.$isEmpty=function(a){return!a||0===a.length}}}else e.registerOption=D},post:function(a,b,d,c){var e=c[1];if(e){var f=c[0];e.$render=function(){f.writeValue(e.$viewValue)}}}}}},Ne=["$interpolate",function(a){return{restrict:"E",priority:100,compile:function(b,d){var c,e;u(d.ngValue)||
(u(d.value)?c=a(d.value,!0):(e=a(b.text(),!0))||d.$set("value",b.text()));return function(a,b,d){var h=b.parent();(h=h.data("$selectController")||h.parent().data("$selectController"))&&h.registerOption(a,b,d,c,e)}}}}],cd=function(){return{restrict:"A",require:"?ngModel",link:function(a,b,d,c){c&&(d.required=!0,c.$validators.required=function(a,b){return!d.required||!c.$isEmpty(b)},d.$observe("required",function(){c.$validate()}))}}},bd=function(){return{restrict:"A",require:"?ngModel",link:function(a,
b,d,c){if(c){var e,f=d.ngPattern||d.pattern;d.$observe("pattern",function(a){F(a)&&0<a.length&&(a=new RegExp("^"+a+"$"));if(a&&!a.test)throw M("ngPattern")("noregexp",f,a,za(b));e=a||void 0;c.$validate()});c.$validators.pattern=function(a,b){return c.$isEmpty(b)||x(e)||e.test(b)}}}}},ed=function(){return{restrict:"A",require:"?ngModel",link:function(a,b,d,c){if(c){var e=-1;d.$observe("maxlength",function(a){a=Z(a);e=X(a)?-1:a;c.$validate()});c.$validators.maxlength=function(a,b){return 0>e||c.$isEmpty(b)||
b.length<=e}}}}},dd=function(){return{restrict:"A",require:"?ngModel",link:function(a,b,d,c){if(c){var e=0;d.$observe("minlength",function(a){e=Z(a)||0;c.$validate()});c.$validators.minlength=function(a,b){return c.$isEmpty(b)||b.length>=e}}}}};y.angular.bootstrap?y.console&&console.log("WARNING: Tried to load AngularJS more than once."):(De(),Ge(ea),ea.module("ngLocale",[],["$provide",function(a){function b(a){a+="";var b=a.indexOf(".");return-1==b?0:a.length-b-1}a.value("$locale",{DATETIME_FORMATS:{AMPMS:["AM",
"PM"],DAY:"Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),ERANAMES:["Before Christ","Anno Domini"],ERAS:["BC","AD"],FIRSTDAYOFWEEK:6,MONTH:"January February March April May June July August September October November December".split(" "),SHORTDAY:"Sun Mon Tue Wed Thu Fri Sat".split(" "),SHORTMONTH:"Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "),STANDALONEMONTH:"January February March April May June July August September October November December".split(" "),WEEKENDRANGE:[5,
6],fullDate:"EEEE, MMMM d, y",longDate:"MMMM d, y",medium:"MMM d, y h:mm:ss a",mediumDate:"MMM d, y",mediumTime:"h:mm:ss a","short":"M/d/yy h:mm a",shortDate:"M/d/yy",shortTime:"h:mm a"},NUMBER_FORMATS:{CURRENCY_SYM:"$",DECIMAL_SEP:".",GROUP_SEP:",",PATTERNS:[{gSize:3,lgSize:3,maxFrac:3,minFrac:0,minInt:1,negPre:"-",negSuf:"",posPre:"",posSuf:""},{gSize:3,lgSize:3,maxFrac:2,minFrac:2,minInt:1,negPre:"-\u00a4",negSuf:"",posPre:"\u00a4",posSuf:""}]},id:"en-us",localeID:"en_US",pluralCat:function(a,
c){var e=a|0,f=c;void 0===f&&(f=Math.min(b(a),3));Math.pow(10,f);return 1==e&&0==f?"one":"other"}})}]),z(function(){ye(y.document,Wc)}))})(window);!window.angular.$$csp().noInlineStyle&&window.angular.element(document.head).prepend('<style type="text/css">@charset "UTF-8";[ng\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide:not(.ng-hide-animate){display:none !important;}ng\\:form{display:block;}.ng-animate-shim{visibility:hidden;}.ng-anchor{position:absolute;}</style>');
//# sourceMappingURL=angular.min.js.map
;/*
 AngularJS v1.7.8
 (c) 2010-2018 Google, Inc. http://angularjs.org
 License: MIT
*/
(function(I,b){'use strict';function z(b,h){var d=[],c=b.replace(/([().])/g,"\\$1").replace(/(\/)?:(\w+)(\*\?|[?*])?/g,function(b,c,h,k){b="?"===k||"*?"===k;k="*"===k||"*?"===k;d.push({name:h,optional:b});c=c||"";return(b?"(?:"+c:c+"(?:")+(k?"(.+?)":"([^/]+)")+(b?"?)?":")")}).replace(/([/$*])/g,"\\$1");h.ignoreTrailingSlashes&&(c=c.replace(/\/+$/,"")+"/*");return{keys:d,regexp:new RegExp("^"+c+"(?:[?#]|$)",h.caseInsensitiveMatch?"i":"")}}function A(b){p&&b.get("$route")}function v(u,h,d){return{restrict:"ECA",
terminal:!0,priority:400,transclude:"element",link:function(c,f,g,l,k){function q(){r&&(d.cancel(r),r=null);m&&(m.$destroy(),m=null);s&&(r=d.leave(s),r.done(function(b){!1!==b&&(r=null)}),s=null)}function C(){var g=u.current&&u.current.locals;if(b.isDefined(g&&g.$template)){var g=c.$new(),l=u.current;s=k(g,function(g){d.enter(g,null,s||f).done(function(d){!1===d||!b.isDefined(w)||w&&!c.$eval(w)||h()});q()});m=l.scope=g;m.$emit("$viewContentLoaded");m.$eval(p)}else q()}var m,s,r,w=g.autoscroll,p=g.onload||
"";c.$on("$routeChangeSuccess",C);C()}}}function x(b,h,d){return{restrict:"ECA",priority:-400,link:function(c,f){var g=d.current,l=g.locals;f.html(l.$template);var k=b(f.contents());if(g.controller){l.$scope=c;var q=h(g.controller,l);g.controllerAs&&(c[g.controllerAs]=q);f.data("$ngControllerController",q);f.children().data("$ngControllerController",q)}c[g.resolveAs||"$resolve"]=l;k(c)}}}var D,E,F,G,y=b.module("ngRoute",[]).info({angularVersion:"1.7.8"}).provider("$route",function(){function u(d,
c){return b.extend(Object.create(d),c)}D=b.isArray;E=b.isObject;F=b.isDefined;G=b.noop;var h={};this.when=function(d,c){var f;f=void 0;if(D(c)){f=f||[];for(var g=0,l=c.length;g<l;g++)f[g]=c[g]}else if(E(c))for(g in f=f||{},c)if("$"!==g.charAt(0)||"$"!==g.charAt(1))f[g]=c[g];f=f||c;b.isUndefined(f.reloadOnUrl)&&(f.reloadOnUrl=!0);b.isUndefined(f.reloadOnSearch)&&(f.reloadOnSearch=!0);b.isUndefined(f.caseInsensitiveMatch)&&(f.caseInsensitiveMatch=this.caseInsensitiveMatch);h[d]=b.extend(f,{originalPath:d},
d&&z(d,f));d&&(g="/"===d[d.length-1]?d.substr(0,d.length-1):d+"/",h[g]=b.extend({originalPath:d,redirectTo:d},z(g,f)));return this};this.caseInsensitiveMatch=!1;this.otherwise=function(b){"string"===typeof b&&(b={redirectTo:b});this.when(null,b);return this};p=!0;this.eagerInstantiationEnabled=function(b){return F(b)?(p=b,this):p};this.$get=["$rootScope","$location","$routeParams","$q","$injector","$templateRequest","$sce","$browser",function(d,c,f,g,l,k,q,p){function m(a){var e=t.current;n=A();(x=
!B&&n&&e&&n.$$route===e.$$route&&(!n.reloadOnUrl||!n.reloadOnSearch&&b.equals(n.pathParams,e.pathParams)))||!e&&!n||d.$broadcast("$routeChangeStart",n,e).defaultPrevented&&a&&a.preventDefault()}function s(){var a=t.current,e=n;if(x)a.params=e.params,b.copy(a.params,f),d.$broadcast("$routeUpdate",a);else if(e||a){B=!1;t.current=e;var c=g.resolve(e);p.$$incOutstandingRequestCount("$route");c.then(r).then(w).then(function(g){return g&&c.then(y).then(function(c){e===t.current&&(e&&(e.locals=c,b.copy(e.params,
f)),d.$broadcast("$routeChangeSuccess",e,a))})}).catch(function(b){e===t.current&&d.$broadcast("$routeChangeError",e,a,b)}).finally(function(){p.$$completeOutstandingRequest(G,"$route")})}}function r(a){var e={route:a,hasRedirection:!1};if(a)if(a.redirectTo)if(b.isString(a.redirectTo))e.path=v(a.redirectTo,a.params),e.search=a.params,e.hasRedirection=!0;else{var d=c.path(),f=c.search();a=a.redirectTo(a.pathParams,d,f);b.isDefined(a)&&(e.url=a,e.hasRedirection=!0)}else if(a.resolveRedirectTo)return g.resolve(l.invoke(a.resolveRedirectTo)).then(function(a){b.isDefined(a)&&
(e.url=a,e.hasRedirection=!0);return e});return e}function w(a){var b=!0;if(a.route!==t.current)b=!1;else if(a.hasRedirection){var g=c.url(),d=a.url;d?c.url(d).replace():d=c.path(a.path).search(a.search).replace().url();d!==g&&(b=!1)}return b}function y(a){if(a){var e=b.extend({},a.resolve);b.forEach(e,function(a,c){e[c]=b.isString(a)?l.get(a):l.invoke(a,null,null,c)});a=z(a);b.isDefined(a)&&(e.$template=a);return g.all(e)}}function z(a){var e,c;b.isDefined(e=a.template)?b.isFunction(e)&&(e=e(a.params)):
b.isDefined(c=a.templateUrl)&&(b.isFunction(c)&&(c=c(a.params)),b.isDefined(c)&&(a.loadedTemplateUrl=q.valueOf(c),e=k(c)));return e}function A(){var a,e;b.forEach(h,function(d,g){var f;if(f=!e){var h=c.path();f=d.keys;var l={};if(d.regexp)if(h=d.regexp.exec(h)){for(var k=1,p=h.length;k<p;++k){var m=f[k-1],n=h[k];m&&n&&(l[m.name]=n)}f=l}else f=null;else f=null;f=a=f}f&&(e=u(d,{params:b.extend({},c.search(),a),pathParams:a}),e.$$route=d)});return e||h[null]&&u(h[null],{params:{},pathParams:{}})}function v(a,
c){var d=[];b.forEach((a||"").split(":"),function(a,b){if(0===b)d.push(a);else{var f=a.match(/(\w+)(?:[?*])?(.*)/),g=f[1];d.push(c[g]);d.push(f[2]||"");delete c[g]}});return d.join("")}var B=!1,n,x,t={routes:h,reload:function(){B=!0;var a={defaultPrevented:!1,preventDefault:function(){this.defaultPrevented=!0;B=!1}};d.$evalAsync(function(){m(a);a.defaultPrevented||s()})},updateParams:function(a){if(this.current&&this.current.$$route)a=b.extend({},this.current.params,a),c.path(v(this.current.$$route.originalPath,
a)),c.search(a);else throw H("norout");}};d.$on("$locationChangeStart",m);d.$on("$locationChangeSuccess",s);return t}]}).run(A),H=b.$$minErr("ngRoute"),p;A.$inject=["$injector"];y.provider("$routeParams",function(){this.$get=function(){return{}}});y.directive("ngView",v);y.directive("ngView",x);v.$inject=["$route","$anchorScroll","$animate"];x.$inject=["$compile","$controller","$route"]})(window,window.angular);
//# sourceMappingURL=angular-route.min.js.map
;/*
 * ng-tasty
 * https://github.com/Zizzamia/ng-tasty

 * Version: 0.6.1 - 2016-01-01
 * License: MIT
 */
angular.module("ngTasty",["ngTasty.tpls","ngTasty.component.table","ngTasty.filter.camelize","ngTasty.filter.cleanFieldName","ngTasty.filter.filterInt","ngTasty.filter.range","ngTasty.filter.slugify","ngTasty.service.bindTo","ngTasty.service.debounce","ngTasty.service.joinObjects","ngTasty.service.setProperty","ngTasty.service.tastyUtil","ngTasty.service.throttle","ngTasty.service.webSocket"]),angular.module("ngTasty.tpls",["ngTasty.tpls.table.head","ngTasty.tpls.table.pagination"]),angular.module("ngTasty.component.table",["ngTasty.filter.cleanFieldName","ngTasty.filter.range","ngTasty.service.tastyUtil","ngTasty.tpls.table.head","ngTasty.tpls.table.pagination"]).constant("tableConfig",{init:{count:5,page:1,sortBy:void 0,sortOrder:void 0,filterBase:1},query:{page:"page",count:"count",sortBy:"sort-by",sortOrder:"sort-order"},bootstrapIcon:!1,bindOnce:!0,loadOnInit:!1,iconUp:"fa fa-sort-up",iconDown:"fa fa-sort-down",listItemsPerPage:[5,25,50,100],itemsPerPage:5,templateHeadUrl:"template/table/head.html",templateUrl:"template/table/pagination.html",watchResource:"reference"}).controller("TableController",["$scope","$attrs","$filter","tableConfig","tastyUtil",function($scope,$attrs,$filter,tableConfig,tastyUtil){var listScopeToWatch,newScopeName,initStatus,updateClientSideResource,updateServerSideResource,setDirectivesValues,buildClientResource,buildUrl,paramsInitialCycle,initNow,filterChangedPage,vm=this;vm.$scope=$scope,initStatus={},initNow=!0,paramsInitialCycle=!0,$scope.init={},$scope.query={},$scope.logs={buildClientResourceCount:0,updateServerSideResourceRunning:0},$scope.theme={},listScopeToWatch=["bindFilters","bindFiltersComparator","bindInit","bindQuery","bindResource","bindResourceCallback","bindWatchResource","bindReload","bindTheme"],listScopeToWatch.forEach(function(scopeName){newScopeName=scopeName.substring(4),newScopeName=newScopeName.charAt(0).toLowerCase()+newScopeName.slice(1),$attrs[scopeName]?tastyUtil.bindTo(scopeName,$scope,$attrs,newScopeName):$attrs[newScopeName]&&"watchResource"===newScopeName?$scope[newScopeName]=$attrs[newScopeName]:$attrs[newScopeName]&&"filtersComparator"===newScopeName&&($scope[newScopeName]=JSON.parse($attrs[newScopeName]))}),vm.config={},angular.isObject($scope.theme)?Object.keys(tableConfig).forEach(function(key){vm.config[key]=angular.isDefined($scope.theme[key])?$scope.theme[key]:tableConfig[key]},vm):vm.config=tableConfig,$scope.query.page=$scope.query.page||vm.config.query.page,$scope.query.count=$scope.query.count||vm.config.query.count,$scope.query.sortBy=$scope.query.sortBy||vm.config.query.sortBy,$scope.query.sortOrder=$scope.query.sortOrder||vm.config.query.sortOrder,$scope.reload&&!vm.config.loadOnInit&&(initNow=!1),$scope.init.count=$scope.init.count||vm.config.init.count,$scope.init.page=$scope.init.page||vm.config.init.page,$scope.init.sortBy=$scope.init.sortBy||vm.config.init.sortBy,$scope.init.sortOrder=$scope.init.sortOrder||vm.config.init.sortOrder,$scope.init.filterBase=angular.isUndefined($scope.init.filterBase)?vm.config.init.filterBase:$scope.init.filterBase,$scope.watchResource=$scope.watchResource||vm.config.watchResource;var listImmutableKey=["filters","init","query","rows","header","pagination","params","sortOrder","sortBy","url"];if($scope.clientSide=!0,$scope.url="",$scope.header={columns:[]},$scope.rows=[],$scope.params={},$scope.pagination={count:$scope.init.count,page:$scope.init.page,pages:1,size:0},$scope.theadDirective=!1,$scope.paginationDirective=!1,!angular.isDefined($attrs.bindResource)&&!angular.isDefined($attrs.bindResourceCallback))throw new Error("Angular tastyTable directive: need the bind-resource or bind-resource-callback attribute");if(angular.isDefined($attrs.bindResource)){if(!angular.isObject($scope.resource))throw new Error("Angular tastyTable directive: the bind-resource ("+$attrs.bindResource+") is not an object");if(!$scope.resource.header&&!$scope.resource.rows)throw new Error("Angular tastyTable directive: the bind-resource ("+$attrs.bindResource+") has the property header or rows undefined")}if(angular.isDefined($attrs.bindResourceCallback)){if(!angular.isFunction($scope.resourceCallback))throw new Error("Angular tastyTable directive: the bind-resource-callback ("+$attrs.bindResourceCallback+") is not a function");$scope.clientSide=!1}if(vm.start=!1,vm.activate=function(directiveName){$scope[directiveName+"Directive"]=!0,$scope.params[directiveName]=!0},vm.setParams=function(key,value){$scope.params[key]=value,["sortBy","sortOrder"].indexOf(key)>=0&&($scope.header[key]=value)},vm.initTable=function(keyDirective){initStatus[keyDirective]=!0,$scope.theadDirective||$scope.paginationDirective?$scope.theadDirective&&$scope.paginationDirective?initStatus.thead&&initStatus.pagination&&(vm.start=!0):$scope.theadDirective&&!$scope.paginationDirective?initStatus.thead&&(vm.start=!0):!$scope.theadDirective&&$scope.paginationDirective&&initStatus.pagination&&(vm.start=!0):vm.start=!0,vm.start&&($scope.clientSide?($scope.params.sortBy=$scope.resource.sortBy||$scope.init.sortBy,$scope.params.sortOrder=$scope.resource.sortOrder||$scope.init.sortOrder,$scope.params.page=$scope.init.page,$scope.resource.pagination&&($scope.params.page=$scope.resource.pagination.page||$scope.init.page),initNow&&$scope.$evalAsync(updateClientSideResource)):($scope.params.sortBy=$scope.init.sortBy,$scope.params.sortOrder=$scope.init.sortOrder,$scope.params.page=$scope.init.page,initNow?$scope.$evalAsync(updateServerSideResource):$scope.reload&&($scope.url=buildUrl($scope.params,$scope.filters),$scope.reload=function(){$scope.resourceCallback($scope.url,angular.copy($scope.params)).then(function(resource){setDirectivesValues(resource)})})))},vm.bindOnce=vm.config.bindOnce,setDirectivesValues=function(resource){if(!angular.isObject(resource))throw new Error("Angular tastyTable directive: the resource response is not an object");if(!resource.header&&!resource.rows)throw new Error("Angular tastyTable directive: the resource response object has the property header or rows undefined");Object.keys(resource).forEach(function(key){listImmutableKey.indexOf(key)<0&&($scope[key]=resource[key])}),resource.header.length&&1===Object.keys(resource.header[0]).length&&(resource.header=resource.header.map(function(header){var key=Object.keys(header)[0];return{key:key,name:header[key]}})),$scope.header={columns:resource.header,sortBy:$scope.params.sortBy,sortOrder:$scope.params.sortOrder},$scope.clientSide||($scope.header.sortBy=$scope.header.sortBy||resource.sortBy,$scope.header.sortOrder=$scope.header.sortOrder||resource.sortOrder),$scope.rows=resource.rows,$scope.paginationDirective&&($scope.pagination.page=$scope.params.page,$scope.pagination.count=$scope.params.count,$scope.pagination.size=$scope.rows.length,resource.pagination&&(resource.pagination.count&&($scope.pagination.count=resource.pagination.count),resource.pagination.page&&($scope.pagination.page=resource.pagination.page),resource.pagination.size&&($scope.pagination.size=resource.pagination.size)),$scope.pagination.pages=Math.ceil($scope.pagination.size/$scope.pagination.count),$scope.pagination.pages<$scope.pagination.page&&($scope.params.page=$scope.pagination.pages))},buildClientResource=function(updateFrom){var fromRow,toRow,rowToShow,reverse,listSortBy;$scope.logs.buildClientResourceCount+=1,$scope.theadDirective&&$scope.header.columns.length&&(reverse="asc"===$scope.header.sortOrder?!1:!0,listSortBy=[function(item){return $scope.header.sortBy.split(".").reduce(function(previousValue,currentValue){return previousValue[currentValue]},item)}],$scope.header.columns[0].key!==$scope.header.sortBy&&listSortBy.push(function(item){return $scope.header.columns[0].key.split(".").reduce(function(previousValue,currentValue){return previousValue[currentValue]},item)}),$scope.header.sortBy&&($scope.rows=$filter("orderBy")($scope.rows,listSortBy,reverse))),$attrs.bindFilters&&($scope.rows=$filter("filter")($scope.rows,$scope.filters,$scope.filtersComparator)),$scope.paginationDirective&&($scope.pagination.count=$scope.params.count,$scope.pagination.size=$scope.rows.length,$scope.pagination.pages=Math.ceil($scope.rows.length/$scope.pagination.count),"filters"===updateFrom||$scope.pagination.page>$scope.pagination.pages?($scope.pagination.page=1,$scope.params.page=1):$scope.pagination.page=$scope.params.page,toRow=$scope.pagination.count*$scope.pagination.page,fromRow=toRow-$scope.pagination.count,fromRow>=0&&toRow>=0&&(rowToShow=$scope.rows.slice(fromRow,toRow),$scope.rows=rowToShow))},buildUrl=function(params,filters){var urlQuery,value,listKeyNotJoin;return urlQuery={},listKeyNotJoin=["sortBy","sortOrder","page","count"],$scope.theadDirective&&(urlQuery=tastyUtil.setProperty(urlQuery,params,"sortBy"),urlQuery=tastyUtil.setProperty(urlQuery,params,"sortOrder")),$scope.paginationDirective&&(urlQuery=tastyUtil.setProperty(urlQuery,params,"page"),urlQuery=tastyUtil.setProperty(urlQuery,params,"count")),$attrs.bindFilters&&(urlQuery=tastyUtil.joinObjects(urlQuery,filters,listKeyNotJoin)),Object.keys(urlQuery).map(function(key){return value=urlQuery[key],$scope.query[key]&&(key=$scope.query[key]),encodeURIComponent(key)+"="+encodeURIComponent(value)}).join("&")},updateClientSideResource=function(updateFrom){$scope.params.sortBy&&($scope.resource.sortBy=$scope.params.sortBy),$scope.params.sortOrder&&($scope.resource.sortOrder=$scope.params.sortOrder),$scope.params.page&&$scope.params.count&&($scope.resource.pagination=$scope.pagination,$scope.resource.pagination.page=$scope.params.page,$scope.resource.pagination.count=$scope.params.count),setDirectivesValues($scope.resource),buildClientResource(updateFrom)},updateServerSideResource=function(updateFrom){function updateServerSideResource(){$scope.logs.updateServerSideResourceRunning=!0;var paramsObj=angular.copy($scope.params);paramsObj.filters=$scope.filters,$scope.resourceCallback($scope.url,paramsObj).then(function(resource){setDirectivesValues(resource),$scope.logs.updateServerSideResourceRunning=!1})}"filters"===updateFrom&&Number.isInteger($scope.init.filterBase)&&($scope.params.page!==$scope.init.filterBase&&(filterChangedPage=!0),$scope.params.page=$scope.init.filterBase),$scope.url=buildUrl($scope.params,$scope.filters),$scope.reload&&($scope.reload=updateServerSideResource),!initNow&&"params"!==updateFrom||$scope.logs.updateServerSideResourceRunning||($scope.reload?filterChangedPage||updateServerSideResource():(updateServerSideResource(),filterChangedPage=!1))},$attrs.bindFilters&&$scope.$watch("filters",function(newValue,oldValue){newValue!==oldValue&&($scope.clientSide?$scope.$evalAsync(updateClientSideResource("filters")):$scope.$evalAsync(updateServerSideResource("filters")))},!0),$scope.$watchCollection("params",function(newValue,oldValue){newValue!==oldValue&&(paramsInitialCycle===!1?$scope.clientSide?$scope.$evalAsync(updateClientSideResource("params")):$scope.$evalAsync(updateServerSideResource("params")):paramsInitialCycle=!1)}),$scope.resource){var watchResource=function(newValue,oldValue){newValue!==oldValue&&($scope.params.sortBy=$scope.resource.sortBy||$scope.params.sortBy,$scope.params.sortOrder=$scope.resource.sortOrder||$scope.params.sortOrder,$scope.$evalAsync(updateClientSideResource("resource")),$scope.resource.reload||($scope.resource.reload=function(){$scope.$evalAsync(updateClientSideResource("resource"))}))};"reference"===$scope.watchResource?$scope.$watch("resource",watchResource):"collection"===$scope.watchResource?($scope.$watchCollection("resource.header",watchResource),$scope.$watchCollection("resource.rows",watchResource),$scope.$watchGroup(["resource.sortBy","resource.sortOrder","resource.pagination.count","resource.pagination.page","resource.pagination.pages","resource.pagination.size"],watchResource)):"equality"===$scope.watchResource&&($scope.$watch("resource.header",watchResource,!0),$scope.$watch("resource.rows",watchResource,!0),$scope.$watch("resource.sortBy",watchResource,!0),$scope.$watch("resource.sortOrder",watchResource,!0),$scope.$watch("resource.pagination.count",watchResource,!0),$scope.$watch("resource.pagination.page",watchResource,!0),$scope.$watch("resource.pagination.pages",watchResource,!0),$scope.$watch("resource.pagination.size",watchResource,!0))}}]).directive("tastyTable",function(){return{restrict:"A",scope:!0,controller:"TableController",link:function(scope,element,attrs,tastyTable){(element.find("tasty-thead").length||element[0].querySelector("[tasty-thead]"))&&tastyTable.activate("thead"),(element.find("tasty-pagination").length||element[0].querySelector("[tasty-pagination]"))&&tastyTable.activate("pagination"),tastyTable.initTable()}}}).directive("tastyThead",["$filter","$templateCache","$http","$compile","tableConfig","tastyUtil",function($filter,$templateCache,$http,$compile,tableConfig,tastyUtil){return{restrict:"AE",require:"^tastyTable",scope:{},templateUrl:tableConfig.templateHeadUrl,link:function(scope,element,attrs,tastyTable){function cleanSortBy(sortBy){return sortBy?$filter("cleanFieldName")(sortBy):void 0}var newScopeName,listScopeToWatch;scope.bindOnce=tastyTable.bindOnce,scope.columns=[],scope.bootstrapIcon=tastyTable.config.bootstrapIcon,scope.iconUp=tastyTable.config.iconUp,scope.iconDown=tastyTable.config.iconDown,listScopeToWatch=["bindNotSortBy","bindBootstrapIcon","bindIconUp","bindIconDown","bindTemplateUrl"],listScopeToWatch.forEach(function(scopeName){newScopeName=scopeName.substring(4),newScopeName=newScopeName.charAt(0).toLowerCase()+newScopeName.slice(1),attrs[scopeName]?tastyUtil.bindTo(scopeName,scope,attrs,newScopeName):attrs[newScopeName]&&("["===attrs[newScopeName][0]?(attrs[newScopeName]=attrs[newScopeName].replace(/'/g,'"'),scope[newScopeName]=JSON.parse(attrs[newScopeName])):scope[newScopeName]=attrs[newScopeName])}),scope.templateUrl&&$http.get(scope.templateUrl,{cache:$templateCache}).success(function(templateContent){element.replaceWith($compile(templateContent)(scope))}),scope.setColumns=function(){var active,sortable,sort,isSorted,isSortedCaret;scope.columns=[],"dsc"===scope.header.sortOrder&&scope.header.sortBy&&"-"!==scope.header.sortBy[0]&&(scope.header.sortBy="-"+scope.header.sortBy),scope.header.columns.forEach(function(column){if(column.style=column.style||{},angular.isArray(column.class)||(column.class=[]),sortable=!0,active=!1,isSorted="",isSortedCaret="",angular.isArray(scope.notSortBy)?sortable=scope.notSortBy.length?scope.notSortBy.indexOf(column.key)<0:!1:angular.isDefined(column.sortable)&&(sortable=column.sortable===!0),(column.key===scope.header.sortBy||"-"+column.key===scope.header.sortBy)&&(active=!0),!angular.isDefined(column.key))throw new Error("Angular tastyTable directive: need a key value each column table header");sort=$filter("cleanFieldName")(column.key),cleanSortBy(scope.header.sortBy)==="-"+sort?tastyTable.config.bootstrapIcon?(isSorted="",isSortedCaret="caret"):isSorted=scope.iconDown:cleanSortBy(scope.header.sortBy)===sort&&(tastyTable.config.bootstrapIcon?(isSorted="dropup",isSortedCaret="caret"):isSorted=scope.iconUp),scope.columns.push({key:column.key,name:column.name,active:active,sortable:sortable,"class":column.class,style:column.style,isSorted:isSorted,isSortedCaret:isSortedCaret})}),tastyTable.start||tastyTable.initTable("thead")},scope.sortBy=function(column){if(!column.sortable)return!1;var columnName,sortOrder;columnName=$filter("cleanFieldName")(column.key),sortOrder=cleanSortBy(scope.header.sortBy)===columnName?"dsc":"asc",tastyTable.setParams("sortBy",column.key),tastyTable.setParams("sortOrder",sortOrder)},scope.classToShow=function(column){var listClassToShow=[];return column.sortable&&listClassToShow.push("sortable"),column.active&&listClassToShow.push("active"),column.class.forEach(function(className){listClassToShow.push(className)}),listClassToShow},tastyTable.$scope.$watchCollection("header",function(newValue,oldValue){!newValue||newValue===oldValue&&tastyTable.start||(scope.header=newValue,scope.setColumns())})}}}]).directive("tastyPagination",["$filter","$templateCache","$http","$compile","tableConfig","tastyUtil",function($filter,$templateCache,$http,$compile,tableConfig,tastyUtil){return{restrict:"AE",require:"^tastyTable",scope:{},templateUrl:tableConfig.templateUrl,link:function(scope,element,attrs,tastyTable){var getPage,setCount,setPaginationRange,setPreviousRange,setRemainingRange,setPaginationRanges,listScopeToWatch,newScopeName;listScopeToWatch=["bindItemsPerPage","bindListItemsPerPage","bindTemplateUrl"],listScopeToWatch.forEach(function(scopeName){if(newScopeName=scopeName.substring(4),newScopeName=newScopeName.charAt(0).toLowerCase()+newScopeName.slice(1),attrs[scopeName])tastyUtil.bindTo(scopeName,scope,attrs,newScopeName);else if(attrs[newScopeName])if("itemsPerPage"===newScopeName)scope[newScopeName]=parseInt(attrs[newScopeName]);else try{scope[newScopeName]=JSON.parse(attrs[newScopeName])}catch(err){scope[newScopeName]=attrs[newScopeName]}}),scope.templateUrl&&$http.get(scope.templateUrl,{cache:$templateCache}).success(function(templateContent){element.replaceWith($compile(templateContent)(scope))}),scope.itemsPerPage=scope.itemsPerPage||tastyTable.config.itemsPerPage,scope.listItemsPerPage=scope.listItemsPerPage||tastyTable.config.listItemsPerPage,tastyTable.$scope.clientSide||(scope.itemsPerPage=tastyTable.$scope.init.count||scope.itemsPerPage),scope.pagination={},scope.pagMinRange=1,scope.pagMaxRange=1,getPage=function(numPage){tastyTable.setParams("page",numPage)},setCount=function(count){var maxItems,page;scope.itemsPerPage=count,maxItems=count*scope.pagination.page,maxItems>scope.pagination.size&&(page=Math.ceil(scope.pagination.size/count),tastyTable.setParams("page",page)),tastyTable.setParams("count",count)},setPaginationRange=function(){var currentPage;currentPage=scope.pagination.page,currentPage>scope.pagination.pages&&(currentPage=scope.pagination.pages),scope.pagMinRange=currentPage-2>0?currentPage-2:1,scope.pagMaxRange=currentPage+2,scope.pagination.page=currentPage,setPaginationRanges()},setPreviousRange=function(){return scope.pagHideMinRange===!0||scope.pagMinRange<1?!1:(scope.pagMaxRange=scope.pagMinRange,scope.pagMinRange=scope.pagMaxRange-5,setPaginationRanges(),void 0)},setRemainingRange=function(){return scope.pagHideMaxRange===!0||scope.pagMaxRange>scope.pagination.pages?!1:(scope.pagMinRange=scope.pagMaxRange,scope.pagMaxRange=scope.pagMinRange+5,scope.pagMaxRange>=scope.pagination.pages&&(scope.pagMaxRange=scope.pagination.pages+1,scope.pagMinRange=scope.pagMaxRange-5+1),scope.pagMinRange=scope.pagMaxRange-5,setPaginationRanges(),void 0)},setPaginationRanges=function(){scope.listItemsPerPageShow=[],scope.pagMinRange=scope.pagMinRange>0?scope.pagMinRange:1,scope.pagMaxRange=scope.pagMinRange+5,scope.pagMaxRange>scope.pagination.pages&&(scope.pagMaxRange=scope.pagination.pages+1),scope.pagHideMinRange=scope.pagMinRange<=1,scope.pagHideMaxRange=scope.pagMaxRange>scope.pagination.pages,scope.classPageMinRange=scope.pagHideMinRange?"disabled":"",scope.classPageMaxRange=scope.pagHideMaxRange?"disabled":"";for(var i=scope.listItemsPerPage.length;i>=0;i--)if(scope.pagination.size>scope.listItemsPerPage[i]){scope.listItemsPerPageShow=scope.listItemsPerPage.slice(0,i+2);break}scope.rangePage=$filter("range")([],scope.pagMinRange,scope.pagMaxRange),tastyTable.start||tastyTable.initTable("pagination")},scope.classPaginationCount=function(count){return count==scope.pagination.count?"active":""},scope.classNumPage=function(numPage){return numPage==scope.pagination.page?"active":!1},scope.page={get:getPage,setCount:setCount,previous:setPreviousRange,remaining:setRemainingRange},tastyTable.$scope.$watchCollection("pagination",function(newValue,oldValue){!newValue||newValue===oldValue&&tastyTable.start||(scope.pagination=newValue,setPaginationRange())}),scope.page.setCount(scope.itemsPerPage)}}}]),angular.module("ngTasty.filter.camelize",[]).filter("camelize",function(){var CAMELIZE_REGEX=/(?:^|[-_ ])(\w)/g;return function(input,first){var isString="string"==typeof input,firstLetter="undefined"==typeof first?!1:!!first;return"undefined"==typeof input||null===input||!isString&&isNaN(input)?"":isString?input.trim().replace(/ +(?= )/g,"").replace(CAMELIZE_REGEX,function(_,character,pos){return character&&(firstLetter||pos>0)?character.toUpperCase():character}):""+input}}),angular.module("ngTasty.filter.cleanFieldName",[]).filter("cleanFieldName",function(){return function(input){return input.replace(/[^a-zA-Z0-9-_-]+/g,"-")}}),angular.module("ngTasty.filter.filterInt",[]).filter("filterInt",function(){return function(input){return/^(\-|\+)?([0-9]+|Infinity)$/.test(input)?Number(input):0/0}}),angular.module("ngTasty.filter.range",["ngTasty.filter.filterInt"]).filter("range",["$filter",function($filter){return function(input,start,stop,step){if(start=$filter("filterInt")(start),stop=$filter("filterInt")(stop),step=$filter("filterInt")(step),isNaN(start)&&(start=0),isNaN(stop)&&(stop=start,start=0),isNaN(step)&&(step=1),step>0&&start>=stop||0>step&&stop>=start)return[];for(var i=start;step>0?stop>i:i>stop;i+=step)input.push(i);return input}}]),angular.module("ngTasty.filter.slugify",[]).filter("slugify",function(){var makeString=function(object){return null==object?"":""+object},from="ąàáäâãåæăćčĉęèéëêĝĥìíïîĵłľńňòóöőôõðøśșšŝťțŭùúüűûñÿýçżźž",to="aaaaaaaaaccceeeeeghiiiijllnnoooooooossssttuuuuuunyyczzz",regex=new RegExp("["+from+"]","g");return function(str){return str=makeString(str).toString().toLowerCase().replace(regex,function(c){var index=from.indexOf(c);return to.charAt(index)||"-"}).replace(/[^\w\-\s]+/g,"").trim().replace(/\s+/g,"-").replace(/\-\-+/g,"-")}}),angular.module("ngTasty.service.bindTo",[]).factory("bindTo",["$parse",function($parse){return function(scopeName,scope,attrs,newScopeName){var lastValue,parentGet,compare,parentSet,parentValueWatch,isolateScopeName;attrs[scopeName]&&(parentGet=$parse(attrs[scopeName]),compare=parentGet.literal?angular.equals:function(a,b){return a===b||a!==a&&b!==b},isolateScopeName=newScopeName?newScopeName:scopeName,parentSet=parentGet.assign||function(){throw lastValue=scope[scopeName]=parentGet(scopeName),"Expression "+attrs[attrName]+" is non-assignable!"},lastValue=scope[isolateScopeName]=parentGet(scope.$parent),parentValueWatch=function(parentValue){return compare(parentValue,scope[isolateScopeName])||(compare(parentValue,lastValue)?parentSet(scope.$parent,parentValue=scope[isolateScopeName]):scope[isolateScopeName]=parentValue),lastValue=parentValue},parentValueWatch.$stateful=!0,scope.$parent.$watch($parse(attrs[scopeName],parentValueWatch),null,parentGet.literal))}}]),angular.module("ngTasty.service.debounce",[]).factory("debounce",["$timeout",function($timeout){return function(func,wait,immediate){var args,context,debounceTimeout,timeout;return debounceTimeout=function(){timeout=null,immediate||func.apply(context,args)},function(){context=this,args=arguments;var callNow=immediate&&!timeout;$timeout.cancel(timeout),timeout=$timeout(debounceTimeout,wait),callNow&&func.apply(context,args)}}}]),angular.module("ngTasty.service.joinObjects",["ngTasty.service.setProperty"]).factory("joinObjects",["setProperty",function(setProperty){return function(objOne,objTwo,listKeyNotJoin){listKeyNotJoin=listKeyNotJoin||[];for(var attrname in objTwo)listKeyNotJoin.indexOf(attrname)<0&&setProperty(objOne,objTwo,attrname);return objOne}}]),angular.module("ngTasty.service.setProperty",[]).factory("setProperty",function(){return function(objOne,objTwo,attrname){return"undefined"!=typeof objTwo[attrname]&&null!==objTwo[attrname]&&(angular.isString(objTwo[attrname])?objTwo[attrname].length&&(objOne[attrname]=objTwo[attrname]):objOne[attrname]=objTwo[attrname]),objOne}}),angular.module("ngTasty.service.tastyUtil",["ngTasty.service.bindTo","ngTasty.service.debounce","ngTasty.service.setProperty","ngTasty.service.joinObjects","ngTasty.service.throttle","ngTasty.service.webSocket"]).factory("tastyUtil",["debounce","setProperty","joinObjects","bindTo","webSocket","throttle",function(debounce,setProperty,joinObjects,bindTo,webSocket,throttle){return{bindTo:bindTo,debounce:debounce,setProperty:setProperty,joinObjects:joinObjects,throttle:throttle,webSocket:webSocket}}]),angular.module("ngTasty.service.throttle",[]).factory("throttle",["$timeout",function($timeout){return function(fn,threshhold,scope){threshhold=threshhold||250;var last,promise;return function(){var context=scope||this,now=Date.now(),args=arguments;last&&last+threshhold>now?($timeout.cancel(promise),promise=$timeout(function(){last=now,fn.apply(context,args)},threshhold)):(last=now,fn.apply(context,args))}}}]),angular.module("ngTasty.service.webSocket",[]).factory("webSocket",function(){return function(url){var blobURL=URL.createObjectURL(new Blob(["(",function(){var WSWorker=function(){var _ws,initialize=function(url){_ws=new WebSocket(url)},on=function(){_ws.onmessage=function(response){var data=JSON.parse(response.data);self.postMessage(data)}},send=function(data){_ws.send(data)};return{initialize:initialize,on:on,send:send}}();self.addEventListener("message",function(e){switch(e.data.cmd){case"ws_new":WSWorker.initialize(e.data.url);break;case"ws_on":WSWorker.on();break;case"ws_send":WSWorker.send(JSON.stringify(e.data.data));break;default:console.log("Unknown command: "+e.data.cmd)}})}.toString(),")()"],{type:"application/javascript"})),_worker=new Worker(blobURL);return URL.revokeObjectURL(blobURL),_worker.postMessage({cmd:"ws_new",url:url}),{on:function(event,cb){_worker.postMessage({cmd:"ws_on"}),_worker.addEventListener("message",function(e){("all"===event||e.data.type===event)&&cb(e.data)})},send:function(data){_worker.postMessage({cmd:"ws_send",data:data})}}}}),function(module){try{module=angular.module("ngTasty.tpls.table.head")}catch(e){module=angular.module("ngTasty.tpls.table.head",[])}module.run(["$templateCache",function($templateCache){$templateCache.put("template/table/head.html",'<tr>\n  <th ng-repeat="column in columns track by $index" \n  ng-class="classToShow(column)"\n  ng-style="::column.style" ng-click="sortBy(column)">\n    <span ng-if="bindOnce" ng-bind="::column.name"></span>\n    <span ng-if="!bindOnce" ng-bind="column.name"></span>\n    <span ng-class="column.isSorted">\n      <span ng-class="column.isSortedCaret" ng-if="::bootstrapIcon"></span>\n    </span>\n  </th> \n</tr>')}])}(),function(module){try{module=angular.module("ngTasty.tpls.table.pagination")}catch(e){module=angular.module("ngTasty.tpls.table.pagination",[])}module.run(["$templateCache",function($templateCache){$templateCache.put("template/table/pagination.html",'<div class="row">\n  <div class="col-xs-3 text-left">\n    <div class="btn-group">\n      <button type="button" class="btn btn-default" \n      ng-repeat="count in listItemsPerPageShow" \n      ng-class="classPaginationCount(count)" \n      ng-click="page.setCount(count)" ng-bind="count"></button>\n    </div>\n  </div>\n  <div class="col-xs-6 text-center">\n    <ul class="pagination">\n      <li ng-class="classPageMinRange">\n        <a href ng-click="page.previous()">&laquo;</a>\n      </li>\n      <li ng-repeat="numPage in rangePage" ng-class="classNumPage(numPage)">\n        <a href ng-click="page.get(numPage)">\n          <span ng-bind="numPage"></span>\n          <span class="sr-only" ng-if="classNumPage(numPage)">(current)</span>\n        </a>\n      </li>\n      <li ng-class="classPageMaxRange">\n        <a href ng-click="page.remaining()">&raquo;</a>\n      </li>\n    </ul>\n  </div>\n  <div class="col-xs-3 text-right">\n    <p>Page <span ng-bind="pagination.page"></span> \n    of <span ng-bind="pagination.pages"></span>,\n    of <span ng-bind="pagination.size"></span> entries</p>\n  </div>\n</div>')}])}();;/** 
* @version 2.1.10
* @license MIT
*/
!function(t,e){"use strict";t.module("smart-table",[]).run(["$templateCache",function(t){t.put("template/smart-table/pagination.html",'<nav ng-if="numPages && pages.length >= 2"><ul class="pagination"><li ng-repeat="page in pages" ng-class="{active: page==currentPage}"><a href="#" ng-click="selectPage(page); $event.preventDefault(); $event.stopPropagation();">{{page}}</a></li></ul></nav>')}]),t.module("smart-table").constant("stConfig",{pagination:{template:"template/smart-table/pagination.html",itemsByPage:10,displayedPages:5},search:{delay:400,inputEvent:"input",trimSearch:!1},select:{mode:"single",selectedClass:"st-selected"},sort:{ascentClass:"st-sort-ascent",descentClass:"st-sort-descent",descendingFirst:!1,skipNatural:!1,delay:300},pipe:{delay:100}}),t.module("smart-table").controller("stTableController",["$scope","$parse","$filter","$attrs",function(a,n,s,r){function i(t){return t?[].concat(t):[]}function c(){b=i(o(a)),!0===S&&P.pipe()}function l(t,e){if(-1!=e.indexOf(".")){var a=e.split("."),s=a.pop(),r=a.join("."),i=n(r)(t);delete i[s],0==Object.keys(i).length&&l(t,r)}else delete t[e]}var o,u,p,g=r.stTable,d=n(g),f=d.assign,m=s("orderBy"),h=s("filter"),b=i(d(a)),v={sort:{},search:{},pagination:{start:0,totalItemCount:0}},S=!0,P=this;r.stSafeSrc&&(o=n(r.stSafeSrc),a.$watch(function(){var t=o(a);return t&&t.length?t[0]:e},function(t,e){t!==e&&c()}),a.$watch(function(){var t=o(a);return t?t.length:0},function(t,e){t!==b.length&&c()}),a.$watch(function(){return o(a)},function(t,e){t!==e&&(v.pagination.start=0,c())})),this.sortBy=function(e,a){return v.sort.predicate=e,v.sort.reverse=!0===a,t.isFunction(e)?v.sort.functionName=e.name:delete v.sort.functionName,v.pagination.start=0,this.pipe()},this.search=function(t,e,a){var s=v.search.predicateObject||{},r=e||"$";return n(r).assign(s,t),t||l(s,r),v.search.predicateObject=s,v.pagination.start=0,this.pipe()},this.pipe=function(){var t,n=v.pagination;u=v.search.predicateObject?h(b,v.search.predicateObject):b,v.sort.predicate&&(u=m(u,v.sort.predicate,v.sort.reverse)),n.totalItemCount=u.length,n.number!==e&&(n.numberOfPages=u.length>0?Math.ceil(u.length/n.number):1,n.start=n.start>=u.length?(n.numberOfPages-1)*n.number:n.start,t=u.slice(n.start,n.start+parseInt(n.number))),f(a,t||u)},this.select=function(t,n){var s=i(d(a)),r=s.indexOf(t);-1!==r&&("single"===n?(t.isSelected=!0!==t.isSelected,p&&(p.isSelected=!1),p=!0===t.isSelected?t:e):s[r].isSelected=!s[r].isSelected)},this.slice=function(t,e){return v.pagination.start=t,v.pagination.number=e,this.pipe()},this.tableState=function(){return v},this.getFilteredCollection=function(){return u||b},this.setFilterFunction=function(t){h=s(t)},this.setSortFunction=function(t){m=s(t)},this.preventPipeOnWatch=function(){S=!1}}]).directive("stTable",function(){return{restrict:"A",controller:"stTableController",link:function(t,e,a,n){a.stSetFilter&&n.setFilterFunction(a.stSetFilter),a.stSetSort&&n.setSortFunction(a.stSetSort)}}}),t.module("smart-table").directive("stSearch",["stConfig","$timeout","$parse",function(e,a,n){return{require:"^stTable",link:function(s,r,i,c){var l=c,o=null,u=i.stDelay||e.search.delay,p=i.stInputEvent||e.search.inputEvent,g=i.trimSearch||e.search.trimSearch;i.$observe("stSearch",function(e,a){var n=r[0].value;e!==a&&n&&(c.tableState().search={},n=t.isString(n)&&g?n.trim():n,l.search(n,e))}),s.$watch(function(){return c.tableState().search},function(t,e){var a=i.stSearch||"$";t.predicateObject&&n(a)(t.predicateObject)!==r[0].value&&(r[0].value=n(a)(t.predicateObject)||"")},!0),r.bind(p,function(e){e=e.originalEvent||e,null!==o&&a.cancel(o),o=a(function(){var a=e.target.value;a=t.isString(a)&&g?a.trim():a,l.search(a,i.stSearch||""),o=null},u)})}}}]),t.module("smart-table").directive("stSelectRow",["stConfig",function(t){return{restrict:"A",require:"^stTable",scope:{row:"=stSelectRow"},link:function(e,a,n,s){var r=n.stSelectMode||t.select.mode;a.bind("click",function(){e.$apply(function(){s.select(e.row,r)})}),e.$watch("row.isSelected",function(e){!0===e?a.addClass(t.select.selectedClass):a.removeClass(t.select.selectedClass)})}}}]),t.module("smart-table").directive("stSort",["stConfig","$parse","$timeout",function(a,n,s){return{restrict:"A",require:"^stTable",link:function(r,i,c,l){function o(){v?d=0===d?2:d-1:d++;var e;p=t.isFunction(g(r))||t.isArray(g(r))?g(r):c.stSort,d%3==0&&!0!=!!b?(d=0,l.tableState().sort={},l.tableState().pagination.start=0,e=l.pipe.bind(l)):e=l.sortBy.bind(l,p,d%2==0),null!==S&&s.cancel(S),P<0?e():S=s(function(){e()},P)}var u,p=c.stSort,g=n(p),d=0,f=c.stClassAscent||a.sort.ascentClass,m=c.stClassDescent||a.sort.descentClass,h=[f,m],b=c.stSkipNatural!==e?c.stSkipNatural:a.sort.skipNatural,v=c.stDescendingFirst!==e?c.stDescendingFirst:a.sort.descendingFirst,S=null,P=c.stDelay||a.sort.delay,y="aria-sort";i.attr("role","columnheader").attr(y,"none"),c.stSortDefault&&(u=r.$eval(c.stSortDefault)!==e?r.$eval(c.stSortDefault):c.stSortDefault),i.bind("click",function(){p&&r.$apply(o)}),u&&(d="reverse"===u?1:0,o()),r.$watch(function(){return l.tableState().sort},function(t){t.predicate!==p?(d=0,i.removeClass(f).removeClass(m).attr(y,"none")):(d=!0===t.reverse?2:1,i.removeClass(h[d%2]).addClass(h[d-1]).attr(y,t.reverse?"ascending":"descending"))},!0)}}}]),t.module("smart-table").directive("stPagination",["stConfig",function(t){return{restrict:"EA",require:"^stTable",scope:{stItemsByPage:"=?",stDisplayedPages:"=?",stPageChange:"&"},templateUrl:function(e,a){return a.stTemplate?a.stTemplate:t.pagination.template},link:function(e,a,n,s){function r(){var t,a,n=s.tableState().pagination,r=1,i=e.currentPage;for(e.totalItemCount=n.totalItemCount,e.currentPage=Math.floor(n.start/n.number)+1,(t=(r=Math.max(r,e.currentPage-Math.abs(Math.floor(e.stDisplayedPages/2))))+e.stDisplayedPages)>n.numberOfPages&&(t=n.numberOfPages+1,r=Math.max(1,t-e.stDisplayedPages)),e.pages=[],e.numPages=n.numberOfPages,a=r;a<t;a++)e.pages.push(a);i!==e.currentPage&&e.stPageChange({newPage:e.currentPage})}e.stItemsByPage=e.stItemsByPage?+e.stItemsByPage:t.pagination.itemsByPage,e.stDisplayedPages=e.stDisplayedPages?+e.stDisplayedPages:t.pagination.displayedPages,e.currentPage=1,e.pages=[],e.$watch(function(){return s.tableState().pagination},r,!0),e.$watch("stItemsByPage",function(t,a){t!==a&&e.selectPage(1)}),e.$watch("stDisplayedPages",r),e.selectPage=function(t){t>0&&t<=e.numPages&&s.slice((t-1)*e.stItemsByPage,e.stItemsByPage)},s.tableState().pagination.number||s.slice(0,e.stItemsByPage)}}}]),t.module("smart-table").directive("stPipe",["stConfig","$timeout",function(e,a){return{require:"stTable",scope:{stPipe:"="},link:{pre:function(n,s,r,i){var c=null;t.isFunction(n.stPipe)&&(i.preventPipeOnWatch(),i.pipe=function(){return null!==c&&a.cancel(c),c=a(function(){n.stPipe(i.tableState(),i)},e.pipe.delay)})},post:function(t,e,a,n){n.pipe()}}}}])}(angular);
//# sourceMappingURL=smart-table.min.js.map
;/*! 12.2.13 */
!window.XMLHttpRequest||window.FileAPI&&FileAPI.shouldLoad||(window.XMLHttpRequest.prototype.setRequestHeader=function(a){return function(b,c){if("__setXHR_"===b){var d=c(this);d instanceof Function&&d(this)}else a.apply(this,arguments)}}(window.XMLHttpRequest.prototype.setRequestHeader));var ngFileUpload=angular.module("ngFileUpload",[]);ngFileUpload.version="12.2.13",ngFileUpload.service("UploadBase",["$http","$q","$timeout",function(a,b,c){function d(d){function e(a){j.notify&&j.notify(a),k.progressFunc&&c(function(){k.progressFunc(a)})}function h(a){return null!=d._start&&g?{loaded:a.loaded+d._start,total:d._file&&d._file.size||a.total,type:a.type,config:d,lengthComputable:!0,target:a.target}:a}function i(){a(d).then(function(a){if(g&&d._chunkSize&&!d._finished&&d._file){var b=d._file&&d._file.size||0;e({loaded:Math.min(d._end,b),total:b,config:d,type:"progress"}),f.upload(d,!0)}else d._finished&&delete d._finished,j.resolve(a)},function(a){j.reject(a)},function(a){j.notify(a)})}d.method=d.method||"POST",d.headers=d.headers||{};var j=d._deferred=d._deferred||b.defer(),k=j.promise;return d.disableProgress||(d.headers.__setXHR_=function(){return function(a){a&&a.upload&&a.upload.addEventListener&&(d.__XHR=a,d.xhrFn&&d.xhrFn(a),a.upload.addEventListener("progress",function(a){a.config=d,e(h(a))},!1),a.upload.addEventListener("load",function(a){a.lengthComputable&&(a.config=d,e(h(a)))},!1))}}),g?d._chunkSize&&d._end&&!d._finished?(d._start=d._end,d._end+=d._chunkSize,i()):d.resumeSizeUrl?a.get(d.resumeSizeUrl).then(function(a){d._start=d.resumeSizeResponseReader?d.resumeSizeResponseReader(a.data):parseInt((null==a.data.size?a.data:a.data.size).toString()),d._chunkSize&&(d._end=d._start+d._chunkSize),i()},function(a){throw a}):d.resumeSize?d.resumeSize().then(function(a){d._start=a,d._chunkSize&&(d._end=d._start+d._chunkSize),i()},function(a){throw a}):(d._chunkSize&&(d._start=0,d._end=d._start+d._chunkSize),i()):i(),k.success=function(a){return k.then(function(b){a(b.data,b.status,b.headers,d)}),k},k.error=function(a){return k.then(null,function(b){a(b.data,b.status,b.headers,d)}),k},k.progress=function(a){return k.progressFunc=a,k.then(null,null,function(b){a(b)}),k},k.abort=k.pause=function(){return d.__XHR&&c(function(){d.__XHR.abort()}),k},k.xhr=function(a){return d.xhrFn=function(b){return function(){b&&b.apply(k,arguments),a.apply(k,arguments)}}(d.xhrFn),k},f.promisesCount++,k["finally"]&&k["finally"]instanceof Function&&k["finally"](function(){f.promisesCount--}),k}function e(a){var b={};for(var c in a)a.hasOwnProperty(c)&&(b[c]=a[c]);return b}var f=this;f.promisesCount=0,this.isResumeSupported=function(){return window.Blob&&window.Blob.prototype.slice};var g=this.isResumeSupported();this.isUploadInProgress=function(){return f.promisesCount>0},this.rename=function(a,b){return a.ngfName=b,a},this.jsonBlob=function(a){null==a||angular.isString(a)||(a=JSON.stringify(a));var b=new window.Blob([a],{type:"application/json"});return b._ngfBlob=!0,b},this.json=function(a){return angular.toJson(a)},this.isFile=function(a){return null!=a&&(a instanceof window.Blob||a.flashId&&a.name&&a.size)},this.upload=function(a,b){function c(b,c){if(b._ngfBlob)return b;if(a._file=a._file||b,null!=a._start&&g){a._end&&a._end>=b.size&&(a._finished=!0,a._end=b.size);var d=b.slice(a._start,a._end||b.size);return d.name=b.name,d.ngfName=b.ngfName,a._chunkSize&&(c.append("_chunkSize",a._chunkSize),c.append("_currentChunkSize",a._end-a._start),c.append("_chunkNumber",Math.floor(a._start/a._chunkSize)),c.append("_totalSize",a._file.size)),d}return b}function h(b,d,e){if(void 0!==d)if(angular.isDate(d)&&(d=d.toISOString()),angular.isString(d))b.append(e,d);else if(f.isFile(d)){var g=c(d,b),i=e.split(",");i[1]&&(g.ngfName=i[1].replace(/^\s+|\s+$/g,""),e=i[0]),a._fileKey=a._fileKey||e,b.append(e,g,g.ngfName||g.name)}else if(angular.isObject(d)){if(d.$$ngfCircularDetection)throw"ngFileUpload: Circular reference in config.data. Make sure specified data for Upload.upload() has no circular reference: "+e;d.$$ngfCircularDetection=!0;try{for(var j in d)if(d.hasOwnProperty(j)&&"$$ngfCircularDetection"!==j){var k=null==a.objectKey?"[i]":a.objectKey;d.length&&parseInt(j)>-1&&(k=null==a.arrayKey?k:a.arrayKey),h(b,d[j],e+k.replace(/[ik]/g,j))}}finally{delete d.$$ngfCircularDetection}}else b.append(e,d)}function i(){a._chunkSize=f.translateScalars(a.resumeChunkSize),a._chunkSize=a._chunkSize?parseInt(a._chunkSize.toString()):null,a.headers=a.headers||{},a.headers["Content-Type"]=void 0,a.transformRequest=a.transformRequest?angular.isArray(a.transformRequest)?a.transformRequest:[a.transformRequest]:[],a.transformRequest.push(function(b){var c,d=new window.FormData;b=b||a.fields||{},a.file&&(b.file=a.file);for(c in b)if(b.hasOwnProperty(c)){var e=b[c];a.formDataAppender?a.formDataAppender(d,c,e):h(d,e,c)}return d})}return b||(a=e(a)),a._isDigested||(a._isDigested=!0,i()),d(a)},this.http=function(b){return b=e(b),b.transformRequest=b.transformRequest||function(b){return window.ArrayBuffer&&b instanceof window.ArrayBuffer||b instanceof window.Blob?b:a.defaults.transformRequest[0].apply(this,arguments)},b._chunkSize=f.translateScalars(b.resumeChunkSize),b._chunkSize=b._chunkSize?parseInt(b._chunkSize.toString()):null,d(b)},this.translateScalars=function(a){if(angular.isString(a)){if(a.search(/kb/i)===a.length-2)return parseFloat(1024*a.substring(0,a.length-2));if(a.search(/mb/i)===a.length-2)return parseFloat(1048576*a.substring(0,a.length-2));if(a.search(/gb/i)===a.length-2)return parseFloat(1073741824*a.substring(0,a.length-2));if(a.search(/b/i)===a.length-1)return parseFloat(a.substring(0,a.length-1));if(a.search(/s/i)===a.length-1)return parseFloat(a.substring(0,a.length-1));if(a.search(/m/i)===a.length-1)return parseFloat(60*a.substring(0,a.length-1));if(a.search(/h/i)===a.length-1)return parseFloat(3600*a.substring(0,a.length-1))}return a},this.urlToBlob=function(c){var d=b.defer();return a({url:c,method:"get",responseType:"arraybuffer"}).then(function(a){var b=new Uint8Array(a.data),e=a.headers("content-type")||"image/WebP",f=new window.Blob([b],{type:e}),g=c.match(/.*\/(.+?)(\?.*)?$/);g.length>1&&(f.name=g[1]),d.resolve(f)},function(a){d.reject(a)}),d.promise},this.setDefaults=function(a){this.defaults=a||{}},this.defaults={},this.version=ngFileUpload.version}]),ngFileUpload.service("Upload",["$parse","$timeout","$compile","$q","UploadExif",function(a,b,c,d,e){function f(a,b,c){var e=[i.emptyPromise()];return angular.forEach(a,function(d,f){0===d.type.indexOf("image/jpeg")&&i.attrGetter("ngfFixOrientation",b,c,{$file:d})&&e.push(i.happyPromise(i.applyExifRotation(d),d).then(function(b){a.splice(f,1,b)}))}),d.all(e)}function g(a,b,c,e){var f=i.attrGetter("ngfResize",b,c);if(!f||!i.isResizeSupported()||!a.length)return i.emptyPromise();if(f instanceof Function){var g=d.defer();return f(a).then(function(d){h(d,a,b,c,e).then(function(a){g.resolve(a)},function(a){g.reject(a)})},function(a){g.reject(a)})}return h(f,a,b,c,e)}function h(a,b,c,e,f){function g(d,g){if(0===d.type.indexOf("image")){if(a.pattern&&!i.validatePattern(d,a.pattern))return;a.resizeIf=function(a,b){return i.attrGetter("ngfResizeIf",c,e,{$width:a,$height:b,$file:d})};var j=i.resize(d,a);h.push(j),j.then(function(a){b.splice(g,1,a)},function(a){d.$error="resize",(d.$errorMessages=d.$errorMessages||{}).resize=!0,d.$errorParam=(a?(a.message?a.message:a)+": ":"")+(d&&d.name),f.$ngfValidations.push({name:"resize",valid:!1}),i.applyModelValidation(f,b)})}}for(var h=[i.emptyPromise()],j=0;j<b.length;j++)g(b[j],j);return d.all(h)}var i=e;return i.getAttrWithDefaults=function(a,b){if(null!=a[b])return a[b];var c=i.defaults[b];return null==c?c:angular.isString(c)?c:JSON.stringify(c)},i.attrGetter=function(b,c,d,e){var f=this.getAttrWithDefaults(c,b);if(!d)return f;try{return e?a(f)(d,e):a(f)(d)}catch(g){if(b.search(/min|max|pattern/i))return f;throw g}},i.shouldUpdateOn=function(a,b,c){var d=i.attrGetter("ngfModelOptions",b,c);return d&&d.updateOn?d.updateOn.split(" ").indexOf(a)>-1:!0},i.emptyPromise=function(){var a=d.defer(),c=arguments;return b(function(){a.resolve.apply(a,c)}),a.promise},i.rejectPromise=function(){var a=d.defer(),c=arguments;return b(function(){a.reject.apply(a,c)}),a.promise},i.happyPromise=function(a,c){var e=d.defer();return a.then(function(a){e.resolve(a)},function(a){b(function(){throw a}),e.resolve(c)}),e.promise},i.updateModel=function(c,d,e,h,j,k,l){function m(f,g,j,l,m){d.$$ngfPrevValidFiles=f,d.$$ngfPrevInvalidFiles=g;var n=f&&f.length?f[0]:null,o=g&&g.length?g[0]:null;c&&(i.applyModelValidation(c,f),c.$setViewValue(m?n:f)),h&&a(h)(e,{$files:f,$file:n,$newFiles:j,$duplicateFiles:l,$invalidFiles:g,$invalidFile:o,$event:k});var p=i.attrGetter("ngfModelInvalid",d);p&&b(function(){a(p).assign(e,m?o:g)}),b(function(){})}function n(){function a(a,b){return a.name===b.name&&(a.$ngfOrigSize||a.size)===(b.$ngfOrigSize||b.size)&&a.type===b.type}function b(b){var c;for(c=0;c<r.length;c++)if(a(b,r[c]))return!0;for(c=0;c<s.length;c++)if(a(b,s[c]))return!0;return!1}if(j){q=[],t=[];for(var c=0;c<j.length;c++)b(j[c])?t.push(j[c]):q.push(j[c])}}function o(a){return angular.isArray(a)?a:[a]}function p(){function a(){b(function(){m(w?r.concat(v):v,w?s.concat(u):u,j,t,x)},z&&z.debounce?z.debounce.change||z.debounce:0)}var f=y?q:v;g(f,d,e,c).then(function(){y?i.validate(q,w?r.length:0,c,d,e).then(function(b){v=b.validsFiles,u=b.invalidsFiles,a()}):a()},function(){for(var b=0;b<f.length;b++){var c=f[b];if("resize"===c.$error){var d=v.indexOf(c);d>-1&&(v.splice(d,1),u.push(c)),a()}}})}var q,r,s,t=[],u=[],v=[];r=d.$$ngfPrevValidFiles||[],s=d.$$ngfPrevInvalidFiles||[],c&&c.$modelValue&&(r=o(c.$modelValue));var w=i.attrGetter("ngfKeep",d,e);q=(j||[]).slice(0),("distinct"===w||i.attrGetter("ngfKeepDistinct",d,e)===!0)&&n(d,e);var x=!w&&!i.attrGetter("ngfMultiple",d,e)&&!i.attrGetter("multiple",d);if(!w||q.length){i.attrGetter("ngfBeforeModelChange",d,e,{$files:j,$file:j&&j.length?j[0]:null,$newFiles:q,$duplicateFiles:t,$event:k});var y=i.attrGetter("ngfValidateAfterResize",d,e),z=i.attrGetter("ngfModelOptions",d,e);i.validate(q,w?r.length:0,c,d,e).then(function(a){l?m(q,[],j,t,x):(z&&z.allowInvalid||y?v=q:(v=a.validFiles,u=a.invalidFiles),i.attrGetter("ngfFixOrientation",d,e)&&i.isExifSupported()?f(v,d,e).then(function(){p()}):p())})}},i}]),ngFileUpload.directive("ngfSelect",["$parse","$timeout","$compile","Upload",function(a,b,c,d){function e(a){var b=a.match(/Android[^\d]*(\d+)\.(\d+)/);if(b&&b.length>2){var c=d.defaults.androidFixMinorVersion||4;return parseInt(b[1])<4||parseInt(b[1])===c&&parseInt(b[2])<c}return-1===a.indexOf("Chrome")&&/.*Windows.*Safari.*/.test(a)}function f(a,b,c,d,f,h,i,j){function k(){return"input"===b[0].tagName.toLowerCase()&&c.type&&"file"===c.type.toLowerCase()}function l(){return t("ngfChange")||t("ngfSelect")}function m(b){if(j.shouldUpdateOn("change",c,a)){var e=b.__files_||b.target&&b.target.files,f=[];if(!e)return;for(var g=0;g<e.length;g++)f.push(e[g]);j.updateModel(d,c,a,l(),f.length?f:null,b)}}function n(a,d){function e(b){a.attr("id","ngf-"+b),d.attr("id","ngf-label-"+b)}for(var f=0;f<b[0].attributes.length;f++){var g=b[0].attributes[f];"type"!==g.name&&"class"!==g.name&&"style"!==g.name&&("id"===g.name?(e(g.value),u.push(c.$observe("id",e))):a.attr(g.name,g.value||"required"!==g.name&&"multiple"!==g.name?g.value:g.name))}}function o(){if(k())return b;var a=angular.element('<input type="file">'),c=angular.element("<label>upload</label>");return c.css("visibility","hidden").css("position","absolute").css("overflow","hidden").css("width","0px").css("height","0px").css("border","none").css("margin","0px").css("padding","0px").attr("tabindex","-1"),n(a,c),g.push({el:b,ref:c}),document.body.appendChild(c.append(a)[0]),a}function p(c){if(b.attr("disabled"))return!1;if(!t("ngfSelectDisabled",a)){var d=q(c);if(null!=d)return d;r(c);try{k()||document.body.contains(x[0])||(g.push({el:b,ref:x.parent()}),document.body.appendChild(x.parent()[0]),x.bind("change",m))}catch(f){}return e(navigator.userAgent)?setTimeout(function(){x[0].click()},0):x[0].click(),!1}}function q(a){var b=a.changedTouches||a.originalEvent&&a.originalEvent.changedTouches;if(b){if("touchstart"===a.type)return w=b[0].clientX,v=b[0].clientY,!0;if("touchend"===a.type){var c=b[0].clientX,d=b[0].clientY;if(Math.abs(c-w)>20||Math.abs(d-v)>20)return a.stopPropagation(),a.preventDefault(),!1}return!0}}function r(b){j.shouldUpdateOn("click",c,a)&&x.val()&&(x.val(null),j.updateModel(d,c,a,l(),null,b,!0))}function s(a){if(x&&!x.attr("__ngf_ie10_Fix_")){if(!x[0].parentNode)return void(x=null);a.preventDefault(),a.stopPropagation(),x.unbind("click");var b=x.clone();return x.replaceWith(b),x=b,x.attr("__ngf_ie10_Fix_","true"),x.bind("change",m),x.bind("click",s),x[0].click(),!1}x.removeAttr("__ngf_ie10_Fix_")}var t=function(a,b){return j.attrGetter(a,c,b)};j.registerModelChangeValidator(d,c,a);var u=[];t("ngfMultiple")&&u.push(a.$watch(t("ngfMultiple"),function(){x.attr("multiple",t("ngfMultiple",a))})),t("ngfCapture")&&u.push(a.$watch(t("ngfCapture"),function(){x.attr("capture",t("ngfCapture",a))})),t("ngfAccept")&&u.push(a.$watch(t("ngfAccept"),function(){x.attr("accept",t("ngfAccept",a))})),u.push(c.$observe("accept",function(){x.attr("accept",t("accept"))}));var v=0,w=0,x=b;k()||(x=o()),x.bind("change",m),k()?b.bind("click",r):b.bind("click touchstart touchend",p),-1!==navigator.appVersion.indexOf("MSIE 10")&&x.bind("click",s),d&&d.$formatters.push(function(a){return(null==a||0===a.length)&&x.val()&&x.val(null),a}),a.$on("$destroy",function(){k()||x.parent().remove(),angular.forEach(u,function(a){a()})}),h(function(){for(var a=0;a<g.length;a++){var b=g[a];document.body.contains(b.el[0])||(g.splice(a,1),b.ref.remove())}}),window.FileAPI&&window.FileAPI.ngfFixIE&&window.FileAPI.ngfFixIE(b,x,m)}var g=[];return{restrict:"AEC",require:"?ngModel",link:function(e,g,h,i){f(e,g,h,i,a,b,c,d)}}}]),function(){function a(a){return"img"===a.tagName.toLowerCase()?"image":"audio"===a.tagName.toLowerCase()?"audio":"video"===a.tagName.toLowerCase()?"video":/./}function b(b,c,d,e,f,g,h,i){function j(a){var g=b.attrGetter("ngfNoObjectUrl",f,d);b.dataUrl(a,g)["finally"](function(){c(function(){var b=(g?a.$ngfDataUrl:a.$ngfBlobUrl)||a.$ngfDataUrl;i?e.css("background-image","url('"+(b||"")+"')"):e.attr("src",b),b?e.removeClass("ng-hide"):e.addClass("ng-hide")})})}c(function(){var c=d.$watch(f[g],function(c){var k=h;if("ngfThumbnail"===g&&(k||(k={width:e[0].naturalWidth||e[0].clientWidth,height:e[0].naturalHeight||e[0].clientHeight}),0===k.width&&window.getComputedStyle)){var l=getComputedStyle(e[0]);l.width&&l.width.indexOf("px")>-1&&l.height&&l.height.indexOf("px")>-1&&(k={width:parseInt(l.width.slice(0,-2)),height:parseInt(l.height.slice(0,-2))})}return angular.isString(c)?(e.removeClass("ng-hide"),i?e.css("background-image","url('"+c+"')"):e.attr("src",c)):void(!c||!c.type||0!==c.type.search(a(e[0]))||i&&0!==c.type.indexOf("image")?e.addClass("ng-hide"):k&&b.isResizeSupported()?(k.resizeIf=function(a,e){return b.attrGetter("ngfResizeIf",f,d,{$width:a,$height:e,$file:c})},b.resize(c,k).then(function(a){j(a)},function(a){throw a})):j(c))});d.$on("$destroy",function(){c()})})}ngFileUpload.service("UploadDataUrl",["UploadBase","$timeout","$q",function(a,b,c){var d=a;return d.base64DataUrl=function(a){if(angular.isArray(a)){var b=c.defer(),e=0;return angular.forEach(a,function(c){d.dataUrl(c,!0)["finally"](function(){if(e++,e===a.length){var c=[];angular.forEach(a,function(a){c.push(a.$ngfDataUrl)}),b.resolve(c,a)}})}),b.promise}return d.dataUrl(a,!0)},d.dataUrl=function(a,e){if(!a)return d.emptyPromise(a,a);if(e&&null!=a.$ngfDataUrl||!e&&null!=a.$ngfBlobUrl)return d.emptyPromise(e?a.$ngfDataUrl:a.$ngfBlobUrl,a);var f=e?a.$$ngfDataUrlPromise:a.$$ngfBlobUrlPromise;if(f)return f;var g=c.defer();return b(function(){if(window.FileReader&&a&&(!window.FileAPI||-1===navigator.userAgent.indexOf("MSIE 8")||a.size<2e4)&&(!window.FileAPI||-1===navigator.userAgent.indexOf("MSIE 9")||a.size<4e6)){var c=window.URL||window.webkitURL;if(c&&c.createObjectURL&&!e){var f;try{f=c.createObjectURL(a)}catch(h){return void b(function(){a.$ngfBlobUrl="",g.reject()})}b(function(){if(a.$ngfBlobUrl=f,f){g.resolve(f,a),d.blobUrls=d.blobUrls||[],d.blobUrlsTotalSize=d.blobUrlsTotalSize||0,d.blobUrls.push({url:f,size:a.size}),d.blobUrlsTotalSize+=a.size||0;for(var b=d.defaults.blobUrlsMaxMemory||268435456,e=d.defaults.blobUrlsMaxQueueSize||200;(d.blobUrlsTotalSize>b||d.blobUrls.length>e)&&d.blobUrls.length>1;){var h=d.blobUrls.splice(0,1)[0];c.revokeObjectURL(h.url),d.blobUrlsTotalSize-=h.size}}})}else{var i=new FileReader;i.onload=function(c){b(function(){a.$ngfDataUrl=c.target.result,g.resolve(c.target.result,a),b(function(){delete a.$ngfDataUrl},1e3)})},i.onerror=function(){b(function(){a.$ngfDataUrl="",g.reject()})},i.readAsDataURL(a)}}else b(function(){a[e?"$ngfDataUrl":"$ngfBlobUrl"]="",g.reject()})}),f=e?a.$$ngfDataUrlPromise=g.promise:a.$$ngfBlobUrlPromise=g.promise,f["finally"](function(){delete a[e?"$$ngfDataUrlPromise":"$$ngfBlobUrlPromise"]}),f},d}]),ngFileUpload.directive("ngfSrc",["Upload","$timeout",function(a,c){return{restrict:"AE",link:function(d,e,f){b(a,c,d,e,f,"ngfSrc",a.attrGetter("ngfResize",f,d),!1)}}}]),ngFileUpload.directive("ngfBackground",["Upload","$timeout",function(a,c){return{restrict:"AE",link:function(d,e,f){b(a,c,d,e,f,"ngfBackground",a.attrGetter("ngfResize",f,d),!0)}}}]),ngFileUpload.directive("ngfThumbnail",["Upload","$timeout",function(a,c){return{restrict:"AE",link:function(d,e,f){var g=a.attrGetter("ngfSize",f,d);b(a,c,d,e,f,"ngfThumbnail",g,a.attrGetter("ngfAsBackground",f,d))}}}]),ngFileUpload.config(["$compileProvider",function(a){a.imgSrcSanitizationWhitelist&&a.imgSrcSanitizationWhitelist(/^\s*(https?|ftp|mailto|tel|webcal|local|file|data|blob):/),a.aHrefSanitizationWhitelist&&a.aHrefSanitizationWhitelist(/^\s*(https?|ftp|mailto|tel|webcal|local|file|data|blob):/)}]),ngFileUpload.filter("ngfDataUrl",["UploadDataUrl","$sce",function(a,b){return function(c,d,e){if(angular.isString(c))return b.trustAsResourceUrl(c);var f=c&&((d?c.$ngfDataUrl:c.$ngfBlobUrl)||c.$ngfDataUrl);return c&&!f?(!c.$ngfDataUrlFilterInProgress&&angular.isObject(c)&&(c.$ngfDataUrlFilterInProgress=!0,a.dataUrl(c,d)),""):(c&&delete c.$ngfDataUrlFilterInProgress,(c&&f?e?b.trustAsResourceUrl(f):f:c)||"")}}])}(),ngFileUpload.service("UploadValidate",["UploadDataUrl","$q","$timeout",function(a,b,c){function d(a){var b="",c=[];if(a.length>2&&"/"===a[0]&&"/"===a[a.length-1])b=a.substring(1,a.length-1);else{var e=a.split(",");if(e.length>1)for(var f=0;f<e.length;f++){var g=d(e[f]);g.regexp?(b+="("+g.regexp+")",f<e.length-1&&(b+="|")):c=c.concat(g.excludes)}else 0===a.indexOf("!")?c.push("^((?!"+d(a.substring(1)).regexp+").)*$"):(0===a.indexOf(".")&&(a="*"+a),b="^"+a.replace(new RegExp("[.\\\\+*?\\[\\^\\]$(){}=!<>|:\\-]","g"),"\\$&")+"$",b=b.replace(/\\\*/g,".*").replace(/\\\?/g,"."))}return{regexp:b,excludes:c}}function e(a,b){null==b||a.$dirty||(a.$setDirty?a.$setDirty():a.$dirty=!0)}var f=a;return f.validatePattern=function(a,b){if(!b)return!0;var c=d(b),e=!0;if(c.regexp&&c.regexp.length){var f=new RegExp(c.regexp,"i");e=null!=a.type&&f.test(a.type)||null!=a.name&&f.test(a.name)}for(var g=c.excludes.length;g--;){var h=new RegExp(c.excludes[g],"i");e=e&&(null==a.type||h.test(a.type))&&(null==a.name||h.test(a.name))}return e},f.ratioToFloat=function(a){var b=a.toString(),c=b.search(/[x:]/i);return b=c>-1?parseFloat(b.substring(0,c))/parseFloat(b.substring(c+1)):parseFloat(b)},f.registerModelChangeValidator=function(a,b,c){a&&a.$formatters.push(function(d){if(a.$dirty){var e=d;d&&!angular.isArray(d)&&(e=[d]),f.validate(e,0,a,b,c).then(function(){f.applyModelValidation(a,e)})}return d})},f.applyModelValidation=function(a,b){e(a,b),angular.forEach(a.$ngfValidations,function(b){a.$setValidity(b.name,b.valid)})},f.getValidationAttr=function(a,b,c,d,e){var g="ngf"+c[0].toUpperCase()+c.substr(1),h=f.attrGetter(g,a,b,{$file:e});if(null==h&&(h=f.attrGetter("ngfValidate",a,b,{$file:e}))){var i=(d||c).split(".");h=h[i[0]],i.length>1&&(h=h&&h[i[1]])}return h},f.validate=function(a,c,d,e,g){function h(b,c,h){if(a){for(var i=a.length,j=null;i--;){var n=a[i];if(n){var o=f.getValidationAttr(e,g,b,c,n);null!=o&&(h(n,o,i)||(-1===k.indexOf(b)?(n.$error=b,(n.$errorMessages=n.$errorMessages||{})[b]=!0,n.$errorParam=o,-1===m.indexOf(n)&&m.push(n),l||a.splice(i,1),j=!1):a.splice(i,1)))}}null!==j&&d.$ngfValidations.push({name:b,valid:j})}}function i(c,h,i,n,o){function p(b,d,e){function f(f){if(f())if(-1===k.indexOf(c)){if(d.$error=c,(d.$errorMessages=d.$errorMessages||{})[c]=!0,d.$errorParam=e,-1===m.indexOf(d)&&m.push(d),!l){var g=a.indexOf(d);g>-1&&a.splice(g,1)}b.resolve(!1)}else{var h=a.indexOf(d);h>-1&&a.splice(h,1),b.resolve(!0)}else b.resolve(!0)}null!=e?n(d,e).then(function(a){f(function(){return!o(a,e)})},function(){f(function(){return j("ngfValidateForce",{$file:d})})}):b.resolve(!0)}var q=[f.emptyPromise(!0)];a&&(a=void 0===a.length?[a]:a,angular.forEach(a,function(a){var d=b.defer();return q.push(d.promise),!i||null!=a.type&&0===a.type.search(i)?void("dimensions"===c&&null!=f.attrGetter("ngfDimensions",e)?f.imageDimensions(a).then(function(b){p(d,a,j("ngfDimensions",{$file:a,$width:b.width,$height:b.height}))},function(){d.resolve(!1)}):"duration"===c&&null!=f.attrGetter("ngfDuration",e)?f.mediaDuration(a).then(function(b){p(d,a,j("ngfDuration",{$file:a,$duration:b}))},function(){d.resolve(!1)}):p(d,a,f.getValidationAttr(e,g,c,h,a))):void d.resolve(!0)}));var r=b.defer();return b.all(q).then(function(a){for(var b=!0,e=0;e<a.length;e++)if(!a[e]){b=!1;break}d.$ngfValidations.push({name:c,valid:b}),r.resolve(b)}),r.promise}d=d||{},d.$ngfValidations=d.$ngfValidations||[],angular.forEach(d.$ngfValidations,function(a){a.valid=!0});var j=function(a,b){return f.attrGetter(a,e,g,b)},k=(f.attrGetter("ngfIgnoreInvalid",e,g)||"").split(" "),l=f.attrGetter("ngfRunAllValidations",e,g);if(null==a||0===a.length)return f.emptyPromise({validFiles:a,invalidFiles:[]});a=void 0===a.length?[a]:a.slice(0);var m=[];h("pattern",null,f.validatePattern),h("minSize","size.min",function(a,b){return a.size+.1>=f.translateScalars(b)}),h("maxSize","size.max",function(a,b){return a.size-.1<=f.translateScalars(b)});var n=0;if(h("maxTotalSize",null,function(b,c){return n+=b.size,n>f.translateScalars(c)?(a.splice(0,a.length),!1):!0}),h("validateFn",null,function(a,b){return b===!0||null===b||""===b}),!a.length)return f.emptyPromise({validFiles:[],invalidFiles:m});var o=b.defer(),p=[];return p.push(i("maxHeight","height.max",/image/,this.imageDimensions,function(a,b){return a.height<=b})),p.push(i("minHeight","height.min",/image/,this.imageDimensions,function(a,b){return a.height>=b})),p.push(i("maxWidth","width.max",/image/,this.imageDimensions,function(a,b){return a.width<=b})),p.push(i("minWidth","width.min",/image/,this.imageDimensions,function(a,b){return a.width>=b})),p.push(i("dimensions",null,/image/,function(a,b){return f.emptyPromise(b)},function(a){return a})),p.push(i("ratio",null,/image/,this.imageDimensions,function(a,b){for(var c=b.toString().split(","),d=!1,e=0;e<c.length;e++)Math.abs(a.width/a.height-f.ratioToFloat(c[e]))<.01&&(d=!0);return d})),p.push(i("maxRatio","ratio.max",/image/,this.imageDimensions,function(a,b){return a.width/a.height-f.ratioToFloat(b)<1e-4})),p.push(i("minRatio","ratio.min",/image/,this.imageDimensions,function(a,b){return a.width/a.height-f.ratioToFloat(b)>-1e-4})),p.push(i("maxDuration","duration.max",/audio|video/,this.mediaDuration,function(a,b){return a<=f.translateScalars(b)})),p.push(i("minDuration","duration.min",/audio|video/,this.mediaDuration,function(a,b){return a>=f.translateScalars(b)})),p.push(i("duration",null,/audio|video/,function(a,b){return f.emptyPromise(b)},function(a){return a})),p.push(i("validateAsyncFn",null,null,function(a,b){return b},function(a){return a===!0||null===a||""===a})),b.all(p).then(function(){if(l)for(var b=0;b<a.length;b++){var d=a[b];d.$error&&a.splice(b--,1)}l=!1,h("maxFiles",null,function(a,b,d){return b>c+d}),o.resolve({validFiles:a,invalidFiles:m})}),o.promise},f.imageDimensions=function(a){if(a.$ngfWidth&&a.$ngfHeight){var d=b.defer();return c(function(){d.resolve({width:a.$ngfWidth,height:a.$ngfHeight})}),d.promise}if(a.$ngfDimensionPromise)return a.$ngfDimensionPromise;var e=b.defer();return c(function(){return 0!==a.type.indexOf("image")?void e.reject("not image"):void f.dataUrl(a).then(function(b){function d(){var b=h[0].naturalWidth||h[0].clientWidth,c=h[0].naturalHeight||h[0].clientHeight;h.remove(),a.$ngfWidth=b,a.$ngfHeight=c,e.resolve({width:b,height:c})}function f(){h.remove(),e.reject("load error")}function g(){c(function(){h[0].parentNode&&(h[0].clientWidth?d():i++>10?f():g())},1e3)}var h=angular.element("<img>").attr("src",b).css("visibility","hidden").css("position","fixed").css("max-width","none !important").css("max-height","none !important");h.on("load",d),h.on("error",f);var i=0;g(),angular.element(document.getElementsByTagName("body")[0]).append(h)},function(){e.reject("load error")})}),a.$ngfDimensionPromise=e.promise,a.$ngfDimensionPromise["finally"](function(){delete a.$ngfDimensionPromise}),a.$ngfDimensionPromise},f.mediaDuration=function(a){if(a.$ngfDuration){var d=b.defer();return c(function(){d.resolve(a.$ngfDuration)}),d.promise}if(a.$ngfDurationPromise)return a.$ngfDurationPromise;var e=b.defer();return c(function(){return 0!==a.type.indexOf("audio")&&0!==a.type.indexOf("video")?void e.reject("not media"):void f.dataUrl(a).then(function(b){function d(){var b=h[0].duration;a.$ngfDuration=b,h.remove(),e.resolve(b)}function f(){h.remove(),e.reject("load error")}function g(){c(function(){h[0].parentNode&&(h[0].duration?d():i>10?f():g())},1e3)}var h=angular.element(0===a.type.indexOf("audio")?"<audio>":"<video>").attr("src",b).css("visibility","none").css("position","fixed");h.on("loadedmetadata",d),h.on("error",f);var i=0;g(),angular.element(document.body).append(h)},function(){e.reject("load error")})}),a.$ngfDurationPromise=e.promise,a.$ngfDurationPromise["finally"](function(){delete a.$ngfDurationPromise}),a.$ngfDurationPromise},f}]),ngFileUpload.service("UploadResize",["UploadValidate","$q",function(a,b){var c=a,d=function(a,b,c,d,e){var f=e?Math.max(c/a,d/b):Math.min(c/a,d/b);return{width:a*f,height:b*f,marginX:a*f-c,marginY:b*f-d}},e=function(a,e,f,g,h,i,j,k){var l=b.defer(),m=document.createElement("canvas"),n=document.createElement("img");return n.setAttribute("style","visibility:hidden;position:fixed;z-index:-100000"),document.body.appendChild(n),n.onload=function(){var a=n.width,b=n.height;if(n.parentNode.removeChild(n),null!=k&&k(a,b)===!1)return void l.reject("resizeIf");try{if(i){var o=c.ratioToFloat(i),p=a/b;o>p?(e=a,f=e/o):(f=b,e=f*o)}e||(e=a),f||(f=b);var q=d(a,b,e,f,j);m.width=Math.min(q.width,e),m.height=Math.min(q.height,f);var r=m.getContext("2d");r.drawImage(n,Math.min(0,-q.marginX/2),Math.min(0,-q.marginY/2),q.width,q.height),l.resolve(m.toDataURL(h||"image/WebP",g||.934))}catch(s){l.reject(s)}},n.onerror=function(){n.parentNode.removeChild(n),l.reject()},n.src=a,l.promise};return c.dataUrltoBlob=function(a,b,c){for(var d=a.split(","),e=d[0].match(/:(.*?);/)[1],f=atob(d[1]),g=f.length,h=new Uint8Array(g);g--;)h[g]=f.charCodeAt(g);var i=new window.Blob([h],{type:e});return i.name=b,i.$ngfOrigSize=c,i},c.isResizeSupported=function(){var a=document.createElement("canvas");return window.atob&&a.getContext&&a.getContext("2d")&&window.Blob},c.isResizeSupported()&&Object.defineProperty(window.Blob.prototype,"name",{get:function(){return this.$ngfName},set:function(a){this.$ngfName=a},configurable:!0}),c.resize=function(a,d){if(0!==a.type.indexOf("image"))return c.emptyPromise(a);var f=b.defer();return c.dataUrl(a,!0).then(function(b){e(b,d.width,d.height,d.quality,d.type||a.type,d.ratio,d.centerCrop,d.resizeIf).then(function(e){if("image/jpeg"===a.type&&d.restoreExif!==!1)try{e=c.restoreExif(b,e)}catch(g){setTimeout(function(){throw g},1)}try{var h=c.dataUrltoBlob(e,a.name,a.size);f.resolve(h)}catch(g){f.reject(g)}},function(b){"resizeIf"===b&&f.resolve(a),f.reject(b)})},function(a){f.reject(a)}),f.promise},c}]),function(){function a(a,c,d,e,f,g,h,i,j,k){function l(){return c.attr("disabled")||s("ngfDropDisabled",a)}function m(b,c,d){if(b){var e;try{e=b&&b.getData&&b.getData("text/html")}catch(f){}q(b.items,b.files,s("ngfAllowDir",a)!==!1,s("multiple")||s("ngfMultiple",a)).then(function(a){a.length?n(a,c):o(d,e).then(function(a){n(a,c)})})}}function n(b,c){i.updateModel(e,d,a,s("ngfChange")||s("ngfDrop"),b,c)}function o(b,c){if(!i.shouldUpdateOn(b,d,a)||"string"!=typeof c)return i.rejectPromise([]);var e=[];c.replace(/<(img src|img [^>]* src) *=\"([^\"]*)\"/gi,function(a,b,c){e.push(c)});var f=[],g=[];if(e.length){angular.forEach(e,function(a){f.push(i.urlToBlob(a).then(function(a){g.push(a)}))});var h=k.defer();return k.all(f).then(function(){h.resolve(g)},function(a){h.reject(a)}),h.promise}return i.emptyPromise()}function p(a,b,c,d){var e=s("ngfDragOverClass",a,{$event:c}),f="dragover";if(angular.isString(e))f=e;else if(e&&(e.delay&&(w=e.delay),e.accept||e.reject)){var g=c.dataTransfer.items;if(null!=g&&g.length)for(var h=e.pattern||s("ngfPattern",a,{$event:c}),j=g.length;j--;){if(!i.validatePattern(g[j],h)){f=e.reject;break}f=e.accept}else f=e.accept}d(f)}function q(b,c,e,f){function g(a,b){var c=k.defer();if(null!=a)if(a.isDirectory){var d=[i.emptyPromise()];if(m){var e={type:"directory"};e.name=e.path=(b||"")+a.name,n.push(e)}var f=a.createReader(),h=[],p=function(){f.readEntries(function(e){try{e.length?(h=h.concat(Array.prototype.slice.call(e||[],0)),p()):(angular.forEach(h.slice(0),function(c){n.length<=j&&l>=o&&d.push(g(c,(b?b:"")+a.name+"/"))}),k.all(d).then(function(){c.resolve()},function(a){c.reject(a)}))}catch(f){c.reject(f)}},function(a){c.reject(a)})};p()}else a.file(function(a){try{a.path=(b?b:"")+a.name,m&&(a=i.rename(a,a.path)),n.push(a),o+=a.size,c.resolve()}catch(d){c.reject(d)}},function(a){c.reject(a)});return c.promise}var j=i.getValidationAttr(d,a,"maxFiles");null==j&&(j=Number.MAX_VALUE);var l=i.getValidationAttr(d,a,"maxTotalSize");null==l&&(l=Number.MAX_VALUE);var m=s("ngfIncludeDir",a),n=[],o=0,p=[i.emptyPromise()];if(b&&b.length>0&&"file:"!==h.location.protocol)for(var q=0;q<b.length;q++){if(b[q].webkitGetAsEntry&&b[q].webkitGetAsEntry()&&b[q].webkitGetAsEntry().isDirectory){var r=b[q].webkitGetAsEntry();if(r.isDirectory&&!e)continue;null!=r&&p.push(g(r))}else{var t=b[q].getAsFile();null!=t&&(n.push(t),o+=t.size)}if(n.length>j||o>l||!f&&n.length>0)break}else if(null!=c)for(var u=0;u<c.length;u++){var v=c.item(u);if((v.type||v.size>0)&&(n.push(v),o+=v.size),n.length>j||o>l||!f&&n.length>0)break}var w=k.defer();return k.all(p).then(function(){if(f||m||!n.length)w.resolve(n);else{for(var a=0;n[a]&&"directory"===n[a].type;)a++;w.resolve([n[a]])}},function(a){w.reject(a)}),w.promise}var r=b(),s=function(a,b,c){return i.attrGetter(a,d,b,c)};if(s("dropAvailable")&&g(function(){a[s("dropAvailable")]?a[s("dropAvailable")].value=r:a[s("dropAvailable")]=r}),!r)return void(s("ngfHideOnDropNotAvailable",a)===!0&&c.css("display","none"));null==s("ngfSelect")&&i.registerModelChangeValidator(e,d,a);var t,u=null,v=f(s("ngfStopPropagation")),w=1;c[0].addEventListener("dragover",function(b){if(!l()&&i.shouldUpdateOn("drop",d,a)){if(b.preventDefault(),v(a)&&b.stopPropagation(),navigator.userAgent.indexOf("Chrome")>-1){var e=b.dataTransfer.effectAllowed;b.dataTransfer.dropEffect="move"===e||"linkMove"===e?"move":"copy"}g.cancel(u),t||(t="C",p(a,d,b,function(d){t=d,c.addClass(t),s("ngfDrag",a,{$isDragging:!0,$class:t,$event:b})}))}},!1),c[0].addEventListener("dragenter",function(b){!l()&&i.shouldUpdateOn("drop",d,a)&&(b.preventDefault(),v(a)&&b.stopPropagation())},!1),c[0].addEventListener("dragleave",function(b){!l()&&i.shouldUpdateOn("drop",d,a)&&(b.preventDefault(),
v(a)&&b.stopPropagation(),u=g(function(){t&&c.removeClass(t),t=null,s("ngfDrag",a,{$isDragging:!1,$event:b})},w||100))},!1),c[0].addEventListener("drop",function(b){!l()&&i.shouldUpdateOn("drop",d,a)&&(b.preventDefault(),v(a)&&b.stopPropagation(),t&&c.removeClass(t),t=null,m(b.dataTransfer,b,"dropUrl"))},!1),c[0].addEventListener("paste",function(b){navigator.userAgent.toLowerCase().indexOf("firefox")>-1&&s("ngfEnableFirefoxPaste",a)&&b.preventDefault(),!l()&&i.shouldUpdateOn("paste",d,a)&&m(b.clipboardData||b.originalEvent.clipboardData,b,"pasteUrl")},!1),navigator.userAgent.toLowerCase().indexOf("firefox")>-1&&s("ngfEnableFirefoxPaste",a)&&(c.attr("contenteditable",!0),c.on("keypress",function(a){a.metaKey||a.ctrlKey||a.preventDefault()}))}function b(){var a=document.createElement("div");return"draggable"in a&&"ondrop"in a&&!/Edge\/12./i.test(navigator.userAgent)}ngFileUpload.directive("ngfDrop",["$parse","$timeout","$window","Upload","$http","$q",function(b,c,d,e,f,g){return{restrict:"AEC",require:"?ngModel",link:function(h,i,j,k){a(h,i,j,k,b,c,d,e,f,g)}}}]),ngFileUpload.directive("ngfNoFileDrop",function(){return function(a,c){b()&&c.css("display","none")}}),ngFileUpload.directive("ngfDropAvailable",["$parse","$timeout","Upload",function(a,c,d){return function(e,f,g){if(b()){var h=a(d.attrGetter("ngfDropAvailable",g));c(function(){h(e),h.assign&&h.assign(e,!0)})}}}])}(),ngFileUpload.service("UploadExif",["UploadResize","$q",function(a,b){function c(a,b,c,d){switch(b){case 2:return a.transform(-1,0,0,1,c,0);case 3:return a.transform(-1,0,0,-1,c,d);case 4:return a.transform(1,0,0,-1,0,d);case 5:return a.transform(0,1,1,0,0,0);case 6:return a.transform(0,1,-1,0,d,0);case 7:return a.transform(0,-1,-1,0,d,c);case 8:return a.transform(0,-1,1,0,0,c)}}function d(a){for(var b="",c=new Uint8Array(a),d=c.byteLength,e=0;d>e;e++)b+=String.fromCharCode(c[e]);return window.btoa(b)}var e=a;return e.isExifSupported=function(){return window.FileReader&&(new FileReader).readAsArrayBuffer&&e.isResizeSupported()},e.readOrientation=function(a){var c=b.defer(),d=new FileReader,e=a.slice?a.slice(0,65536):a;return d.readAsArrayBuffer(e),d.onerror=function(a){return c.reject(a)},d.onload=function(a){var b={orientation:1},d=new DataView(this.result);if(65496!==d.getUint16(0,!1))return c.resolve(b);for(var e=d.byteLength,f=2;e>f;){var g=d.getUint16(f,!1);if(f+=2,65505===g){if(1165519206!==d.getUint32(f+=2,!1))return c.resolve(b);var h=18761===d.getUint16(f+=6,!1);f+=d.getUint32(f+4,h);var i=d.getUint16(f,h);f+=2;for(var j=0;i>j;j++)if(274===d.getUint16(f+12*j,h)){var k=d.getUint16(f+12*j+8,h);return k>=2&&8>=k&&(d.setUint16(f+12*j+8,1,h),b.fixedArrayBuffer=a.target.result),b.orientation=k,c.resolve(b)}}else{if(65280!==(65280&g))break;f+=d.getUint16(f,!1)}}return c.resolve(b)},c.promise},e.applyExifRotation=function(a){if(0!==a.type.indexOf("image/jpeg"))return e.emptyPromise(a);var f=b.defer();return e.readOrientation(a).then(function(b){return b.orientation<2||b.orientation>8?f.resolve(a):void e.dataUrl(a,!0).then(function(g){var h=document.createElement("canvas"),i=document.createElement("img");i.onload=function(){try{h.width=b.orientation>4?i.height:i.width,h.height=b.orientation>4?i.width:i.height;var g=h.getContext("2d");c(g,b.orientation,i.width,i.height),g.drawImage(i,0,0);var j=h.toDataURL(a.type||"image/WebP",.934);j=e.restoreExif(d(b.fixedArrayBuffer),j);var k=e.dataUrltoBlob(j,a.name);f.resolve(k)}catch(l){return f.reject(l)}},i.onerror=function(){f.reject()},i.src=g},function(a){f.reject(a)})},function(a){f.reject(a)}),f.promise},e.restoreExif=function(a,b){var c={};return c.KEY_STR="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",c.encode64=function(a){var b,c,d,e,f,g="",h="",i="",j=0;do b=a[j++],c=a[j++],h=a[j++],d=b>>2,e=(3&b)<<4|c>>4,f=(15&c)<<2|h>>6,i=63&h,isNaN(c)?f=i=64:isNaN(h)&&(i=64),g=g+this.KEY_STR.charAt(d)+this.KEY_STR.charAt(e)+this.KEY_STR.charAt(f)+this.KEY_STR.charAt(i),b=c=h="",d=e=f=i="";while(j<a.length);return g},c.restore=function(a,b){a.match("data:image/jpeg;base64,")&&(a=a.replace("data:image/jpeg;base64,",""));var c=this.decode64(a),d=this.slice2Segments(c),e=this.exifManipulation(b,d);return"data:image/jpeg;base64,"+this.encode64(e)},c.exifManipulation=function(a,b){var c=this.getExifArray(b),d=this.insertExif(a,c);return new Uint8Array(d)},c.getExifArray=function(a){for(var b,c=0;c<a.length;c++)if(b=a[c],255===b[0]&225===b[1])return b;return[]},c.insertExif=function(a,b){var c=a.replace("data:image/jpeg;base64,",""),d=this.decode64(c),e=d.indexOf(255,3),f=d.slice(0,e),g=d.slice(e),h=f;return h=h.concat(b),h=h.concat(g)},c.slice2Segments=function(a){for(var b=0,c=[];;){if(255===a[b]&218===a[b+1])break;if(255===a[b]&216===a[b+1])b+=2;else{var d=256*a[b+2]+a[b+3],e=b+d+2,f=a.slice(b,e);c.push(f),b=e}if(b>a.length)break}return c},c.decode64=function(a){var b,c,d,e,f,g="",h="",i=0,j=[],k=/[^A-Za-z0-9\+\/\=]/g;k.exec(a)&&console.log("There were invalid base64 characters in the input text.\nValid base64 characters are A-Z, a-z, 0-9, NaNExpect errors in decoding."),a=a.replace(/[^A-Za-z0-9\+\/\=]/g,"");do d=this.KEY_STR.indexOf(a.charAt(i++)),e=this.KEY_STR.indexOf(a.charAt(i++)),f=this.KEY_STR.indexOf(a.charAt(i++)),h=this.KEY_STR.indexOf(a.charAt(i++)),b=d<<2|e>>4,c=(15&e)<<4|f>>2,g=(3&f)<<6|h,j.push(b),64!==f&&j.push(c),64!==h&&j.push(g),b=c=g="",d=e=f=h="";while(i<a.length);return j},c.restore(a,b)},e}]);;//download.js v4.21, by dandavis; 2008-2018. [MIT] see http://danml.com/download.html for tests/usage
// v1 landed a FF+Chrome compatible way of downloading strings to local un-named files, upgraded to use a hidden frame and optional mime
// v2 added named files via a[download], msSaveBlob, IE (10+) support, and window.URL support for larger+faster saves than dataURLs
// v3 added dataURL and Blob Input, bind-toggle arity, and legacy dataURL fallback was improved with force-download mime and base64 support. 3.1 improved safari handling.
// v4 adds AMD/UMD, commonJS, and plain browser support
// v4.1 adds url download capability via solo URL argument (same domain/CORS only)
// v4.2 adds semantic variable names, long (over 2MB) dataURL support, and hidden by default temp anchors
// https://github.com/rndme/download

(function (root, factory) {
	if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define([], factory);
	} else if (typeof exports === 'object') {
		// Node. Does not work with strict CommonJS, but
		// only CommonJS-like environments that support module.exports,
		// like Node.
		module.exports = factory();
	} else {
		// Browser globals (root is window)
		root.download = factory();
  }
}(this, function () {

	return function download(data, strFileName, strMimeType) {

		var self = window, // this script is only for browsers anyway...
			defaultMime = "application/octet-stream", // this default mime also triggers iframe downloads
			mimeType = strMimeType || defaultMime,
			payload = data,
			url = !strFileName && !strMimeType && payload,
			anchor = document.createElement("a"),
			toString = function(a){return String(a);},
			myBlob = (self.Blob || self.MozBlob || self.WebKitBlob || toString),
			fileName = strFileName || "download",
			blob,
			reader;
			myBlob= myBlob.call ? myBlob.bind(self) : Blob ;
	  
		if(String(this)==="true"){ //reverse arguments, allowing download.bind(true, "text/xml", "export.xml") to act as a callback
			payload=[payload, mimeType];
			mimeType=payload[0];
			payload=payload[1];
		}


		if(url && url.length< 2048){ // if no filename and no mime, assume a url was passed as the only argument
			fileName = url.split("/").pop().split("?")[0];
			anchor.href = url; // assign href prop to temp anchor
		  	if(anchor.href.indexOf(url) !== -1){ // if the browser determines that it's a potentially valid url path:
        		var ajax=new XMLHttpRequest();
        		ajax.open( "GET", url, true);
        		ajax.responseType = 'blob';
        		ajax.onload= function(e){ 
				  download(e.target.response, fileName, defaultMime);
				};
        		setTimeout(function(){ ajax.send();}, 0); // allows setting custom ajax headers using the return:
			    return ajax;
			} // end if valid url?
		} // end if url?


		//go ahead and download dataURLs right away
		if(/^data:([\w+-]+\/[\w+.-]+)?[,;]/.test(payload)){
		
			if(payload.length > (1024*1024*1.999) && myBlob !== toString ){
				payload=dataUrlToBlob(payload);
				mimeType=payload.type || defaultMime;
			}else{			
				return navigator.msSaveBlob ?  // IE10 can't do a[download], only Blobs:
					navigator.msSaveBlob(dataUrlToBlob(payload), fileName) :
					saver(payload) ; // everyone else can save dataURLs un-processed
			}
			
		}else{//not data url, is it a string with special needs?
			if(/([\x80-\xff])/.test(payload)){			  
				var i=0, tempUiArr= new Uint8Array(payload.length), mx=tempUiArr.length;
				for(i;i<mx;++i) tempUiArr[i]= payload.charCodeAt(i);
			 	payload=new myBlob([tempUiArr], {type: mimeType});
			}		  
		}
		blob = payload instanceof myBlob ?
			payload :
			new myBlob([payload], {type: mimeType}) ;


		function dataUrlToBlob(strUrl) {
			var parts= strUrl.split(/[:;,]/),
			type= parts[1],
			indexDecoder = strUrl.indexOf("charset")>0 ? 3: 2,
			decoder= parts[indexDecoder] == "base64" ? atob : decodeURIComponent,
			binData= decoder( parts.pop() ),
			mx= binData.length,
			i= 0,
			uiArr= new Uint8Array(mx);

			for(i;i<mx;++i) uiArr[i]= binData.charCodeAt(i);

			return new myBlob([uiArr], {type: type});
		 }

		function saver(url, winMode){

			if ('download' in anchor) { //html5 A[download]
				anchor.href = url;
				anchor.setAttribute("download", fileName);
				anchor.className = "download-js-link";
				anchor.innerHTML = "downloading...";
				anchor.style.display = "none";
 				anchor.addEventListener('click', function(e) {
 					e.stopPropagation();
 					this.removeEventListener('click', arguments.callee);
 				});
				document.body.appendChild(anchor);
				setTimeout(function() {
					anchor.click();
					document.body.removeChild(anchor);
					if(winMode===true){setTimeout(function(){ self.URL.revokeObjectURL(anchor.href);}, 250 );}
				}, 66);
				return true;
			}

			// handle non-a[download] safari as best we can:
			if(/(Version)\/(\d+)\.(\d+)(?:\.(\d+))?.*Safari\//.test(navigator.userAgent)) {
				if(/^data:/.test(url))	url="data:"+url.replace(/^data:([\w\/\-\+]+)/, defaultMime);
				if(!window.open(url)){ // popup blocked, offer direct download:
					if(confirm("Displaying New Document\n\nUse Save As... to download, then click back to return to this page.")){ location.href=url; }
				}
				return true;
			}

			//do iframe dataURL download (old ch+FF):
			var f = document.createElement("iframe");
			document.body.appendChild(f);

			if(!winMode && /^data:/.test(url)){ // force a mime that will download:
				url="data:"+url.replace(/^data:([\w\/\-\+]+)/, defaultMime);
			}
			f.src=url;
			setTimeout(function(){ document.body.removeChild(f); }, 333);

		}//end saver




		if (navigator.msSaveBlob) { // IE10+ : (has Blob, but not a[download] or URL)
			return navigator.msSaveBlob(blob, fileName);
		}

		if(self.URL){ // simple fast and modern way using Blob and URL:
			saver(self.URL.createObjectURL(blob), true);
		}else{
			// handle non-Blob()+non-URL browsers:
			if(typeof blob === "string" || blob.constructor===toString ){
				try{
					return saver( "data:" +  mimeType   + ";base64,"  +  self.btoa(blob)  );
				}catch(y){
					return saver( "data:" +  mimeType   + "," + encodeURIComponent(blob)  );
				}
			}

			// Blob but not URL support:
			reader=new FileReader();
			reader.onload=function(e){
				saver(this.result);
			};
			reader.readAsDataURL(blob);
		}
		return true;
	}; /* end download() */
}));
;/*
 * Angular Material Time Picker
 * https://github.com/classlinkinc/angular-material-time-picker
 * @license MIT
 * v1.0.1
 */
(function(window, angular, undefined) {
  'use strict';

  function increase(value, min, max, type) {
    var num = parseInt(value);
    if (isNaN(num) || num === max)
      num = min;
    else
      num++;
    if (type === 'MM')
      return format(num);
    return String(num);
  }

  function decrease(value, min, max, type) {
    var num = parseInt(value);
    if (isNaN(num) || num === min)
      num = max;
    else
      num--;
    if (type === 'MM')
      return format(num);
    return String(num);
  }

  function format(num) {
    if (num < 10)
      return '0' + String(num);
    return String(num);
  }

  function handleInput(value, max, blur, type) {
    var num = parseInt(value);
    if (type === 'HH' && num === 0) {
      if (num === 0) {
        return String(num);
      }
      return;
    }
    if (num > max) 
      return String(num)[0];
    else if (!isNaN(num)) {
      if (value.length === 2 || (blur && type === 'MM'))
        return format(num);
      return String(num);
    }
  }

  angular.module('md.time.picker', ['ngMessages'])

    .directive('mdHoursMinutes', function() {

      return {

        restrict: 'E',
        scope: {
          type: '@',
          message: '@',
          ngModel: '=',
          readOnly: '<', // true or false
          mandatory: '<' // true or false
        },
        template: '<md-input-container md-no-float>' +
          '<input ' +
          'ng-required="mandatory" ' +
          'type="text"' +
          'name="time_{{type}}"' +
          'ng-model="time[type]"' +
          'ng-change="handleInput()"' +
          'placeholder="{{type}}"' +
          'maxlength="2"' +
          'ng-blur="handleInput(true)"' +
          'ng-keydown="handleKeypress($event)" ng-disabled="readOnly"/>' +
          '<span class="md-up-arrow" aria-hidden="true" ng-click="!readOnly && increase()"></span>' +
          '<span class="md-down-arrow" aria-hidden="true" ng-click="!readOnly && decrease()"></span>' +
          '<div class="time-error-messages" ng-messages="$parent.timeForm[\'time_\' + type].$error" role="alert">' +
          '<div ng-message="required">{{message}}</div>' +
          '</div>' +
          '</md-input-container>',
        controller: ["$scope", "$rootScope", function($scope, $rootScope) {

          if ($scope.type === "HH") {
            if ($scope.$parent.noMeridiem) {
              $scope.min = 0;
              $scope.max = 23;
            } else {
              $scope.min = 1;
              $scope.max = 12;
            }
          } else {
            $scope.min = 0;
            $scope.max = 59;
          }

          function setTime() {
            if ($scope.type === "HH") {
              var hours = '';
              try {
                hours = $scope.$parent.ngModel.getHours();
              } catch (e) {
                // leave hours empty to allow empty values
              }

              if (!$scope.$parent.noMeridiem) {
                if (hours > 12)
                  hours -= 12;
                else if (hours === 0)
                  hours += 12;
              }
              $scope.time.HH = String(hours);
            } else
              if ($scope.$parent.ngModel) {
                $scope.time.MM = format($scope.$parent.ngModel.getMinutes());
              } else {
                // leave MM empty to allow empty values
                $scope.time.MM = '';
              }
          }

          $scope.time = {};

          // make sure we update our variables if new values
          $scope.$watch("ngModel", function() {
            setTime();
          });

          var removeListener = $scope.$on('mdpTimePickerModalUpdated', setTime);
          $scope.$on('$destroy', removeListener);

          function updateTime(next) {
            // prevent NaN value in input field
            if (isNaN(next))
              return;

            // if $scope.ngModel is undefined, create new date object. else leave as is, which means user has specified date object
            // Set hours, minutes, seconds and milliseconds to 0 in order for the user to be able to set own values
            if (angular.isDate($scope.ngModel)) {
              if (isNaN($scope.ngModel.getTime())) {
                $scope.ngModel = new Date(2017, 0, 0, 0, 0, 0, 0);
              } else {
                // continue
              }
            } else {
              $scope.ngModel = new Date(2017, 0, 0, 0, 0, 0, 0);
            }
            if ($scope.type === 'MM') {
                $scope.ngModel.setMinutes(next);
                return;
            } else if (!$scope.$parent.noMeridiem) {
              var hours = $scope.ngModel.getHours();
              if (hours >= 12 && next != 12)
                next += 12;
              else if (hours < 12 && next == 12)
                next = 0;
            }
              $scope.ngModel.setHours(next);
          }

          $scope.increase = function() {
            var next = increase($scope.time[$scope.type], $scope.min, $scope.max, $scope.type)
            $scope.time[$scope.type] = next;
            updateTime(parseInt(next));
            $rootScope.$emit('mdpTimePickerUpdated');
          }

          $scope.decrease = function() {
            var next = decrease($scope.time[$scope.type], $scope.min, $scope.max, $scope.type);
            $scope.time[$scope.type] = next;
            updateTime(parseInt(next));
            $rootScope.$emit('mdpTimePickerUpdated');
          }

          $scope.handleInput = function(blur) {
            var next = handleInput($scope.time[$scope.type], $scope.max, blur, $scope.type);
            $scope.time[$scope.type] = next;
            updateTime(parseInt(next));
            $rootScope.$emit('mdpTimePickerUpdated');
          }

          $scope.handleKeypress = function(ev) {
            if (ev.keyCode === 38) $scope.increase();
            else if (ev.keyCode === 40) $scope.decrease();
          }

        }]
      }

    })

    .directive('mdMeridiem', function() {

      return {

        restrict: 'E',
        scope: {
          message: '@',
          readOnly: '<', // true or false
          ngModel: '=',
          mandatory: '<' // true or false
        },
        template: '<md-input-container md-no-float>' +
          '<md-select ' +
          'ng-required="mandatory" ' +
          'name="meridiem"' +
          'ng-model="meridiem"' +
          'ng-change="updateTime()"' +
          'placeholder="AM/PM"' +
          'flex-gt-sm ' +
          'ng-disabled="readOnly">' +
          '<md-option value="AM" ng-disabled="readOnly">AM</md-option>' +
          '<md-option value="PM" ng-disabled="readOnly">PM</md-option>' +
          '</md-select>' +
          '<div class="time-error-messages" ng-messages="$parent.timeForm.meridiem.$error" role="alert">' +
          '<div ng-message="required">{{message}}</div>' +
          '</div>' +
          '</md-input-container>',
        controller: ["$scope", "$rootScope", function($scope, $rootScope) {

          function setMeridiem() {
            var hours = '';
            try {
              hours = $scope.$parent.$parent.ngModel.getHours();
            } catch (e) {
              // leave hours empty
            }
            $scope.meridiem = hours >= 0 && hours < 12 ? 'AM' : 'PM';
          }

          // update meridiem on load of view and when model is changing
          $scope.$watch("ngModel", function() {
            setMeridiem();
          });

          $scope.updateTime = function() {
            var hours = $scope.$parent.$parent.ngModel.getHours();
            if ($scope.meridiem === 'AM') $scope.$parent.$parent.ngModel.setHours(hours-12);
            else $scope.$parent.$parent.ngModel.setHours(hours+12);
            $rootScope.$emit('mdpTimePickerUpdated');
          }

          var removeListener = $scope.$on('mdpTimePickerModalUpdated', setMeridiem);
          $scope.$on('$destroy', removeListener);

        }]

      }

    })

    .directive('mdTimePicker', function() {

      return {

        restrict: 'E',
        scope: {
          message: '<',
          ngModel: '=',
          readOnly: '<', // true or false
          mandatory: '<' // true or false
        },
        template: '<ng-form name="timeForm">' +
          '<button class="md-icon-button md-button md-ink-ripple" type="button" ng-click="!readOnly && showPicker($event)" ng-disabled="readOnly">' +
          '<md-icon>' +
          '<i class="material-icons">&#xE192;</i>' +
          '</md-icon>' +
          '<div class="md-ripple-container"></div>' +
          '</button>' +
          '<md-hours-minutes type="HH" ng-model="ngModel" message="{{message.hour}}" read-only="readOnly" mandatory="mandatory"></md-hours-minutes>' +
          '<span class="time-colon">:</span>' +
          '<md-hours-minutes type="MM" ng-model="ngModel" message="{{message.minute}}" read-only="readOnly" mandatory="mandatory"></md-hours-minutes>' +
          '<md-meridiem ng-if="!noMeridiem" ng-model="ngModel" message="{{message.meridiem}}" read-only="readOnly" mandatory="mandatory"></md-meridiem>' +
          '</ng-form>',
        controller: ["$scope", "$rootScope", "$mdpTimePicker", "$attrs", function($scope, $rootScope, $mdpTimePicker, $attrs) {

          $scope.showPicker = function(ev) {

            $mdpTimePicker($scope.ngModel, {
              targetEvent: ev,
              noMeridiem: $scope.noMeridiem,
              autoSwitch: !$scope.noAutoSwitch
            }).then(function(time) {
              // if $scope.ngModel is not a valid date, create new date object.
              // Set hours, minutes, seconds and milliseconds to 0 in order for the user to be able to set own values
              if (angular.isDate($scope.ngModel)) {
                if (isNaN($scope.ngModel.getTime())) {
                  $scope.ngModel = new Date(2017, 0, 0, 0, 0, 0, 0);
                }
              } else {
                $scope.ngModel = new Date(2017, 0, 0, 0, 0, 0, 0);
              }
              $scope.ngModel.setHours(time.getHours());
              $scope.ngModel.setMinutes(time.getMinutes());
              $scope.$broadcast('mdpTimePickerModalUpdated');
              $rootScope.$emit('mdpTimePickerUpdated');
            });

          }

        }],
        compile: function(tElement, tAttrs) {
          return {
            pre: function preLink(scope) {
              scope.noMeridiem = tAttrs.noMeridiem === "" ? true : false;
              scope.noAutoSwitch = tAttrs.noAutoSwitch === "" ? true : false;
            }
          }
        }

      }

    })

    .provider("$mdpTimePicker", function() {
      var LABEL_OK = "OK",
        LABEL_CANCEL = "Cancel";

      this.setOKButtonLabel = function(label) {
        LABEL_OK = label;
      };

      this.setCancelButtonLabel = function(label) {
        LABEL_CANCEL = label;
      };

      this.$get = ["$mdDialog", function($mdDialog) {
        var timePicker = function(time, options) {

          return $mdDialog.show({
            controller: ['$scope', '$mdDialog', '$mdMedia', function ($scope, $mdDialog, $mdMedia) {
              var self = this;

              // check if time is valid date. Create new date object if not.
              if (angular.isDate(time)) {
                if (isNaN(time.getTime())) {
                  time = new Date(2017, 0, 0, 0, 0, 0, 0);
                } else {
                  // continue
                }
              } else {
                time = new Date(2017, 0, 0, 0, 0, 0, 0);
              }

              this.time = new Date(time.getTime());
              this.noMeridiem = options.noMeridiem;
              if (!self.noMeridiem)
                this.meridiem = time.getHours() < 12 ? 'AM' : 'PM';

              this.VIEW_HOURS = 1;
              this.VIEW_MINUTES = 2;
              this.currentView = this.VIEW_HOURS;
              this.autoSwitch = !!options.autoSwitch;

              $scope.$mdMedia = $mdMedia;

              this.switchView = function() {
                self.currentView = self.currentView == self.VIEW_HOURS ? self.VIEW_MINUTES : self.VIEW_HOURS;
              };

              this.hours = function() {
                var hours = self.time.getHours();
                if (self.noMeridiem) return hours;
                if (hours > 12) return hours-12;
                else if (hours === 0) return 12;
                return hours;
              }

              this.minutes = function() {
                return format(self.time.getMinutes());
              }

              this.setAM = function() {
                var hours = self.time.getHours();
                if (hours >= 12) {
                  self.time.setHours(hours - 12);
                  self.meridiem = 'AM';
                }
              };

              this.setPM = function() {
                var hours = self.time.getHours();
                if (hours < 12) {
                  self.time.setHours(hours + 12);
                  self.meridiem = 'PM';
                }
              };

              this.cancel = function() {
                $mdDialog.cancel();
              };

              this.confirm = function() {
                $mdDialog.hide(this.time);
              };
            }],
            controllerAs: 'timepicker',
            clickOutsideToClose: true,
            template: '<md-dialog aria-label="" class="mdp-timepicker" ng-class="{ \'portrait\': !$mdMedia(\'gt-xs\') }">' +
              '<md-dialog-content layout-gt-xs="row" layout-wrap>' +
              '<md-toolbar layout-gt-xs="column" layout-xs="row" layout-align="center center" flex class="mdp-timepicker-time md-hue-1 md-primary">' +
              '<div class="mdp-timepicker-selected-time">' +
              '<span ng-class="{ \'active\': timepicker.currentView == timepicker.VIEW_HOURS }" ng-click="timepicker.currentView = timepicker.VIEW_HOURS">{{ timepicker.hours() }}</span>:' +
              '<span ng-class="{ \'active\': timepicker.currentView == timepicker.VIEW_MINUTES }" ng-click="timepicker.currentView = timepicker.VIEW_MINUTES">{{ timepicker.minutes() }}</span>' +
              '</div>' +
              '<div layout="column" class="mdp-timepicker-selected-ampm">' +
              '<span ng-if="timepicker.meridiem" ng-click="timepicker.setAM()" ng-class="{ \'active\': timepicker.meridiem === \'AM\' }">AM</span>' +
              '<span ng-if="timepicker.meridiem" ng-click="timepicker.setPM()" ng-class="{ \'active\': timepicker.meridiem === \'PM\' }">PM</span>' +
              '</div>' +
              '</md-toolbar>' +
              '<div>' +
              '<div class="mdp-clock-switch-container" ng-switch="timepicker.currentView" layout layout-align="center center">' +
              '<mdp-clock class="mdp-animation-zoom" auto-switch="timepicker.autoSwitch" time="timepicker.time" no-meridiem="noMeridiem" type="hours" ng-switch-when="1"></mdp-clock>' +
              '<mdp-clock class="mdp-animation-zoom" auto-switch="timepicker.autoSwitch" time="timepicker.time" type="minutes" ng-switch-when="2"></mdp-clock>' +
              '</div>' +

              '<md-dialog-actions layout="row">' +
              '<span flex></span>' +
              '<md-button ng-click="timepicker.cancel()" aria-label="' + LABEL_CANCEL + '">' + LABEL_CANCEL + '</md-button>' +
              '<md-button ng-click="timepicker.confirm()" class="md-primary" aria-label="' + LABEL_OK + '">' + LABEL_OK + '</md-button>' +
              '</md-dialog-actions>' +
              '</div>' +
              '</md-dialog-content>' +
              '</md-dialog>',
            targetEvent: options.targetEvent,
            locals: {
              time: time,
              noMeridiem: options.noMeridiem,
              autoSwitch: options.autoSwitch
            },
            skipHide: true,
            multiple: true
          });
        };

        return timePicker;
      }];
    })

    .directive("mdpClock", ["$animate", "$timeout", function($animate, $timeout) {
      return {
        restrict: 'E',
        bindToController: {
          'type': '@?',
          'time': '=',
          'autoSwitch': '=?'
        },
        replace: true,
        template: '<div class="mdp-clock">' +
          '<div class="mdp-clock-container">' +
          '<md-toolbar class="mdp-clock-center md-primary"></md-toolbar>' +
          '<md-toolbar ng-style="clock.getPointerStyle()" class="mdp-pointer md-primary">' +
          '<span class="mdp-clock-selected md-button md-raised md-primary"></span>' +
          '</md-toolbar>' +
          '<md-button ng-if="clock.type === \'minutes\'" ng-class="{ \'md-primary\': clock.selected == step }" class="md-icon-button md-raised mdp-clock-deg{{ ::(clock.STEP_DEG_MINUTES * ($index + 1)) }}" ng-repeat="step in clock.steps">{{ step }}</md-button>' +
          '<md-button ng-if="clock.type !== \'minutes\'" ng-class="{ \'md-primary\': clock.selected == step }" class="md-icon-button md-raised mdp-clock-deg{{ ::(clock.STEP_DEG * ($index + 1)) }}" ng-repeat="step in clock.steps">{{ step }}</md-button>' +
          '</div>' +
          '</div>',
        controller: ["$scope", function ($scope) {
          var TYPE_HOURS = "hours";
          var TYPE_MINUTES = "minutes";
          var self = this;

          this.noMeridiem = $scope.$parent.timepicker.noMeridiem;

          this.STEP_DEG = this.noMeridiem ? 360/24 : 360/12;
          this.STEP_DEG_MINUTES = 360/12;
          this.steps = [];

          this.CLOCK_TYPES = {
            "hours": {
              range: this.noMeridiem ? 24 : 12,
            },
            "minutes": {
              range: 60,
            }
          }

          this.getPointerStyle = function() {
            var divider = 1;
            switch (self.type) {
              case TYPE_HOURS:
                divider = self.noMeridiem ? 24 : 12;
                break;
              case TYPE_MINUTES:
                divider = 60;
                break;
            }
            var degrees = Math.round(self.selected * (360 / divider)) - 180;
            return {
              "-webkit-transform": "rotate(" + degrees + "deg)",
              "-ms-transform": "rotate(" + degrees + "deg)",
              "transform": "rotate(" + degrees + "deg)"
            }
          };

          this.setTimeByDeg = function(deg) {

            var divider = 0;
            switch (self.type) {
              case TYPE_HOURS:
                divider = self.noMeridiem ? 24 : 12;
                break;
              case TYPE_MINUTES:
                divider = 60;
                break;
            }

            var time = Math.round(divider / 360 * deg);
            if (!self.noMeridiem && self.type === "hours" && time === 0)
              time = 12;
            else if (self.type === "minutes" && time === 60)
              time = 0;
            self.setTime(time);
          };

          this.setTime = function(time) {

            this.selected = time;

            switch (self.type) {
              case TYPE_HOURS:
                if (!self.noMeridiem) {
                  var PM = this.time.getHours() >= 12 ? true : false;
                  if (PM && time != 12)
                    time += 12;
                  else if (!PM && time === 12)
                    time = 0;
                }
                this.time.setHours(time);
                break;
              case TYPE_MINUTES:
                this.time.setMinutes(time);
                break;
            }

          };

          this.$onInit = function() {

            self.type = self.type || "hours";

            switch (self.type) {
              case TYPE_HOURS:
                if (self.noMeridiem) {
                  for (var i = 1; i <= 23; i++)
                    self.steps.push(i);
                  self.steps.push(0);
                  self.selected = self.time.getHours() || 0;
                }
                else {
                  for (var i = 1; i <= 12; i++)
                    self.steps.push(i);
                    self.selected = self.time.getHours() || 0;
                    if (self.selected > 12) self.selected -= 12;
                }

                break;
              case TYPE_MINUTES:
                for (var i = 5; i <= 55; i += 5)
                  self.steps.push(i);
                self.steps.push(0);

                self.selected = self.time.getMinutes() || 0;

                break;
            }
          };
           // Prior to v1.5, we need to call `$onInit()` manually.
           // (Bindings will always be pre-assigned in these versions.)
          if (angular.version.major === 1 && angular.version.minor < 5) {
            this.$onInit();
          }
        }],
        controllerAs: "clock",
        link: function(scope, element, attrs, ctrl) {
          var pointer = angular.element(element[0].querySelector(".mdp-pointer")),
            timepickerCtrl = scope.$parent.timepicker;

          var onEvent = function(event) {
            var containerCoords = event.currentTarget.getClientRects()[0];
            var x = ((event.currentTarget.offsetWidth / 2) - (event.pageX - containerCoords.left)),
              y = ((event.pageY - containerCoords.top) - (event.currentTarget.offsetHeight / 2));

            var deg = Math.round((Math.atan2(x, y) * (180 / Math.PI)));
            $timeout(function() {
              ctrl.setTimeByDeg(deg + 180);
              if (ctrl.type === 'hours' && ctrl.autoSwitch) timepickerCtrl.switchView();
            });
          };

          element.on("click", onEvent);
          scope.$on("$destroy", function() {
              element.off("click", onEvent);
          });

        }
      }
    }]);

})(window, angular);
;(function (global, factory) {
  if (typeof define === "function" && define.amd) {
    define([], factory);
  } else if (typeof exports !== "undefined") {
    factory();
  } else {
    var mod = {
      exports: {}
    };
    factory();
    global.FileSaver = mod.exports;
  }
})(this, function () {
  "use strict";

  /*
  * FileSaver.js
  * A saveAs() FileSaver implementation.
  *
  * By Eli Grey, http://eligrey.com
  *
  * License : https://github.com/eligrey/FileSaver.js/blob/master/LICENSE.md (MIT)
  * source  : http://purl.eligrey.com/github/FileSaver.js
  */
  // The one and only way of getting global scope in all environments
  // https://stackoverflow.com/q/3277182/1008999
  var _global = typeof window === 'object' && window.window === window ? window : typeof self === 'object' && self.self === self ? self : typeof global === 'object' && global.global === global ? global : void 0;

  function bom(blob, opts) {
    if (typeof opts === 'undefined') opts = {
      autoBom: false
    };else if (typeof opts !== 'object') {
      console.warn('Deprecated: Expected third argument to be a object');
      opts = {
        autoBom: !opts
      };
    } // prepend BOM for UTF-8 XML and text/* types (including HTML)
    // note: your browser will automatically convert UTF-16 U+FEFF to EF BB BF

    if (opts.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(blob.type)) {
      return new Blob([String.fromCharCode(0xFEFF), blob], {
        type: blob.type
      });
    }

    return blob;
  }

  function download(url, name, opts) {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', url);
    xhr.responseType = 'blob';

    xhr.onload = function () {
      saveAs(xhr.response, name, opts);
    };

    xhr.onerror = function () {
      console.error('could not download file');
    };

    xhr.send();
  }

  function corsEnabled(url) {
    var xhr = new XMLHttpRequest(); // use sync to avoid popup blocker

    xhr.open('HEAD', url, false);

    try {
      xhr.send();
    } catch (e) {}

    return xhr.status >= 200 && xhr.status <= 299;
  } // `a.click()` doesn't work for all browsers (#465)


  function click(node) {
    try {
      node.dispatchEvent(new MouseEvent('click'));
    } catch (e) {
      var evt = document.createEvent('MouseEvents');
      evt.initMouseEvent('click', true, true, window, 0, 0, 0, 80, 20, false, false, false, false, 0, null);
      node.dispatchEvent(evt);
    }
  }

  var saveAs = _global.saveAs || ( // probably in some web worker
  typeof window !== 'object' || window !== _global ? function saveAs() {}
  /* noop */
  // Use download attribute first if possible (#193 Lumia mobile)
  : 'download' in HTMLAnchorElement.prototype ? function saveAs(blob, name, opts) {
    var URL = _global.URL || _global.webkitURL;
    var a = document.createElement('a');
    name = name || blob.name || 'download';
    a.download = name;
    a.rel = 'noopener'; // tabnabbing
    // TODO: detect chrome extensions & packaged apps
    // a.target = '_blank'

    if (typeof blob === 'string') {
      // Support regular links
      a.href = blob;

      if (a.origin !== location.origin) {
        corsEnabled(a.href) ? download(blob, name, opts) : click(a, a.target = '_blank');
      } else {
        click(a);
      }
    } else {
      // Support blobs
      a.href = URL.createObjectURL(blob);
      setTimeout(function () {
        URL.revokeObjectURL(a.href);
      }, 4E4); // 40s

      setTimeout(function () {
        click(a);
      }, 0);
    }
  } // Use msSaveOrOpenBlob as a second approach
  : 'msSaveOrOpenBlob' in navigator ? function saveAs(blob, name, opts) {
    name = name || blob.name || 'download';

    if (typeof blob === 'string') {
      if (corsEnabled(blob)) {
        download(blob, name, opts);
      } else {
        var a = document.createElement('a');
        a.href = blob;
        a.target = '_blank';
        setTimeout(function () {
          click(a);
        });
      }
    } else {
      navigator.msSaveOrOpenBlob(bom(blob, opts), name);
    }
  } // Fallback to using FileReader and a popup
  : function saveAs(blob, name, opts, popup) {
    // Open a popup immediately do go around popup blocker
    // Mostly only available on user interaction and the fileReader is async so...
    popup = popup || open('', '_blank');

    if (popup) {
      popup.document.title = popup.document.body.innerText = 'downloading...';
    }

    if (typeof blob === 'string') return download(blob, name, opts);
    var force = blob.type === 'application/octet-stream';

    var isSafari = /constructor/i.test(_global.HTMLElement) || _global.safari;

    var isChromeIOS = /CriOS\/[\d]+/.test(navigator.userAgent);

    if ((isChromeIOS || force && isSafari) && typeof FileReader === 'object') {
      // Safari doesn't allow downloading of blob URLs
      var reader = new FileReader();

      reader.onloadend = function () {
        var url = reader.result;
        url = isChromeIOS ? url : url.replace(/^data:[^;]*;/, 'data:attachment/file;');
        if (popup) popup.location.href = url;else location = url;
        popup = null; // reverse-tabnabbing #460
      };

      reader.readAsDataURL(blob);
    } else {
      var URL = _global.URL || _global.webkitURL;
      var url = URL.createObjectURL(blob);
      if (popup) popup.location = url;else location.href = url;
      popup = null; // reverse-tabnabbing #460

      setTimeout(function () {
        URL.revokeObjectURL(url);
      }, 4E4); // 40s
    }
  });
  _global.saveAs = saveAs.saveAs = saveAs;

  if (typeof module !== 'undefined') {
    module.exports = saveAs;
  }
});
;/**
 * @license AngularJS v1.7.8
 * (c) 2010-2018 Google, Inc. http://angularjs.org
 * License: MIT
 */
(function(window, angular) {'use strict';

/**
 * @ngdoc module
 * @name ngAria
 * @description
 *
 * The `ngAria` module provides support for common
 * [<abbr title="Accessible Rich Internet Applications">ARIA</abbr>](http://www.w3.org/TR/wai-aria/)
 * attributes that convey state or semantic information about the application for users
 * of assistive technologies, such as screen readers.
 *
 * ## Usage
 *
 * For ngAria to do its magic, simply include the module `ngAria` as a dependency. The following
 * directives are supported:
 * `ngModel`, `ngChecked`, `ngReadonly`, `ngRequired`, `ngValue`, `ngDisabled`, `ngShow`, `ngHide`,
 * `ngClick`, `ngDblClick`, and `ngMessages`.
 *
 * Below is a more detailed breakdown of the attributes handled by ngAria:
 *
 * | Directive                                   | Supported Attributes                                                                                |
 * |---------------------------------------------|-----------------------------------------------------------------------------------------------------|
 * | {@link ng.directive:ngModel ngModel}        | aria-checked, aria-valuemin, aria-valuemax, aria-valuenow, aria-invalid, aria-required, input roles |
 * | {@link ng.directive:ngDisabled ngDisabled}  | aria-disabled                                                                                       |
 * | {@link ng.directive:ngRequired ngRequired}  | aria-required                                                                                       |
 * | {@link ng.directive:ngChecked ngChecked}    | aria-checked                                                                                        |
 * | {@link ng.directive:ngReadonly ngReadonly}  | aria-readonly                                                                                       |
 * | {@link ng.directive:ngValue ngValue}        | aria-checked                                                                                        |
 * | {@link ng.directive:ngShow ngShow}          | aria-hidden                                                                                         |
 * | {@link ng.directive:ngHide ngHide}          | aria-hidden                                                                                         |
 * | {@link ng.directive:ngDblclick ngDblclick}  | tabindex                                                                                            |
 * | {@link module:ngMessages ngMessages}        | aria-live                                                                                           |
 * | {@link ng.directive:ngClick ngClick}        | tabindex, keydown event, button role                                                                |
 *
 * Find out more information about each directive by reading the
 * {@link guide/accessibility ngAria Developer Guide}.
 *
 * ## Example
 * Using ngDisabled with ngAria:
 * ```html
 * <md-checkbox ng-disabled="disabled">
 * ```
 * Becomes:
 * ```html
 * <md-checkbox ng-disabled="disabled" aria-disabled="true">
 * ```
 *
 * ## Disabling Specific Attributes
 * It is possible to disable individual attributes added by ngAria with the
 * {@link ngAria.$ariaProvider#config config} method. For more details, see the
 * {@link guide/accessibility Developer Guide}.
 *
 * ## Disabling `ngAria` on Specific Elements
 * It is possible to make `ngAria` ignore a specific element, by adding the `ng-aria-disable`
 * attribute on it. Note that only the element itself (and not its child elements) will be ignored.
 */
var ARIA_DISABLE_ATTR = 'ngAriaDisable';

var ngAriaModule = angular.module('ngAria', ['ng']).
                        info({ angularVersion: '1.7.8' }).
                        provider('$aria', $AriaProvider);

/**
* Internal Utilities
*/
var nodeBlackList = ['BUTTON', 'A', 'INPUT', 'TEXTAREA', 'SELECT', 'DETAILS', 'SUMMARY'];

var isNodeOneOf = function(elem, nodeTypeArray) {
  if (nodeTypeArray.indexOf(elem[0].nodeName) !== -1) {
    return true;
  }
};
/**
 * @ngdoc provider
 * @name $ariaProvider
 * @this
 *
 * @description
 *
 * Used for configuring the ARIA attributes injected and managed by ngAria.
 *
 * ```js
 * angular.module('myApp', ['ngAria'], function config($ariaProvider) {
 *   $ariaProvider.config({
 *     ariaValue: true,
 *     tabindex: false
 *   });
 * });
 *```
 *
 * ## Dependencies
 * Requires the {@link ngAria} module to be installed.
 *
 */
function $AriaProvider() {
  var config = {
    ariaHidden: true,
    ariaChecked: true,
    ariaReadonly: true,
    ariaDisabled: true,
    ariaRequired: true,
    ariaInvalid: true,
    ariaValue: true,
    tabindex: true,
    bindKeydown: true,
    bindRoleForClick: true
  };

  /**
   * @ngdoc method
   * @name $ariaProvider#config
   *
   * @param {object} config object to enable/disable specific ARIA attributes
   *
   *  - **ariaHidden** – `{boolean}` – Enables/disables aria-hidden tags
   *  - **ariaChecked** – `{boolean}` – Enables/disables aria-checked tags
   *  - **ariaReadonly** – `{boolean}` – Enables/disables aria-readonly tags
   *  - **ariaDisabled** – `{boolean}` – Enables/disables aria-disabled tags
   *  - **ariaRequired** – `{boolean}` – Enables/disables aria-required tags
   *  - **ariaInvalid** – `{boolean}` – Enables/disables aria-invalid tags
   *  - **ariaValue** – `{boolean}` – Enables/disables aria-valuemin, aria-valuemax and
   *    aria-valuenow tags
   *  - **tabindex** – `{boolean}` – Enables/disables tabindex tags
   *  - **bindKeydown** – `{boolean}` – Enables/disables keyboard event binding on non-interactive
   *    elements (such as `div` or `li`) using ng-click, making them more accessible to users of
   *    assistive technologies
   *  - **bindRoleForClick** – `{boolean}` – Adds role=button to non-interactive elements (such as
   *    `div` or `li`) using ng-click, making them more accessible to users of assistive
   *    technologies
   *
   * @description
   * Enables/disables various ARIA attributes
   */
  this.config = function(newConfig) {
    config = angular.extend(config, newConfig);
  };

  function watchExpr(attrName, ariaAttr, nodeBlackList, negate) {
    return function(scope, elem, attr) {
      if (attr.hasOwnProperty(ARIA_DISABLE_ATTR)) return;

      var ariaCamelName = attr.$normalize(ariaAttr);
      if (config[ariaCamelName] && !isNodeOneOf(elem, nodeBlackList) && !attr[ariaCamelName]) {
        scope.$watch(attr[attrName], function(boolVal) {
          // ensure boolean value
          boolVal = negate ? !boolVal : !!boolVal;
          elem.attr(ariaAttr, boolVal);
        });
      }
    };
  }
  /**
   * @ngdoc service
   * @name $aria
   *
   * @description
   * @priority 200
   *
   * The $aria service contains helper methods for applying common
   * [ARIA](http://www.w3.org/TR/wai-aria/) attributes to HTML directives.
   *
   * ngAria injects common accessibility attributes that tell assistive technologies when HTML
   * elements are enabled, selected, hidden, and more. To see how this is performed with ngAria,
   * let's review a code snippet from ngAria itself:
   *
   *```js
   * ngAriaModule.directive('ngDisabled', ['$aria', function($aria) {
   *   return $aria.$$watchExpr('ngDisabled', 'aria-disabled', nodeBlackList, false);
   * }])
   *```
   * Shown above, the ngAria module creates a directive with the same signature as the
   * traditional `ng-disabled` directive. But this ngAria version is dedicated to
   * solely managing accessibility attributes on custom elements. The internal `$aria` service is
   * used to watch the boolean attribute `ngDisabled`. If it has not been explicitly set by the
   * developer, `aria-disabled` is injected as an attribute with its value synchronized to the
   * value in `ngDisabled`.
   *
   * Because ngAria hooks into the `ng-disabled` directive, developers do not have to do
   * anything to enable this feature. The `aria-disabled` attribute is automatically managed
   * simply as a silent side-effect of using `ng-disabled` with the ngAria module.
   *
   * The full list of directives that interface with ngAria:
   * * **ngModel**
   * * **ngChecked**
   * * **ngReadonly**
   * * **ngRequired**
   * * **ngDisabled**
   * * **ngValue**
   * * **ngShow**
   * * **ngHide**
   * * **ngClick**
   * * **ngDblclick**
   * * **ngMessages**
   *
   * Read the {@link guide/accessibility ngAria Developer Guide} for a thorough explanation of each
   * directive.
   *
   *
   * ## Dependencies
   * Requires the {@link ngAria} module to be installed.
   */
  this.$get = function() {
    return {
      config: function(key) {
        return config[key];
      },
      $$watchExpr: watchExpr
    };
  };
}


ngAriaModule.directive('ngShow', ['$aria', function($aria) {
  return $aria.$$watchExpr('ngShow', 'aria-hidden', [], true);
}])
.directive('ngHide', ['$aria', function($aria) {
  return $aria.$$watchExpr('ngHide', 'aria-hidden', [], false);
}])
.directive('ngValue', ['$aria', function($aria) {
  return $aria.$$watchExpr('ngValue', 'aria-checked', nodeBlackList, false);
}])
.directive('ngChecked', ['$aria', function($aria) {
  return $aria.$$watchExpr('ngChecked', 'aria-checked', nodeBlackList, false);
}])
.directive('ngReadonly', ['$aria', function($aria) {
  return $aria.$$watchExpr('ngReadonly', 'aria-readonly', nodeBlackList, false);
}])
.directive('ngRequired', ['$aria', function($aria) {
  return $aria.$$watchExpr('ngRequired', 'aria-required', nodeBlackList, false);
}])
.directive('ngModel', ['$aria', function($aria) {

  function shouldAttachAttr(attr, normalizedAttr, elem, allowBlacklistEls) {
    return $aria.config(normalizedAttr) &&
      !elem.attr(attr) &&
      (allowBlacklistEls || !isNodeOneOf(elem, nodeBlackList)) &&
      (elem.attr('type') !== 'hidden' || elem[0].nodeName !== 'INPUT');
  }

  function shouldAttachRole(role, elem) {
    // if element does not have role attribute
    // AND element type is equal to role (if custom element has a type equaling shape) <-- remove?
    // AND element is not in nodeBlackList
    return !elem.attr('role') && (elem.attr('type') === role) && !isNodeOneOf(elem, nodeBlackList);
  }

  function getShape(attr, elem) {
    var type = attr.type,
        role = attr.role;

    return ((type || role) === 'checkbox' || role === 'menuitemcheckbox') ? 'checkbox' :
           ((type || role) === 'radio'    || role === 'menuitemradio') ? 'radio' :
           (type === 'range'              || role === 'progressbar' || role === 'slider') ? 'range' : '';
  }

  return {
    restrict: 'A',
    require: 'ngModel',
    priority: 200, //Make sure watches are fired after any other directives that affect the ngModel value
    compile: function(elem, attr) {
      if (attr.hasOwnProperty(ARIA_DISABLE_ATTR)) return;

      var shape = getShape(attr, elem);

      return {
        post: function(scope, elem, attr, ngModel) {
          var needsTabIndex = shouldAttachAttr('tabindex', 'tabindex', elem, false);

          function ngAriaWatchModelValue() {
            return ngModel.$modelValue;
          }

          function getRadioReaction(newVal) {
            // Strict comparison would cause a BC
            // eslint-disable-next-line eqeqeq
            var boolVal = (attr.value == ngModel.$viewValue);
            elem.attr('aria-checked', boolVal);
          }

          function getCheckboxReaction() {
            elem.attr('aria-checked', !ngModel.$isEmpty(ngModel.$viewValue));
          }

          switch (shape) {
            case 'radio':
            case 'checkbox':
              if (shouldAttachRole(shape, elem)) {
                elem.attr('role', shape);
              }
              if (shouldAttachAttr('aria-checked', 'ariaChecked', elem, false)) {
                scope.$watch(ngAriaWatchModelValue, shape === 'radio' ?
                    getRadioReaction : getCheckboxReaction);
              }
              if (needsTabIndex) {
                elem.attr('tabindex', 0);
              }
              break;
            case 'range':
              if (shouldAttachRole(shape, elem)) {
                elem.attr('role', 'slider');
              }
              if ($aria.config('ariaValue')) {
                var needsAriaValuemin = !elem.attr('aria-valuemin') &&
                    (attr.hasOwnProperty('min') || attr.hasOwnProperty('ngMin'));
                var needsAriaValuemax = !elem.attr('aria-valuemax') &&
                    (attr.hasOwnProperty('max') || attr.hasOwnProperty('ngMax'));
                var needsAriaValuenow = !elem.attr('aria-valuenow');

                if (needsAriaValuemin) {
                  attr.$observe('min', function ngAriaValueMinReaction(newVal) {
                    elem.attr('aria-valuemin', newVal);
                  });
                }
                if (needsAriaValuemax) {
                  attr.$observe('max', function ngAriaValueMinReaction(newVal) {
                    elem.attr('aria-valuemax', newVal);
                  });
                }
                if (needsAriaValuenow) {
                  scope.$watch(ngAriaWatchModelValue, function ngAriaValueNowReaction(newVal) {
                    elem.attr('aria-valuenow', newVal);
                  });
                }
              }
              if (needsTabIndex) {
                elem.attr('tabindex', 0);
              }
              break;
          }

          if (!attr.hasOwnProperty('ngRequired') && ngModel.$validators.required
            && shouldAttachAttr('aria-required', 'ariaRequired', elem, false)) {
            // ngModel.$error.required is undefined on custom controls
            attr.$observe('required', function() {
              elem.attr('aria-required', !!attr['required']);
            });
          }

          if (shouldAttachAttr('aria-invalid', 'ariaInvalid', elem, true)) {
            scope.$watch(function ngAriaInvalidWatch() {
              return ngModel.$invalid;
            }, function ngAriaInvalidReaction(newVal) {
              elem.attr('aria-invalid', !!newVal);
            });
          }
        }
      };
    }
  };
}])
.directive('ngDisabled', ['$aria', function($aria) {
  return $aria.$$watchExpr('ngDisabled', 'aria-disabled', nodeBlackList, false);
}])
.directive('ngMessages', function() {
  return {
    restrict: 'A',
    require: '?ngMessages',
    link: function(scope, elem, attr, ngMessages) {
      if (attr.hasOwnProperty(ARIA_DISABLE_ATTR)) return;

      if (!elem.attr('aria-live')) {
        elem.attr('aria-live', 'assertive');
      }
    }
  };
})
.directive('ngClick',['$aria', '$parse', function($aria, $parse) {
  return {
    restrict: 'A',
    compile: function(elem, attr) {
      if (attr.hasOwnProperty(ARIA_DISABLE_ATTR)) return;

      var fn = $parse(attr.ngClick);
      return function(scope, elem, attr) {

        if (!isNodeOneOf(elem, nodeBlackList)) {

          if ($aria.config('bindRoleForClick') && !elem.attr('role')) {
            elem.attr('role', 'button');
          }

          if ($aria.config('tabindex') && !elem.attr('tabindex')) {
            elem.attr('tabindex', 0);
          }

          if ($aria.config('bindKeydown') && !attr.ngKeydown && !attr.ngKeypress && !attr.ngKeyup) {
            elem.on('keydown', function(event) {
              var keyCode = event.which || event.keyCode;

              if (keyCode === 13 || keyCode === 32) {
                // If the event is triggered on a non-interactive element ...
                if (nodeBlackList.indexOf(event.target.nodeName) === -1 && !event.target.isContentEditable) {
                  // ... prevent the default browser behavior (e.g. scrolling when pressing spacebar)
                  // See https://github.com/angular/angular.js/issues/16664
                  event.preventDefault();
                }
                scope.$apply(callback);
              }

              function callback() {
                fn(scope, { $event: event });
              }
            });
          }
        }
      };
    }
  };
}])
.directive('ngDblclick', ['$aria', function($aria) {
  return function(scope, elem, attr) {
    if (attr.hasOwnProperty(ARIA_DISABLE_ATTR)) return;

    if ($aria.config('tabindex') && !elem.attr('tabindex') && !isNodeOneOf(elem, nodeBlackList)) {
      elem.attr('tabindex', 0);
    }
  };
}]);


})(window, window.angular);
;/**
 * @license AngularJS v1.7.8
 * (c) 2010-2018 Google, Inc. http://angularjs.org
 * License: MIT
 */
(function(window, angular) {'use strict';

var ELEMENT_NODE = 1;
var COMMENT_NODE = 8;

var ADD_CLASS_SUFFIX = '-add';
var REMOVE_CLASS_SUFFIX = '-remove';
var EVENT_CLASS_PREFIX = 'ng-';
var ACTIVE_CLASS_SUFFIX = '-active';
var PREPARE_CLASS_SUFFIX = '-prepare';

var NG_ANIMATE_CLASSNAME = 'ng-animate';
var NG_ANIMATE_CHILDREN_DATA = '$$ngAnimateChildren';

// Detect proper transitionend/animationend event names.
var CSS_PREFIX = '', TRANSITION_PROP, TRANSITIONEND_EVENT, ANIMATION_PROP, ANIMATIONEND_EVENT;

// If unprefixed events are not supported but webkit-prefixed are, use the latter.
// Otherwise, just use W3C names, browsers not supporting them at all will just ignore them.
// Note: Chrome implements `window.onwebkitanimationend` and doesn't implement `window.onanimationend`
// but at the same time dispatches the `animationend` event and not `webkitAnimationEnd`.
// Register both events in case `window.onanimationend` is not supported because of that,
// do the same for `transitionend` as Safari is likely to exhibit similar behavior.
// Also, the only modern browser that uses vendor prefixes for transitions/keyframes is webkit
// therefore there is no reason to test anymore for other vendor prefixes:
// http://caniuse.com/#search=transition
if ((window.ontransitionend === undefined) && (window.onwebkittransitionend !== undefined)) {
  CSS_PREFIX = '-webkit-';
  TRANSITION_PROP = 'WebkitTransition';
  TRANSITIONEND_EVENT = 'webkitTransitionEnd transitionend';
} else {
  TRANSITION_PROP = 'transition';
  TRANSITIONEND_EVENT = 'transitionend';
}

if ((window.onanimationend === undefined) && (window.onwebkitanimationend !== undefined)) {
  CSS_PREFIX = '-webkit-';
  ANIMATION_PROP = 'WebkitAnimation';
  ANIMATIONEND_EVENT = 'webkitAnimationEnd animationend';
} else {
  ANIMATION_PROP = 'animation';
  ANIMATIONEND_EVENT = 'animationend';
}

var DURATION_KEY = 'Duration';
var PROPERTY_KEY = 'Property';
var DELAY_KEY = 'Delay';
var TIMING_KEY = 'TimingFunction';
var ANIMATION_ITERATION_COUNT_KEY = 'IterationCount';
var ANIMATION_PLAYSTATE_KEY = 'PlayState';
var SAFE_FAST_FORWARD_DURATION_VALUE = 9999;

var ANIMATION_DELAY_PROP = ANIMATION_PROP + DELAY_KEY;
var ANIMATION_DURATION_PROP = ANIMATION_PROP + DURATION_KEY;
var TRANSITION_DELAY_PROP = TRANSITION_PROP + DELAY_KEY;
var TRANSITION_DURATION_PROP = TRANSITION_PROP + DURATION_KEY;

var ngMinErr = angular.$$minErr('ng');
function assertArg(arg, name, reason) {
  if (!arg) {
    throw ngMinErr('areq', 'Argument \'{0}\' is {1}', (name || '?'), (reason || 'required'));
  }
  return arg;
}

function mergeClasses(a,b) {
  if (!a && !b) return '';
  if (!a) return b;
  if (!b) return a;
  if (isArray(a)) a = a.join(' ');
  if (isArray(b)) b = b.join(' ');
  return a + ' ' + b;
}

function packageStyles(options) {
  var styles = {};
  if (options && (options.to || options.from)) {
    styles.to = options.to;
    styles.from = options.from;
  }
  return styles;
}

function pendClasses(classes, fix, isPrefix) {
  var className = '';
  classes = isArray(classes)
      ? classes
      : classes && isString(classes) && classes.length
          ? classes.split(/\s+/)
          : [];
  forEach(classes, function(klass, i) {
    if (klass && klass.length > 0) {
      className += (i > 0) ? ' ' : '';
      className += isPrefix ? fix + klass
                            : klass + fix;
    }
  });
  return className;
}

function removeFromArray(arr, val) {
  var index = arr.indexOf(val);
  if (val >= 0) {
    arr.splice(index, 1);
  }
}

function stripCommentsFromElement(element) {
  if (element instanceof jqLite) {
    switch (element.length) {
      case 0:
        return element;

      case 1:
        // there is no point of stripping anything if the element
        // is the only element within the jqLite wrapper.
        // (it's important that we retain the element instance.)
        if (element[0].nodeType === ELEMENT_NODE) {
          return element;
        }
        break;

      default:
        return jqLite(extractElementNode(element));
    }
  }

  if (element.nodeType === ELEMENT_NODE) {
    return jqLite(element);
  }
}

function extractElementNode(element) {
  if (!element[0]) return element;
  for (var i = 0; i < element.length; i++) {
    var elm = element[i];
    if (elm.nodeType === ELEMENT_NODE) {
      return elm;
    }
  }
}

function $$addClass($$jqLite, element, className) {
  forEach(element, function(elm) {
    $$jqLite.addClass(elm, className);
  });
}

function $$removeClass($$jqLite, element, className) {
  forEach(element, function(elm) {
    $$jqLite.removeClass(elm, className);
  });
}

function applyAnimationClassesFactory($$jqLite) {
  return function(element, options) {
    if (options.addClass) {
      $$addClass($$jqLite, element, options.addClass);
      options.addClass = null;
    }
    if (options.removeClass) {
      $$removeClass($$jqLite, element, options.removeClass);
      options.removeClass = null;
    }
  };
}

function prepareAnimationOptions(options) {
  options = options || {};
  if (!options.$$prepared) {
    var domOperation = options.domOperation || noop;
    options.domOperation = function() {
      options.$$domOperationFired = true;
      domOperation();
      domOperation = noop;
    };
    options.$$prepared = true;
  }
  return options;
}

function applyAnimationStyles(element, options) {
  applyAnimationFromStyles(element, options);
  applyAnimationToStyles(element, options);
}

function applyAnimationFromStyles(element, options) {
  if (options.from) {
    element.css(options.from);
    options.from = null;
  }
}

function applyAnimationToStyles(element, options) {
  if (options.to) {
    element.css(options.to);
    options.to = null;
  }
}

function mergeAnimationDetails(element, oldAnimation, newAnimation) {
  var target = oldAnimation.options || {};
  var newOptions = newAnimation.options || {};

  var toAdd = (target.addClass || '') + ' ' + (newOptions.addClass || '');
  var toRemove = (target.removeClass || '') + ' ' + (newOptions.removeClass || '');
  var classes = resolveElementClasses(element.attr('class'), toAdd, toRemove);

  if (newOptions.preparationClasses) {
    target.preparationClasses = concatWithSpace(newOptions.preparationClasses, target.preparationClasses);
    delete newOptions.preparationClasses;
  }

  // noop is basically when there is no callback; otherwise something has been set
  var realDomOperation = target.domOperation !== noop ? target.domOperation : null;

  extend(target, newOptions);

  // TODO(matsko or sreeramu): proper fix is to maintain all animation callback in array and call at last,but now only leave has the callback so no issue with this.
  if (realDomOperation) {
    target.domOperation = realDomOperation;
  }

  if (classes.addClass) {
    target.addClass = classes.addClass;
  } else {
    target.addClass = null;
  }

  if (classes.removeClass) {
    target.removeClass = classes.removeClass;
  } else {
    target.removeClass = null;
  }

  oldAnimation.addClass = target.addClass;
  oldAnimation.removeClass = target.removeClass;

  return target;
}

function resolveElementClasses(existing, toAdd, toRemove) {
  var ADD_CLASS = 1;
  var REMOVE_CLASS = -1;

  var flags = {};
  existing = splitClassesToLookup(existing);

  toAdd = splitClassesToLookup(toAdd);
  forEach(toAdd, function(value, key) {
    flags[key] = ADD_CLASS;
  });

  toRemove = splitClassesToLookup(toRemove);
  forEach(toRemove, function(value, key) {
    flags[key] = flags[key] === ADD_CLASS ? null : REMOVE_CLASS;
  });

  var classes = {
    addClass: '',
    removeClass: ''
  };

  forEach(flags, function(val, klass) {
    var prop, allow;
    if (val === ADD_CLASS) {
      prop = 'addClass';
      allow = !existing[klass] || existing[klass + REMOVE_CLASS_SUFFIX];
    } else if (val === REMOVE_CLASS) {
      prop = 'removeClass';
      allow = existing[klass] || existing[klass + ADD_CLASS_SUFFIX];
    }
    if (allow) {
      if (classes[prop].length) {
        classes[prop] += ' ';
      }
      classes[prop] += klass;
    }
  });

  function splitClassesToLookup(classes) {
    if (isString(classes)) {
      classes = classes.split(' ');
    }

    var obj = {};
    forEach(classes, function(klass) {
      // sometimes the split leaves empty string values
      // incase extra spaces were applied to the options
      if (klass.length) {
        obj[klass] = true;
      }
    });
    return obj;
  }

  return classes;
}

function getDomNode(element) {
  return (element instanceof jqLite) ? element[0] : element;
}

function applyGeneratedPreparationClasses($$jqLite, element, event, options) {
  var classes = '';
  if (event) {
    classes = pendClasses(event, EVENT_CLASS_PREFIX, true);
  }
  if (options.addClass) {
    classes = concatWithSpace(classes, pendClasses(options.addClass, ADD_CLASS_SUFFIX));
  }
  if (options.removeClass) {
    classes = concatWithSpace(classes, pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX));
  }
  if (classes.length) {
    options.preparationClasses = classes;
    element.addClass(classes);
  }
}

function clearGeneratedClasses(element, options) {
  if (options.preparationClasses) {
    element.removeClass(options.preparationClasses);
    options.preparationClasses = null;
  }
  if (options.activeClasses) {
    element.removeClass(options.activeClasses);
    options.activeClasses = null;
  }
}

function blockKeyframeAnimations(node, applyBlock) {
  var value = applyBlock ? 'paused' : '';
  var key = ANIMATION_PROP + ANIMATION_PLAYSTATE_KEY;
  applyInlineStyle(node, [key, value]);
  return [key, value];
}

function applyInlineStyle(node, styleTuple) {
  var prop = styleTuple[0];
  var value = styleTuple[1];
  node.style[prop] = value;
}

function concatWithSpace(a,b) {
  if (!a) return b;
  if (!b) return a;
  return a + ' ' + b;
}

var helpers = {
  blockTransitions: function(node, duration) {
    // we use a negative delay value since it performs blocking
    // yet it doesn't kill any existing transitions running on the
    // same element which makes this safe for class-based animations
    var value = duration ? '-' + duration + 's' : '';
    applyInlineStyle(node, [TRANSITION_DELAY_PROP, value]);
    return [TRANSITION_DELAY_PROP, value];
  }
};

var $$rAFSchedulerFactory = ['$$rAF', function($$rAF) {
  var queue, cancelFn;

  function scheduler(tasks) {
    // we make a copy since RAFScheduler mutates the state
    // of the passed in array variable and this would be difficult
    // to track down on the outside code
    queue = queue.concat(tasks);
    nextTick();
  }

  queue = scheduler.queue = [];

  /* waitUntilQuiet does two things:
   * 1. It will run the FINAL `fn` value only when an uncanceled RAF has passed through
   * 2. It will delay the next wave of tasks from running until the quiet `fn` has run.
   *
   * The motivation here is that animation code can request more time from the scheduler
   * before the next wave runs. This allows for certain DOM properties such as classes to
   * be resolved in time for the next animation to run.
   */
  scheduler.waitUntilQuiet = function(fn) {
    if (cancelFn) cancelFn();

    cancelFn = $$rAF(function() {
      cancelFn = null;
      fn();
      nextTick();
    });
  };

  return scheduler;

  function nextTick() {
    if (!queue.length) return;

    var items = queue.shift();
    for (var i = 0; i < items.length; i++) {
      items[i]();
    }

    if (!cancelFn) {
      $$rAF(function() {
        if (!cancelFn) nextTick();
      });
    }
  }
}];

/**
 * @ngdoc directive
 * @name ngAnimateChildren
 * @restrict AE
 * @element ANY
 *
 * @description
 *
 * ngAnimateChildren allows you to specify that children of this element should animate even if any
 * of the children's parents are currently animating. By default, when an element has an active `enter`, `leave`, or `move`
 * (structural) animation, child elements that also have an active structural animation are not animated.
 *
 * Note that even if `ngAnimateChildren` is set, no child animations will run when the parent element is removed from the DOM (`leave` animation).
 *
 *
 * @param {string} ngAnimateChildren If the value is empty, `true` or `on`,
 *     then child animations are allowed. If the value is `false`, child animations are not allowed.
 *
 * @example
 * <example module="ngAnimateChildren" name="ngAnimateChildren" deps="angular-animate.js" animations="true">
     <file name="index.html">
       <div ng-controller="MainController as main">
         <label>Show container? <input type="checkbox" ng-model="main.enterElement" /></label>
         <label>Animate children? <input type="checkbox" ng-model="main.animateChildren" /></label>
         <hr>
         <div ng-animate-children="{{main.animateChildren}}">
           <div ng-if="main.enterElement" class="container">
             List of items:
             <div ng-repeat="item in [0, 1, 2, 3]" class="item">Item {{item}}</div>
           </div>
         </div>
       </div>
     </file>
     <file name="animations.css">

      .container.ng-enter,
      .container.ng-leave {
        transition: all ease 1.5s;
      }

      .container.ng-enter,
      .container.ng-leave-active {
        opacity: 0;
      }

      .container.ng-leave,
      .container.ng-enter-active {
        opacity: 1;
      }

      .item {
        background: firebrick;
        color: #FFF;
        margin-bottom: 10px;
      }

      .item.ng-enter,
      .item.ng-leave {
        transition: transform 1.5s ease;
      }

      .item.ng-enter {
        transform: translateX(50px);
      }

      .item.ng-enter-active {
        transform: translateX(0);
      }
    </file>
    <file name="script.js">
      angular.module('ngAnimateChildren', ['ngAnimate'])
        .controller('MainController', function MainController() {
          this.animateChildren = false;
          this.enterElement = false;
        });
    </file>
  </example>
 */
var $$AnimateChildrenDirective = ['$interpolate', function($interpolate) {
  return {
    link: function(scope, element, attrs) {
      var val = attrs.ngAnimateChildren;
      if (isString(val) && val.length === 0) { //empty attribute
        element.data(NG_ANIMATE_CHILDREN_DATA, true);
      } else {
        // Interpolate and set the value, so that it is available to
        // animations that run right after compilation
        setData($interpolate(val)(scope));
        attrs.$observe('ngAnimateChildren', setData);
      }

      function setData(value) {
        value = value === 'on' || value === 'true';
        element.data(NG_ANIMATE_CHILDREN_DATA, value);
      }
    }
  };
}];

/* exported $AnimateCssProvider */

var ANIMATE_TIMER_KEY = '$$animateCss';

/**
 * @ngdoc service
 * @name $animateCss
 * @kind object
 *
 * @description
 * The `$animateCss` service is a useful utility to trigger customized CSS-based transitions/keyframes
 * from a JavaScript-based animation or directly from a directive. The purpose of `$animateCss` is NOT
 * to side-step how `$animate` and ngAnimate work, but the goal is to allow pre-existing animations or
 * directives to create more complex animations that can be purely driven using CSS code.
 *
 * Note that only browsers that support CSS transitions and/or keyframe animations are capable of
 * rendering animations triggered via `$animateCss` (bad news for IE9 and lower).
 *
 * ## General Use
 * Once again, `$animateCss` is designed to be used inside of a registered JavaScript animation that
 * is powered by ngAnimate. It is possible to use `$animateCss` directly inside of a directive, however,
 * any automatic control over cancelling animations and/or preventing animations from being run on
 * child elements will not be handled by AngularJS. For this to work as expected, please use `$animate` to
 * trigger the animation and then setup a JavaScript animation that injects `$animateCss` to trigger
 * the CSS animation.
 *
 * The example below shows how we can create a folding animation on an element using `ng-if`:
 *
 * ```html
 * <!-- notice the `fold-animation` CSS class -->
 * <div ng-if="onOff" class="fold-animation">
 *   This element will go BOOM
 * </div>
 * <button ng-click="onOff=true">Fold In</button>
 * ```
 *
 * Now we create the **JavaScript animation** that will trigger the CSS transition:
 *
 * ```js
 * ngModule.animation('.fold-animation', ['$animateCss', function($animateCss) {
 *   return {
 *     enter: function(element, doneFn) {
 *       var height = element[0].offsetHeight;
 *       return $animateCss(element, {
 *         from: { height:'0px' },
 *         to: { height:height + 'px' },
 *         duration: 1 // one second
 *       });
 *     }
 *   }
 * }]);
 * ```
 *
 * ## More Advanced Uses
 *
 * `$animateCss` is the underlying code that ngAnimate uses to power **CSS-based animations** behind the scenes. Therefore CSS hooks
 * like `.ng-EVENT`, `.ng-EVENT-active`, `.ng-EVENT-stagger` are all features that can be triggered using `$animateCss` via JavaScript code.
 *
 * This also means that just about any combination of adding classes, removing classes, setting styles, dynamically setting a keyframe animation,
 * applying a hardcoded duration or delay value, changing the animation easing or applying a stagger animation are all options that work with
 * `$animateCss`. The service itself is smart enough to figure out the combination of options and examine the element styling properties in order
 * to provide a working animation that will run in CSS.
 *
 * The example below showcases a more advanced version of the `.fold-animation` from the example above:
 *
 * ```js
 * ngModule.animation('.fold-animation', ['$animateCss', function($animateCss) {
 *   return {
 *     enter: function(element, doneFn) {
 *       var height = element[0].offsetHeight;
 *       return $animateCss(element, {
 *         addClass: 'red large-text pulse-twice',
 *         easing: 'ease-out',
 *         from: { height:'0px' },
 *         to: { height:height + 'px' },
 *         duration: 1 // one second
 *       });
 *     }
 *   }
 * }]);
 * ```
 *
 * Since we're adding/removing CSS classes then the CSS transition will also pick those up:
 *
 * ```css
 * /&#42; since a hardcoded duration value of 1 was provided in the JavaScript animation code,
 * the CSS classes below will be transitioned despite them being defined as regular CSS classes &#42;/
 * .red { background:red; }
 * .large-text { font-size:20px; }
 *
 * /&#42; we can also use a keyframe animation and $animateCss will make it work alongside the transition &#42;/
 * .pulse-twice {
 *   animation: 0.5s pulse linear 2;
 *   -webkit-animation: 0.5s pulse linear 2;
 * }
 *
 * @keyframes pulse {
 *   from { transform: scale(0.5); }
 *   to { transform: scale(1.5); }
 * }
 *
 * @-webkit-keyframes pulse {
 *   from { -webkit-transform: scale(0.5); }
 *   to { -webkit-transform: scale(1.5); }
 * }
 * ```
 *
 * Given this complex combination of CSS classes, styles and options, `$animateCss` will figure everything out and make the animation happen.
 *
 * ## How the Options are handled
 *
 * `$animateCss` is very versatile and intelligent when it comes to figuring out what configurations to apply to the element to ensure the animation
 * works with the options provided. Say for example we were adding a class that contained a keyframe value and we wanted to also animate some inline
 * styles using the `from` and `to` properties.
 *
 * ```js
 * var animator = $animateCss(element, {
 *   from: { background:'red' },
 *   to: { background:'blue' }
 * });
 * animator.start();
 * ```
 *
 * ```css
 * .rotating-animation {
 *   animation:0.5s rotate linear;
 *   -webkit-animation:0.5s rotate linear;
 * }
 *
 * @keyframes rotate {
 *   from { transform: rotate(0deg); }
 *   to { transform: rotate(360deg); }
 * }
 *
 * @-webkit-keyframes rotate {
 *   from { -webkit-transform: rotate(0deg); }
 *   to { -webkit-transform: rotate(360deg); }
 * }
 * ```
 *
 * The missing pieces here are that we do not have a transition set (within the CSS code nor within the `$animateCss` options) and the duration of the animation is
 * going to be detected from what the keyframe styles on the CSS class are. In this event, `$animateCss` will automatically create an inline transition
 * style matching the duration detected from the keyframe style (which is present in the CSS class that is being added) and then prepare both the transition
 * and keyframe animations to run in parallel on the element. Then when the animation is underway the provided `from` and `to` CSS styles will be applied
 * and spread across the transition and keyframe animation.
 *
 * ## What is returned
 *
 * `$animateCss` works in two stages: a preparation phase and an animation phase. Therefore when `$animateCss` is first called it will NOT actually
 * start the animation. All that is going on here is that the element is being prepared for the animation (which means that the generated CSS classes are
 * added and removed on the element). Once `$animateCss` is called it will return an object with the following properties:
 *
 * ```js
 * var animator = $animateCss(element, { ... });
 * ```
 *
 * Now what do the contents of our `animator` variable look like:
 *
 * ```js
 * {
 *   // starts the animation
 *   start: Function,
 *
 *   // ends (aborts) the animation
 *   end: Function
 * }
 * ```
 *
 * To actually start the animation we need to run `animation.start()` which will then return a promise that we can hook into to detect when the animation ends.
 * If we choose not to run the animation then we MUST run `animation.end()` to perform a cleanup on the element (since some CSS classes and styles may have been
 * applied to the element during the preparation phase). Note that all other properties such as duration, delay, transitions and keyframes are just properties
 * and that changing them will not reconfigure the parameters of the animation.
 *
 * ### runner.done() vs runner.then()
 * It is documented that `animation.start()` will return a promise object and this is true, however, there is also an additional method available on the
 * runner called `.done(callbackFn)`. The done method works the same as `.finally(callbackFn)`, however, it does **not trigger a digest to occur**.
 * Therefore, for performance reasons, it's always best to use `runner.done(callback)` instead of `runner.then()`, `runner.catch()` or `runner.finally()`
 * unless you really need a digest to kick off afterwards.
 *
 * Keep in mind that, to make this easier, ngAnimate has tweaked the JS animations API to recognize when a runner instance is returned from $animateCss
 * (so there is no need to call `runner.done(doneFn)` inside of your JavaScript animation code).
 * Check the {@link ngAnimate.$animateCss#usage animation code above} to see how this works.
 *
 * @param {DOMElement} element the element that will be animated
 * @param {object} options the animation-related options that will be applied during the animation
 *
 * * `event` - The DOM event (e.g. enter, leave, move). When used, a generated CSS class of `ng-EVENT` and `ng-EVENT-active` will be applied
 * to the element during the animation. Multiple events can be provided when spaces are used as a separator. (Note that this will not perform any DOM operation.)
 * * `structural` - Indicates that the `ng-` prefix will be added to the event class. Setting to `false` or omitting will turn `ng-EVENT` and
 * `ng-EVENT-active` in `EVENT` and `EVENT-active`. Unused if `event` is omitted.
 * * `easing` - The CSS easing value that will be applied to the transition or keyframe animation (or both).
 * * `transitionStyle` - The raw CSS transition style that will be used (e.g. `1s linear all`).
 * * `keyframeStyle` - The raw CSS keyframe animation style that will be used (e.g. `1s my_animation linear`).
 * * `from` - The starting CSS styles (a key/value object) that will be applied at the start of the animation.
 * * `to` - The ending CSS styles (a key/value object) that will be applied across the animation via a CSS transition.
 * * `addClass` - A space separated list of CSS classes that will be added to the element and spread across the animation.
 * * `removeClass` - A space separated list of CSS classes that will be removed from the element and spread across the animation.
 * * `duration` - A number value representing the total duration of the transition and/or keyframe (note that a value of 1 is 1000ms). If a value of `0`
 * is provided then the animation will be skipped entirely.
 * * `delay` - A number value representing the total delay of the transition and/or keyframe (note that a value of 1 is 1000ms). If a value of `true` is
 * used then whatever delay value is detected from the CSS classes will be mirrored on the elements styles (e.g. by setting delay true then the style value
 * of the element will be `transition-delay: DETECTED_VALUE`). Using `true` is useful when you want the CSS classes and inline styles to all share the same
 * CSS delay value.
 * * `stagger` - A numeric time value representing the delay between successively animated elements
 * ({@link ngAnimate#css-staggering-animations Click here to learn how CSS-based staggering works in ngAnimate.})
 * * `staggerIndex` - The numeric index representing the stagger item (e.g. a value of 5 is equal to the sixth item in the stagger; therefore when a
 *   `stagger` option value of `0.1` is used then there will be a stagger delay of `600ms`)
 * * `applyClassesEarly` - Whether or not the classes being added or removed will be used when detecting the animation. This is set by `$animate` when enter/leave/move animations are fired to ensure that the CSS classes are resolved in time. (Note that this will prevent any transitions from occurring on the classes being added and removed.)
 * * `cleanupStyles` - Whether or not the provided `from` and `to` styles will be removed once
 *    the animation is closed. This is useful for when the styles are used purely for the sake of
 *    the animation and do not have a lasting visual effect on the element (e.g. a collapse and open animation).
 *    By default this value is set to `false`.
 *
 * @return {object} an object with start and end methods and details about the animation.
 *
 * * `start` - The method to start the animation. This will return a `Promise` when called.
 * * `end` - This method will cancel the animation and remove all applied CSS classes and styles.
 */
var ONE_SECOND = 1000;

var ELAPSED_TIME_MAX_DECIMAL_PLACES = 3;
var CLOSING_TIME_BUFFER = 1.5;

var DETECT_CSS_PROPERTIES = {
  transitionDuration:      TRANSITION_DURATION_PROP,
  transitionDelay:         TRANSITION_DELAY_PROP,
  transitionProperty:      TRANSITION_PROP + PROPERTY_KEY,
  animationDuration:       ANIMATION_DURATION_PROP,
  animationDelay:          ANIMATION_DELAY_PROP,
  animationIterationCount: ANIMATION_PROP + ANIMATION_ITERATION_COUNT_KEY
};

var DETECT_STAGGER_CSS_PROPERTIES = {
  transitionDuration:      TRANSITION_DURATION_PROP,
  transitionDelay:         TRANSITION_DELAY_PROP,
  animationDuration:       ANIMATION_DURATION_PROP,
  animationDelay:          ANIMATION_DELAY_PROP
};

function getCssKeyframeDurationStyle(duration) {
  return [ANIMATION_DURATION_PROP, duration + 's'];
}

function getCssDelayStyle(delay, isKeyframeAnimation) {
  var prop = isKeyframeAnimation ? ANIMATION_DELAY_PROP : TRANSITION_DELAY_PROP;
  return [prop, delay + 's'];
}

function computeCssStyles($window, element, properties) {
  var styles = Object.create(null);
  var detectedStyles = $window.getComputedStyle(element) || {};
  forEach(properties, function(formalStyleName, actualStyleName) {
    var val = detectedStyles[formalStyleName];
    if (val) {
      var c = val.charAt(0);

      // only numerical-based values have a negative sign or digit as the first value
      if (c === '-' || c === '+' || c >= 0) {
        val = parseMaxTime(val);
      }

      // by setting this to null in the event that the delay is not set or is set directly as 0
      // then we can still allow for negative values to be used later on and not mistake this
      // value for being greater than any other negative value.
      if (val === 0) {
        val = null;
      }
      styles[actualStyleName] = val;
    }
  });

  return styles;
}

function parseMaxTime(str) {
  var maxValue = 0;
  var values = str.split(/\s*,\s*/);
  forEach(values, function(value) {
    // it's always safe to consider only second values and omit `ms` values since
    // getComputedStyle will always handle the conversion for us
    if (value.charAt(value.length - 1) === 's') {
      value = value.substring(0, value.length - 1);
    }
    value = parseFloat(value) || 0;
    maxValue = maxValue ? Math.max(value, maxValue) : value;
  });
  return maxValue;
}

function truthyTimingValue(val) {
  return val === 0 || val != null;
}

function getCssTransitionDurationStyle(duration, applyOnlyDuration) {
  var style = TRANSITION_PROP;
  var value = duration + 's';
  if (applyOnlyDuration) {
    style += DURATION_KEY;
  } else {
    value += ' linear all';
  }
  return [style, value];
}

// we do not reassign an already present style value since
// if we detect the style property value again we may be
// detecting styles that were added via the `from` styles.
// We make use of `isDefined` here since an empty string
// or null value (which is what getPropertyValue will return
// for a non-existing style) will still be marked as a valid
// value for the style (a falsy value implies that the style
// is to be removed at the end of the animation). If we had a simple
// "OR" statement then it would not be enough to catch that.
function registerRestorableStyles(backup, node, properties) {
  forEach(properties, function(prop) {
    backup[prop] = isDefined(backup[prop])
        ? backup[prop]
        : node.style.getPropertyValue(prop);
  });
}

var $AnimateCssProvider = ['$animateProvider', /** @this */ function($animateProvider) {

  this.$get = ['$window', '$$jqLite', '$$AnimateRunner', '$timeout', '$$animateCache',
               '$$forceReflow', '$sniffer', '$$rAFScheduler', '$$animateQueue',
       function($window,   $$jqLite,   $$AnimateRunner,   $timeout,   $$animateCache,
                $$forceReflow,   $sniffer,   $$rAFScheduler, $$animateQueue) {

    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);

    function computeCachedCssStyles(node, className, cacheKey, allowNoDuration, properties) {
      var timings = $$animateCache.get(cacheKey);

      if (!timings) {
        timings = computeCssStyles($window, node, properties);
        if (timings.animationIterationCount === 'infinite') {
          timings.animationIterationCount = 1;
        }
      }

      // if a css animation has no duration we
      // should mark that so that repeated addClass/removeClass calls are skipped
      var hasDuration = allowNoDuration || (timings.transitionDuration > 0 || timings.animationDuration > 0);

      // we keep putting this in multiple times even though the value and the cacheKey are the same
      // because we're keeping an internal tally of how many duplicate animations are detected.
      $$animateCache.put(cacheKey, timings, hasDuration);

      return timings;
    }

    function computeCachedCssStaggerStyles(node, className, cacheKey, properties) {
      var stagger;
      var staggerCacheKey = 'stagger-' + cacheKey;

      // if we have one or more existing matches of matching elements
      // containing the same parent + CSS styles (which is how cacheKey works)
      // then staggering is possible
      if ($$animateCache.count(cacheKey) > 0) {
        stagger = $$animateCache.get(staggerCacheKey);

        if (!stagger) {
          var staggerClassName = pendClasses(className, '-stagger');

          $$jqLite.addClass(node, staggerClassName);

          stagger = computeCssStyles($window, node, properties);

          // force the conversion of a null value to zero incase not set
          stagger.animationDuration = Math.max(stagger.animationDuration, 0);
          stagger.transitionDuration = Math.max(stagger.transitionDuration, 0);

          $$jqLite.removeClass(node, staggerClassName);

          $$animateCache.put(staggerCacheKey, stagger, true);
        }
      }

      return stagger || {};
    }

    var rafWaitQueue = [];
    function waitUntilQuiet(callback) {
      rafWaitQueue.push(callback);
      $$rAFScheduler.waitUntilQuiet(function() {
        $$animateCache.flush();

        // DO NOT REMOVE THIS LINE OR REFACTOR OUT THE `pageWidth` variable.
        // PLEASE EXAMINE THE `$$forceReflow` service to understand why.
        var pageWidth = $$forceReflow();

        // we use a for loop to ensure that if the queue is changed
        // during this looping then it will consider new requests
        for (var i = 0; i < rafWaitQueue.length; i++) {
          rafWaitQueue[i](pageWidth);
        }
        rafWaitQueue.length = 0;
      });
    }

    function computeTimings(node, className, cacheKey, allowNoDuration) {
      var timings = computeCachedCssStyles(node, className, cacheKey, allowNoDuration, DETECT_CSS_PROPERTIES);
      var aD = timings.animationDelay;
      var tD = timings.transitionDelay;
      timings.maxDelay = aD && tD
          ? Math.max(aD, tD)
          : (aD || tD);
      timings.maxDuration = Math.max(
          timings.animationDuration * timings.animationIterationCount,
          timings.transitionDuration);

      return timings;
    }

    return function init(element, initialOptions) {
      // all of the animation functions should create
      // a copy of the options data, however, if a
      // parent service has already created a copy then
      // we should stick to using that
      var options = initialOptions || {};
      if (!options.$$prepared) {
        options = prepareAnimationOptions(copy(options));
      }

      var restoreStyles = {};
      var node = getDomNode(element);
      if (!node
          || !node.parentNode
          || !$$animateQueue.enabled()) {
        return closeAndReturnNoopAnimator();
      }

      var temporaryStyles = [];
      var classes = element.attr('class');
      var styles = packageStyles(options);
      var animationClosed;
      var animationPaused;
      var animationCompleted;
      var runner;
      var runnerHost;
      var maxDelay;
      var maxDelayTime;
      var maxDuration;
      var maxDurationTime;
      var startTime;
      var events = [];

      if (options.duration === 0 || (!$sniffer.animations && !$sniffer.transitions)) {
        return closeAndReturnNoopAnimator();
      }

      var method = options.event && isArray(options.event)
            ? options.event.join(' ')
            : options.event;

      var isStructural = method && options.structural;
      var structuralClassName = '';
      var addRemoveClassName = '';

      if (isStructural) {
        structuralClassName = pendClasses(method, EVENT_CLASS_PREFIX, true);
      } else if (method) {
        structuralClassName = method;
      }

      if (options.addClass) {
        addRemoveClassName += pendClasses(options.addClass, ADD_CLASS_SUFFIX);
      }

      if (options.removeClass) {
        if (addRemoveClassName.length) {
          addRemoveClassName += ' ';
        }
        addRemoveClassName += pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX);
      }

      // there may be a situation where a structural animation is combined together
      // with CSS classes that need to resolve before the animation is computed.
      // However this means that there is no explicit CSS code to block the animation
      // from happening (by setting 0s none in the class name). If this is the case
      // we need to apply the classes before the first rAF so we know to continue if
      // there actually is a detected transition or keyframe animation
      if (options.applyClassesEarly && addRemoveClassName.length) {
        applyAnimationClasses(element, options);
      }

      var preparationClasses = [structuralClassName, addRemoveClassName].join(' ').trim();
      var fullClassName = classes + ' ' + preparationClasses;
      var hasToStyles = styles.to && Object.keys(styles.to).length > 0;
      var containsKeyframeAnimation = (options.keyframeStyle || '').length > 0;

      // there is no way we can trigger an animation if no styles and
      // no classes are being applied which would then trigger a transition,
      // unless there a is raw keyframe value that is applied to the element.
      if (!containsKeyframeAnimation
           && !hasToStyles
           && !preparationClasses) {
        return closeAndReturnNoopAnimator();
      }

      var stagger, cacheKey = $$animateCache.cacheKey(node, method, options.addClass, options.removeClass);
      if ($$animateCache.containsCachedAnimationWithoutDuration(cacheKey)) {
        preparationClasses = null;
        return closeAndReturnNoopAnimator();
      }

      if (options.stagger > 0) {
        var staggerVal = parseFloat(options.stagger);
        stagger = {
          transitionDelay: staggerVal,
          animationDelay: staggerVal,
          transitionDuration: 0,
          animationDuration: 0
        };
      } else {
        stagger = computeCachedCssStaggerStyles(node, preparationClasses, cacheKey, DETECT_STAGGER_CSS_PROPERTIES);
      }

      if (!options.$$skipPreparationClasses) {
        $$jqLite.addClass(element, preparationClasses);
      }

      var applyOnlyDuration;

      if (options.transitionStyle) {
        var transitionStyle = [TRANSITION_PROP, options.transitionStyle];
        applyInlineStyle(node, transitionStyle);
        temporaryStyles.push(transitionStyle);
      }

      if (options.duration >= 0) {
        applyOnlyDuration = node.style[TRANSITION_PROP].length > 0;
        var durationStyle = getCssTransitionDurationStyle(options.duration, applyOnlyDuration);

        // we set the duration so that it will be picked up by getComputedStyle later
        applyInlineStyle(node, durationStyle);
        temporaryStyles.push(durationStyle);
      }

      if (options.keyframeStyle) {
        var keyframeStyle = [ANIMATION_PROP, options.keyframeStyle];
        applyInlineStyle(node, keyframeStyle);
        temporaryStyles.push(keyframeStyle);
      }

      var itemIndex = stagger
          ? options.staggerIndex >= 0
              ? options.staggerIndex
              : $$animateCache.count(cacheKey)
          : 0;

      var isFirst = itemIndex === 0;

      // this is a pre-emptive way of forcing the setup classes to be added and applied INSTANTLY
      // without causing any combination of transitions to kick in. By adding a negative delay value
      // it forces the setup class' transition to end immediately. We later then remove the negative
      // transition delay to allow for the transition to naturally do it's thing. The beauty here is
      // that if there is no transition defined then nothing will happen and this will also allow
      // other transitions to be stacked on top of each other without any chopping them out.
      if (isFirst && !options.skipBlocking) {
        helpers.blockTransitions(node, SAFE_FAST_FORWARD_DURATION_VALUE);
      }

      var timings = computeTimings(node, fullClassName, cacheKey, !isStructural);
      var relativeDelay = timings.maxDelay;
      maxDelay = Math.max(relativeDelay, 0);
      maxDuration = timings.maxDuration;

      var flags = {};
      flags.hasTransitions          = timings.transitionDuration > 0;
      flags.hasAnimations           = timings.animationDuration > 0;
      flags.hasTransitionAll        = flags.hasTransitions && timings.transitionProperty === 'all';
      flags.applyTransitionDuration = hasToStyles && (
                                        (flags.hasTransitions && !flags.hasTransitionAll)
                                         || (flags.hasAnimations && !flags.hasTransitions));
      flags.applyAnimationDuration  = options.duration && flags.hasAnimations;
      flags.applyTransitionDelay    = truthyTimingValue(options.delay) && (flags.applyTransitionDuration || flags.hasTransitions);
      flags.applyAnimationDelay     = truthyTimingValue(options.delay) && flags.hasAnimations;
      flags.recalculateTimingStyles = addRemoveClassName.length > 0;

      if (flags.applyTransitionDuration || flags.applyAnimationDuration) {
        maxDuration = options.duration ? parseFloat(options.duration) : maxDuration;

        if (flags.applyTransitionDuration) {
          flags.hasTransitions = true;
          timings.transitionDuration = maxDuration;
          applyOnlyDuration = node.style[TRANSITION_PROP + PROPERTY_KEY].length > 0;
          temporaryStyles.push(getCssTransitionDurationStyle(maxDuration, applyOnlyDuration));
        }

        if (flags.applyAnimationDuration) {
          flags.hasAnimations = true;
          timings.animationDuration = maxDuration;
          temporaryStyles.push(getCssKeyframeDurationStyle(maxDuration));
        }
      }

      if (maxDuration === 0 && !flags.recalculateTimingStyles) {
        return closeAndReturnNoopAnimator();
      }

      var activeClasses = pendClasses(preparationClasses, ACTIVE_CLASS_SUFFIX);

      if (options.delay != null) {
        var delayStyle;
        if (typeof options.delay !== 'boolean') {
          delayStyle = parseFloat(options.delay);
          // number in options.delay means we have to recalculate the delay for the closing timeout
          maxDelay = Math.max(delayStyle, 0);
        }

        if (flags.applyTransitionDelay) {
          temporaryStyles.push(getCssDelayStyle(delayStyle));
        }

        if (flags.applyAnimationDelay) {
          temporaryStyles.push(getCssDelayStyle(delayStyle, true));
        }
      }

      // we need to recalculate the delay value since we used a pre-emptive negative
      // delay value and the delay value is required for the final event checking. This
      // property will ensure that this will happen after the RAF phase has passed.
      if (options.duration == null && timings.transitionDuration > 0) {
        flags.recalculateTimingStyles = flags.recalculateTimingStyles || isFirst;
      }

      maxDelayTime = maxDelay * ONE_SECOND;
      maxDurationTime = maxDuration * ONE_SECOND;
      if (!options.skipBlocking) {
        flags.blockTransition = timings.transitionDuration > 0;
        flags.blockKeyframeAnimation = timings.animationDuration > 0 &&
                                       stagger.animationDelay > 0 &&
                                       stagger.animationDuration === 0;
      }

      if (options.from) {
        if (options.cleanupStyles) {
          registerRestorableStyles(restoreStyles, node, Object.keys(options.from));
        }
        applyAnimationFromStyles(element, options);
      }

      if (flags.blockTransition || flags.blockKeyframeAnimation) {
        applyBlocking(maxDuration);
      } else if (!options.skipBlocking) {
        helpers.blockTransitions(node, false);
      }

      // TODO(matsko): for 1.5 change this code to have an animator object for better debugging
      return {
        $$willAnimate: true,
        end: endFn,
        start: function() {
          if (animationClosed) return;

          runnerHost = {
            end: endFn,
            cancel: cancelFn,
            resume: null, //this will be set during the start() phase
            pause: null
          };

          runner = new $$AnimateRunner(runnerHost);

          waitUntilQuiet(start);

          // we don't have access to pause/resume the animation
          // since it hasn't run yet. AnimateRunner will therefore
          // set noop functions for resume and pause and they will
          // later be overridden once the animation is triggered
          return runner;
        }
      };

      function endFn() {
        close();
      }

      function cancelFn() {
        close(true);
      }

      function close(rejected) {
        // if the promise has been called already then we shouldn't close
        // the animation again
        if (animationClosed || (animationCompleted && animationPaused)) return;
        animationClosed = true;
        animationPaused = false;

        if (preparationClasses && !options.$$skipPreparationClasses) {
          $$jqLite.removeClass(element, preparationClasses);
        }

        if (activeClasses) {
          $$jqLite.removeClass(element, activeClasses);
        }

        blockKeyframeAnimations(node, false);
        helpers.blockTransitions(node, false);

        forEach(temporaryStyles, function(entry) {
          // There is only one way to remove inline style properties entirely from elements.
          // By using `removeProperty` this works, but we need to convert camel-cased CSS
          // styles down to hyphenated values.
          node.style[entry[0]] = '';
        });

        applyAnimationClasses(element, options);
        applyAnimationStyles(element, options);

        if (Object.keys(restoreStyles).length) {
          forEach(restoreStyles, function(value, prop) {
            if (value) {
              node.style.setProperty(prop, value);
            } else {
              node.style.removeProperty(prop);
            }
          });
        }

        // the reason why we have this option is to allow a synchronous closing callback
        // that is fired as SOON as the animation ends (when the CSS is removed) or if
        // the animation never takes off at all. A good example is a leave animation since
        // the element must be removed just after the animation is over or else the element
        // will appear on screen for one animation frame causing an overbearing flicker.
        if (options.onDone) {
          options.onDone();
        }

        if (events && events.length) {
          // Remove the transitionend / animationend listener(s)
          element.off(events.join(' '), onAnimationProgress);
        }

        //Cancel the fallback closing timeout and remove the timer data
        var animationTimerData = element.data(ANIMATE_TIMER_KEY);
        if (animationTimerData) {
          $timeout.cancel(animationTimerData[0].timer);
          element.removeData(ANIMATE_TIMER_KEY);
        }

        // if the preparation function fails then the promise is not setup
        if (runner) {
          runner.complete(!rejected);
        }
      }

      function applyBlocking(duration) {
        if (flags.blockTransition) {
          helpers.blockTransitions(node, duration);
        }

        if (flags.blockKeyframeAnimation) {
          blockKeyframeAnimations(node, !!duration);
        }
      }

      function closeAndReturnNoopAnimator() {
        runner = new $$AnimateRunner({
          end: endFn,
          cancel: cancelFn
        });

        // should flush the cache animation
        waitUntilQuiet(noop);
        close();

        return {
          $$willAnimate: false,
          start: function() {
            return runner;
          },
          end: endFn
        };
      }

      function onAnimationProgress(event) {
        event.stopPropagation();
        var ev = event.originalEvent || event;

        if (ev.target !== node) {
          // Since TransitionEvent / AnimationEvent bubble up,
          // we have to ignore events by finished child animations
          return;
        }

        // we now always use `Date.now()` due to the recent changes with
        // event.timeStamp in Firefox, Webkit and Chrome (see #13494 for more info)
        var timeStamp = ev.$manualTimeStamp || Date.now();

        /* Firefox (or possibly just Gecko) likes to not round values up
         * when a ms measurement is used for the animation */
        var elapsedTime = parseFloat(ev.elapsedTime.toFixed(ELAPSED_TIME_MAX_DECIMAL_PLACES));

        /* $manualTimeStamp is a mocked timeStamp value which is set
         * within browserTrigger(). This is only here so that tests can
         * mock animations properly. Real events fallback to event.timeStamp,
         * or, if they don't, then a timeStamp is automatically created for them.
         * We're checking to see if the timeStamp surpasses the expected delay,
         * but we're using elapsedTime instead of the timeStamp on the 2nd
         * pre-condition since animationPauseds sometimes close off early */
        if (Math.max(timeStamp - startTime, 0) >= maxDelayTime && elapsedTime >= maxDuration) {
          // we set this flag to ensure that if the transition is paused then, when resumed,
          // the animation will automatically close itself since transitions cannot be paused.
          animationCompleted = true;
          close();
        }
      }

      function start() {
        if (animationClosed) return;
        if (!node.parentNode) {
          close();
          return;
        }

        // even though we only pause keyframe animations here the pause flag
        // will still happen when transitions are used. Only the transition will
        // not be paused since that is not possible. If the animation ends when
        // paused then it will not complete until unpaused or cancelled.
        var playPause = function(playAnimation) {
          if (!animationCompleted) {
            animationPaused = !playAnimation;
            if (timings.animationDuration) {
              var value = blockKeyframeAnimations(node, animationPaused);
              if (animationPaused) {
                temporaryStyles.push(value);
              } else {
                removeFromArray(temporaryStyles, value);
              }
            }
          } else if (animationPaused && playAnimation) {
            animationPaused = false;
            close();
          }
        };

        // checking the stagger duration prevents an accidentally cascade of the CSS delay style
        // being inherited from the parent. If the transition duration is zero then we can safely
        // rely that the delay value is an intentional stagger delay style.
        var maxStagger = itemIndex > 0
                         && ((timings.transitionDuration && stagger.transitionDuration === 0) ||
                            (timings.animationDuration && stagger.animationDuration === 0))
                         && Math.max(stagger.animationDelay, stagger.transitionDelay);
        if (maxStagger) {
          $timeout(triggerAnimationStart,
                   Math.floor(maxStagger * itemIndex * ONE_SECOND),
                   false);
        } else {
          triggerAnimationStart();
        }

        // this will decorate the existing promise runner with pause/resume methods
        runnerHost.resume = function() {
          playPause(true);
        };

        runnerHost.pause = function() {
          playPause(false);
        };

        function triggerAnimationStart() {
          // just incase a stagger animation kicks in when the animation
          // itself was cancelled entirely
          if (animationClosed) return;

          applyBlocking(false);

          forEach(temporaryStyles, function(entry) {
            var key = entry[0];
            var value = entry[1];
            node.style[key] = value;
          });

          applyAnimationClasses(element, options);
          $$jqLite.addClass(element, activeClasses);

          if (flags.recalculateTimingStyles) {
            fullClassName = node.getAttribute('class') + ' ' + preparationClasses;
            cacheKey = $$animateCache.cacheKey(node, method, options.addClass, options.removeClass);

            timings = computeTimings(node, fullClassName, cacheKey, false);
            relativeDelay = timings.maxDelay;
            maxDelay = Math.max(relativeDelay, 0);
            maxDuration = timings.maxDuration;

            if (maxDuration === 0) {
              close();
              return;
            }

            flags.hasTransitions = timings.transitionDuration > 0;
            flags.hasAnimations = timings.animationDuration > 0;
          }

          if (flags.applyAnimationDelay) {
            relativeDelay = typeof options.delay !== 'boolean' && truthyTimingValue(options.delay)
                  ? parseFloat(options.delay)
                  : relativeDelay;

            maxDelay = Math.max(relativeDelay, 0);
            timings.animationDelay = relativeDelay;
            delayStyle = getCssDelayStyle(relativeDelay, true);
            temporaryStyles.push(delayStyle);
            node.style[delayStyle[0]] = delayStyle[1];
          }

          maxDelayTime = maxDelay * ONE_SECOND;
          maxDurationTime = maxDuration * ONE_SECOND;

          if (options.easing) {
            var easeProp, easeVal = options.easing;
            if (flags.hasTransitions) {
              easeProp = TRANSITION_PROP + TIMING_KEY;
              temporaryStyles.push([easeProp, easeVal]);
              node.style[easeProp] = easeVal;
            }
            if (flags.hasAnimations) {
              easeProp = ANIMATION_PROP + TIMING_KEY;
              temporaryStyles.push([easeProp, easeVal]);
              node.style[easeProp] = easeVal;
            }
          }

          if (timings.transitionDuration) {
            events.push(TRANSITIONEND_EVENT);
          }

          if (timings.animationDuration) {
            events.push(ANIMATIONEND_EVENT);
          }

          startTime = Date.now();
          var timerTime = maxDelayTime + CLOSING_TIME_BUFFER * maxDurationTime;
          var endTime = startTime + timerTime;

          var animationsData = element.data(ANIMATE_TIMER_KEY) || [];
          var setupFallbackTimer = true;
          if (animationsData.length) {
            var currentTimerData = animationsData[0];
            setupFallbackTimer = endTime > currentTimerData.expectedEndTime;
            if (setupFallbackTimer) {
              $timeout.cancel(currentTimerData.timer);
            } else {
              animationsData.push(close);
            }
          }

          if (setupFallbackTimer) {
            var timer = $timeout(onAnimationExpired, timerTime, false);
            animationsData[0] = {
              timer: timer,
              expectedEndTime: endTime
            };
            animationsData.push(close);
            element.data(ANIMATE_TIMER_KEY, animationsData);
          }

          if (events.length) {
            element.on(events.join(' '), onAnimationProgress);
          }

          if (options.to) {
            if (options.cleanupStyles) {
              registerRestorableStyles(restoreStyles, node, Object.keys(options.to));
            }
            applyAnimationToStyles(element, options);
          }
        }

        function onAnimationExpired() {
          var animationsData = element.data(ANIMATE_TIMER_KEY);

          // this will be false in the event that the element was
          // removed from the DOM (via a leave animation or something
          // similar)
          if (animationsData) {
            for (var i = 1; i < animationsData.length; i++) {
              animationsData[i]();
            }
            element.removeData(ANIMATE_TIMER_KEY);
          }
        }
      }
    };
  }];
}];

var $$AnimateCssDriverProvider = ['$$animationProvider', /** @this */ function($$animationProvider) {
  $$animationProvider.drivers.push('$$animateCssDriver');

  var NG_ANIMATE_SHIM_CLASS_NAME = 'ng-animate-shim';
  var NG_ANIMATE_ANCHOR_CLASS_NAME = 'ng-anchor';

  var NG_OUT_ANCHOR_CLASS_NAME = 'ng-anchor-out';
  var NG_IN_ANCHOR_CLASS_NAME = 'ng-anchor-in';

  function isDocumentFragment(node) {
    return node.parentNode && node.parentNode.nodeType === 11;
  }

  this.$get = ['$animateCss', '$rootScope', '$$AnimateRunner', '$rootElement', '$sniffer', '$$jqLite', '$document',
       function($animateCss,   $rootScope,   $$AnimateRunner,   $rootElement,   $sniffer,   $$jqLite,   $document) {

    // only browsers that support these properties can render animations
    if (!$sniffer.animations && !$sniffer.transitions) return noop;

    var bodyNode = $document[0].body;
    var rootNode = getDomNode($rootElement);

    var rootBodyElement = jqLite(
      // this is to avoid using something that exists outside of the body
      // we also special case the doc fragment case because our unit test code
      // appends the $rootElement to the body after the app has been bootstrapped
      isDocumentFragment(rootNode) || bodyNode.contains(rootNode) ? rootNode : bodyNode
    );

    return function initDriverFn(animationDetails) {
      return animationDetails.from && animationDetails.to
          ? prepareFromToAnchorAnimation(animationDetails.from,
                                         animationDetails.to,
                                         animationDetails.classes,
                                         animationDetails.anchors)
          : prepareRegularAnimation(animationDetails);
    };

    function filterCssClasses(classes) {
      //remove all the `ng-` stuff
      return classes.replace(/\bng-\S+\b/g, '');
    }

    function getUniqueValues(a, b) {
      if (isString(a)) a = a.split(' ');
      if (isString(b)) b = b.split(' ');
      return a.filter(function(val) {
        return b.indexOf(val) === -1;
      }).join(' ');
    }

    function prepareAnchoredAnimation(classes, outAnchor, inAnchor) {
      var clone = jqLite(getDomNode(outAnchor).cloneNode(true));
      var startingClasses = filterCssClasses(getClassVal(clone));

      outAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);
      inAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);

      clone.addClass(NG_ANIMATE_ANCHOR_CLASS_NAME);

      rootBodyElement.append(clone);

      var animatorIn, animatorOut = prepareOutAnimation();

      // the user may not end up using the `out` animation and
      // only making use of the `in` animation or vice-versa.
      // In either case we should allow this and not assume the
      // animation is over unless both animations are not used.
      if (!animatorOut) {
        animatorIn = prepareInAnimation();
        if (!animatorIn) {
          return end();
        }
      }

      var startingAnimator = animatorOut || animatorIn;

      return {
        start: function() {
          var runner;

          var currentAnimation = startingAnimator.start();
          currentAnimation.done(function() {
            currentAnimation = null;
            if (!animatorIn) {
              animatorIn = prepareInAnimation();
              if (animatorIn) {
                currentAnimation = animatorIn.start();
                currentAnimation.done(function() {
                  currentAnimation = null;
                  end();
                  runner.complete();
                });
                return currentAnimation;
              }
            }
            // in the event that there is no `in` animation
            end();
            runner.complete();
          });

          runner = new $$AnimateRunner({
            end: endFn,
            cancel: endFn
          });

          return runner;

          function endFn() {
            if (currentAnimation) {
              currentAnimation.end();
            }
          }
        }
      };

      function calculateAnchorStyles(anchor) {
        var styles = {};

        var coords = getDomNode(anchor).getBoundingClientRect();

        // we iterate directly since safari messes up and doesn't return
        // all the keys for the coords object when iterated
        forEach(['width','height','top','left'], function(key) {
          var value = coords[key];
          switch (key) {
            case 'top':
              value += bodyNode.scrollTop;
              break;
            case 'left':
              value += bodyNode.scrollLeft;
              break;
          }
          styles[key] = Math.floor(value) + 'px';
        });
        return styles;
      }

      function prepareOutAnimation() {
        var animator = $animateCss(clone, {
          addClass: NG_OUT_ANCHOR_CLASS_NAME,
          delay: true,
          from: calculateAnchorStyles(outAnchor)
        });

        // read the comment within `prepareRegularAnimation` to understand
        // why this check is necessary
        return animator.$$willAnimate ? animator : null;
      }

      function getClassVal(element) {
        return element.attr('class') || '';
      }

      function prepareInAnimation() {
        var endingClasses = filterCssClasses(getClassVal(inAnchor));
        var toAdd = getUniqueValues(endingClasses, startingClasses);
        var toRemove = getUniqueValues(startingClasses, endingClasses);

        var animator = $animateCss(clone, {
          to: calculateAnchorStyles(inAnchor),
          addClass: NG_IN_ANCHOR_CLASS_NAME + ' ' + toAdd,
          removeClass: NG_OUT_ANCHOR_CLASS_NAME + ' ' + toRemove,
          delay: true
        });

        // read the comment within `prepareRegularAnimation` to understand
        // why this check is necessary
        return animator.$$willAnimate ? animator : null;
      }

      function end() {
        clone.remove();
        outAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);
        inAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);
      }
    }

    function prepareFromToAnchorAnimation(from, to, classes, anchors) {
      var fromAnimation = prepareRegularAnimation(from, noop);
      var toAnimation = prepareRegularAnimation(to, noop);

      var anchorAnimations = [];
      forEach(anchors, function(anchor) {
        var outElement = anchor['out'];
        var inElement = anchor['in'];
        var animator = prepareAnchoredAnimation(classes, outElement, inElement);
        if (animator) {
          anchorAnimations.push(animator);
        }
      });

      // no point in doing anything when there are no elements to animate
      if (!fromAnimation && !toAnimation && anchorAnimations.length === 0) return;

      return {
        start: function() {
          var animationRunners = [];

          if (fromAnimation) {
            animationRunners.push(fromAnimation.start());
          }

          if (toAnimation) {
            animationRunners.push(toAnimation.start());
          }

          forEach(anchorAnimations, function(animation) {
            animationRunners.push(animation.start());
          });

          var runner = new $$AnimateRunner({
            end: endFn,
            cancel: endFn // CSS-driven animations cannot be cancelled, only ended
          });

          $$AnimateRunner.all(animationRunners, function(status) {
            runner.complete(status);
          });

          return runner;

          function endFn() {
            forEach(animationRunners, function(runner) {
              runner.end();
            });
          }
        }
      };
    }

    function prepareRegularAnimation(animationDetails) {
      var element = animationDetails.element;
      var options = animationDetails.options || {};

      if (animationDetails.structural) {
        options.event = animationDetails.event;
        options.structural = true;
        options.applyClassesEarly = true;

        // we special case the leave animation since we want to ensure that
        // the element is removed as soon as the animation is over. Otherwise
        // a flicker might appear or the element may not be removed at all
        if (animationDetails.event === 'leave') {
          options.onDone = options.domOperation;
        }
      }

      // We assign the preparationClasses as the actual animation event since
      // the internals of $animateCss will just suffix the event token values
      // with `-active` to trigger the animation.
      if (options.preparationClasses) {
        options.event = concatWithSpace(options.event, options.preparationClasses);
      }

      var animator = $animateCss(element, options);

      // the driver lookup code inside of $$animation attempts to spawn a
      // driver one by one until a driver returns a.$$willAnimate animator object.
      // $animateCss will always return an object, however, it will pass in
      // a flag as a hint as to whether an animation was detected or not
      return animator.$$willAnimate ? animator : null;
    }
  }];
}];

// TODO(matsko): use caching here to speed things up for detection
// TODO(matsko): add documentation
//  by the time...

var $$AnimateJsProvider = ['$animateProvider', /** @this */ function($animateProvider) {
  this.$get = ['$injector', '$$AnimateRunner', '$$jqLite',
       function($injector,   $$AnimateRunner,   $$jqLite) {

    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
         // $animateJs(element, 'enter');
    return function(element, event, classes, options) {
      var animationClosed = false;

      // the `classes` argument is optional and if it is not used
      // then the classes will be resolved from the element's className
      // property as well as options.addClass/options.removeClass.
      if (arguments.length === 3 && isObject(classes)) {
        options = classes;
        classes = null;
      }

      options = prepareAnimationOptions(options);
      if (!classes) {
        classes = element.attr('class') || '';
        if (options.addClass) {
          classes += ' ' + options.addClass;
        }
        if (options.removeClass) {
          classes += ' ' + options.removeClass;
        }
      }

      var classesToAdd = options.addClass;
      var classesToRemove = options.removeClass;

      // the lookupAnimations function returns a series of animation objects that are
      // matched up with one or more of the CSS classes. These animation objects are
      // defined via the module.animation factory function. If nothing is detected then
      // we don't return anything which then makes $animation query the next driver.
      var animations = lookupAnimations(classes);
      var before, after;
      if (animations.length) {
        var afterFn, beforeFn;
        if (event === 'leave') {
          beforeFn = 'leave';
          afterFn = 'afterLeave'; // TODO(matsko): get rid of this
        } else {
          beforeFn = 'before' + event.charAt(0).toUpperCase() + event.substr(1);
          afterFn = event;
        }

        if (event !== 'enter' && event !== 'move') {
          before = packageAnimations(element, event, options, animations, beforeFn);
        }
        after  = packageAnimations(element, event, options, animations, afterFn);
      }

      // no matching animations
      if (!before && !after) return;

      function applyOptions() {
        options.domOperation();
        applyAnimationClasses(element, options);
      }

      function close() {
        animationClosed = true;
        applyOptions();
        applyAnimationStyles(element, options);
      }

      var runner;

      return {
        $$willAnimate: true,
        end: function() {
          if (runner) {
            runner.end();
          } else {
            close();
            runner = new $$AnimateRunner();
            runner.complete(true);
          }
          return runner;
        },
        start: function() {
          if (runner) {
            return runner;
          }

          runner = new $$AnimateRunner();
          var closeActiveAnimations;
          var chain = [];

          if (before) {
            chain.push(function(fn) {
              closeActiveAnimations = before(fn);
            });
          }

          if (chain.length) {
            chain.push(function(fn) {
              applyOptions();
              fn(true);
            });
          } else {
            applyOptions();
          }

          if (after) {
            chain.push(function(fn) {
              closeActiveAnimations = after(fn);
            });
          }

          runner.setHost({
            end: function() {
              endAnimations();
            },
            cancel: function() {
              endAnimations(true);
            }
          });

          $$AnimateRunner.chain(chain, onComplete);
          return runner;

          function onComplete(success) {
            close(success);
            runner.complete(success);
          }

          function endAnimations(cancelled) {
            if (!animationClosed) {
              (closeActiveAnimations || noop)(cancelled);
              onComplete(cancelled);
            }
          }
        }
      };

      function executeAnimationFn(fn, element, event, options, onDone) {
        var args;
        switch (event) {
          case 'animate':
            args = [element, options.from, options.to, onDone];
            break;

          case 'setClass':
            args = [element, classesToAdd, classesToRemove, onDone];
            break;

          case 'addClass':
            args = [element, classesToAdd, onDone];
            break;

          case 'removeClass':
            args = [element, classesToRemove, onDone];
            break;

          default:
            args = [element, onDone];
            break;
        }

        args.push(options);

        var value = fn.apply(fn, args);
        if (value) {
          if (isFunction(value.start)) {
            value = value.start();
          }

          if (value instanceof $$AnimateRunner) {
            value.done(onDone);
          } else if (isFunction(value)) {
            // optional onEnd / onCancel callback
            return value;
          }
        }

        return noop;
      }

      function groupEventedAnimations(element, event, options, animations, fnName) {
        var operations = [];
        forEach(animations, function(ani) {
          var animation = ani[fnName];
          if (!animation) return;

          // note that all of these animations will run in parallel
          operations.push(function() {
            var runner;
            var endProgressCb;

            var resolved = false;
            var onAnimationComplete = function(rejected) {
              if (!resolved) {
                resolved = true;
                (endProgressCb || noop)(rejected);
                runner.complete(!rejected);
              }
            };

            runner = new $$AnimateRunner({
              end: function() {
                onAnimationComplete();
              },
              cancel: function() {
                onAnimationComplete(true);
              }
            });

            endProgressCb = executeAnimationFn(animation, element, event, options, function(result) {
              var cancelled = result === false;
              onAnimationComplete(cancelled);
            });

            return runner;
          });
        });

        return operations;
      }

      function packageAnimations(element, event, options, animations, fnName) {
        var operations = groupEventedAnimations(element, event, options, animations, fnName);
        if (operations.length === 0) {
          var a, b;
          if (fnName === 'beforeSetClass') {
            a = groupEventedAnimations(element, 'removeClass', options, animations, 'beforeRemoveClass');
            b = groupEventedAnimations(element, 'addClass', options, animations, 'beforeAddClass');
          } else if (fnName === 'setClass') {
            a = groupEventedAnimations(element, 'removeClass', options, animations, 'removeClass');
            b = groupEventedAnimations(element, 'addClass', options, animations, 'addClass');
          }

          if (a) {
            operations = operations.concat(a);
          }
          if (b) {
            operations = operations.concat(b);
          }
        }

        if (operations.length === 0) return;

        // TODO(matsko): add documentation
        return function startAnimation(callback) {
          var runners = [];
          if (operations.length) {
            forEach(operations, function(animateFn) {
              runners.push(animateFn());
            });
          }

          if (runners.length) {
            $$AnimateRunner.all(runners, callback);
          }  else {
            callback();
          }

          return function endFn(reject) {
            forEach(runners, function(runner) {
              if (reject) {
                runner.cancel();
              } else {
                runner.end();
              }
            });
          };
        };
      }
    };

    function lookupAnimations(classes) {
      classes = isArray(classes) ? classes : classes.split(' ');
      var matches = [], flagMap = {};
      for (var i = 0; i < classes.length; i++) {
        var klass = classes[i],
            animationFactory = $animateProvider.$$registeredAnimations[klass];
        if (animationFactory && !flagMap[klass]) {
          matches.push($injector.get(animationFactory));
          flagMap[klass] = true;
        }
      }
      return matches;
    }
  }];
}];

var $$AnimateJsDriverProvider = ['$$animationProvider', /** @this */ function($$animationProvider) {
  $$animationProvider.drivers.push('$$animateJsDriver');
  this.$get = ['$$animateJs', '$$AnimateRunner', function($$animateJs, $$AnimateRunner) {
    return function initDriverFn(animationDetails) {
      if (animationDetails.from && animationDetails.to) {
        var fromAnimation = prepareAnimation(animationDetails.from);
        var toAnimation = prepareAnimation(animationDetails.to);
        if (!fromAnimation && !toAnimation) return;

        return {
          start: function() {
            var animationRunners = [];

            if (fromAnimation) {
              animationRunners.push(fromAnimation.start());
            }

            if (toAnimation) {
              animationRunners.push(toAnimation.start());
            }

            $$AnimateRunner.all(animationRunners, done);

            var runner = new $$AnimateRunner({
              end: endFnFactory(),
              cancel: endFnFactory()
            });

            return runner;

            function endFnFactory() {
              return function() {
                forEach(animationRunners, function(runner) {
                  // at this point we cannot cancel animations for groups just yet. 1.5+
                  runner.end();
                });
              };
            }

            function done(status) {
              runner.complete(status);
            }
          }
        };
      } else {
        return prepareAnimation(animationDetails);
      }
    };

    function prepareAnimation(animationDetails) {
      // TODO(matsko): make sure to check for grouped animations and delegate down to normal animations
      var element = animationDetails.element;
      var event = animationDetails.event;
      var options = animationDetails.options;
      var classes = animationDetails.classes;
      return $$animateJs(element, event, classes, options);
    }
  }];
}];

var NG_ANIMATE_ATTR_NAME = 'data-ng-animate';
var NG_ANIMATE_PIN_DATA = '$ngAnimatePin';
var $$AnimateQueueProvider = ['$animateProvider', /** @this */ function($animateProvider) {
  var PRE_DIGEST_STATE = 1;
  var RUNNING_STATE = 2;
  var ONE_SPACE = ' ';

  var rules = this.rules = {
    skip: [],
    cancel: [],
    join: []
  };

  function getEventData(options) {
    return {
      addClass: options.addClass,
      removeClass: options.removeClass,
      from: options.from,
      to: options.to
    };
  }

  function makeTruthyCssClassMap(classString) {
    if (!classString) {
      return null;
    }

    var keys = classString.split(ONE_SPACE);
    var map = Object.create(null);

    forEach(keys, function(key) {
      map[key] = true;
    });
    return map;
  }

  function hasMatchingClasses(newClassString, currentClassString) {
    if (newClassString && currentClassString) {
      var currentClassMap = makeTruthyCssClassMap(currentClassString);
      return newClassString.split(ONE_SPACE).some(function(className) {
        return currentClassMap[className];
      });
    }
  }

  function isAllowed(ruleType, currentAnimation, previousAnimation) {
    return rules[ruleType].some(function(fn) {
      return fn(currentAnimation, previousAnimation);
    });
  }

  function hasAnimationClasses(animation, and) {
    var a = (animation.addClass || '').length > 0;
    var b = (animation.removeClass || '').length > 0;
    return and ? a && b : a || b;
  }

  rules.join.push(function(newAnimation, currentAnimation) {
    // if the new animation is class-based then we can just tack that on
    return !newAnimation.structural && hasAnimationClasses(newAnimation);
  });

  rules.skip.push(function(newAnimation, currentAnimation) {
    // there is no need to animate anything if no classes are being added and
    // there is no structural animation that will be triggered
    return !newAnimation.structural && !hasAnimationClasses(newAnimation);
  });

  rules.skip.push(function(newAnimation, currentAnimation) {
    // why should we trigger a new structural animation if the element will
    // be removed from the DOM anyway?
    return currentAnimation.event === 'leave' && newAnimation.structural;
  });

  rules.skip.push(function(newAnimation, currentAnimation) {
    // if there is an ongoing current animation then don't even bother running the class-based animation
    return currentAnimation.structural && currentAnimation.state === RUNNING_STATE && !newAnimation.structural;
  });

  rules.cancel.push(function(newAnimation, currentAnimation) {
    // there can never be two structural animations running at the same time
    return currentAnimation.structural && newAnimation.structural;
  });

  rules.cancel.push(function(newAnimation, currentAnimation) {
    // if the previous animation is already running, but the new animation will
    // be triggered, but the new animation is structural
    return currentAnimation.state === RUNNING_STATE && newAnimation.structural;
  });

  rules.cancel.push(function(newAnimation, currentAnimation) {
    // cancel the animation if classes added / removed in both animation cancel each other out,
    // but only if the current animation isn't structural

    if (currentAnimation.structural) return false;

    var nA = newAnimation.addClass;
    var nR = newAnimation.removeClass;
    var cA = currentAnimation.addClass;
    var cR = currentAnimation.removeClass;

    // early detection to save the global CPU shortage :)
    if ((isUndefined(nA) && isUndefined(nR)) || (isUndefined(cA) && isUndefined(cR))) {
      return false;
    }

    return hasMatchingClasses(nA, cR) || hasMatchingClasses(nR, cA);
  });

  this.$get = ['$$rAF', '$rootScope', '$rootElement', '$document', '$$Map',
               '$$animation', '$$AnimateRunner', '$templateRequest', '$$jqLite', '$$forceReflow',
               '$$isDocumentHidden',
       function($$rAF,   $rootScope,   $rootElement,   $document,   $$Map,
                $$animation,   $$AnimateRunner,   $templateRequest,   $$jqLite,   $$forceReflow,
                $$isDocumentHidden) {

    var activeAnimationsLookup = new $$Map();
    var disabledElementsLookup = new $$Map();
    var animationsEnabled = null;

    function removeFromDisabledElementsLookup(evt) {
      disabledElementsLookup.delete(evt.target);
    }

    function postDigestTaskFactory() {
      var postDigestCalled = false;
      return function(fn) {
        // we only issue a call to postDigest before
        // it has first passed. This prevents any callbacks
        // from not firing once the animation has completed
        // since it will be out of the digest cycle.
        if (postDigestCalled) {
          fn();
        } else {
          $rootScope.$$postDigest(function() {
            postDigestCalled = true;
            fn();
          });
        }
      };
    }

    // Wait until all directive and route-related templates are downloaded and
    // compiled. The $templateRequest.totalPendingRequests variable keeps track of
    // all of the remote templates being currently downloaded. If there are no
    // templates currently downloading then the watcher will still fire anyway.
    var deregisterWatch = $rootScope.$watch(
      function() { return $templateRequest.totalPendingRequests === 0; },
      function(isEmpty) {
        if (!isEmpty) return;
        deregisterWatch();

        // Now that all templates have been downloaded, $animate will wait until
        // the post digest queue is empty before enabling animations. By having two
        // calls to $postDigest calls we can ensure that the flag is enabled at the
        // very end of the post digest queue. Since all of the animations in $animate
        // use $postDigest, it's important that the code below executes at the end.
        // This basically means that the page is fully downloaded and compiled before
        // any animations are triggered.
        $rootScope.$$postDigest(function() {
          $rootScope.$$postDigest(function() {
            // we check for null directly in the event that the application already called
            // .enabled() with whatever arguments that it provided it with
            if (animationsEnabled === null) {
              animationsEnabled = true;
            }
          });
        });
      }
    );

    var callbackRegistry = Object.create(null);

    // remember that the `customFilter`/`classNameFilter` are set during the
    // provider/config stage therefore we can optimize here and setup helper functions
    var customFilter = $animateProvider.customFilter();
    var classNameFilter = $animateProvider.classNameFilter();
    var returnTrue = function() { return true; };

    var isAnimatableByFilter = customFilter || returnTrue;
    var isAnimatableClassName = !classNameFilter ? returnTrue : function(node, options) {
      var className = [node.getAttribute('class'), options.addClass, options.removeClass].join(' ');
      return classNameFilter.test(className);
    };

    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);

    function normalizeAnimationDetails(element, animation) {
      return mergeAnimationDetails(element, animation, {});
    }

    // IE9-11 has no method "contains" in SVG element and in Node.prototype. Bug #10259.
    var contains = window.Node.prototype.contains || /** @this */ function(arg) {
      // eslint-disable-next-line no-bitwise
      return this === arg || !!(this.compareDocumentPosition(arg) & 16);
    };

    function findCallbacks(targetParentNode, targetNode, event) {
      var matches = [];
      var entries = callbackRegistry[event];
      if (entries) {
        forEach(entries, function(entry) {
          if (contains.call(entry.node, targetNode)) {
            matches.push(entry.callback);
          } else if (event === 'leave' && contains.call(entry.node, targetParentNode)) {
            matches.push(entry.callback);
          }
        });
      }

      return matches;
    }

    function filterFromRegistry(list, matchContainer, matchCallback) {
      var containerNode = extractElementNode(matchContainer);
      return list.filter(function(entry) {
        var isMatch = entry.node === containerNode &&
                        (!matchCallback || entry.callback === matchCallback);
        return !isMatch;
      });
    }

    function cleanupEventListeners(phase, node) {
      if (phase === 'close' && !node.parentNode) {
        // If the element is not attached to a parentNode, it has been removed by
        // the domOperation, and we can safely remove the event callbacks
        $animate.off(node);
      }
    }

    var $animate = {
      on: function(event, container, callback) {
        var node = extractElementNode(container);
        callbackRegistry[event] = callbackRegistry[event] || [];
        callbackRegistry[event].push({
          node: node,
          callback: callback
        });

        // Remove the callback when the element is removed from the DOM
        jqLite(container).on('$destroy', function() {
          var animationDetails = activeAnimationsLookup.get(node);

          if (!animationDetails) {
            // If there's an animation ongoing, the callback calling code will remove
            // the event listeners. If we'd remove here, the callbacks would be removed
            // before the animation ends
            $animate.off(event, container, callback);
          }
        });
      },

      off: function(event, container, callback) {
        if (arguments.length === 1 && !isString(arguments[0])) {
          container = arguments[0];
          for (var eventType in callbackRegistry) {
            callbackRegistry[eventType] = filterFromRegistry(callbackRegistry[eventType], container);
          }

          return;
        }

        var entries = callbackRegistry[event];
        if (!entries) return;

        callbackRegistry[event] = arguments.length === 1
            ? null
            : filterFromRegistry(entries, container, callback);
      },

      pin: function(element, parentElement) {
        assertArg(isElement(element), 'element', 'not an element');
        assertArg(isElement(parentElement), 'parentElement', 'not an element');
        element.data(NG_ANIMATE_PIN_DATA, parentElement);
      },

      push: function(element, event, options, domOperation) {
        options = options || {};
        options.domOperation = domOperation;
        return queueAnimation(element, event, options);
      },

      // this method has four signatures:
      //  () - global getter
      //  (bool) - global setter
      //  (element) - element getter
      //  (element, bool) - element setter<F37>
      enabled: function(element, bool) {
        var argCount = arguments.length;

        if (argCount === 0) {
          // () - Global getter
          bool = !!animationsEnabled;
        } else {
          var hasElement = isElement(element);

          if (!hasElement) {
            // (bool) - Global setter
            bool = animationsEnabled = !!element;
          } else {
            var node = getDomNode(element);

            if (argCount === 1) {
              // (element) - Element getter
              bool = !disabledElementsLookup.get(node);
            } else {
              // (element, bool) - Element setter
              if (!disabledElementsLookup.has(node)) {
                // The element is added to the map for the first time.
                // Create a listener to remove it on `$destroy` (to avoid memory leak).
                jqLite(element).on('$destroy', removeFromDisabledElementsLookup);
              }
              disabledElementsLookup.set(node, !bool);
            }
          }
        }

        return bool;
      }
    };

    return $animate;

    function queueAnimation(originalElement, event, initialOptions) {
      // we always make a copy of the options since
      // there should never be any side effects on
      // the input data when running `$animateCss`.
      var options = copy(initialOptions);

      var element = stripCommentsFromElement(originalElement);
      var node = getDomNode(element);
      var parentNode = node && node.parentNode;

      options = prepareAnimationOptions(options);

      // we create a fake runner with a working promise.
      // These methods will become available after the digest has passed
      var runner = new $$AnimateRunner();

      // this is used to trigger callbacks in postDigest mode
      var runInNextPostDigestOrNow = postDigestTaskFactory();

      if (isArray(options.addClass)) {
        options.addClass = options.addClass.join(' ');
      }

      if (options.addClass && !isString(options.addClass)) {
        options.addClass = null;
      }

      if (isArray(options.removeClass)) {
        options.removeClass = options.removeClass.join(' ');
      }

      if (options.removeClass && !isString(options.removeClass)) {
        options.removeClass = null;
      }

      if (options.from && !isObject(options.from)) {
        options.from = null;
      }

      if (options.to && !isObject(options.to)) {
        options.to = null;
      }

      // If animations are hard-disabled for the whole application there is no need to continue.
      // There are also situations where a directive issues an animation for a jqLite wrapper that
      // contains only comment nodes. In this case, there is no way we can perform an animation.
      if (!animationsEnabled ||
          !node ||
          !isAnimatableByFilter(node, event, initialOptions) ||
          !isAnimatableClassName(node, options)) {
        close();
        return runner;
      }

      var isStructural = ['enter', 'move', 'leave'].indexOf(event) >= 0;

      var documentHidden = $$isDocumentHidden();

      // This is a hard disable of all animations the element itself, therefore  there is no need to
      // continue further past this point if not enabled
      // Animations are also disabled if the document is currently hidden (page is not visible
      // to the user), because browsers slow down or do not flush calls to requestAnimationFrame
      var skipAnimations = documentHidden || disabledElementsLookup.get(node);
      var existingAnimation = (!skipAnimations && activeAnimationsLookup.get(node)) || {};
      var hasExistingAnimation = !!existingAnimation.state;

      // there is no point in traversing the same collection of parent ancestors if a followup
      // animation will be run on the same element that already did all that checking work
      if (!skipAnimations && (!hasExistingAnimation || existingAnimation.state !== PRE_DIGEST_STATE)) {
        skipAnimations = !areAnimationsAllowed(node, parentNode, event);
      }

      if (skipAnimations) {
        // Callbacks should fire even if the document is hidden (regression fix for issue #14120)
        if (documentHidden) notifyProgress(runner, event, 'start', getEventData(options));
        close();
        if (documentHidden) notifyProgress(runner, event, 'close', getEventData(options));
        return runner;
      }

      if (isStructural) {
        closeChildAnimations(node);
      }

      var newAnimation = {
        structural: isStructural,
        element: element,
        event: event,
        addClass: options.addClass,
        removeClass: options.removeClass,
        close: close,
        options: options,
        runner: runner
      };

      if (hasExistingAnimation) {
        var skipAnimationFlag = isAllowed('skip', newAnimation, existingAnimation);
        if (skipAnimationFlag) {
          if (existingAnimation.state === RUNNING_STATE) {
            close();
            return runner;
          } else {
            mergeAnimationDetails(element, existingAnimation, newAnimation);
            return existingAnimation.runner;
          }
        }
        var cancelAnimationFlag = isAllowed('cancel', newAnimation, existingAnimation);
        if (cancelAnimationFlag) {
          if (existingAnimation.state === RUNNING_STATE) {
            // this will end the animation right away and it is safe
            // to do so since the animation is already running and the
            // runner callback code will run in async
            existingAnimation.runner.end();
          } else if (existingAnimation.structural) {
            // this means that the animation is queued into a digest, but
            // hasn't started yet. Therefore it is safe to run the close
            // method which will call the runner methods in async.
            existingAnimation.close();
          } else {
            // this will merge the new animation options into existing animation options
            mergeAnimationDetails(element, existingAnimation, newAnimation);

            return existingAnimation.runner;
          }
        } else {
          // a joined animation means that this animation will take over the existing one
          // so an example would involve a leave animation taking over an enter. Then when
          // the postDigest kicks in the enter will be ignored.
          var joinAnimationFlag = isAllowed('join', newAnimation, existingAnimation);
          if (joinAnimationFlag) {
            if (existingAnimation.state === RUNNING_STATE) {
              normalizeAnimationDetails(element, newAnimation);
            } else {
              applyGeneratedPreparationClasses($$jqLite, element, isStructural ? event : null, options);

              event = newAnimation.event = existingAnimation.event;
              options = mergeAnimationDetails(element, existingAnimation, newAnimation);

              //we return the same runner since only the option values of this animation will
              //be fed into the `existingAnimation`.
              return existingAnimation.runner;
            }
          }
        }
      } else {
        // normalization in this case means that it removes redundant CSS classes that
        // already exist (addClass) or do not exist (removeClass) on the element
        normalizeAnimationDetails(element, newAnimation);
      }

      // when the options are merged and cleaned up we may end up not having to do
      // an animation at all, therefore we should check this before issuing a post
      // digest callback. Structural animations will always run no matter what.
      var isValidAnimation = newAnimation.structural;
      if (!isValidAnimation) {
        // animate (from/to) can be quickly checked first, otherwise we check if any classes are present
        isValidAnimation = (newAnimation.event === 'animate' && Object.keys(newAnimation.options.to || {}).length > 0)
                            || hasAnimationClasses(newAnimation);
      }

      if (!isValidAnimation) {
        close();
        clearElementAnimationState(node);
        return runner;
      }

      // the counter keeps track of cancelled animations
      var counter = (existingAnimation.counter || 0) + 1;
      newAnimation.counter = counter;

      markElementAnimationState(node, PRE_DIGEST_STATE, newAnimation);

      $rootScope.$$postDigest(function() {
        // It is possible that the DOM nodes inside `originalElement` have been replaced. This can
        // happen if the animated element is a transcluded clone and also has a `templateUrl`
        // directive on it. Therefore, we must recreate `element` in order to interact with the
        // actual DOM nodes.
        // Note: We still need to use the old `node` for certain things, such as looking up in
        //       HashMaps where it was used as the key.

        element = stripCommentsFromElement(originalElement);

        var animationDetails = activeAnimationsLookup.get(node);
        var animationCancelled = !animationDetails;
        animationDetails = animationDetails || {};

        // if addClass/removeClass is called before something like enter then the
        // registered parent element may not be present. The code below will ensure
        // that a final value for parent element is obtained
        var parentElement = element.parent() || [];

        // animate/structural/class-based animations all have requirements. Otherwise there
        // is no point in performing an animation. The parent node must also be set.
        var isValidAnimation = parentElement.length > 0
                                && (animationDetails.event === 'animate'
                                    || animationDetails.structural
                                    || hasAnimationClasses(animationDetails));

        // this means that the previous animation was cancelled
        // even if the follow-up animation is the same event
        if (animationCancelled || animationDetails.counter !== counter || !isValidAnimation) {
          // if another animation did not take over then we need
          // to make sure that the domOperation and options are
          // handled accordingly
          if (animationCancelled) {
            applyAnimationClasses(element, options);
            applyAnimationStyles(element, options);
          }

          // if the event changed from something like enter to leave then we do
          // it, otherwise if it's the same then the end result will be the same too
          if (animationCancelled || (isStructural && animationDetails.event !== event)) {
            options.domOperation();
            runner.end();
          }

          // in the event that the element animation was not cancelled or a follow-up animation
          // isn't allowed to animate from here then we need to clear the state of the element
          // so that any future animations won't read the expired animation data.
          if (!isValidAnimation) {
            clearElementAnimationState(node);
          }

          return;
        }

        // this combined multiple class to addClass / removeClass into a setClass event
        // so long as a structural event did not take over the animation
        event = !animationDetails.structural && hasAnimationClasses(animationDetails, true)
            ? 'setClass'
            : animationDetails.event;

        markElementAnimationState(node, RUNNING_STATE);
        var realRunner = $$animation(element, event, animationDetails.options);

        // this will update the runner's flow-control events based on
        // the `realRunner` object.
        runner.setHost(realRunner);
        notifyProgress(runner, event, 'start', getEventData(options));

        realRunner.done(function(status) {
          close(!status);
          var animationDetails = activeAnimationsLookup.get(node);
          if (animationDetails && animationDetails.counter === counter) {
            clearElementAnimationState(node);
          }
          notifyProgress(runner, event, 'close', getEventData(options));
        });
      });

      return runner;

      function notifyProgress(runner, event, phase, data) {
        runInNextPostDigestOrNow(function() {
          var callbacks = findCallbacks(parentNode, node, event);
          if (callbacks.length) {
            // do not optimize this call here to RAF because
            // we don't know how heavy the callback code here will
            // be and if this code is buffered then this can
            // lead to a performance regression.
            $$rAF(function() {
              forEach(callbacks, function(callback) {
                callback(element, phase, data);
              });
              cleanupEventListeners(phase, node);
            });
          } else {
            cleanupEventListeners(phase, node);
          }
        });
        runner.progress(event, phase, data);
      }

      function close(reject) {
        clearGeneratedClasses(element, options);
        applyAnimationClasses(element, options);
        applyAnimationStyles(element, options);
        options.domOperation();
        runner.complete(!reject);
      }
    }

    function closeChildAnimations(node) {
      var children = node.querySelectorAll('[' + NG_ANIMATE_ATTR_NAME + ']');
      forEach(children, function(child) {
        var state = parseInt(child.getAttribute(NG_ANIMATE_ATTR_NAME), 10);
        var animationDetails = activeAnimationsLookup.get(child);
        if (animationDetails) {
          switch (state) {
            case RUNNING_STATE:
              animationDetails.runner.end();
              /* falls through */
            case PRE_DIGEST_STATE:
              activeAnimationsLookup.delete(child);
              break;
          }
        }
      });
    }

    function clearElementAnimationState(node) {
      node.removeAttribute(NG_ANIMATE_ATTR_NAME);
      activeAnimationsLookup.delete(node);
    }

    /**
     * This fn returns false if any of the following is true:
     * a) animations on any parent element are disabled, and animations on the element aren't explicitly allowed
     * b) a parent element has an ongoing structural animation, and animateChildren is false
     * c) the element is not a child of the body
     * d) the element is not a child of the $rootElement
     */
    function areAnimationsAllowed(node, parentNode, event) {
      var bodyNode = $document[0].body;
      var rootNode = getDomNode($rootElement);

      var bodyNodeDetected = (node === bodyNode) || node.nodeName === 'HTML';
      var rootNodeDetected = (node === rootNode);
      var parentAnimationDetected = false;
      var elementDisabled = disabledElementsLookup.get(node);
      var animateChildren;

      var parentHost = jqLite.data(node, NG_ANIMATE_PIN_DATA);
      if (parentHost) {
        parentNode = getDomNode(parentHost);
      }

      while (parentNode) {
        if (!rootNodeDetected) {
          // AngularJS doesn't want to attempt to animate elements outside of the application
          // therefore we need to ensure that the rootElement is an ancestor of the current element
          rootNodeDetected = (parentNode === rootNode);
        }

        if (parentNode.nodeType !== ELEMENT_NODE) {
          // no point in inspecting the #document element
          break;
        }

        var details = activeAnimationsLookup.get(parentNode) || {};
        // either an enter, leave or move animation will commence
        // therefore we can't allow any animations to take place
        // but if a parent animation is class-based then that's ok
        if (!parentAnimationDetected) {
          var parentNodeDisabled = disabledElementsLookup.get(parentNode);

          if (parentNodeDisabled === true && elementDisabled !== false) {
            // disable animations if the user hasn't explicitly enabled animations on the
            // current element
            elementDisabled = true;
            // element is disabled via parent element, no need to check anything else
            break;
          } else if (parentNodeDisabled === false) {
            elementDisabled = false;
          }
          parentAnimationDetected = details.structural;
        }

        if (isUndefined(animateChildren) || animateChildren === true) {
          var value = jqLite.data(parentNode, NG_ANIMATE_CHILDREN_DATA);
          if (isDefined(value)) {
            animateChildren = value;
          }
        }

        // there is no need to continue traversing at this point
        if (parentAnimationDetected && animateChildren === false) break;

        if (!bodyNodeDetected) {
          // we also need to ensure that the element is or will be a part of the body element
          // otherwise it is pointless to even issue an animation to be rendered
          bodyNodeDetected = (parentNode === bodyNode);
        }

        if (bodyNodeDetected && rootNodeDetected) {
          // If both body and root have been found, any other checks are pointless,
          // as no animation data should live outside the application
          break;
        }

        if (!rootNodeDetected) {
          // If `rootNode` is not detected, check if `parentNode` is pinned to another element
          parentHost = jqLite.data(parentNode, NG_ANIMATE_PIN_DATA);
          if (parentHost) {
            // The pin target element becomes the next parent element
            parentNode = getDomNode(parentHost);
            continue;
          }
        }

        parentNode = parentNode.parentNode;
      }

      var allowAnimation = (!parentAnimationDetected || animateChildren) && elementDisabled !== true;
      return allowAnimation && rootNodeDetected && bodyNodeDetected;
    }

    function markElementAnimationState(node, state, details) {
      details = details || {};
      details.state = state;

      node.setAttribute(NG_ANIMATE_ATTR_NAME, state);

      var oldValue = activeAnimationsLookup.get(node);
      var newValue = oldValue
          ? extend(oldValue, details)
          : details;
      activeAnimationsLookup.set(node, newValue);
    }
  }];
}];

/** @this */
var $$AnimateCacheProvider = function() {

  var KEY = '$$ngAnimateParentKey';
  var parentCounter = 0;
  var cache = Object.create(null);

  this.$get = [function() {
    return {
      cacheKey: function(node, method, addClass, removeClass) {
        var parentNode = node.parentNode;
        var parentID = parentNode[KEY] || (parentNode[KEY] = ++parentCounter);
        var parts = [parentID, method, node.getAttribute('class')];
        if (addClass) {
          parts.push(addClass);
        }
        if (removeClass) {
          parts.push(removeClass);
        }
        return parts.join(' ');
      },

      containsCachedAnimationWithoutDuration: function(key) {
        var entry = cache[key];

        // nothing cached, so go ahead and animate
        // otherwise it should be a valid animation
        return (entry && !entry.isValid) || false;
      },

      flush: function() {
        cache = Object.create(null);
      },

      count: function(key) {
        var entry = cache[key];
        return entry ? entry.total : 0;
      },

      get: function(key) {
        var entry = cache[key];
        return entry && entry.value;
      },

      put: function(key, value, isValid) {
        if (!cache[key]) {
          cache[key] = { total: 1, value: value, isValid: isValid };
        } else {
          cache[key].total++;
          cache[key].value = value;
        }
      }
    };
  }];
};

/* exported $$AnimationProvider */

var $$AnimationProvider = ['$animateProvider', /** @this */ function($animateProvider) {
  var NG_ANIMATE_REF_ATTR = 'ng-animate-ref';

  var drivers = this.drivers = [];

  var RUNNER_STORAGE_KEY = '$$animationRunner';
  var PREPARE_CLASSES_KEY = '$$animatePrepareClasses';

  function setRunner(element, runner) {
    element.data(RUNNER_STORAGE_KEY, runner);
  }

  function removeRunner(element) {
    element.removeData(RUNNER_STORAGE_KEY);
  }

  function getRunner(element) {
    return element.data(RUNNER_STORAGE_KEY);
  }

  this.$get = ['$$jqLite', '$rootScope', '$injector', '$$AnimateRunner', '$$Map', '$$rAFScheduler', '$$animateCache',
       function($$jqLite,   $rootScope,   $injector,   $$AnimateRunner,   $$Map,   $$rAFScheduler, $$animateCache) {

    var animationQueue = [];
    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);

    function sortAnimations(animations) {
      var tree = { children: [] };
      var i, lookup = new $$Map();

      // this is done first beforehand so that the map
      // is filled with a list of the elements that will be animated
      for (i = 0; i < animations.length; i++) {
        var animation = animations[i];
        lookup.set(animation.domNode, animations[i] = {
          domNode: animation.domNode,
          element: animation.element,
          fn: animation.fn,
          children: []
        });
      }

      for (i = 0; i < animations.length; i++) {
        processNode(animations[i]);
      }

      return flatten(tree);

      function processNode(entry) {
        if (entry.processed) return entry;
        entry.processed = true;

        var elementNode = entry.domNode;
        var parentNode = elementNode.parentNode;
        lookup.set(elementNode, entry);

        var parentEntry;
        while (parentNode) {
          parentEntry = lookup.get(parentNode);
          if (parentEntry) {
            if (!parentEntry.processed) {
              parentEntry = processNode(parentEntry);
            }
            break;
          }
          parentNode = parentNode.parentNode;
        }

        (parentEntry || tree).children.push(entry);
        return entry;
      }

      function flatten(tree) {
        var result = [];
        var queue = [];
        var i;

        for (i = 0; i < tree.children.length; i++) {
          queue.push(tree.children[i]);
        }

        var remainingLevelEntries = queue.length;
        var nextLevelEntries = 0;
        var row = [];

        for (i = 0; i < queue.length; i++) {
          var entry = queue[i];
          if (remainingLevelEntries <= 0) {
            remainingLevelEntries = nextLevelEntries;
            nextLevelEntries = 0;
            result.push(row);
            row = [];
          }
          row.push(entry);
          entry.children.forEach(function(childEntry) {
            nextLevelEntries++;
            queue.push(childEntry);
          });
          remainingLevelEntries--;
        }

        if (row.length) {
          result.push(row);
        }

        return result;
      }
    }

    // TODO(matsko): document the signature in a better way
    return function(element, event, options) {
      options = prepareAnimationOptions(options);
      var isStructural = ['enter', 'move', 'leave'].indexOf(event) >= 0;

      // there is no animation at the current moment, however
      // these runner methods will get later updated with the
      // methods leading into the driver's end/cancel methods
      // for now they just stop the animation from starting
      var runner = new $$AnimateRunner({
        end: function() { close(); },
        cancel: function() { close(true); }
      });

      if (!drivers.length) {
        close();
        return runner;
      }

      var classes = mergeClasses(element.attr('class'), mergeClasses(options.addClass, options.removeClass));
      var tempClasses = options.tempClasses;
      if (tempClasses) {
        classes += ' ' + tempClasses;
        options.tempClasses = null;
      }

      if (isStructural) {
        element.data(PREPARE_CLASSES_KEY, 'ng-' + event + PREPARE_CLASS_SUFFIX);
      }

      setRunner(element, runner);

      animationQueue.push({
        // this data is used by the postDigest code and passed into
        // the driver step function
        element: element,
        classes: classes,
        event: event,
        structural: isStructural,
        options: options,
        beforeStart: beforeStart,
        close: close
      });

      element.on('$destroy', handleDestroyedElement);

      // we only want there to be one function called within the post digest
      // block. This way we can group animations for all the animations that
      // were apart of the same postDigest flush call.
      if (animationQueue.length > 1) return runner;

      $rootScope.$$postDigest(function() {
        var animations = [];
        forEach(animationQueue, function(entry) {
          // the element was destroyed early on which removed the runner
          // form its storage. This means we can't animate this element
          // at all and it already has been closed due to destruction.
          if (getRunner(entry.element)) {
            animations.push(entry);
          } else {
            entry.close();
          }
        });

        // now any future animations will be in another postDigest
        animationQueue.length = 0;

        var groupedAnimations = groupAnimations(animations);
        var toBeSortedAnimations = [];

        forEach(groupedAnimations, function(animationEntry) {
          var element = animationEntry.from ? animationEntry.from.element : animationEntry.element;
          var extraClasses = options.addClass;

          extraClasses = (extraClasses ? (extraClasses + ' ') : '') + NG_ANIMATE_CLASSNAME;
          var cacheKey = $$animateCache.cacheKey(element[0], animationEntry.event, extraClasses, options.removeClass);

          toBeSortedAnimations.push({
            element: element,
            domNode: getDomNode(element),
            fn: function triggerAnimationStart() {
              var startAnimationFn, closeFn = animationEntry.close;

              // in the event that we've cached the animation status for this element
              // and it's in fact an invalid animation (something that has duration = 0)
              // then we should skip all the heavy work from here on
              if ($$animateCache.containsCachedAnimationWithoutDuration(cacheKey)) {
                closeFn();
                return;
              }

              // it's important that we apply the `ng-animate` CSS class and the
              // temporary classes before we do any driver invoking since these
              // CSS classes may be required for proper CSS detection.
              animationEntry.beforeStart();

              // in the event that the element was removed before the digest runs or
              // during the RAF sequencing then we should not trigger the animation.
              var targetElement = animationEntry.anchors
                  ? (animationEntry.from.element || animationEntry.to.element)
                  : animationEntry.element;

              if (getRunner(targetElement)) {
                var operation = invokeFirstDriver(animationEntry);
                if (operation) {
                  startAnimationFn = operation.start;
                }
              }

              if (!startAnimationFn) {
                closeFn();
              } else {
                var animationRunner = startAnimationFn();
                animationRunner.done(function(status) {
                  closeFn(!status);
                });
                updateAnimationRunners(animationEntry, animationRunner);
              }
            }
          });
        });

        // we need to sort each of the animations in order of parent to child
        // relationships. This ensures that the child classes are applied at the
        // right time.
        var finalAnimations = sortAnimations(toBeSortedAnimations);
        for (var i = 0; i < finalAnimations.length; i++) {
          var innerArray = finalAnimations[i];
          for (var j = 0; j < innerArray.length; j++) {
            var entry = innerArray[j];
            var element = entry.element;

            // the RAFScheduler code only uses functions
            finalAnimations[i][j] = entry.fn;

            // the first row of elements shouldn't have a prepare-class added to them
            // since the elements are at the top of the animation hierarchy and they
            // will be applied without a RAF having to pass...
            if (i === 0) {
              element.removeData(PREPARE_CLASSES_KEY);
              continue;
            }

            var prepareClassName = element.data(PREPARE_CLASSES_KEY);
            if (prepareClassName) {
              $$jqLite.addClass(element, prepareClassName);
            }
          }
        }

        $$rAFScheduler(finalAnimations);
      });

      return runner;

      // TODO(matsko): change to reference nodes
      function getAnchorNodes(node) {
        var SELECTOR = '[' + NG_ANIMATE_REF_ATTR + ']';
        var items = node.hasAttribute(NG_ANIMATE_REF_ATTR)
              ? [node]
              : node.querySelectorAll(SELECTOR);
        var anchors = [];
        forEach(items, function(node) {
          var attr = node.getAttribute(NG_ANIMATE_REF_ATTR);
          if (attr && attr.length) {
            anchors.push(node);
          }
        });
        return anchors;
      }

      function groupAnimations(animations) {
        var preparedAnimations = [];
        var refLookup = {};
        forEach(animations, function(animation, index) {
          var element = animation.element;
          var node = getDomNode(element);
          var event = animation.event;
          var enterOrMove = ['enter', 'move'].indexOf(event) >= 0;
          var anchorNodes = animation.structural ? getAnchorNodes(node) : [];

          if (anchorNodes.length) {
            var direction = enterOrMove ? 'to' : 'from';

            forEach(anchorNodes, function(anchor) {
              var key = anchor.getAttribute(NG_ANIMATE_REF_ATTR);
              refLookup[key] = refLookup[key] || {};
              refLookup[key][direction] = {
                animationID: index,
                element: jqLite(anchor)
              };
            });
          } else {
            preparedAnimations.push(animation);
          }
        });

        var usedIndicesLookup = {};
        var anchorGroups = {};
        forEach(refLookup, function(operations, key) {
          var from = operations.from;
          var to = operations.to;

          if (!from || !to) {
            // only one of these is set therefore we can't have an
            // anchor animation since all three pieces are required
            var index = from ? from.animationID : to.animationID;
            var indexKey = index.toString();
            if (!usedIndicesLookup[indexKey]) {
              usedIndicesLookup[indexKey] = true;
              preparedAnimations.push(animations[index]);
            }
            return;
          }

          var fromAnimation = animations[from.animationID];
          var toAnimation = animations[to.animationID];
          var lookupKey = from.animationID.toString();
          if (!anchorGroups[lookupKey]) {
            var group = anchorGroups[lookupKey] = {
              structural: true,
              beforeStart: function() {
                fromAnimation.beforeStart();
                toAnimation.beforeStart();
              },
              close: function() {
                fromAnimation.close();
                toAnimation.close();
              },
              classes: cssClassesIntersection(fromAnimation.classes, toAnimation.classes),
              from: fromAnimation,
              to: toAnimation,
              anchors: [] // TODO(matsko): change to reference nodes
            };

            // the anchor animations require that the from and to elements both have at least
            // one shared CSS class which effectively marries the two elements together to use
            // the same animation driver and to properly sequence the anchor animation.
            if (group.classes.length) {
              preparedAnimations.push(group);
            } else {
              preparedAnimations.push(fromAnimation);
              preparedAnimations.push(toAnimation);
            }
          }

          anchorGroups[lookupKey].anchors.push({
            'out': from.element, 'in': to.element
          });
        });

        return preparedAnimations;
      }

      function cssClassesIntersection(a,b) {
        a = a.split(' ');
        b = b.split(' ');
        var matches = [];

        for (var i = 0; i < a.length; i++) {
          var aa = a[i];
          if (aa.substring(0,3) === 'ng-') continue;

          for (var j = 0; j < b.length; j++) {
            if (aa === b[j]) {
              matches.push(aa);
              break;
            }
          }
        }

        return matches.join(' ');
      }

      function invokeFirstDriver(animationDetails) {
        // we loop in reverse order since the more general drivers (like CSS and JS)
        // may attempt more elements, but custom drivers are more particular
        for (var i = drivers.length - 1; i >= 0; i--) {
          var driverName = drivers[i];
          var factory = $injector.get(driverName);
          var driver = factory(animationDetails);
          if (driver) {
            return driver;
          }
        }
      }

      function beforeStart() {
        tempClasses = (tempClasses ? (tempClasses + ' ') : '') + NG_ANIMATE_CLASSNAME;
        $$jqLite.addClass(element, tempClasses);

        var prepareClassName = element.data(PREPARE_CLASSES_KEY);
        if (prepareClassName) {
          $$jqLite.removeClass(element, prepareClassName);
          prepareClassName = null;
        }
      }

      function updateAnimationRunners(animation, newRunner) {
        if (animation.from && animation.to) {
          update(animation.from.element);
          update(animation.to.element);
        } else {
          update(animation.element);
        }

        function update(element) {
          var runner = getRunner(element);
          if (runner) runner.setHost(newRunner);
        }
      }

      function handleDestroyedElement() {
        var runner = getRunner(element);
        if (runner && (event !== 'leave' || !options.$$domOperationFired)) {
          runner.end();
        }
      }

      function close(rejected) {
        element.off('$destroy', handleDestroyedElement);
        removeRunner(element);

        applyAnimationClasses(element, options);
        applyAnimationStyles(element, options);
        options.domOperation();

        if (tempClasses) {
          $$jqLite.removeClass(element, tempClasses);
        }

        runner.complete(!rejected);
      }
    };
  }];
}];

/**
 * @ngdoc directive
 * @name ngAnimateSwap
 * @restrict A
 * @scope
 *
 * @description
 *
 * ngAnimateSwap is a animation-oriented directive that allows for the container to
 * be removed and entered in whenever the associated expression changes. A
 * common usecase for this directive is a rotating banner or slider component which
 * contains one image being present at a time. When the active image changes
 * then the old image will perform a `leave` animation and the new element
 * will be inserted via an `enter` animation.
 *
 * @animations
 * | Animation                        | Occurs                               |
 * |----------------------------------|--------------------------------------|
 * | {@link ng.$animate#enter enter}  | when the new element is inserted to the DOM  |
 * | {@link ng.$animate#leave leave}  | when the old element is removed from the DOM |
 *
 * @example
 * <example name="ngAnimateSwap-directive" module="ngAnimateSwapExample"
 *          deps="angular-animate.js"
 *          animations="true" fixBase="true">
 *   <file name="index.html">
 *     <div class="container" ng-controller="AppCtrl">
 *       <div ng-animate-swap="number" class="cell swap-animation" ng-class="colorClass(number)">
 *         {{ number }}
 *       </div>
 *     </div>
 *   </file>
 *   <file name="script.js">
 *     angular.module('ngAnimateSwapExample', ['ngAnimate'])
 *       .controller('AppCtrl', ['$scope', '$interval', function($scope, $interval) {
 *         $scope.number = 0;
 *         $interval(function() {
 *           $scope.number++;
 *         }, 1000);
 *
 *         var colors = ['red','blue','green','yellow','orange'];
 *         $scope.colorClass = function(number) {
 *           return colors[number % colors.length];
 *         };
 *       }]);
 *   </file>
 *  <file name="animations.css">
 *  .container {
 *    height:250px;
 *    width:250px;
 *    position:relative;
 *    overflow:hidden;
 *    border:2px solid black;
 *  }
 *  .container .cell {
 *    font-size:150px;
 *    text-align:center;
 *    line-height:250px;
 *    position:absolute;
 *    top:0;
 *    left:0;
 *    right:0;
 *    border-bottom:2px solid black;
 *  }
 *  .swap-animation.ng-enter, .swap-animation.ng-leave {
 *    transition:0.5s linear all;
 *  }
 *  .swap-animation.ng-enter {
 *    top:-250px;
 *  }
 *  .swap-animation.ng-enter-active {
 *    top:0px;
 *  }
 *  .swap-animation.ng-leave {
 *    top:0px;
 *  }
 *  .swap-animation.ng-leave-active {
 *    top:250px;
 *  }
 *  .red { background:red; }
 *  .green { background:green; }
 *  .blue { background:blue; }
 *  .yellow { background:yellow; }
 *  .orange { background:orange; }
 *  </file>
 * </example>
 */
var ngAnimateSwapDirective = ['$animate', function($animate) {
  return {
    restrict: 'A',
    transclude: 'element',
    terminal: true,
    priority: 550, // We use 550 here to ensure that the directive is caught before others,
                   // but after `ngIf` (at priority 600).
    link: function(scope, $element, attrs, ctrl, $transclude) {
      var previousElement, previousScope;
      scope.$watchCollection(attrs.ngAnimateSwap || attrs['for'], function(value) {
        if (previousElement) {
          $animate.leave(previousElement);
        }
        if (previousScope) {
          previousScope.$destroy();
          previousScope = null;
        }
        if (value || value === 0) {
          $transclude(function(clone, childScope) {
            previousElement = clone;
            previousScope = childScope;
            $animate.enter(clone, null, $element);
          });
        }
      });
    }
  };
}];

/**
 * @ngdoc module
 * @name ngAnimate
 * @description
 *
 * The `ngAnimate` module provides support for CSS-based animations (keyframes and transitions) as well as JavaScript-based animations via
 * callback hooks. Animations are not enabled by default, however, by including `ngAnimate` the animation hooks are enabled for an AngularJS app.
 *
 * ## Usage
 * Simply put, there are two ways to make use of animations when ngAnimate is used: by using **CSS** and **JavaScript**. The former works purely based
 * using CSS (by using matching CSS selectors/styles) and the latter triggers animations that are registered via `module.animation()`. For
 * both CSS and JS animations the sole requirement is to have a matching `CSS class` that exists both in the registered animation and within
 * the HTML element that the animation will be triggered on.
 *
 * ## Directive Support
 * The following directives are "animation aware":
 *
 * | Directive                                                                     | Supported Animations                                                      |
 * |-------------------------------------------------------------------------------|---------------------------------------------------------------------------|
 * | {@link ng.directive:form#animations form / ngForm}                            | add and remove ({@link ng.directive:form#css-classes various classes})    |
 * | {@link ngAnimate.directive:ngAnimateSwap#animations ngAnimateSwap}            | enter and leave                                                           |
 * | {@link ng.directive:ngClass#animations ngClass / {{class&#125;&#8203;&#125;}  | add and remove                                                            |
 * | {@link ng.directive:ngClassEven#animations ngClassEven}                       | add and remove                                                            |
 * | {@link ng.directive:ngClassOdd#animations ngClassOdd}                         | add and remove                                                            |
 * | {@link ng.directive:ngHide#animations ngHide}                                 | add and remove (the `ng-hide` class)                                      |
 * | {@link ng.directive:ngIf#animations ngIf}                                     | enter and leave                                                           |
 * | {@link ng.directive:ngInclude#animations ngInclude}                           | enter and leave                                                           |
 * | {@link module:ngMessages#animations ngMessage / ngMessageExp}                 | enter and leave                                                           |
 * | {@link module:ngMessages#animations ngMessages}                               | add and remove (the `ng-active`/`ng-inactive` classes)                    |
 * | {@link ng.directive:ngModel#animations ngModel}                               | add and remove ({@link ng.directive:ngModel#css-classes various classes}) |
 * | {@link ng.directive:ngRepeat#animations ngRepeat}                             | enter, leave, and move                                                    |
 * | {@link ng.directive:ngShow#animations ngShow}                                 | add and remove (the `ng-hide` class)                                      |
 * | {@link ng.directive:ngSwitch#animations ngSwitch}                             | enter and leave                                                           |
 * | {@link ngRoute.directive:ngView#animations ngView}                            | enter and leave                                                           |
 *
 * (More information can be found by visiting the documentation associated with each directive.)
 *
 * For a full breakdown of the steps involved during each animation event, refer to the
 * {@link ng.$animate `$animate` API docs}.
 *
 * ## CSS-based Animations
 *
 * CSS-based animations with ngAnimate are unique since they require no JavaScript code at all. By using a CSS class that we reference between our HTML
 * and CSS code we can create an animation that will be picked up by AngularJS when an underlying directive performs an operation.
 *
 * The example below shows how an `enter` animation can be made possible on an element using `ng-if`:
 *
 * ```html
 * <div ng-if="bool" class="fade">
 *    Fade me in out
 * </div>
 * <button ng-click="bool=true">Fade In!</button>
 * <button ng-click="bool=false">Fade Out!</button>
 * ```
 *
 * Notice the CSS class **fade**? We can now create the CSS transition code that references this class:
 *
 * ```css
 * /&#42; The starting CSS styles for the enter animation &#42;/
 * .fade.ng-enter {
 *   transition:0.5s linear all;
 *   opacity:0;
 * }
 *
 * /&#42; The finishing CSS styles for the enter animation &#42;/
 * .fade.ng-enter.ng-enter-active {
 *   opacity:1;
 * }
 * ```
 *
 * The key thing to remember here is that, depending on the animation event (which each of the directives above trigger depending on what's going on) two
 * generated CSS classes will be applied to the element; in the example above we have `.ng-enter` and `.ng-enter-active`. For CSS transitions, the transition
 * code **must** be defined within the starting CSS class (in this case `.ng-enter`). The destination class is what the transition will animate towards.
 *
 * If for example we wanted to create animations for `leave` and `move` (ngRepeat triggers move) then we can do so using the same CSS naming conventions:
 *
 * ```css
 * /&#42; now the element will fade out before it is removed from the DOM &#42;/
 * .fade.ng-leave {
 *   transition:0.5s linear all;
 *   opacity:1;
 * }
 * .fade.ng-leave.ng-leave-active {
 *   opacity:0;
 * }
 * ```
 *
 * We can also make use of **CSS Keyframes** by referencing the keyframe animation within the starting CSS class:
 *
 * ```css
 * /&#42; there is no need to define anything inside of the destination
 * CSS class since the keyframe will take charge of the animation &#42;/
 * .fade.ng-leave {
 *   animation: my_fade_animation 0.5s linear;
 *   -webkit-animation: my_fade_animation 0.5s linear;
 * }
 *
 * @keyframes my_fade_animation {
 *   from { opacity:1; }
 *   to { opacity:0; }
 * }
 *
 * @-webkit-keyframes my_fade_animation {
 *   from { opacity:1; }
 *   to { opacity:0; }
 * }
 * ```
 *
 * Feel free also mix transitions and keyframes together as well as any other CSS classes on the same element.
 *
 * ### CSS Class-based Animations
 *
 * Class-based animations (animations that are triggered via `ngClass`, `ngShow`, `ngHide` and some other directives) have a slightly different
 * naming convention. Class-based animations are basic enough that a standard transition or keyframe can be referenced on the class being added
 * and removed.
 *
 * For example if we wanted to do a CSS animation for `ngHide` then we place an animation on the `.ng-hide` CSS class:
 *
 * ```html
 * <div ng-show="bool" class="fade">
 *   Show and hide me
 * </div>
 * <button ng-click="bool=!bool">Toggle</button>
 *
 * <style>
 * .fade.ng-hide {
 *   transition:0.5s linear all;
 *   opacity:0;
 * }
 * </style>
 * ```
 *
 * All that is going on here with ngShow/ngHide behind the scenes is the `.ng-hide` class is added/removed (when the hidden state is valid). Since
 * ngShow and ngHide are animation aware then we can match up a transition and ngAnimate handles the rest.
 *
 * In addition the addition and removal of the CSS class, ngAnimate also provides two helper methods that we can use to further decorate the animation
 * with CSS styles.
 *
 * ```html
 * <div ng-class="{on:onOff}" class="highlight">
 *   Highlight this box
 * </div>
 * <button ng-click="onOff=!onOff">Toggle</button>
 *
 * <style>
 * .highlight {
 *   transition:0.5s linear all;
 * }
 * .highlight.on-add {
 *   background:white;
 * }
 * .highlight.on {
 *   background:yellow;
 * }
 * .highlight.on-remove {
 *   background:black;
 * }
 * </style>
 * ```
 *
 * We can also make use of CSS keyframes by placing them within the CSS classes.
 *
 *
 * ### CSS Staggering Animations
 * A Staggering animation is a collection of animations that are issued with a slight delay in between each successive operation resulting in a
 * curtain-like effect. The ngAnimate module (versions >=1.2) supports staggering animations and the stagger effect can be
 * performed by creating a **ng-EVENT-stagger** CSS class and attaching that class to the base CSS class used for
 * the animation. The style property expected within the stagger class can either be a **transition-delay** or an
 * **animation-delay** property (or both if your animation contains both transitions and keyframe animations).
 *
 * ```css
 * .my-animation.ng-enter {
 *   /&#42; standard transition code &#42;/
 *   transition: 1s linear all;
 *   opacity:0;
 * }
 * .my-animation.ng-enter-stagger {
 *   /&#42; this will have a 100ms delay between each successive leave animation &#42;/
 *   transition-delay: 0.1s;
 *
 *   /&#42; As of 1.4.4, this must always be set: it signals ngAnimate
 *     to not accidentally inherit a delay property from another CSS class &#42;/
 *   transition-duration: 0s;
 *
 *   /&#42; if you are using animations instead of transitions you should configure as follows:
 *     animation-delay: 0.1s;
 *     animation-duration: 0s; &#42;/
 * }
 * .my-animation.ng-enter.ng-enter-active {
 *   /&#42; standard transition styles &#42;/
 *   opacity:1;
 * }
 * ```
 *
 * Staggering animations work by default in ngRepeat (so long as the CSS class is defined). Outside of ngRepeat, to use staggering animations
 * on your own, they can be triggered by firing multiple calls to the same event on $animate. However, the restrictions surrounding this
 * are that each of the elements must have the same CSS className value as well as the same parent element. A stagger operation
 * will also be reset if one or more animation frames have passed since the multiple calls to `$animate` were fired.
 *
 * The following code will issue the **ng-leave-stagger** event on the element provided:
 *
 * ```js
 * var kids = parent.children();
 *
 * $animate.leave(kids[0]); //stagger index=0
 * $animate.leave(kids[1]); //stagger index=1
 * $animate.leave(kids[2]); //stagger index=2
 * $animate.leave(kids[3]); //stagger index=3
 * $animate.leave(kids[4]); //stagger index=4
 *
 * window.requestAnimationFrame(function() {
 *   //stagger has reset itself
 *   $animate.leave(kids[5]); //stagger index=0
 *   $animate.leave(kids[6]); //stagger index=1
 *
 *   $scope.$digest();
 * });
 * ```
 *
 * Stagger animations are currently only supported within CSS-defined animations.
 *
 * ### The `ng-animate` CSS class
 *
 * When ngAnimate is animating an element it will apply the `ng-animate` CSS class to the element for the duration of the animation.
 * This is a temporary CSS class and it will be removed once the animation is over (for both JavaScript and CSS-based animations).
 *
 * Therefore, animations can be applied to an element using this temporary class directly via CSS.
 *
 * ```css
 * .zipper.ng-animate {
 *   transition:0.5s linear all;
 * }
 * .zipper.ng-enter {
 *   opacity:0;
 * }
 * .zipper.ng-enter.ng-enter-active {
 *   opacity:1;
 * }
 * .zipper.ng-leave {
 *   opacity:1;
 * }
 * .zipper.ng-leave.ng-leave-active {
 *   opacity:0;
 * }
 * ```
 *
 * (Note that the `ng-animate` CSS class is reserved and it cannot be applied on an element directly since ngAnimate will always remove
 * the CSS class once an animation has completed.)
 *
 *
 * ### The `ng-[event]-prepare` class
 *
 * This is a special class that can be used to prevent unwanted flickering / flash of content before
 * the actual animation starts. The class is added as soon as an animation is initialized, but removed
 * before the actual animation starts (after waiting for a $digest).
 * It is also only added for *structural* animations (`enter`, `move`, and `leave`).
 *
 * In practice, flickering can appear when nesting elements with structural animations such as `ngIf`
 * into elements that have class-based animations such as `ngClass`.
 *
 * ```html
 * <div ng-class="{red: myProp}">
 *   <div ng-class="{blue: myProp}">
 *     <div class="message" ng-if="myProp"></div>
 *   </div>
 * </div>
 * ```
 *
 * It is possible that during the `enter` animation, the `.message` div will be briefly visible before it starts animating.
 * In that case, you can add styles to the CSS that make sure the element stays hidden before the animation starts:
 *
 * ```css
 * .message.ng-enter-prepare {
 *   opacity: 0;
 * }
 * ```
 *
 * ### Animating between value changes
 *
 * Sometimes you need to animate between different expression states, whose values
 * don't necessary need to be known or referenced in CSS styles.
 * Unless possible with another {@link ngAnimate#directive-support "animation aware" directive},
 * that specific use case can always be covered with {@link ngAnimate.directive:ngAnimateSwap} as
 * can be seen in {@link ngAnimate.directive:ngAnimateSwap#examples this example}.
 *
 * Note that {@link ngAnimate.directive:ngAnimateSwap} is a *structural directive*, which means it
 * creates a new instance of the element (including any other/child directives it may have) and
 * links it to a new scope every time *swap* happens. In some cases this might not be desirable
 * (e.g. for performance reasons, or when you wish to retain internal state on the original
 * element instance).
 *
 * ## JavaScript-based Animations
 *
 * ngAnimate also allows for animations to be consumed by JavaScript code. The approach is similar to CSS-based animations (where there is a shared
 * CSS class that is referenced in our HTML code) but in addition we need to register the JavaScript animation on the module. By making use of the
 * `module.animation()` module function we can register the animation.
 *
 * Let's see an example of a enter/leave animation using `ngRepeat`:
 *
 * ```html
 * <div ng-repeat="item in items" class="slide">
 *   {{ item }}
 * </div>
 * ```
 *
 * See the **slide** CSS class? Let's use that class to define an animation that we'll structure in our module code by using `module.animation`:
 *
 * ```js
 * myModule.animation('.slide', [function() {
 *   return {
 *     // make note that other events (like addClass/removeClass)
 *     // have different function input parameters
 *     enter: function(element, doneFn) {
 *       jQuery(element).fadeIn(1000, doneFn);
 *
 *       // remember to call doneFn so that AngularJS
 *       // knows that the animation has concluded
 *     },
 *
 *     move: function(element, doneFn) {
 *       jQuery(element).fadeIn(1000, doneFn);
 *     },
 *
 *     leave: function(element, doneFn) {
 *       jQuery(element).fadeOut(1000, doneFn);
 *     }
 *   }
 * }]);
 * ```
 *
 * The nice thing about JS-based animations is that we can inject other services and make use of advanced animation libraries such as
 * greensock.js and velocity.js.
 *
 * If our animation code class-based (meaning that something like `ngClass`, `ngHide` and `ngShow` triggers it) then we can still define
 * our animations inside of the same registered animation, however, the function input arguments are a bit different:
 *
 * ```html
 * <div ng-class="color" class="colorful">
 *   this box is moody
 * </div>
 * <button ng-click="color='red'">Change to red</button>
 * <button ng-click="color='blue'">Change to blue</button>
 * <button ng-click="color='green'">Change to green</button>
 * ```
 *
 * ```js
 * myModule.animation('.colorful', [function() {
 *   return {
 *     addClass: function(element, className, doneFn) {
 *       // do some cool animation and call the doneFn
 *     },
 *     removeClass: function(element, className, doneFn) {
 *       // do some cool animation and call the doneFn
 *     },
 *     setClass: function(element, addedClass, removedClass, doneFn) {
 *       // do some cool animation and call the doneFn
 *     }
 *   }
 * }]);
 * ```
 *
 * ## CSS + JS Animations Together
 *
 * AngularJS 1.4 and higher has taken steps to make the amalgamation of CSS and JS animations more flexible. However, unlike earlier versions of AngularJS,
 * defining CSS and JS animations to work off of the same CSS class will not work anymore. Therefore the example below will only result in **JS animations taking
 * charge of the animation**:
 *
 * ```html
 * <div ng-if="bool" class="slide">
 *   Slide in and out
 * </div>
 * ```
 *
 * ```js
 * myModule.animation('.slide', [function() {
 *   return {
 *     enter: function(element, doneFn) {
 *       jQuery(element).slideIn(1000, doneFn);
 *     }
 *   }
 * }]);
 * ```
 *
 * ```css
 * .slide.ng-enter {
 *   transition:0.5s linear all;
 *   transform:translateY(-100px);
 * }
 * .slide.ng-enter.ng-enter-active {
 *   transform:translateY(0);
 * }
 * ```
 *
 * Does this mean that CSS and JS animations cannot be used together? Do JS-based animations always have higher priority? We can make up for the
 * lack of CSS animations by using the `$animateCss` service to trigger our own tweaked-out, CSS-based animations directly from
 * our own JS-based animation code:
 *
 * ```js
 * myModule.animation('.slide', ['$animateCss', function($animateCss) {
 *   return {
 *     enter: function(element) {
*        // this will trigger `.slide.ng-enter` and `.slide.ng-enter-active`.
 *       return $animateCss(element, {
 *         event: 'enter',
 *         structural: true
 *       });
 *     }
 *   }
 * }]);
 * ```
 *
 * The nice thing here is that we can save bandwidth by sticking to our CSS-based animation code and we don't need to rely on a 3rd-party animation framework.
 *
 * The `$animateCss` service is very powerful since we can feed in all kinds of extra properties that will be evaluated and fed into a CSS transition or
 * keyframe animation. For example if we wanted to animate the height of an element while adding and removing classes then we can do so by providing that
 * data into `$animateCss` directly:
 *
 * ```js
 * myModule.animation('.slide', ['$animateCss', function($animateCss) {
 *   return {
 *     enter: function(element) {
 *       return $animateCss(element, {
 *         event: 'enter',
 *         structural: true,
 *         addClass: 'maroon-setting',
 *         from: { height:0 },
 *         to: { height: 200 }
 *       });
 *     }
 *   }
 * }]);
 * ```
 *
 * Now we can fill in the rest via our transition CSS code:
 *
 * ```css
 * /&#42; the transition tells ngAnimate to make the animation happen &#42;/
 * .slide.ng-enter { transition:0.5s linear all; }
 *
 * /&#42; this extra CSS class will be absorbed into the transition
 * since the $animateCss code is adding the class &#42;/
 * .maroon-setting { background:red; }
 * ```
 *
 * And `$animateCss` will figure out the rest. Just make sure to have the `done()` callback fire the `doneFn` function to signal when the animation is over.
 *
 * To learn more about what's possible be sure to visit the {@link ngAnimate.$animateCss $animateCss service}.
 *
 * ## Animation Anchoring (via `ng-animate-ref`)
 *
 * ngAnimate in AngularJS 1.4 comes packed with the ability to cross-animate elements between
 * structural areas of an application (like views) by pairing up elements using an attribute
 * called `ng-animate-ref`.
 *
 * Let's say for example we have two views that are managed by `ng-view` and we want to show
 * that there is a relationship between two components situated in within these views. By using the
 * `ng-animate-ref` attribute we can identify that the two components are paired together and we
 * can then attach an animation, which is triggered when the view changes.
 *
 * Say for example we have the following template code:
 *
 * ```html
 * <!-- index.html -->
 * <div ng-view class="view-animation">
 * </div>
 *
 * <!-- home.html -->
 * <a href="#/banner-page">
 *   <img src="./banner.jpg" class="banner" ng-animate-ref="banner">
 * </a>
 *
 * <!-- banner-page.html -->
 * <img src="./banner.jpg" class="banner" ng-animate-ref="banner">
 * ```
 *
 * Now, when the view changes (once the link is clicked), ngAnimate will examine the
 * HTML contents to see if there is a match reference between any components in the view
 * that is leaving and the view that is entering. It will scan both the view which is being
 * removed (leave) and inserted (enter) to see if there are any paired DOM elements that
 * contain a matching ref value.
 *
 * The two images match since they share the same ref value. ngAnimate will now create a
 * transport element (which is a clone of the first image element) and it will then attempt
 * to animate to the position of the second image element in the next view. For the animation to
 * work a special CSS class called `ng-anchor` will be added to the transported element.
 *
 * We can now attach a transition onto the `.banner.ng-anchor` CSS class and then
 * ngAnimate will handle the entire transition for us as well as the addition and removal of
 * any changes of CSS classes between the elements:
 *
 * ```css
 * .banner.ng-anchor {
 *   /&#42; this animation will last for 1 second since there are
 *          two phases to the animation (an `in` and an `out` phase) &#42;/
 *   transition:0.5s linear all;
 * }
 * ```
 *
 * We also **must** include animations for the views that are being entered and removed
 * (otherwise anchoring wouldn't be possible since the new view would be inserted right away).
 *
 * ```css
 * .view-animation.ng-enter, .view-animation.ng-leave {
 *   transition:0.5s linear all;
 *   position:fixed;
 *   left:0;
 *   top:0;
 *   width:100%;
 * }
 * .view-animation.ng-enter {
 *   transform:translateX(100%);
 * }
 * .view-animation.ng-leave,
 * .view-animation.ng-enter.ng-enter-active {
 *   transform:translateX(0%);
 * }
 * .view-animation.ng-leave.ng-leave-active {
 *   transform:translateX(-100%);
 * }
 * ```
 *
 * Now we can jump back to the anchor animation. When the animation happens, there are two stages that occur:
 * an `out` and an `in` stage. The `out` stage happens first and that is when the element is animated away
 * from its origin. Once that animation is over then the `in` stage occurs which animates the
 * element to its destination. The reason why there are two animations is to give enough time
 * for the enter animation on the new element to be ready.
 *
 * The example above sets up a transition for both the in and out phases, but we can also target the out or
 * in phases directly via `ng-anchor-out` and `ng-anchor-in`.
 *
 * ```css
 * .banner.ng-anchor-out {
 *   transition: 0.5s linear all;
 *
 *   /&#42; the scale will be applied during the out animation,
 *          but will be animated away when the in animation runs &#42;/
 *   transform: scale(1.2);
 * }
 *
 * .banner.ng-anchor-in {
 *   transition: 1s linear all;
 * }
 * ```
 *
 *
 *
 *
 * ### Anchoring Demo
 *
  <example module="anchoringExample"
           name="anchoringExample"
           id="anchoringExample"
           deps="angular-animate.js;angular-route.js"
           animations="true">
    <file name="index.html">
      <a href="#!/">Home</a>
      <hr />
      <div class="view-container">
        <div ng-view class="view"></div>
      </div>
    </file>
    <file name="script.js">
      angular.module('anchoringExample', ['ngAnimate', 'ngRoute'])
        .config(['$routeProvider', function($routeProvider) {
          $routeProvider.when('/', {
            templateUrl: 'home.html',
            controller: 'HomeController as home'
          });
          $routeProvider.when('/profile/:id', {
            templateUrl: 'profile.html',
            controller: 'ProfileController as profile'
          });
        }])
        .run(['$rootScope', function($rootScope) {
          $rootScope.records = [
            { id: 1, title: 'Miss Beulah Roob' },
            { id: 2, title: 'Trent Morissette' },
            { id: 3, title: 'Miss Ava Pouros' },
            { id: 4, title: 'Rod Pouros' },
            { id: 5, title: 'Abdul Rice' },
            { id: 6, title: 'Laurie Rutherford Sr.' },
            { id: 7, title: 'Nakia McLaughlin' },
            { id: 8, title: 'Jordon Blanda DVM' },
            { id: 9, title: 'Rhoda Hand' },
            { id: 10, title: 'Alexandrea Sauer' }
          ];
        }])
        .controller('HomeController', [function() {
          //empty
        }])
        .controller('ProfileController', ['$rootScope', '$routeParams',
            function ProfileController($rootScope, $routeParams) {
          var index = parseInt($routeParams.id, 10);
          var record = $rootScope.records[index - 1];

          this.title = record.title;
          this.id = record.id;
        }]);
    </file>
    <file name="home.html">
      <h2>Welcome to the home page</h1>
      <p>Please click on an element</p>
      <a class="record"
         ng-href="#!/profile/{{ record.id }}"
         ng-animate-ref="{{ record.id }}"
         ng-repeat="record in records">
        {{ record.title }}
      </a>
    </file>
    <file name="profile.html">
      <div class="profile record" ng-animate-ref="{{ profile.id }}">
        {{ profile.title }}
      </div>
    </file>
    <file name="animations.css">
      .record {
        display:block;
        font-size:20px;
      }
      .profile {
        background:black;
        color:white;
        font-size:100px;
      }
      .view-container {
        position:relative;
      }
      .view-container > .view.ng-animate {
        position:absolute;
        top:0;
        left:0;
        width:100%;
        min-height:500px;
      }
      .view.ng-enter, .view.ng-leave,
      .record.ng-anchor {
        transition:0.5s linear all;
      }
      .view.ng-enter {
        transform:translateX(100%);
      }
      .view.ng-enter.ng-enter-active, .view.ng-leave {
        transform:translateX(0%);
      }
      .view.ng-leave.ng-leave-active {
        transform:translateX(-100%);
      }
      .record.ng-anchor-out {
        background:red;
      }
    </file>
  </example>
 *
 * ### How is the element transported?
 *
 * When an anchor animation occurs, ngAnimate will clone the starting element and position it exactly where the starting
 * element is located on screen via absolute positioning. The cloned element will be placed inside of the root element
 * of the application (where ng-app was defined) and all of the CSS classes of the starting element will be applied. The
 * element will then animate into the `out` and `in` animations and will eventually reach the coordinates and match
 * the dimensions of the destination element. During the entire animation a CSS class of `.ng-animate-shim` will be applied
 * to both the starting and destination elements in order to hide them from being visible (the CSS styling for the class
 * is: `visibility:hidden`). Once the anchor reaches its destination then it will be removed and the destination element
 * will become visible since the shim class will be removed.
 *
 * ### How is the morphing handled?
 *
 * CSS Anchoring relies on transitions and keyframes and the internal code is intelligent enough to figure out
 * what CSS classes differ between the starting element and the destination element. These different CSS classes
 * will be added/removed on the anchor element and a transition will be applied (the transition that is provided
 * in the anchor class). Long story short, ngAnimate will figure out what classes to add and remove which will
 * make the transition of the element as smooth and automatic as possible. Be sure to use simple CSS classes that
 * do not rely on DOM nesting structure so that the anchor element appears the same as the starting element (since
 * the cloned element is placed inside of root element which is likely close to the body element).
 *
 * Note that if the root element is on the `<html>` element then the cloned node will be placed inside of body.
 *
 *
 * ## Using $animate in your directive code
 *
 * So far we've explored how to feed in animations into an AngularJS application, but how do we trigger animations within our own directives in our application?
 * By injecting the `$animate` service into our directive code, we can trigger structural and class-based hooks which can then be consumed by animations. Let's
 * imagine we have a greeting box that shows and hides itself when the data changes
 *
 * ```html
 * <greeting-box active="onOrOff">Hi there</greeting-box>
 * ```
 *
 * ```js
 * ngModule.directive('greetingBox', ['$animate', function($animate) {
 *   return function(scope, element, attrs) {
 *     attrs.$observe('active', function(value) {
 *       value ? $animate.addClass(element, 'on') : $animate.removeClass(element, 'on');
 *     });
 *   });
 * }]);
 * ```
 *
 * Now the `on` CSS class is added and removed on the greeting box component. Now if we add a CSS class on top of the greeting box element
 * in our HTML code then we can trigger a CSS or JS animation to happen.
 *
 * ```css
 * /&#42; normally we would create a CSS class to reference on the element &#42;/
 * greeting-box.on { transition:0.5s linear all; background:green; color:white; }
 * ```
 *
 * The `$animate` service contains a variety of other methods like `enter`, `leave`, `animate` and `setClass`. To learn more about what's
 * possible be sure to visit the {@link ng.$animate $animate service API page}.
 *
 *
 * ## Callbacks and Promises
 *
 * When `$animate` is called it returns a promise that can be used to capture when the animation has ended. Therefore if we were to trigger
 * an animation (within our directive code) then we can continue performing directive and scope related activities after the animation has
 * ended by chaining onto the returned promise that animation method returns.
 *
 * ```js
 * // somewhere within the depths of the directive
 * $animate.enter(element, parent).then(function() {
 *   //the animation has completed
 * });
 * ```
 *
 * (Note that earlier versions of AngularJS prior to v1.4 required the promise code to be wrapped using `$scope.$apply(...)`. This is not the case
 * anymore.)
 *
 * In addition to the animation promise, we can also make use of animation-related callbacks within our directives and controller code by registering
 * an event listener using the `$animate` service. Let's say for example that an animation was triggered on our view
 * routing controller to hook into that:
 *
 * ```js
 * ngModule.controller('HomePageController', ['$animate', function($animate) {
 *   $animate.on('enter', ngViewElement, function(element) {
 *     // the animation for this route has completed
 *   }]);
 * }])
 * ```
 *
 * (Note that you will need to trigger a digest within the callback to get AngularJS to notice any scope-related changes.)
 */

var copy;
var extend;
var forEach;
var isArray;
var isDefined;
var isElement;
var isFunction;
var isObject;
var isString;
var isUndefined;
var jqLite;
var noop;

/**
 * @ngdoc service
 * @name $animate
 * @kind object
 *
 * @description
 * The ngAnimate `$animate` service documentation is the same for the core `$animate` service.
 *
 * Click here {@link ng.$animate to learn more about animations with `$animate`}.
 */
angular.module('ngAnimate', [], function initAngularHelpers() {
  // Access helpers from AngularJS core.
  // Do it inside a `config` block to ensure `window.angular` is available.
  noop        = angular.noop;
  copy        = angular.copy;
  extend      = angular.extend;
  jqLite      = angular.element;
  forEach     = angular.forEach;
  isArray     = angular.isArray;
  isString    = angular.isString;
  isObject    = angular.isObject;
  isUndefined = angular.isUndefined;
  isDefined   = angular.isDefined;
  isFunction  = angular.isFunction;
  isElement   = angular.isElement;
})
  .info({ angularVersion: '1.7.8' })
  .directive('ngAnimateSwap', ngAnimateSwapDirective)

  .directive('ngAnimateChildren', $$AnimateChildrenDirective)
  .factory('$$rAFScheduler', $$rAFSchedulerFactory)

  .provider('$$animateQueue', $$AnimateQueueProvider)
  .provider('$$animateCache', $$AnimateCacheProvider)
  .provider('$$animation', $$AnimationProvider)

  .provider('$animateCss', $AnimateCssProvider)
  .provider('$$animateCssDriver', $$AnimateCssDriverProvider)

  .provider('$$animateJs', $$AnimateJsProvider)
  .provider('$$animateJsDriver', $$AnimateJsDriverProvider);


})(window, window.angular);
;/**
 * @license AngularJS v1.7.8
 * (c) 2010-2018 Google, Inc. http://angularjs.org
 * License: MIT
 */
(function(window, angular) {'use strict';

var forEach;
var isArray;
var isString;
var jqLite;

/**
 * @ngdoc module
 * @name ngMessages
 * @description
 *
 * The `ngMessages` module provides enhanced support for displaying messages within templates
 * (typically within forms or when rendering message objects that return key/value data).
 * Instead of relying on JavaScript code and/or complex ng-if statements within your form template to
 * show and hide error messages specific to the state of an input field, the `ngMessages` and
 * `ngMessage` directives are designed to handle the complexity, inheritance and priority
 * sequencing based on the order of how the messages are defined in the template.
 *
 * Currently, the ngMessages module only contains the code for the `ngMessages`, `ngMessagesInclude`
 * `ngMessage`, `ngMessageExp` and `ngMessageDefault` directives.
 *
 * ## Usage
 * The `ngMessages` directive allows keys in a key/value collection to be associated with a child element
 * (or 'message') that will show or hide based on the truthiness of that key's value in the collection. A common use
 * case for `ngMessages` is to display error messages for inputs using the `$error` object exposed by the
 * {@link ngModel ngModel} directive.
 *
 * The child elements of the `ngMessages` directive are matched to the collection keys by a `ngMessage` or
 * `ngMessageExp` directive. The value of these attributes must match a key in the collection that is provided by
 * the `ngMessages` directive.
 *
 * Consider the following example, which illustrates a typical use case of `ngMessages`. Within the form `myForm` we
 * have a text input named `myField` which is bound to the scope variable `field` using the {@link ngModel ngModel}
 * directive.
 *
 * The `myField` field is a required input of type `email` with a maximum length of 15 characters.
 *
 * ```html
 * <form name="myForm">
 *   <label>
 *     Enter text:
 *     <input type="email" ng-model="field" name="myField" required maxlength="15" />
 *   </label>
 *   <div ng-messages="myForm.myField.$error" role="alert">
 *     <div ng-message="required">Please enter a value for this field.</div>
 *     <div ng-message="email">This field must be a valid email address.</div>
 *     <div ng-message="maxlength">This field can be at most 15 characters long.</div>
 *   </div>
 * </form>
 * ```
 *
 * In order to show error messages corresponding to `myField` we first create an element with an `ngMessages` attribute
 * set to the `$error` object owned by the `myField` input in our `myForm` form.
 *
 * Within this element we then create separate elements for each of the possible errors that `myField` could have.
 * The `ngMessage` attribute is used to declare which element(s) will appear for which error - for example,
 * setting `ng-message="required"` specifies that this particular element should be displayed when there
 * is no value present for the required field `myField` (because the key `required` will be `true` in the object
 * `myForm.myField.$error`).
 *
 * ### Message order
 *
 * By default, `ngMessages` will only display one message for a particular key/value collection at any time. If more
 * than one message (or error) key is currently true, then which message is shown is determined by the order of messages
 * in the HTML template code (messages declared first are prioritised). This mechanism means the developer does not have
 * to prioritize messages using custom JavaScript code.
 *
 * Given the following error object for our example (which informs us that the field `myField` currently has both the
 * `required` and `email` errors):
 *
 * ```javascript
 * <!-- keep in mind that ngModel automatically sets these error flags -->
 * myField.$error = { required : true, email: true, maxlength: false };
 * ```
 * The `required` message will be displayed to the user since it appears before the `email` message in the DOM.
 * Once the user types a single character, the `required` message will disappear (since the field now has a value)
 * but the `email` message will be visible because it is still applicable.
 *
 * ### Displaying multiple messages at the same time
 *
 * While `ngMessages` will by default only display one error element at a time, the `ng-messages-multiple` attribute can
 * be applied to the `ngMessages` container element to cause it to display all applicable error messages at once:
 *
 * ```html
 * <!-- attribute-style usage -->
 * <div ng-messages="myForm.myField.$error" ng-messages-multiple>...</div>
 *
 * <!-- element-style usage -->
 * <ng-messages for="myForm.myField.$error" multiple>...</ng-messages>
 * ```
 *
 * ## Reusing and Overriding Messages
 * In addition to prioritization, ngMessages also allows for including messages from a remote or an inline
 * template. This allows for generic collection of messages to be reused across multiple parts of an
 * application.
 *
 * ```html
 * <script type="text/ng-template" id="error-messages">
 *   <div ng-message="required">This field is required</div>
 *   <div ng-message="minlength">This field is too short</div>
 * </script>
 *
 * <div ng-messages="myForm.myField.$error" role="alert">
 *   <div ng-messages-include="error-messages"></div>
 * </div>
 * ```
 *
 * However, including generic messages may not be useful enough to match all input fields, therefore,
 * `ngMessages` provides the ability to override messages defined in the remote template by redefining
 * them within the directive container.
 *
 * ```html
 * <!-- a generic template of error messages known as "my-custom-messages" -->
 * <script type="text/ng-template" id="my-custom-messages">
 *   <div ng-message="required">This field is required</div>
 *   <div ng-message="minlength">This field is too short</div>
 * </script>
 *
 * <form name="myForm">
 *   <label>
 *     Email address
 *     <input type="email"
 *            id="email"
 *            name="myEmail"
 *            ng-model="email"
 *            minlength="5"
 *            required />
 *   </label>
 *   <!-- any ng-message elements that appear BEFORE the ng-messages-include will
 *        override the messages present in the ng-messages-include template -->
 *   <div ng-messages="myForm.myEmail.$error" role="alert">
 *     <!-- this required message has overridden the template message -->
 *     <div ng-message="required">You did not enter your email address</div>
 *
 *     <!-- this is a brand new message and will appear last in the prioritization -->
 *     <div ng-message="email">Your email address is invalid</div>
 *
 *     <!-- and here are the generic error messages -->
 *     <div ng-messages-include="my-custom-messages"></div>
 *   </div>
 * </form>
 * ```
 *
 * In the example HTML code above the message that is set on required will override the corresponding
 * required message defined within the remote template. Therefore, with particular input fields (such
 * email addresses, date fields, autocomplete inputs, etc...), specialized error messages can be applied
 * while more generic messages can be used to handle other, more general input errors.
 *
 * ## Dynamic Messaging
 * ngMessages also supports using expressions to dynamically change key values. Using arrays and
 * repeaters to list messages is also supported. This means that the code below will be able to
 * fully adapt itself and display the appropriate message when any of the expression data changes:
 *
 * ```html
 * <form name="myForm">
 *   <label>
 *     Email address
 *     <input type="email"
 *            name="myEmail"
 *            ng-model="email"
 *            minlength="5"
 *            required />
 *   </label>
 *   <div ng-messages="myForm.myEmail.$error" role="alert">
 *     <div ng-message="required">You did not enter your email address</div>
 *     <div ng-repeat="errorMessage in errorMessages">
 *       <!-- use ng-message-exp for a message whose key is given by an expression -->
 *       <div ng-message-exp="errorMessage.type">{{ errorMessage.text }}</div>
 *     </div>
 *   </div>
 * </form>
 * ```
 *
 * The `errorMessage.type` expression can be a string value or it can be an array so
 * that multiple errors can be associated with a single error message:
 *
 * ```html
 *   <label>
 *     Email address
 *     <input type="email"
 *            ng-model="data.email"
 *            name="myEmail"
 *            ng-minlength="5"
 *            ng-maxlength="100"
 *            required />
 *   </label>
 *   <div ng-messages="myForm.myEmail.$error" role="alert">
 *     <div ng-message-exp="'required'">You did not enter your email address</div>
 *     <div ng-message-exp="['minlength', 'maxlength']">
 *       Your email must be between 5 and 100 characters long
 *     </div>
 *   </div>
 * ```
 *
 * Feel free to use other structural directives such as ng-if and ng-switch to further control
 * what messages are active and when. Be careful, if you place ng-message on the same element
 * as these structural directives, AngularJS may not be able to determine if a message is active
 * or not. Therefore it is best to place the ng-message on a child element of the structural
 * directive.
 *
 * ```html
 * <div ng-messages="myForm.myEmail.$error" role="alert">
 *   <div ng-if="showRequiredError">
 *     <div ng-message="required">Please enter something</div>
 *   </div>
 * </div>
 * ```
 *
 * ## Animations
 * If the `ngAnimate` module is active within the application then the `ngMessages`, `ngMessage` and
 * `ngMessageExp` directives will trigger animations whenever any messages are added and removed from
 * the DOM by the `ngMessages` directive.
 *
 * Whenever the `ngMessages` directive contains one or more visible messages then the `.ng-active` CSS
 * class will be added to the element. The `.ng-inactive` CSS class will be applied when there are no
 * messages present. Therefore, CSS transitions and keyframes as well as JavaScript animations can
 * hook into the animations whenever these classes are added/removed.
 *
 * Let's say that our HTML code for our messages container looks like so:
 *
 * ```html
 * <div ng-messages="myMessages" class="my-messages" role="alert">
 *   <div ng-message="alert" class="some-message">...</div>
 *   <div ng-message="fail" class="some-message">...</div>
 * </div>
 * ```
 *
 * Then the CSS animation code for the message container looks like so:
 *
 * ```css
 * .my-messages {
 *   transition:1s linear all;
 * }
 * .my-messages.ng-active {
 *   // messages are visible
 * }
 * .my-messages.ng-inactive {
 *   // messages are hidden
 * }
 * ```
 *
 * Whenever an inner message is attached (becomes visible) or removed (becomes hidden) then the enter
 * and leave animation is triggered for each particular element bound to the `ngMessage` directive.
 *
 * Therefore, the CSS code for the inner messages looks like so:
 *
 * ```css
 * .some-message {
 *   transition:1s linear all;
 * }
 *
 * .some-message.ng-enter {}
 * .some-message.ng-enter.ng-enter-active {}
 *
 * .some-message.ng-leave {}
 * .some-message.ng-leave.ng-leave-active {}
 * ```
 *
 * {@link ngAnimate See the ngAnimate docs} to learn how to use JavaScript animations or to learn
 * more about ngAnimate.
 *
 * ## Displaying a default message
 * If the ngMessages renders no inner ngMessage directive (i.e. when none of the truthy
 * keys are matched by a defined message), then it will render a default message
 * using the {@link ngMessageDefault} directive.
 * Note that matched messages will always take precedence over unmatched messages. That means
 * the default message will not be displayed when another message is matched. This is also
 * true for `ng-messages-multiple`.
 *
 * ```html
 * <div ng-messages="myForm.myField.$error" role="alert">
 *   <div ng-message="required">This field is required</div>
 *   <div ng-message="minlength">This field is too short</div>
 *   <div ng-message-default>This field has an input error</div>
 * </div>
 * ```
 *

 */
angular.module('ngMessages', [], function initAngularHelpers() {
  // Access helpers from AngularJS core.
  // Do it inside a `config` block to ensure `window.angular` is available.
  forEach = angular.forEach;
  isArray = angular.isArray;
  isString = angular.isString;
  jqLite = angular.element;
})
  .info({ angularVersion: '1.7.8' })

  /**
   * @ngdoc directive
   * @module ngMessages
   * @name ngMessages
   * @restrict AE
   *
   * @description
   * `ngMessages` is a directive that is designed to show and hide messages based on the state
   * of a key/value object that it listens on. The directive itself complements error message
   * reporting with the `ngModel` $error object (which stores a key/value state of validation errors).
   *
   * `ngMessages` manages the state of internal messages within its container element. The internal
   * messages use the `ngMessage` directive and will be inserted/removed from the page depending
   * on if they're present within the key/value object. By default, only one message will be displayed
   * at a time and this depends on the prioritization of the messages within the template. (This can
   * be changed by using the `ng-messages-multiple` or `multiple` attribute on the directive container.)
   *
   * A remote template can also be used (With {@link ngMessagesInclude}) to promote message
   * reusability and messages can also be overridden.
   *
   * A default message can also be displayed when no `ngMessage` directive is inserted, using the
   * {@link ngMessageDefault} directive.
   *
   * {@link module:ngMessages Click here} to learn more about `ngMessages` and `ngMessage`.
   *
   * @usage
   * ```html
   * <!-- using attribute directives -->
   * <ANY ng-messages="expression" role="alert">
   *   <ANY ng-message="stringValue">...</ANY>
   *   <ANY ng-message="stringValue1, stringValue2, ...">...</ANY>
   *   <ANY ng-message-exp="expressionValue">...</ANY>
   *   <ANY ng-message-default>...</ANY>
   * </ANY>
   *
   * <!-- or by using element directives -->
   * <ng-messages for="expression" role="alert">
   *   <ng-message when="stringValue">...</ng-message>
   *   <ng-message when="stringValue1, stringValue2, ...">...</ng-message>
   *   <ng-message when-exp="expressionValue">...</ng-message>
   *   <ng-message-default>...</ng-message-default>
   * </ng-messages>
   * ```
   *
   * @param {string} ngMessages an AngularJS expression evaluating to a key/value object
   *                 (this is typically the $error object on an ngModel instance).
   * @param {string=} ngMessagesMultiple|multiple when set, all messages will be displayed with true
   *
   * @example
   * <example name="ngMessages-directive" module="ngMessagesExample"
   *          deps="angular-messages.js"
   *          animations="true" fixBase="true">
   *   <file name="index.html">
   *     <form name="myForm">
   *       <label>
   *         Enter your name:
   *         <input type="text"
   *                name="myName"
   *                ng-model="name"
   *                ng-minlength="5"
   *                ng-maxlength="20"
   *                required />
   *       </label>
   *       <pre>myForm.myName.$error = {{ myForm.myName.$error | json }}</pre>
   *
   *       <div ng-messages="myForm.myName.$error" style="color:maroon" role="alert">
   *         <div ng-message="required">You did not enter a field</div>
   *         <div ng-message="minlength">Your field is too short</div>
   *         <div ng-message="maxlength">Your field is too long</div>
   *         <div ng-message-default>This field has an input error</div>
   *       </div>
   *     </form>
   *   </file>
   *   <file name="script.js">
   *     angular.module('ngMessagesExample', ['ngMessages']);
   *   </file>
   * </example>
   */
  .directive('ngMessages', ['$animate', function($animate) {
    var ACTIVE_CLASS = 'ng-active';
    var INACTIVE_CLASS = 'ng-inactive';

    return {
      require: 'ngMessages',
      restrict: 'AE',
      controller: ['$element', '$scope', '$attrs', function NgMessagesCtrl($element, $scope, $attrs) {
        var ctrl = this;
        var latestKey = 0;
        var nextAttachId = 0;

        this.getAttachId = function getAttachId() { return nextAttachId++; };

        var messages = this.messages = {};
        var renderLater, cachedCollection;

        this.render = function(collection) {
          collection = collection || {};

          renderLater = false;
          cachedCollection = collection;

          // this is true if the attribute is empty or if the attribute value is truthy
          var multiple = isAttrTruthy($scope, $attrs.ngMessagesMultiple) ||
                         isAttrTruthy($scope, $attrs.multiple);

          var unmatchedMessages = [];
          var matchedKeys = {};
          var truthyKeys = 0;
          var messageItem = ctrl.head;
          var messageFound = false;
          var totalMessages = 0;

          // we use != instead of !== to allow for both undefined and null values
          while (messageItem != null) {
            totalMessages++;
            var messageCtrl = messageItem.message;

            var messageUsed = false;
            if (!messageFound) {
              forEach(collection, function(value, key) {
                if (truthy(value) && !messageUsed) {
                  truthyKeys++;

                  if (messageCtrl.test(key)) {
                    // this is to prevent the same error name from showing up twice
                    if (matchedKeys[key]) return;
                    matchedKeys[key] = true;

                    messageUsed = true;
                    messageCtrl.attach();
                  }
                }
              });
            }

            if (messageUsed) {
              // unless we want to display multiple messages then we should
              // set a flag here to avoid displaying the next message in the list
              messageFound = !multiple;
            } else {
              unmatchedMessages.push(messageCtrl);
            }

            messageItem = messageItem.next;
          }

          forEach(unmatchedMessages, function(messageCtrl) {
            messageCtrl.detach();
          });

          var messageMatched = unmatchedMessages.length !== totalMessages;
          var attachDefault = ctrl.default && !messageMatched && truthyKeys > 0;

          if (attachDefault) {
            ctrl.default.attach();
          } else if (ctrl.default) {
            ctrl.default.detach();
          }

          if (messageMatched || attachDefault) {
            $animate.setClass($element, ACTIVE_CLASS, INACTIVE_CLASS);
          } else {
            $animate.setClass($element, INACTIVE_CLASS, ACTIVE_CLASS);
          }
        };

        $scope.$watchCollection($attrs.ngMessages || $attrs['for'], ctrl.render);

        this.reRender = function() {
          if (!renderLater) {
            renderLater = true;
            $scope.$evalAsync(function() {
              if (renderLater && cachedCollection) {
                ctrl.render(cachedCollection);
              }
            });
          }
        };

        this.register = function(comment, messageCtrl, isDefault) {
          if (isDefault) {
            ctrl.default = messageCtrl;
          } else {
            var nextKey = latestKey.toString();
            messages[nextKey] = {
              message: messageCtrl
            };
            insertMessageNode($element[0], comment, nextKey);
            comment.$$ngMessageNode = nextKey;
            latestKey++;
          }

          ctrl.reRender();
        };

        this.deregister = function(comment, isDefault) {
          if (isDefault) {
            delete ctrl.default;
          } else {
            var key = comment.$$ngMessageNode;
            delete comment.$$ngMessageNode;
            removeMessageNode($element[0], comment, key);
            delete messages[key];
          }
          ctrl.reRender();
        };

        function findPreviousMessage(parent, comment) {
          var prevNode = comment;
          var parentLookup = [];

          while (prevNode && prevNode !== parent) {
            var prevKey = prevNode.$$ngMessageNode;
            if (prevKey && prevKey.length) {
              return messages[prevKey];
            }

            // dive deeper into the DOM and examine its children for any ngMessage
            // comments that may be in an element that appears deeper in the list
            if (prevNode.childNodes.length && parentLookup.indexOf(prevNode) === -1) {
              parentLookup.push(prevNode);
              prevNode = prevNode.childNodes[prevNode.childNodes.length - 1];
            } else if (prevNode.previousSibling) {
              prevNode = prevNode.previousSibling;
            } else {
              prevNode = prevNode.parentNode;
              parentLookup.push(prevNode);
            }
          }
        }

        function insertMessageNode(parent, comment, key) {
          var messageNode = messages[key];
          if (!ctrl.head) {
            ctrl.head = messageNode;
          } else {
            var match = findPreviousMessage(parent, comment);
            if (match) {
              messageNode.next = match.next;
              match.next = messageNode;
            } else {
              messageNode.next = ctrl.head;
              ctrl.head = messageNode;
            }
          }
        }

        function removeMessageNode(parent, comment, key) {
          var messageNode = messages[key];

          // This message node may have already been removed by a call to deregister()
          if (!messageNode) return;

          var match = findPreviousMessage(parent, comment);
          if (match) {
            match.next = messageNode.next;
          } else {
            ctrl.head = messageNode.next;
          }
        }
      }]
    };

    function isAttrTruthy(scope, attr) {
     return (isString(attr) && attr.length === 0) || //empty attribute
            truthy(scope.$eval(attr));
    }

    function truthy(val) {
      return isString(val) ? val.length : !!val;
    }
  }])

  /**
   * @ngdoc directive
   * @name ngMessagesInclude
   * @restrict AE
   * @scope
   *
   * @description
   * `ngMessagesInclude` is a directive with the purpose to import existing ngMessage template
   * code from a remote template and place the downloaded template code into the exact spot
   * that the ngMessagesInclude directive is placed within the ngMessages container. This allows
   * for a series of pre-defined messages to be reused and also allows for the developer to
   * determine what messages are overridden due to the placement of the ngMessagesInclude directive.
   *
   * @usage
   * ```html
   * <!-- using attribute directives -->
   * <ANY ng-messages="expression" role="alert">
   *   <ANY ng-messages-include="remoteTplString">...</ANY>
   * </ANY>
   *
   * <!-- or by using element directives -->
   * <ng-messages for="expression" role="alert">
   *   <ng-messages-include src="expressionValue1">...</ng-messages-include>
   * </ng-messages>
   * ```
   *
   * {@link module:ngMessages Click here} to learn more about `ngMessages` and `ngMessage`.
   *
   * @param {string} ngMessagesInclude|src a string value corresponding to the remote template.
   */
  .directive('ngMessagesInclude',
    ['$templateRequest', '$document', '$compile', function($templateRequest, $document, $compile) {

    return {
      restrict: 'AE',
      require: '^^ngMessages', // we only require this for validation sake
      link: function($scope, element, attrs) {
        var src = attrs.ngMessagesInclude || attrs.src;
        $templateRequest(src).then(function(html) {
          if ($scope.$$destroyed) return;

          if (isString(html) && !html.trim()) {
            // Empty template - nothing to compile
            replaceElementWithMarker(element, src);
          } else {
            // Non-empty template - compile and link
            $compile(html)($scope, function(contents) {
              element.after(contents);
              replaceElementWithMarker(element, src);
            });
          }
        });
      }
    };

    // Helpers
    function replaceElementWithMarker(element, src) {
      // A comment marker is placed for debugging purposes
      var comment = $compile.$$createComment ?
          $compile.$$createComment('ngMessagesInclude', src) :
          $document[0].createComment(' ngMessagesInclude: ' + src + ' ');
      var marker = jqLite(comment);
      element.after(marker);

      // Don't pollute the DOM anymore by keeping an empty directive element
      element.remove();
    }
  }])

  /**
   * @ngdoc directive
   * @name ngMessage
   * @restrict AE
   * @scope
   * @priority 1
   *
   * @description
   * `ngMessage` is a directive with the purpose to show and hide a particular message.
   * For `ngMessage` to operate, a parent `ngMessages` directive on a parent DOM element
   * must be situated since it determines which messages are visible based on the state
   * of the provided key/value map that `ngMessages` listens on.
   *
   * More information about using `ngMessage` can be found in the
   * {@link module:ngMessages `ngMessages` module documentation}.
   *
   * @usage
   * ```html
   * <!-- using attribute directives -->
   * <ANY ng-messages="expression" role="alert">
   *   <ANY ng-message="stringValue">...</ANY>
   *   <ANY ng-message="stringValue1, stringValue2, ...">...</ANY>
   * </ANY>
   *
   * <!-- or by using element directives -->
   * <ng-messages for="expression" role="alert">
   *   <ng-message when="stringValue">...</ng-message>
   *   <ng-message when="stringValue1, stringValue2, ...">...</ng-message>
   * </ng-messages>
   * ```
   *
   * @param {expression} ngMessage|when a string value corresponding to the message key.
   */
  .directive('ngMessage', ngMessageDirectiveFactory())


  /**
   * @ngdoc directive
   * @name ngMessageExp
   * @restrict AE
   * @priority 1
   * @scope
   *
   * @description
   * `ngMessageExp` is the same as {@link directive:ngMessage `ngMessage`}, but instead of a static
   * value, it accepts an expression to be evaluated for the message key.
   *
   * @usage
   * ```html
   * <!-- using attribute directives -->
   * <ANY ng-messages="expression">
   *   <ANY ng-message-exp="expressionValue">...</ANY>
   * </ANY>
   *
   * <!-- or by using element directives -->
   * <ng-messages for="expression">
   *   <ng-message when-exp="expressionValue">...</ng-message>
   * </ng-messages>
   * ```
   *
   * {@link module:ngMessages Click here} to learn more about `ngMessages` and `ngMessage`.
   *
   * @param {expression} ngMessageExp|whenExp an expression value corresponding to the message key.
   */
  .directive('ngMessageExp', ngMessageDirectiveFactory())

  /**
   * @ngdoc directive
   * @name ngMessageDefault
   * @restrict AE
   * @scope
   *
   * @description
   * `ngMessageDefault` is a directive with the purpose to show and hide a default message for
   * {@link directive:ngMessages}, when none of provided messages matches.
   *
   * More information about using `ngMessageDefault` can be found in the
   * {@link module:ngMessages `ngMessages` module documentation}.
   *
   * @usage
   * ```html
   * <!-- using attribute directives -->
   * <ANY ng-messages="expression" role="alert">
   *   <ANY ng-message="stringValue">...</ANY>
   *   <ANY ng-message="stringValue1, stringValue2, ...">...</ANY>
   *   <ANY ng-message-default>...</ANY>
   * </ANY>
   *
   * <!-- or by using element directives -->
   * <ng-messages for="expression" role="alert">
   *   <ng-message when="stringValue">...</ng-message>
   *   <ng-message when="stringValue1, stringValue2, ...">...</ng-message>
   *   <ng-message-default>...</ng-message-default>
   * </ng-messages>
   *
  */
  .directive('ngMessageDefault', ngMessageDirectiveFactory(true));

function ngMessageDirectiveFactory(isDefault) {
  return ['$animate', function($animate) {
    return {
      restrict: 'AE',
      transclude: 'element',
      priority: 1, // must run before ngBind, otherwise the text is set on the comment
      terminal: true,
      require: '^^ngMessages',
      link: function(scope, element, attrs, ngMessagesCtrl, $transclude) {
        var commentNode, records, staticExp, dynamicExp;

        if (!isDefault) {
          commentNode = element[0];
          staticExp = attrs.ngMessage || attrs.when;
          dynamicExp = attrs.ngMessageExp || attrs.whenExp;

          var assignRecords = function(items) {
            records = items
                ? (isArray(items)
                      ? items
                      : items.split(/[\s,]+/))
                : null;
            ngMessagesCtrl.reRender();
          };

          if (dynamicExp) {
            assignRecords(scope.$eval(dynamicExp));
            scope.$watchCollection(dynamicExp, assignRecords);
          } else {
            assignRecords(staticExp);
          }
        }

        var currentElement, messageCtrl;
        ngMessagesCtrl.register(commentNode, messageCtrl = {
          test: function(name) {
            return contains(records, name);
          },
          attach: function() {
            if (!currentElement) {
              $transclude(function(elm, newScope) {
                $animate.enter(elm, null, element);
                currentElement = elm;

                // Each time we attach this node to a message we get a new id that we can match
                // when we are destroying the node later.
                var $$attachId = currentElement.$$attachId = ngMessagesCtrl.getAttachId();

                // in the event that the element or a parent element is destroyed
                // by another structural directive then it's time
                // to deregister the message from the controller
                currentElement.on('$destroy', function() {
                  // If the message element was removed via a call to `detach` then `currentElement` will be null
                  // So this handler only handles cases where something else removed the message element.
                  if (currentElement && currentElement.$$attachId === $$attachId) {
                    ngMessagesCtrl.deregister(commentNode, isDefault);
                    messageCtrl.detach();
                  }
                  newScope.$destroy();
                });
              });
            }
          },
          detach: function() {
            if (currentElement) {
              var elm = currentElement;
              currentElement = null;
              $animate.leave(elm);
            }
          }
        }, isDefault);

        // We need to ensure that this directive deregisters itself when it no longer exists
        // Normally this is done when the attached element is destroyed; but if this directive
        // gets removed before we attach the message to the DOM there is nothing to watch
        // in which case we must deregister when the containing scope is destroyed.
        scope.$on('$destroy', function() {
          ngMessagesCtrl.deregister(commentNode, isDefault);
        });
      }
    };
  }];

  function contains(collection, key) {
    if (collection) {
      return isArray(collection)
          ? collection.indexOf(key) >= 0
          : collection.hasOwnProperty(key);
    }
  }
}


})(window, window.angular);
;/*!
 * AngularJS Material Design
 * https://github.com/angular/material
 * @license MIT
 * v1.1.19
 */
(function( window, angular, undefined ){
"use strict";

(function(){
"use strict";

angular.module('ngMaterial', ["ng","ngAnimate","ngAria","material.core","material.core.animate","material.core.gestures","material.core.interaction","material.core.layout","material.core.meta","material.core.theming.palette","material.core.theming","material.components.autocomplete","material.components.backdrop","material.components.bottomSheet","material.components.button","material.components.card","material.components.checkbox","material.components.chips","material.components.colors","material.components.content","material.components.datepicker","material.components.dialog","material.components.divider","material.components.fabActions","material.components.fabShared","material.components.fabSpeedDial","material.components.fabToolbar","material.components.gridList","material.components.icon","material.components.input","material.components.list","material.components.menu","material.components.menuBar","material.components.navBar","material.components.panel","material.components.progressCircular","material.components.progressLinear","material.components.radioButton","material.components.select","material.components.showHide","material.components.sidenav","material.components.slider","material.components.sticky","material.components.subheader","material.components.swipe","material.components.switch","material.components.tabs","material.components.toast","material.components.toolbar","material.components.tooltip","material.components.truncate","material.components.virtualRepeat","material.components.whiteframe"]);
})();
(function(){
"use strict";

/**
 * Initialization function that validates environment
 * requirements.
 */
DetectNgTouch.$inject = ["$log", "$injector"];
MdCoreConfigure.$inject = ["$provide", "$mdThemingProvider"];
rAFDecorator.$inject = ["$delegate"];
qDecorator.$inject = ["$delegate"];
angular
  .module('material.core', [
    'ngAnimate',
    'material.core.animate',
    'material.core.layout',
    'material.core.interaction',
    'material.core.gestures',
    'material.core.theming'
  ])
  .config(MdCoreConfigure)
  .run(DetectNgTouch);


/**
 * Detect if the ng-Touch module is also being used.
 * Warn if detected.
 * @ngInject
 */
function DetectNgTouch($log, $injector) {
  if ($injector.has('$swipe')) {
    var msg = "" +
      "You are using the ngTouch module. \n" +
      "AngularJS Material already has mobile click, tap, and swipe support... \n" +
      "ngTouch is not supported with AngularJS Material!";
    $log.warn(msg);
  }
}

/**
 * @ngInject
 */
function MdCoreConfigure($provide, $mdThemingProvider) {

  $provide.decorator('$$rAF', ['$delegate', rAFDecorator]);
  $provide.decorator('$q', ['$delegate', qDecorator]);

  $mdThemingProvider.theme('default')
    .primaryPalette('indigo')
    .accentPalette('pink')
    .warnPalette('deep-orange')
    .backgroundPalette('grey');
}

/**
 * @ngInject
 */
function rAFDecorator($delegate) {
  /**
   * Use this to throttle events that come in often.
   * The throttled function will always use the *last* invocation before the
   * coming frame.
   *
   * For example, window resize events that fire many times a second:
   * If we set to use an raf-throttled callback on window resize, then
   * our callback will only be fired once per frame, with the last resize
   * event that happened before that frame.
   *
   * @param {function} callback function to debounce
   */
  $delegate.throttle = function(cb) {
    var queuedArgs, alreadyQueued, queueCb, context;
    return function debounced() {
      queuedArgs = arguments;
      context = this;
      queueCb = cb;
      if (!alreadyQueued) {
        alreadyQueued = true;
        $delegate(function() {
          queueCb.apply(context, Array.prototype.slice.call(queuedArgs));
          alreadyQueued = false;
        });
      }
    };
  };
  return $delegate;
}

/**
 * @ngInject
 */
function qDecorator($delegate) {
  /**
   * Adds a shim for $q.resolve for AngularJS version that don't have it,
   * so we don't have to think about it.
   *
   * via https://github.com/angular/angular.js/pull/11987
   */

  // TODO(crisbeto): this won't be necessary once we drop AngularJS 1.3
  if (!$delegate.resolve) {
    $delegate.resolve = $delegate.when;
  }
  return $delegate;
}

})();
(function(){
"use strict";


MdAutofocusDirective.$inject = ["$parse"];angular.module('material.core')
  .directive('mdAutofocus', MdAutofocusDirective)

  // Support the deprecated md-auto-focus and md-sidenav-focus as well
  .directive('mdAutoFocus', MdAutofocusDirective)
  .directive('mdSidenavFocus', MdAutofocusDirective);

/**
 * @ngdoc directive
 * @name mdAutofocus
 * @module material.core.util
 *
 * @description
 *
 * `[md-autofocus]` provides an optional way to identify the focused element when a `$mdDialog`,
 * `$mdBottomSheet`, `$mdMenu` or `$mdSidenav` opens or upon page load for input-like elements.
 *
 * When one of these opens, it will find the first nested element with the `[md-autofocus]`
 * attribute directive and optional expression. An expression may be specified as the directive
 * value to enable conditional activation of the autofocus.
 *
 * @usage
 *
 * ### Dialog
 * <hljs lang="html">
 * <md-dialog>
 *   <form>
 *     <md-input-container>
 *       <label for="testInput">Label</label>
 *       <input id="testInput" type="text" md-autofocus>
 *     </md-input-container>
 *   </form>
 * </md-dialog>
 * </hljs>
 *
 * ### Bottomsheet
 * <hljs lang="html">
 * <md-bottom-sheet class="md-list md-has-header">
 *  <md-subheader>Comment Actions</md-subheader>
 *  <md-list>
 *    <md-list-item ng-repeat="item in items">
 *
 *      <md-button md-autofocus="$index == 2">
 *        <md-icon md-svg-src="{{item.icon}}"></md-icon>
 *        <span class="md-inline-list-icon-label">{{ item.name }}</span>
 *      </md-button>
 *
 *    </md-list-item>
 *  </md-list>
 * </md-bottom-sheet>
 * </hljs>
 *
 * ### Autocomplete
 * <hljs lang="html">
 *   <md-autocomplete
 *       md-autofocus
 *       md-selected-item="selectedItem"
 *       md-search-text="searchText"
 *       md-items="item in getMatches(searchText)"
 *       md-item-text="item.display">
 *     <span md-highlight-text="searchText">{{item.display}}</span>
 *   </md-autocomplete>
 * </hljs>
 *
 * ### Sidenav
 * <hljs lang="html">
 * <div layout="row" ng-controller="MyController">
 *   <md-sidenav md-component-id="left" class="md-sidenav-left">
 *     Left Nav!
 *   </md-sidenav>
 *
 *   <md-content>
 *     Center Content
 *     <md-button ng-click="openLeftMenu()">
 *       Open Left Menu
 *     </md-button>
 *   </md-content>
 *
 *   <md-sidenav md-component-id="right"
 *     md-is-locked-open="$mdMedia('min-width: 333px')"
 *     class="md-sidenav-right">
 *     <form>
 *       <md-input-container>
 *         <label for="testInput">Test input</label>
 *         <input id="testInput" type="text"
 *                ng-model="data" md-autofocus>
 *       </md-input-container>
 *     </form>
 *   </md-sidenav>
 * </div>
 * </hljs>
 **/
function MdAutofocusDirective($parse) {
  return {
    restrict: 'A',
    link: {
      pre: preLink
    }
  };

  function preLink(scope, element, attr) {
    var attrExp = attr.mdAutoFocus || attr.mdAutofocus || attr.mdSidenavFocus;

    // Initially update the expression by manually parsing the expression as per $watch source.
    updateExpression($parse(attrExp)(scope));

    // Only watch the expression if it is not empty.
    if (attrExp) {
      scope.$watch(attrExp, updateExpression);
    }

    /**
     * Updates the autofocus class which is used to determine whether the attribute
     * expression evaluates to true or false.
     * @param {string|boolean} value Attribute Value
     */
    function updateExpression(value) {

      // Rather than passing undefined to the jqLite toggle class function we explicitly set the
      // value to true. Otherwise the class will be just toggled instead of being forced.
      if (angular.isUndefined(value)) {
        value = true;
      }

      element.toggleClass('md-autofocus', !!value);
    }
  }

}

})();
(function(){
"use strict";

/**
 * @ngdoc module
 * @name material.core.colorUtil
 * @description
 * Color Util
 */
angular
  .module('material.core')
  .factory('$mdColorUtil', ColorUtilFactory);

function ColorUtilFactory() {
  /**
   * Converts hex value to RGBA string
   * @param color {string}
   * @returns {string}
   */
  function hexToRgba (color) {
    var hex   = color[ 0 ] === '#' ? color.substr(1) : color,
      dig   = hex.length / 3,
      red   = hex.substr(0, dig),
      green = hex.substr(dig, dig),
      blue  = hex.substr(dig * 2);
    if (dig === 1) {
      red += red;
      green += green;
      blue += blue;
    }
    return 'rgba(' + parseInt(red, 16) + ',' + parseInt(green, 16) + ',' + parseInt(blue, 16) + ',0.1)';
  }

  /**
   * Converts rgba value to hex string
   * @param {string} color
   * @returns {string}
   */
  function rgbaToHex(color) {
    color = color.match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i);

    var hex = (color && color.length === 4) ? "#" +
    ("0" + parseInt(color[1],10).toString(16)).slice(-2) +
    ("0" + parseInt(color[2],10).toString(16)).slice(-2) +
    ("0" + parseInt(color[3],10).toString(16)).slice(-2) : '';

    return hex.toUpperCase();
  }

  /**
   * Converts an RGB color to RGBA
   * @param {string} color
   * @returns {string}
   */
  function rgbToRgba (color) {
    return color.replace(')', ', 0.1)').replace('(', 'a(');
  }

  /**
   * Converts an RGBA color to RGB
   * @param {string} color
   * @returns {string}
   */
  function rgbaToRgb (color) {
    return color
      ? color.replace('rgba', 'rgb').replace(/,[^),]+\)/, ')')
      : 'rgb(0,0,0)';
  }

  return {
    rgbaToHex: rgbaToHex,
    hexToRgba: hexToRgba,
    rgbToRgba: rgbToRgba,
    rgbaToRgb: rgbaToRgb
  };
}

})();
(function(){
"use strict";

angular.module('material.core')
.factory('$mdConstant', MdConstantFactory);

/**
 * Factory function that creates the grab-bag $mdConstant service.
 * @ngInject
 */
function MdConstantFactory() {

  var prefixTestEl = document.createElement('div');
  var vendorPrefix = getVendorPrefix(prefixTestEl);
  var isWebkit = /webkit/i.test(vendorPrefix);
  var SPECIAL_CHARS_REGEXP = /([:\-_]+(.))/g;

  function vendorProperty(name) {
    // Add a dash between the prefix and name, to be able to transform the string into camelcase.
    var prefixedName = vendorPrefix + '-' + name;
    var ucPrefix = camelCase(prefixedName);
    var lcPrefix = ucPrefix.charAt(0).toLowerCase() + ucPrefix.substring(1);

    return hasStyleProperty(prefixTestEl, name)     ? name     :       // The current browser supports the un-prefixed property
           hasStyleProperty(prefixTestEl, ucPrefix) ? ucPrefix :       // The current browser only supports the prefixed property.
           hasStyleProperty(prefixTestEl, lcPrefix) ? lcPrefix : name; // Some browsers are only supporting the prefix in lowercase.
  }

  function hasStyleProperty(testElement, property) {
    return angular.isDefined(testElement.style[property]);
  }

  function camelCase(input) {
    return input.replace(SPECIAL_CHARS_REGEXP, function(matches, separator, letter, offset) {
      return offset ? letter.toUpperCase() : letter;
    });
  }

  function getVendorPrefix(testElement) {
    var prop, match;
    var vendorRegex = /^(Moz|webkit|ms)(?=[A-Z])/;

    for (prop in testElement.style) {
      if (match = vendorRegex.exec(prop)) {
        return match[0];
      }
    }
  }

  var self = {
    isInputKey : function(e) { return (e.keyCode >= 31 && e.keyCode <= 90); },
    isNumPadKey : function(e) { return (3 === e.location && e.keyCode >= 97 && e.keyCode <= 105); },
    isMetaKey: function(e) { return (e.keyCode >= 91 && e.keyCode <= 93); },
    isFnLockKey: function(e) { return (e.keyCode >= 112 && e.keyCode <= 145); },
    isNavigationKey : function(e) {
      var kc = self.KEY_CODE, NAVIGATION_KEYS =  [kc.SPACE, kc.ENTER, kc.UP_ARROW, kc.DOWN_ARROW];
      return (NAVIGATION_KEYS.indexOf(e.keyCode) != -1);
    },
    hasModifierKey: function(e) {
      return e.ctrlKey || e.metaKey || e.altKey;
    },

    /**
     * Maximum size, in pixels, that can be explicitly set to an element. The actual value varies
     * between browsers, but IE11 has the very lowest size at a mere 1,533,917px. Ideally we could
     * compute this value, but Firefox always reports an element to have a size of zero if it
     * goes over the max, meaning that we'd have to binary search for the value.
     */
    ELEMENT_MAX_PIXELS: 1533917,

    /**
     * Priority for a directive that should run before the directives from ngAria.
     */
    BEFORE_NG_ARIA: 210,

    /**
     * Common Keyboard actions and their associated keycode.
     */
    KEY_CODE: {
      COMMA: 188,
      SEMICOLON : 186,
      ENTER: 13,
      ESCAPE: 27,
      SPACE: 32,
      PAGE_UP: 33,
      PAGE_DOWN: 34,
      END: 35,
      HOME: 36,
      LEFT_ARROW : 37,
      UP_ARROW : 38,
      RIGHT_ARROW : 39,
      DOWN_ARROW : 40,
      TAB : 9,
      BACKSPACE: 8,
      DELETE: 46
    },

    /**
     * Vendor prefixed CSS properties to be used to support the given functionality in older browsers
     * as well.
     */
    CSS: {
      /* Constants */
      TRANSITIONEND: 'transitionend' + (isWebkit ? ' webkitTransitionEnd' : ''),
      ANIMATIONEND: 'animationend' + (isWebkit ? ' webkitAnimationEnd' : ''),

      TRANSFORM: vendorProperty('transform'),
      TRANSFORM_ORIGIN: vendorProperty('transformOrigin'),
      TRANSITION: vendorProperty('transition'),
      TRANSITION_DURATION: vendorProperty('transitionDuration'),
      ANIMATION_PLAY_STATE: vendorProperty('animationPlayState'),
      ANIMATION_DURATION: vendorProperty('animationDuration'),
      ANIMATION_NAME: vendorProperty('animationName'),
      ANIMATION_TIMING: vendorProperty('animationTimingFunction'),
      ANIMATION_DIRECTION: vendorProperty('animationDirection')
    },

    /**
     * As defined in core/style/variables.scss
     *
     * $layout-breakpoint-xs:     600px !default;
     * $layout-breakpoint-sm:     960px !default;
     * $layout-breakpoint-md:     1280px !default;
     * $layout-breakpoint-lg:     1920px !default;
     *
     */
    MEDIA: {
      'xs'        : '(max-width: 599px)'                         ,
      'gt-xs'     : '(min-width: 600px)'                         ,
      'sm'        : '(min-width: 600px) and (max-width: 959px)'  ,
      'gt-sm'     : '(min-width: 960px)'                         ,
      'md'        : '(min-width: 960px) and (max-width: 1279px)' ,
      'gt-md'     : '(min-width: 1280px)'                        ,
      'lg'        : '(min-width: 1280px) and (max-width: 1919px)',
      'gt-lg'     : '(min-width: 1920px)'                        ,
      'xl'        : '(min-width: 1920px)'                        ,
      'landscape' : '(orientation: landscape)'                   ,
      'portrait'  : '(orientation: portrait)'                    ,
      'print' : 'print'
    },

    MEDIA_PRIORITY: [
      'xl',
      'gt-lg',
      'lg',
      'gt-md',
      'md',
      'gt-sm',
      'sm',
      'gt-xs',
      'xs',
      'landscape',
      'portrait',
      'print'
    ]
  };

  return self;
}

})();
(function(){
"use strict";

  angular
    .module('material.core')
    .config(["$provide", function($provide){
       $provide.decorator('$mdUtil', ['$delegate', function ($delegate){
           /**
            * Inject the iterator facade to easily support iteration and accessors
            * @see iterator below
            */
           $delegate.iterator = MdIterator;

           return $delegate;
         }
       ]);
     }]);

  /**
   * iterator is a list facade to easily support iteration and accessors
   *
   * @param items Array list which this iterator will enumerate
   * @param reloop Boolean enables iterator to consider the list as an endless reloop
   */
  function MdIterator(items, reloop) {
    var trueFn = function() { return true; };

    if (items && !angular.isArray(items)) {
      items = Array.prototype.slice.call(items);
    }

    reloop = !!reloop;
    var _items = items || [];

    // Published API
    return {
      items: getItems,
      count: count,

      inRange: inRange,
      contains: contains,
      indexOf: indexOf,
      itemAt: itemAt,

      findBy: findBy,

      add: add,
      remove: remove,

      first: first,
      last: last,
      next: angular.bind(null, findSubsequentItem, false),
      previous: angular.bind(null, findSubsequentItem, true),

      hasPrevious: hasPrevious,
      hasNext: hasNext

    };

    /**
     * Publish copy of the enumerable set
     * @returns {Array|*}
     */
    function getItems() {
      return [].concat(_items);
    }

    /**
     * Determine length of the list
     * @returns {Array.length|*|number}
     */
    function count() {
      return _items.length;
    }

    /**
     * Is the index specified valid
     * @param index
     * @returns {Array.length|*|number|boolean}
     */
    function inRange(index) {
      return _items.length && (index > -1) && (index < _items.length);
    }

    /**
     * Can the iterator proceed to the next item in the list; relative to
     * the specified item.
     *
     * @param item
     * @returns {Array.length|*|number|boolean}
     */
    function hasNext(item) {
      return item ? inRange(indexOf(item) + 1) : false;
    }

    /**
     * Can the iterator proceed to the previous item in the list; relative to
     * the specified item.
     *
     * @param item
     * @returns {Array.length|*|number|boolean}
     */
    function hasPrevious(item) {
      return item ? inRange(indexOf(item) - 1) : false;
    }

    /**
     * Get item at specified index/position
     * @param index
     * @returns {*}
     */
    function itemAt(index) {
      return inRange(index) ? _items[index] : null;
    }

    /**
     * Find all elements matching the key/value pair
     * otherwise return null
     *
     * @param val
     * @param key
     *
     * @return array
     */
    function findBy(key, val) {
      return _items.filter(function(item) {
        return item[key] === val;
      });
    }

    /**
     * Add item to list
     * @param item
     * @param index
     * @returns {*}
     */
    function add(item, index) {
      if (!item) return -1;

      if (!angular.isNumber(index)) {
        index = _items.length;
      }

      _items.splice(index, 0, item);

      return indexOf(item);
    }

    /**
     * Remove item from list...
     * @param item
     */
    function remove(item) {
      if (contains(item)){
        _items.splice(indexOf(item), 1);
      }
    }

    /**
     * Get the zero-based index of the target item
     * @param item
     * @returns {*}
     */
    function indexOf(item) {
      return _items.indexOf(item);
    }

    /**
     * Boolean existence check
     * @param item
     * @returns {boolean}
     */
    function contains(item) {
      return item && (indexOf(item) > -1);
    }

    /**
     * Return first item in the list
     * @returns {*}
     */
    function first() {
      return _items.length ? _items[0] : null;
    }

    /**
     * Return last item in the list...
     * @returns {*}
     */
    function last() {
      return _items.length ? _items[_items.length - 1] : null;
    }

    /**
     * Find the next item. If reloop is true and at the end of the list, it will go back to the
     * first item. If given, the `validate` callback will be used to determine whether the next item
     * is valid. If not valid, it will try to find the next item again.
     *
     * @param {boolean} backwards Specifies the direction of searching (forwards/backwards)
     * @param {*} item The item whose subsequent item we are looking for
     * @param {Function=} validate The `validate` function
     * @param {integer=} limit The recursion limit
     *
     * @returns {*} The subsequent item or null
     */
    function findSubsequentItem(backwards, item, validate, limit) {
      validate = validate || trueFn;

      var curIndex = indexOf(item);
      while (true) {
        if (!inRange(curIndex)) return null;

        var nextIndex = curIndex + (backwards ? -1 : 1);
        var foundItem = null;
        if (inRange(nextIndex)) {
          foundItem = _items[nextIndex];
        } else if (reloop) {
          foundItem = backwards ? last() : first();
          nextIndex = indexOf(foundItem);
        }

        if ((foundItem === null) || (nextIndex === limit)) return null;
        if (validate(foundItem)) return foundItem;

        if (angular.isUndefined(limit)) limit = nextIndex;

        curIndex = nextIndex;
      }
    }
  }


})();
(function(){
"use strict";


mdMediaFactory.$inject = ["$mdConstant", "$rootScope", "$window"];angular.module('material.core')
.factory('$mdMedia', mdMediaFactory);

/**
 * @ngdoc service
 * @name $mdMedia
 * @module material.core
 *
 * @description
 * `$mdMedia` is used to evaluate whether a given media query is true or false given the
 * current device's screen / window size. The media query will be re-evaluated on resize, allowing
 * you to register a watch.
 *
 * `$mdMedia` also has pre-programmed support for media queries that match the layout breakpoints:
 *
 *  <table class="md-api-table">
 *    <thead>
 *    <tr>
 *      <th>Breakpoint</th>
 *      <th>mediaQuery</th>
 *    </tr>
 *    </thead>
 *    <tbody>
 *    <tr>
 *      <td>xs</td>
 *      <td>(max-width: 599px)</td>
 *    </tr>
 *    <tr>
 *      <td>gt-xs</td>
 *      <td>(min-width: 600px)</td>
 *    </tr>
 *    <tr>
 *      <td>sm</td>
 *      <td>(min-width: 600px) and (max-width: 959px)</td>
 *    </tr>
 *    <tr>
 *      <td>gt-sm</td>
 *      <td>(min-width: 960px)</td>
 *    </tr>
 *    <tr>
 *      <td>md</td>
 *      <td>(min-width: 960px) and (max-width: 1279px)</td>
 *    </tr>
 *    <tr>
 *      <td>gt-md</td>
 *      <td>(min-width: 1280px)</td>
 *    </tr>
 *    <tr>
 *      <td>lg</td>
 *      <td>(min-width: 1280px) and (max-width: 1919px)</td>
 *    </tr>
 *    <tr>
 *      <td>gt-lg</td>
 *      <td>(min-width: 1920px)</td>
 *    </tr>
 *    <tr>
 *      <td>xl</td>
 *      <td>(min-width: 1920px)</td>
 *    </tr>
 *    <tr>
 *      <td>landscape</td>
 *      <td>landscape</td>
 *    </tr>
 *    <tr>
 *      <td>portrait</td>
 *      <td>portrait</td>
 *    </tr>
 *    <tr>
 *      <td>print</td>
 *      <td>print</td>
 *    </tr>
 *    </tbody>
 *  </table>
 *
 *  See Material Design's <a href="https://material.google.com/layout/responsive-ui.html">Layout - Adaptive UI</a> for more details.
 *
 *  <a href="https://material.io/archive/guidelines/layout/responsive-ui.html#">
 *  <img src="https://material-design.storage.googleapis.com/publish/material_v_4/material_ext_publish/0B8olV15J7abPSGFxemFiQVRtb1k/layout_adaptive_breakpoints_01.png" width="100%" height="100%"></img>
 *  </a>
 *
 * @returns {boolean} a boolean representing whether or not the given media query is true or false.
 *
 * @usage
 * <hljs lang="js">
 * app.controller('MyController', function($mdMedia, $scope) {
 *   $scope.$watch(function() { return $mdMedia('lg'); }, function(big) {
 *     $scope.bigScreen = big;
 *   });
 *
 *   $scope.screenIsSmall = $mdMedia('sm');
 *   $scope.customQuery = $mdMedia('(min-width: 1234px)');
 *   $scope.anotherCustom = $mdMedia('max-width: 300px');
 * });
 * </hljs>
 */

/* @ngInject */
function mdMediaFactory($mdConstant, $rootScope, $window) {
  var queries = {};
  var mqls = {};
  var results = {};
  var normalizeCache = {};

  $mdMedia.getResponsiveAttribute = getResponsiveAttribute;
  $mdMedia.getQuery = getQuery;
  $mdMedia.watchResponsiveAttributes = watchResponsiveAttributes;

  return $mdMedia;

  function $mdMedia(query) {
    var validated = queries[query];
    if (angular.isUndefined(validated)) {
      validated = queries[query] = validate(query);
    }

    var result = results[validated];
    if (angular.isUndefined(result)) {
      result = add(validated);
    }

    return result;
  }

  function validate(query) {
    return $mdConstant.MEDIA[query] ||
           ((query.charAt(0) !== '(') ? ('(' + query + ')') : query);
  }

  function add(query) {
    var result = mqls[query];
    if (!result) {
      result = mqls[query] = $window.matchMedia(query);
    }

    result.addListener(onQueryChange);
    return (results[result.media] = !!result.matches);
  }

  function onQueryChange(query) {
    $rootScope.$evalAsync(function() {
      results[query.media] = !!query.matches;
    });
  }

  function getQuery(name) {
    return mqls[name];
  }

  function getResponsiveAttribute(attrs, attrName) {
    for (var i = 0; i < $mdConstant.MEDIA_PRIORITY.length; i++) {
      var mediaName = $mdConstant.MEDIA_PRIORITY[i];
      if (!mqls[queries[mediaName]].matches) {
        continue;
      }

      var normalizedName = getNormalizedName(attrs, attrName + '-' + mediaName);
      if (attrs[normalizedName]) {
        return attrs[normalizedName];
      }
    }

    // fallback on unprefixed
    return attrs[getNormalizedName(attrs, attrName)];
  }

  function watchResponsiveAttributes(attrNames, attrs, watchFn) {
    var unwatchFns = [];
    attrNames.forEach(function(attrName) {
      var normalizedName = getNormalizedName(attrs, attrName);
      if (angular.isDefined(attrs[normalizedName])) {
        unwatchFns.push(
            attrs.$observe(normalizedName, angular.bind(void 0, watchFn, null)));
      }

      for (var mediaName in $mdConstant.MEDIA) {
        normalizedName = getNormalizedName(attrs, attrName + '-' + mediaName);
        if (angular.isDefined(attrs[normalizedName])) {
          unwatchFns.push(
              attrs.$observe(normalizedName, angular.bind(void 0, watchFn, mediaName)));
        }
      }
    });

    return function unwatch() {
      unwatchFns.forEach(function(fn) { fn(); });
    };
  }

  // Improves performance dramatically
  function getNormalizedName(attrs, attrName) {
    return normalizeCache[attrName] ||
        (normalizeCache[attrName] = attrs.$normalize(attrName));
  }
}

})();
(function(){
"use strict";

angular
  .module('material.core')
  .config(["$provide", function($provide) {
    $provide.decorator('$mdUtil', ['$delegate', function ($delegate) {

      // Inject the prefixer into our original $mdUtil service.
      $delegate.prefixer = MdPrefixer;

      return $delegate;
    }]);
  }]);

function MdPrefixer(initialAttributes, buildSelector) {
  var PREFIXES = ['data', 'x'];

  if (initialAttributes) {
    // The prefixer also accepts attributes as a parameter, and immediately builds a list or selector for
    // the specified attributes.
    return buildSelector ? _buildSelector(initialAttributes) : _buildList(initialAttributes);
  }

  return {
    buildList: _buildList,
    buildSelector: _buildSelector,
    hasAttribute: _hasAttribute,
    removeAttribute: _removeAttribute
  };

  function _buildList(attributes) {
    attributes = angular.isArray(attributes) ? attributes : [attributes];

    attributes.forEach(function(item) {
      PREFIXES.forEach(function(prefix) {
        attributes.push(prefix + '-' + item);
      });
    });

    return attributes;
  }

  function _buildSelector(attributes) {
    attributes = angular.isArray(attributes) ? attributes : [attributes];

    return _buildList(attributes)
      .map(function(item) {
        return '[' + item + ']';
      })
      .join(',');
  }

  function _hasAttribute(element, attribute) {
    element = _getNativeElement(element);

    if (!element) {
      return false;
    }

    var prefixedAttrs = _buildList(attribute);

    for (var i = 0; i < prefixedAttrs.length; i++) {
      if (element.hasAttribute(prefixedAttrs[i])) {
        return true;
      }
    }

    return false;
  }

  function _removeAttribute(element, attribute) {
    element = _getNativeElement(element);

    if (!element) {
      return;
    }

    _buildList(attribute).forEach(function(prefixedAttribute) {
      element.removeAttribute(prefixedAttribute);
    });
  }

  /**
   * Transforms a jqLite or DOM element into a HTML element.
   * This is useful when supporting jqLite elements and DOM elements at
   * same time.
   * @param element {JQLite|Element} Element to be parsed
   * @returns {HTMLElement} Parsed HTMLElement
   */
  function _getNativeElement(element) {
    element =  element[0] || element;

    if (element.nodeType) {
      return element;
    }
  }

}

})();
(function(){
"use strict";

/*
 * This var has to be outside the angular factory, otherwise when
 * there are multiple material apps on the same page, each app
 * will create its own instance of this array and the app's IDs
 * will not be unique.
 */
UtilFactory.$inject = ["$document", "$timeout", "$compile", "$rootScope", "$$mdAnimate", "$interpolate", "$log", "$rootElement", "$window", "$$rAF"];
var nextUniqueId = 0;

/**
 * @ngdoc module
 * @name material.core.util
 * @description
 * Util
 */
angular
.module('material.core')
.factory('$mdUtil', UtilFactory);

/**
 * @ngInject
 */
function UtilFactory($document, $timeout, $compile, $rootScope, $$mdAnimate, $interpolate, $log, $rootElement, $window, $$rAF) {
  // Setup some core variables for the processTemplate method
  var startSymbol = $interpolate.startSymbol(),
    endSymbol = $interpolate.endSymbol(),
    usesStandardSymbols = ((startSymbol === '{{') && (endSymbol === '}}'));

  /**
   * Checks if the target element has the requested style by key
   * @param {DOMElement|JQLite} target Target element
   * @param {string} key Style key
   * @param {string=} expectedVal Optional expected value
   * @returns {boolean} Whether the target element has the style or not
   */
  var hasComputedStyle = function (target, key, expectedVal) {
    var hasValue = false;

    if (target && target.length) {
      var computedStyles = $window.getComputedStyle(target[0]);
      hasValue = angular.isDefined(computedStyles[key]) && (expectedVal ? computedStyles[key] == expectedVal : true);
    }

    return hasValue;
  };

  function validateCssValue(value) {
    return !value       ? '0'   :
      hasPx(value) || hasPercent(value) ? value : value + 'px';
  }

  function hasPx(value) {
    return String(value).indexOf('px') > -1;
  }

  function hasPercent(value) {
    return String(value).indexOf('%') > -1;

  }

  var $mdUtil = {
    dom: {},
    now: window.performance && window.performance.now ?
      angular.bind(window.performance, window.performance.now) : Date.now || function() {
      return new Date().getTime();
    },

    /**
     * Cross-version compatibility method to retrieve an option of a ngModel controller,
     * which supports the breaking changes in the AngularJS snapshot (SHA 87a2ff76af5d0a9268d8eb84db5755077d27c84c).
     * @param {!angular.ngModelCtrl} ngModelCtrl
     * @param {!string} optionName
     * @returns {Object|undefined}
     */
    getModelOption: function (ngModelCtrl, optionName) {
      if (!ngModelCtrl.$options) {
        return;
      }

      var $options = ngModelCtrl.$options;

      // The newer versions of AngularJS introduced a `getOption function and made the option values no longer
      // visible on the $options object.
      return $options.getOption ? $options.getOption(optionName) : $options[optionName];
    },

    /**
     * Bi-directional accessor/mutator used to easily update an element's
     * property based on the current 'dir'ectional value.
     */
    bidi : function(element, property, lValue, rValue) {
      var ltr = !($document[0].dir == 'rtl' || $document[0].body.dir == 'rtl');

      // If accessor
      if (arguments.length == 0) return ltr ? 'ltr' : 'rtl';

      // If mutator
      var elem = angular.element(element);

      if (ltr && angular.isDefined(lValue)) {
        elem.css(property, validateCssValue(lValue));
      }
      else if (!ltr && angular.isDefined(rValue)) {
        elem.css(property, validateCssValue(rValue));
      }
    },

    bidiProperty: function (element, lProperty, rProperty, value) {
      var ltr = !($document[0].dir == 'rtl' || $document[0].body.dir == 'rtl');

      var elem = angular.element(element);

      if (ltr && angular.isDefined(lProperty)) {
        elem.css(lProperty, validateCssValue(value));
        elem.css(rProperty, '');
      }
      else if (!ltr && angular.isDefined(rProperty)) {
        elem.css(rProperty, validateCssValue(value));
        elem.css(lProperty, '');
      }
    },

    clientRect: function(element, offsetParent, isOffsetRect) {
      var node = getNode(element);
      offsetParent = getNode(offsetParent || node.offsetParent || document.body);
      var nodeRect = node.getBoundingClientRect();

      // The user can ask for an offsetRect: a rect relative to the offsetParent,
      // or a clientRect: a rect relative to the page
      var offsetRect = isOffsetRect ?
        offsetParent.getBoundingClientRect() :
        {left: 0, top: 0, width: 0, height: 0};
      return {
        left: nodeRect.left - offsetRect.left,
        top: nodeRect.top - offsetRect.top,
        width: nodeRect.width,
        height: nodeRect.height
      };
    },
    offsetRect: function(element, offsetParent) {
      return $mdUtil.clientRect(element, offsetParent, true);
    },

    // Annoying method to copy nodes to an array, thanks to IE
    nodesToArray: function(nodes) {
      nodes = nodes || [];

      var results = [];
      for (var i = 0; i < nodes.length; ++i) {
        results.push(nodes.item(i));
      }
      return results;
    },

    /**
     * Determines the absolute position of the viewport.
     * Useful when making client rectangles absolute.
     * @returns {number}
     */
    getViewportTop: function() {
      // If body scrolling is disabled, then use the cached viewport top value, otherwise get it
      // fresh from the $window.
      if ($mdUtil.disableScrollAround._count && $mdUtil.disableScrollAround._viewPortTop) {
        return $mdUtil.disableScrollAround._viewPortTop;
      } else {
        return $window.scrollY || $window.pageYOffset || 0;
      }
    },

    /**
     * Finds the proper focus target by searching the DOM.
     *
     * @param containerEl
     * @param attributeVal
     * @returns {*}
     */
    findFocusTarget: function(containerEl, attributeVal) {
      var AUTO_FOCUS = this.prefixer('md-autofocus', true);
      var elToFocus;

      elToFocus = scanForFocusable(containerEl, attributeVal || AUTO_FOCUS);

      if (!elToFocus && attributeVal != AUTO_FOCUS) {
        // Scan for deprecated attribute
        elToFocus = scanForFocusable(containerEl, this.prefixer('md-auto-focus', true));

        if (!elToFocus) {
          // Scan for fallback to 'universal' API
          elToFocus = scanForFocusable(containerEl, AUTO_FOCUS);
        }
      }

      return elToFocus;

      /**
       * Can target and nested children for specified Selector (attribute)
       * whose value may be an expression that evaluates to True/False.
       */
      function scanForFocusable(target, selector) {
        var elFound, items = target[0].querySelectorAll(selector);

        // Find the last child element with the focus attribute
        if (items && items.length){
          items.length && angular.forEach(items, function(it) {
            it = angular.element(it);

            // Check the element for the md-autofocus class to ensure any associated expression
            // evaluated to true.
            var isFocusable = it.hasClass('md-autofocus');
            if (isFocusable) elFound = it;
          });
        }
        return elFound;
      }
    },

    /**
     * Disables scroll around the passed parent element.
     * @param element Unused
     * @param {!Element|!angular.JQLite} parent Element to disable scrolling within.
     *   Defaults to body if none supplied.
     * @param options Object of options to modify functionality
     *   - disableScrollMask Boolean of whether or not to create a scroll mask element or
     *     use the passed parent element.
     */
    disableScrollAround: function(element, parent, options) {
      options = options || {};

      $mdUtil.disableScrollAround._count = Math.max(0, $mdUtil.disableScrollAround._count || 0);
      $mdUtil.disableScrollAround._count++;

      if ($mdUtil.disableScrollAround._restoreScroll) {
        return $mdUtil.disableScrollAround._restoreScroll;
      }

      var body = $document[0].body;
      var restoreBody = disableBodyScroll();
      var restoreElement = disableElementScroll(parent);

      return $mdUtil.disableScrollAround._restoreScroll = function() {
        if (--$mdUtil.disableScrollAround._count <= 0) {
          delete $mdUtil.disableScrollAround._viewPortTop;
          restoreBody();
          restoreElement();
          delete $mdUtil.disableScrollAround._restoreScroll;
        }
      };

      /**
       * Creates a virtual scrolling mask to prevent touchmove, keyboard, scrollbar clicking,
       * and wheel events
       */
      function disableElementScroll(element) {
        element = angular.element(element || body);

        var scrollMask;

        if (options.disableScrollMask) {
          scrollMask = element;
        } else {
          scrollMask = angular.element(
            '<div class="md-scroll-mask">' +
            '  <div class="md-scroll-mask-bar"></div>' +
            '</div>');
          element.append(scrollMask);
        }

        scrollMask.on('wheel', preventDefault);
        scrollMask.on('touchmove', preventDefault);

        return function restoreElementScroll() {
          scrollMask.off('wheel');
          scrollMask.off('touchmove');

          if (!options.disableScrollMask && scrollMask[0].parentNode) {
            scrollMask[0].parentNode.removeChild(scrollMask[0]);
          }
        };

        function preventDefault(e) {
          e.preventDefault();
        }
      }

      // Converts the body to a position fixed block and translate it to the proper scroll position
      function disableBodyScroll() {
        var documentElement = $document[0].documentElement;

        var prevDocumentStyle = documentElement.style.cssText || '';
        var prevBodyStyle = body.style.cssText || '';

        var viewportTop = $mdUtil.getViewportTop();
        $mdUtil.disableScrollAround._viewPortTop = viewportTop;
        var clientWidth = body.clientWidth;
        var hasVerticalScrollbar = body.scrollHeight > body.clientHeight + 1;

        // Scroll may be set on <html> element (for example by overflow-y: scroll)
        // but Chrome is reporting the scrollTop position always on <body>.
        // scrollElement will allow to restore the scrollTop position to proper target.
        var scrollElement = documentElement.scrollTop > 0 ? documentElement : body;

        if (hasVerticalScrollbar) {
          angular.element(body).css({
            position: 'fixed',
            width: '100%',
            top: -viewportTop + 'px'
          });
        }

        if (body.clientWidth < clientWidth) {
          body.style.overflow = 'hidden';
        }

        return function restoreScroll() {
          // Reset the inline style CSS to the previous.
          body.style.cssText = prevBodyStyle;
          documentElement.style.cssText = prevDocumentStyle;

          // The scroll position while being fixed
          scrollElement.scrollTop = viewportTop;
        };
      }

    },

    enableScrolling: function() {
      var restoreFn = this.disableScrollAround._restoreScroll;
      restoreFn && restoreFn();
    },

    floatingScrollbars: function() {
      if (this.floatingScrollbars.cached === undefined) {
        var tempNode = angular.element('<div><div></div></div>').css({
          width: '100%',
          'z-index': -1,
          position: 'absolute',
          height: '35px',
          'overflow-y': 'scroll'
        });
        tempNode.children().css('height', '60px');

        $document[0].body.appendChild(tempNode[0]);
        this.floatingScrollbars.cached = (tempNode[0].offsetWidth == tempNode[0].childNodes[0].offsetWidth);
        tempNode.remove();
      }
      return this.floatingScrollbars.cached;
    },

    // Mobile safari only allows you to set focus in click event listeners...
    forceFocus: function(element) {
      var node = element[0] || element;

      document.addEventListener('click', function focusOnClick(ev) {
        if (ev.target === node && ev.$focus) {
          node.focus();
          ev.stopImmediatePropagation();
          ev.preventDefault();
          node.removeEventListener('click', focusOnClick);
        }
      }, true);

      var newEvent = document.createEvent('MouseEvents');
      newEvent.initMouseEvent('click', false, true, window, {}, 0, 0, 0, 0,
        false, false, false, false, 0, null);
      newEvent.$material = true;
      newEvent.$focus = true;
      node.dispatchEvent(newEvent);
    },

    /**
     * facade to build md-backdrop element with desired styles
     * NOTE: Use $compile to trigger backdrop postLink function
     */
    createBackdrop: function(scope, addClass) {
      return $compile($mdUtil.supplant('<md-backdrop class="{0}">', [addClass]))(scope);
    },

    /**
     * supplant() method from Crockford's `Remedial Javascript`
     * Equivalent to use of $interpolate; without dependency on
     * interpolation symbols and scope. Note: the '{<token>}' can
     * be property names, property chains, or array indices.
     */
    supplant: function(template, values, pattern) {
      pattern = pattern || /\{([^{}]*)\}/g;
      return template.replace(pattern, function(a, b) {
        var p = b.split('.'),
          r = values;
        try {
          for (var s in p) {
            if (p.hasOwnProperty(s)) {
              r = r[p[s]];
            }
          }
        } catch (e) {
          r = a;
        }
        return (typeof r === 'string' || typeof r === 'number') ? r : a;
      });
    },

    fakeNgModel: function() {
      return {
        $fake: true,
        $setTouched: angular.noop,
        $setViewValue: function(value) {
          this.$viewValue = value;
          this.$render(value);
          this.$viewChangeListeners.forEach(function(cb) {
            cb();
          });
        },
        $isEmpty: function(value) {
          return ('' + value).length === 0;
        },
        $parsers: [],
        $formatters: [],
        $viewChangeListeners: [],
        $render: angular.noop
      };
    },

    // Returns a function, that, as long as it continues to be invoked, will not
    // be triggered. The function will be called after it stops being called for
    // N milliseconds.
    // @param wait Integer value of msecs to delay (since last debounce reset); default value 10 msecs
    // @param invokeApply should the $timeout trigger $digest() dirty checking
    debounce: function(func, wait, scope, invokeApply) {
      var timer;

      return function debounced() {
        var context = scope,
          args = Array.prototype.slice.call(arguments);

        $timeout.cancel(timer);
        timer = $timeout(function() {

          timer = undefined;
          func.apply(context, args);

        }, wait || 10, invokeApply);
      };
    },

    // Returns a function that can only be triggered every `delay` milliseconds.
    // In other words, the function will not be called unless it has been more
    // than `delay` milliseconds since the last call.
    throttle: function throttle(func, delay) {
      var recent;
      return function throttled() {
        var context = this;
        var args = arguments;
        var now = $mdUtil.now();

        if (!recent || (now - recent > delay)) {
          func.apply(context, args);
          recent = now;
        }
      };
    },

    /**
     * Measures the number of milliseconds taken to run the provided callback
     * function. Uses a high-precision timer if available.
     */
    time: function time(cb) {
      var start = $mdUtil.now();
      cb();
      return $mdUtil.now() - start;
    },

    /**
     * Create an implicit getter that caches its `getter()`
     * lookup value
     */
    valueOnUse : function (scope, key, getter) {
      var value = null, args = Array.prototype.slice.call(arguments);
      var params = (args.length > 3) ? args.slice(3) : [];

      Object.defineProperty(scope, key, {
        get: function () {
          if (value === null) value = getter.apply(scope, params);
          return value;
        }
      });
    },

    /**
     * Get a unique ID.
     *
     * @returns {string} an unique numeric string
     */
    nextUid: function() {
      return '' + nextUniqueId++;
    },

    // Stop watchers and events from firing on a scope without destroying it,
    // by disconnecting it from its parent and its siblings' linked lists.
    disconnectScope: function disconnectScope(scope) {
      if (!scope) return;

      // we can't destroy the root scope or a scope that has been already destroyed
      if (scope.$root === scope) return;
      if (scope.$$destroyed) return;

      var parent = scope.$parent;
      scope.$$disconnected = true;

      // See Scope.$destroy
      if (parent.$$childHead === scope) parent.$$childHead = scope.$$nextSibling;
      if (parent.$$childTail === scope) parent.$$childTail = scope.$$prevSibling;
      if (scope.$$prevSibling) scope.$$prevSibling.$$nextSibling = scope.$$nextSibling;
      if (scope.$$nextSibling) scope.$$nextSibling.$$prevSibling = scope.$$prevSibling;

      scope.$$nextSibling = scope.$$prevSibling = null;

    },

    // Undo the effects of disconnectScope above.
    reconnectScope: function reconnectScope(scope) {
      if (!scope) return;

      // we can't disconnect the root node or scope already disconnected
      if (scope.$root === scope) return;
      if (!scope.$$disconnected) return;

      var child = scope;

      var parent = child.$parent;
      child.$$disconnected = false;
      // See Scope.$new for this logic...
      child.$$prevSibling = parent.$$childTail;
      if (parent.$$childHead) {
        parent.$$childTail.$$nextSibling = child;
        parent.$$childTail = child;
      } else {
        parent.$$childHead = parent.$$childTail = child;
      }
    },

    /**
     * getClosest replicates jQuery.closest() to walk up the DOM tree until it finds a matching
     * nodeName.
     *
     * @param {Node} el Element to start walking the DOM from
     * @param {string|function} validateWith If a string is passed, it will be evaluated against
     * each of the parent nodes' tag name. If a function is passed, the loop will call it with each
     * of the parents and will use the return value to determine whether the node is a match.
     * @param {boolean=} onlyParent Only start checking from the parent element, not `el`.
     * @returns {Node|null} closest matching parent Node or null if not found
     */
    getClosest: function getClosest(el, validateWith, onlyParent) {
      if (angular.isString(validateWith)) {
        var tagName = validateWith.toUpperCase();
        validateWith = function(el) {
          return el.nodeName.toUpperCase() === tagName;
        };
      }

      if (el instanceof angular.element) el = el[0];
      if (onlyParent) el = el.parentNode;
      if (!el) return null;

      do {
        if (validateWith(el)) {
          return el;
        }
      } while (el = el.parentNode);

      return null;
    },

    /**
     * Build polyfill for the Node.contains feature (if needed)
     * @param {Node} node
     * @param {Node} child
     * @returns {Node}
     */
    elementContains: function(node, child) {
      var hasContains = (window.Node && window.Node.prototype && Node.prototype.contains);
      var findFn = hasContains ? angular.bind(node, node.contains) : angular.bind(node, function(arg) {
        // compares the positions of two nodes and returns a bitmask
        return (node === child) || !!(this.compareDocumentPosition(arg) & 16);
      });

      return findFn(child);
    },

    /**
     * Functional equivalent for $element.filter(‘md-bottom-sheet’)
     * useful with interimElements where the element and its container are important...
     *
     * @param {angular.JQLite} element to scan
     * @param {string} nodeName of node to find (e.g. 'md-dialog')
     * @param {boolean=} scanDeep optional flag to allow deep scans; defaults to 'false'.
     * @param {boolean=} warnNotFound optional flag to enable log warnings; defaults to false
     */
    extractElementByName: function(element, nodeName, scanDeep, warnNotFound) {
      var found = scanTree(element);
      if (!found && !!warnNotFound) {
        $log.warn($mdUtil.supplant("Unable to find node '{0}' in element '{1}'.",[nodeName, element[0].outerHTML]));
      }

      return angular.element(found || element);

      /**
       * Breadth-First tree scan for element with matching `nodeName`
       */
      function scanTree(element) {
        return scanLevel(element) || (scanDeep ? scanChildren(element) : null);
      }

      /**
       * Case-insensitive scan of current elements only (do not descend).
       */
      function scanLevel(element) {
        if (element) {
          for (var i = 0, len = element.length; i < len; i++) {
            if (element[i].nodeName.toLowerCase() === nodeName) {
              return element[i];
            }
          }
        }
        return null;
      }

      /**
       * Scan children of specified node
       */
      function scanChildren(element) {
        var found;
        if (element) {
          for (var i = 0, len = element.length; i < len; i++) {
            var target = element[i];
            if (!found) {
              for (var j = 0, numChild = target.childNodes.length; j < numChild; j++) {
                found = found || scanTree([target.childNodes[j]]);
              }
            }
          }
        }
        return found;
      }

    },

    /**
     * Give optional properties with no value a boolean true if attr provided or false otherwise
     */
    initOptionalProperties: function(scope, attr, defaults) {
      defaults = defaults || {};
      angular.forEach(scope.$$isolateBindings, function(binding, key) {
        if (binding.optional && angular.isUndefined(scope[key])) {
          var attrIsDefined = angular.isDefined(attr[binding.attrName]);
          scope[key] = angular.isDefined(defaults[key]) ? defaults[key] : attrIsDefined;
        }
      });
    },

    /**
     * Alternative to $timeout calls with 0 delay.
     * nextTick() coalesces all calls within a single frame
     * to minimize $digest thrashing
     *
     * @param {Function} callback function to be called after the tick
     * @param {boolean} digest true to call $rootScope.$digest() after callback
     * @param scope scope associated with callback. If the scope is destroyed, the callback will
     *  be skipped.
     * @returns {*}
     */
    nextTick: function(callback, digest, scope) {
      // grab function reference for storing state details
      var nextTick = $mdUtil.nextTick;
      var timeout = nextTick.timeout;
      var queue = nextTick.queue || [];

      // add callback to the queue
      queue.push({scope: scope, callback: callback});

      // set default value for digest
      if (digest == null) digest = true;

      // store updated digest/queue values
      nextTick.digest = nextTick.digest || digest;
      nextTick.queue = queue;

      // either return existing timeout or create a new one
      return timeout || (nextTick.timeout = $timeout(processQueue, 0, false));

      /**
       * Grab a copy of the current queue
       * Clear the queue for future use
       * Process the existing queue
       * Trigger digest if necessary
       */
      function processQueue() {
        var queue = nextTick.queue;
        var digest = nextTick.digest;

        nextTick.queue = [];
        nextTick.timeout = null;
        nextTick.digest = false;

        queue.forEach(function(queueItem) {
          var skip = queueItem.scope && queueItem.scope.$$destroyed;
          if (!skip) {
            queueItem.callback();
          }
        });

        if (digest) $rootScope.$digest();
      }
    },

    /**
     * Processes a template and replaces the start/end symbols if the application has
     * overridden them.
     *
     * @param template The template to process whose start/end tags may be replaced.
     * @returns {*}
     */
    processTemplate: function(template) {
      if (usesStandardSymbols) {
        return template;
      } else {
        if (!template || !angular.isString(template)) return template;
        return template.replace(/\{\{/g, startSymbol).replace(/}}/g, endSymbol);
      }
    },

    /**
     * Scan up dom hierarchy for enabled parent;
     */
    getParentWithPointerEvents: function (element) {
      var parent = element.parent();

      // jqLite might return a non-null, but still empty, parent; so check for parent and length
      while (hasComputedStyle(parent, 'pointer-events', 'none')) {
        parent = parent.parent();
      }

      return parent;
    },

    getNearestContentElement: function (element) {
      var current = element.parent()[0];
      // Look for the nearest parent md-content, stopping at the rootElement.
      while (current && current !== $rootElement[0] && current !== document.body && current.nodeName.toUpperCase() !== 'MD-CONTENT') {
        current = current.parentNode;
      }
      return current;
    },

    /**
     * Checks if the current browser is natively supporting the `sticky` position.
     * @returns {string} supported sticky property name
     */
    checkStickySupport: function() {
      var stickyProp;
      var testEl = angular.element('<div>');
      $document[0].body.appendChild(testEl[0]);

      var stickyProps = ['sticky', '-webkit-sticky'];
      for (var i = 0; i < stickyProps.length; ++i) {
        testEl.css({
          position: stickyProps[i],
          top: 0,
          'z-index': 2
        });

        if (testEl.css('position') == stickyProps[i]) {
          stickyProp = stickyProps[i];
          break;
        }
      }

      testEl.remove();

      return stickyProp;
    },

    /**
     * Parses an attribute value, mostly a string.
     * By default checks for negated values and returns `false´ if present.
     * Negated values are: (native falsy) and negative strings like:
     * `false` or `0`.
     * @param value Attribute value which should be parsed.
     * @param negatedCheck When set to false, won't check for negated values.
     * @returns {boolean}
     */
    parseAttributeBoolean: function(value, negatedCheck) {
      return value === '' || !!value && (negatedCheck === false || value !== 'false' && value !== '0');
    },

    hasComputedStyle: hasComputedStyle,

    /**
     * Returns true if the parent form of the element has been submitted.
     *
     * @param element An AngularJS or HTML5 element.
     *
     * @returns {boolean}
     */
    isParentFormSubmitted: function(element) {
      var parent = $mdUtil.getClosest(element, 'form');
      var form = parent ? angular.element(parent).controller('form') : null;

      return form ? form.$submitted : false;
    },

    /**
     * Animate the requested element's scrollTop to the requested scrollPosition with basic easing.
     *
     * @param {!Element} element The element to scroll.
     * @param {number} scrollEnd The new/final scroll position.
     * @param {number=} duration Duration of the scroll. Default is 1000ms.
     */
    animateScrollTo: function(element, scrollEnd, duration) {
      var scrollStart = element.scrollTop;
      var scrollChange = scrollEnd - scrollStart;
      var scrollingDown = scrollStart < scrollEnd;
      var startTime = $mdUtil.now();

      $$rAF(scrollChunk);

      function scrollChunk() {
        var newPosition = calculateNewPosition();

        element.scrollTop = newPosition;

        if (scrollingDown ? newPosition < scrollEnd : newPosition > scrollEnd) {
          $$rAF(scrollChunk);
        }
      }

      function calculateNewPosition() {
        var easeDuration = duration || 1000;
        var currentTime = $mdUtil.now() - startTime;

        return ease(currentTime, scrollStart, scrollChange, easeDuration);
      }

      function ease(currentTime, start, change, duration) {
        // If the duration has passed (which can occur if our app loses focus due to $$rAF), jump
        // straight to the proper position
        if (currentTime > duration) {
          return start + change;
        }

        var ts = (currentTime /= duration) * currentTime;
        var tc = ts * currentTime;

        return start + change * (-2 * tc + 3 * ts);
      }
    },

    /**
     * Provides an easy mechanism for removing duplicates from an array.
     *
     *    var myArray = [1, 2, 2, 3, 3, 3, 4, 4, 4, 4];
     *
     *    $mdUtil.uniq(myArray) => [1, 2, 3, 4]
     *
     * @param {array} array The array whose unique values should be returned.
     *
     * @returns {array} A copy of the array containing only unique values.
     */
    uniq: function(array) {
      if (!array) { return; }

      return array.filter(function(value, index, self) {
        return self.indexOf(value) === index;
      });
    },

    /**
     * Gets the inner HTML content of the given HTMLElement.
     * Only intended for use with SVG or Symbol elements in IE11.
     * @param {Element} element
     * @returns {string} the inner HTML of the element passed in
     */
    getInnerHTML: function(element) {
      // For SVG or Symbol elements, innerHTML returns `undefined` in IE.
      // Reference: https://stackoverflow.com/q/28129956/633107
      // The XMLSerializer API is supported on IE11 and is the recommended workaround.
      var serializer = new XMLSerializer();

      return Array.prototype.map.call(element.childNodes, function (child) {
        return serializer.serializeToString(child);
      }).join('');
    },

    /**
     * Gets the outer HTML content of the given HTMLElement.
     * Only intended for use with SVG or Symbol elements in IE11.
     * @param {Element} element
     * @returns {string} the outer HTML of the element passed in
     */
    getOuterHTML: function(element) {
      // For SVG or Symbol elements, outerHTML returns `undefined` in IE.
      // Reference: https://stackoverflow.com/q/29888050/633107
      // The XMLSerializer API is supported on IE11 and is the recommended workaround.
      var serializer = new XMLSerializer();
      return serializer.serializeToString(element);
    },

    /**
     * Support: IE 9-11 only
     * documentMode is an IE-only property
     * http://msdn.microsoft.com/en-us/library/ie/cc196988(v=vs.85).aspx
     */
    msie: window.document.documentMode
  };

  // Instantiate other namespace utility methods

  $mdUtil.dom.animator = $$mdAnimate($mdUtil);

  return $mdUtil;

  function getNode(el) {
    return el[0] || el;
  }
}

/*
 * Since removing jQuery from the demos, some code that uses `element.focus()` is broken.
 * We need to add `element.focus()`, because it's testable unlike `element[0].focus`.
 */

angular.element.prototype.focus = angular.element.prototype.focus || function() {
  if (this.length) {
    this[0].focus();
  }
  return this;
};
angular.element.prototype.blur = angular.element.prototype.blur || function() {
  if (this.length) {
    this[0].blur();
  }
  return this;
};

})();
(function(){
"use strict";

// Polyfill angular < 1.4 (provide $animateCss)
angular
  .module('material.core')
  .factory('$$mdAnimate', ["$q", "$timeout", "$mdConstant", "$animateCss", function($q, $timeout, $mdConstant, $animateCss){

     // Since $$mdAnimate is injected into $mdUtil... use a wrapper function
     // to subsequently inject $mdUtil as an argument to the AnimateDomUtils

     return function($mdUtil) {
       return AnimateDomUtils($mdUtil, $q, $timeout, $mdConstant, $animateCss);
     };
   }]);

/**
 * Factory function that requires special injections
 */
function AnimateDomUtils($mdUtil, $q, $timeout, $mdConstant, $animateCss) {
  var self;
  return self = {
    /**
     *
     */
    translate3d : function(target, from, to, options) {
      return $animateCss(target, {
        from: from,
        to: to,
        addClass: options.transitionInClass,
        removeClass: options.transitionOutClass,
        duration: options.duration
      })
      .start()
      .then(function(){
          // Resolve with reverser function...
          return reverseTranslate;
      });

      /**
       * Specific reversal of the request translate animation above...
       */
      function reverseTranslate (newFrom) {
        return $animateCss(target, {
           to: newFrom || from,
           addClass: options.transitionOutClass,
           removeClass: options.transitionInClass,
           duration: options.duration
        }).start();

      }
    },

    /**
     * Listen for transitionEnd event (with optional timeout)
     * Announce completion or failure via promise handlers
     */
    waitTransitionEnd: function (element, opts) {
      var TIMEOUT = 3000; // fallback is 3 secs

      return $q(function(resolve, reject){
        opts = opts || { };

        // If there is no transition is found, resolve immediately
        //
        // NOTE: using $mdUtil.nextTick() causes delays/issues
        if (noTransitionFound(opts.cachedTransitionStyles)) {
          TIMEOUT = 0;
        }

        var timer = $timeout(finished, opts.timeout || TIMEOUT);
        element.on($mdConstant.CSS.TRANSITIONEND, finished);

        /**
         * Upon timeout or transitionEnd, reject or resolve (respectively) this promise.
         * NOTE: Make sure this transitionEnd didn't bubble up from a child
         */
        function finished(ev) {
          if (ev && ev.target !== element[0]) return;

          if (ev) $timeout.cancel(timer);
          element.off($mdConstant.CSS.TRANSITIONEND, finished);

          // Never reject since ngAnimate may cause timeouts due missed transitionEnd events
          resolve();

        }

        /**
         * Checks whether or not there is a transition.
         *
         * @param styles The cached styles to use for the calculation. If null, getComputedStyle()
         * will be used.
         *
         * @returns {boolean} True if there is no transition/duration; false otherwise.
         */
        function noTransitionFound(styles) {
          styles = styles || window.getComputedStyle(element[0]);

          return styles.transitionDuration == '0s' || (!styles.transition && !styles.transitionProperty);
        }

      });
    },

    calculateTransformValues: function (element, originator) {
      var origin = originator.element;
      var bounds = originator.bounds;

      if (origin || bounds) {
        var originBnds = origin ? self.clientRect(origin) || currentBounds() : self.copyRect(bounds);
        var dialogRect = self.copyRect(element[0].getBoundingClientRect());
        var dialogCenterPt = self.centerPointFor(dialogRect);
        var originCenterPt = self.centerPointFor(originBnds);

        return {
          centerX: originCenterPt.x - dialogCenterPt.x,
          centerY: originCenterPt.y - dialogCenterPt.y,
          scaleX: Math.round(100 * Math.min(0.5, originBnds.width / dialogRect.width)) / 100,
          scaleY: Math.round(100 * Math.min(0.5, originBnds.height / dialogRect.height)) / 100
        };
      }
      return {centerX: 0, centerY: 0, scaleX: 0.5, scaleY: 0.5};

      /**
       * This is a fallback if the origin information is no longer valid, then the
       * origin bounds simply becomes the current bounds for the dialogContainer's parent
       */
      function currentBounds() {
        var cntr = element ? element.parent() : null;
        var parent = cntr ? cntr.parent() : null;

        return parent ? self.clientRect(parent) : null;
      }
    },

    /**
     * Calculate the zoom transform from dialog to origin.
     *
     * We use this to set the dialog position immediately;
     * then the md-transition-in actually translates back to
     * `translate3d(0,0,0) scale(1.0)`...
     *
     * NOTE: all values are rounded to the nearest integer
     */
    calculateZoomToOrigin: function (element, originator) {
      var zoomTemplate = "translate3d( {centerX}px, {centerY}px, 0 ) scale( {scaleX}, {scaleY} )";
      var buildZoom = angular.bind(null, $mdUtil.supplant, zoomTemplate);

      return buildZoom(self.calculateTransformValues(element, originator));
    },

    /**
     * Calculate the slide transform from panel to origin.
     * NOTE: all values are rounded to the nearest integer
     */
    calculateSlideToOrigin: function (element, originator) {
      var slideTemplate = "translate3d( {centerX}px, {centerY}px, 0 )";
      var buildSlide = angular.bind(null, $mdUtil.supplant, slideTemplate);

      return buildSlide(self.calculateTransformValues(element, originator));
    },

    /**
     * Enhance raw values to represent valid css stylings...
     */
    toCss : function(raw) {
      var css = { };
      var lookups = 'left top right bottom width height x y min-width min-height max-width max-height';

      angular.forEach(raw, function(value,key) {
        if (angular.isUndefined(value)) return;

        if (lookups.indexOf(key) >= 0) {
          css[key] = value + 'px';
        } else {
          switch (key) {
            case 'transition':
              convertToVendor(key, $mdConstant.CSS.TRANSITION, value);
              break;
            case 'transform':
              convertToVendor(key, $mdConstant.CSS.TRANSFORM, value);
              break;
            case 'transformOrigin':
              convertToVendor(key, $mdConstant.CSS.TRANSFORM_ORIGIN, value);
              break;
            case 'font-size':
              css['font-size'] = value; // font sizes aren't always in px
              break;
          }
        }
      });

      return css;

      function convertToVendor(key, vendor, value) {
        angular.forEach(vendor.split(' '), function (key) {
          css[key] = value;
        });
      }
    },

    /**
     * Convert the translate CSS value to key/value pair(s).
     */
    toTransformCss: function (transform, addTransition, transition) {
      var css = {};
      angular.forEach($mdConstant.CSS.TRANSFORM.split(' '), function (key) {
        css[key] = transform;
      });

      if (addTransition) {
        transition = transition || "all 0.4s cubic-bezier(0.25, 0.8, 0.25, 1) !important";
        css.transition = transition;
      }

      return css;
    },

    /**
     *  Clone the Rect and calculate the height/width if needed
     */
    copyRect: function (source, destination) {
      if (!source) return null;

      destination = destination || {};

      angular.forEach('left top right bottom width height'.split(' '), function (key) {
        destination[key] = Math.round(source[key]);
      });

      destination.width = destination.width || (destination.right - destination.left);
      destination.height = destination.height || (destination.bottom - destination.top);

      return destination;
    },

    /**
     * Calculate ClientRect of element; return null if hidden or zero size
     */
    clientRect: function (element) {
      var bounds = angular.element(element)[0].getBoundingClientRect();
      var isPositiveSizeClientRect = function (rect) {
        return rect && (rect.width > 0) && (rect.height > 0);
      };

      // If the event origin element has zero size, it has probably been hidden.
      return isPositiveSizeClientRect(bounds) ? self.copyRect(bounds) : null;
    },

    /**
     *  Calculate 'rounded' center point of Rect
     */
    centerPointFor: function (targetRect) {
      return targetRect ? {
        x: Math.round(targetRect.left + (targetRect.width / 2)),
        y: Math.round(targetRect.top + (targetRect.height / 2))
      } : { x : 0, y : 0 };
    }

  };
}


})();
(function(){
"use strict";

if (angular.version.minor >= 4) {
  angular.module('material.core.animate', []);
} else {
(function() {
  "use strict";

  var forEach = angular.forEach;

  var WEBKIT = angular.isDefined(document.documentElement.style.WebkitAppearance);
  var TRANSITION_PROP = WEBKIT ? 'WebkitTransition' : 'transition';
  var ANIMATION_PROP = WEBKIT ? 'WebkitAnimation' : 'animation';
  var PREFIX = WEBKIT ? '-webkit-' : '';

  var TRANSITION_EVENTS = (WEBKIT ? 'webkitTransitionEnd ' : '') + 'transitionend';
  var ANIMATION_EVENTS = (WEBKIT ? 'webkitAnimationEnd ' : '') + 'animationend';

  var $$ForceReflowFactory = ['$document', function($document) {
    return function() {
      return $document[0].body.clientWidth + 1;
    };
  }];

  var $$rAFMutexFactory = ['$$rAF', function($$rAF) {
    return function() {
      var passed = false;
      $$rAF(function() {
        passed = true;
      });
      return function(fn) {
        passed ? fn() : $$rAF(fn);
      };
    };
  }];

  var $$AnimateRunnerFactory = ['$q', '$$rAFMutex', function($q, $$rAFMutex) {
    var INITIAL_STATE = 0;
    var DONE_PENDING_STATE = 1;
    var DONE_COMPLETE_STATE = 2;

    function AnimateRunner(host) {
      this.setHost(host);

      this._doneCallbacks = [];
      this._runInAnimationFrame = $$rAFMutex();
      this._state = 0;
    }

    AnimateRunner.prototype = {
      setHost: function(host) {
        this.host = host || {};
      },

      done: function(fn) {
        if (this._state === DONE_COMPLETE_STATE) {
          fn();
        } else {
          this._doneCallbacks.push(fn);
        }
      },

      progress: angular.noop,

      getPromise: function() {
        if (!this.promise) {
          var self = this;
          this.promise = $q(function(resolve, reject) {
            self.done(function(status) {
              status === false ? reject() : resolve();
            });
          });
        }
        return this.promise;
      },

      then: function(resolveHandler, rejectHandler) {
        return this.getPromise().then(resolveHandler, rejectHandler);
      },

      'catch': function(handler) {
        return this.getPromise()['catch'](handler);
      },

      'finally': function(handler) {
        return this.getPromise()['finally'](handler);
      },

      pause: function() {
        if (this.host.pause) {
          this.host.pause();
        }
      },

      resume: function() {
        if (this.host.resume) {
          this.host.resume();
        }
      },

      end: function() {
        if (this.host.end) {
          this.host.end();
        }
        this._resolve(true);
      },

      cancel: function() {
        if (this.host.cancel) {
          this.host.cancel();
        }
        this._resolve(false);
      },

      complete: function(response) {
        var self = this;
        if (self._state === INITIAL_STATE) {
          self._state = DONE_PENDING_STATE;
          self._runInAnimationFrame(function() {
            self._resolve(response);
          });
        }
      },

      _resolve: function(response) {
        if (this._state !== DONE_COMPLETE_STATE) {
          forEach(this._doneCallbacks, function(fn) {
            fn(response);
          });
          this._doneCallbacks.length = 0;
          this._state = DONE_COMPLETE_STATE;
        }
      }
    };

    // Polyfill AnimateRunner.all which is used by input animations
    AnimateRunner.all = function(runners, callback) {
      var count = 0;
      var status = true;
      forEach(runners, function(runner) {
        runner.done(onProgress);
      });

      function onProgress(response) {
        status = status && response;
        if (++count === runners.length) {
          callback(status);
        }
      }
    };

    return AnimateRunner;
  }];

  angular
    .module('material.core.animate', [])
    .factory('$$forceReflow', $$ForceReflowFactory)
    .factory('$$AnimateRunner', $$AnimateRunnerFactory)
    .factory('$$rAFMutex', $$rAFMutexFactory)
    .factory('$animateCss', ['$window', '$$rAF', '$$AnimateRunner', '$$forceReflow', '$$jqLite', '$timeout', '$animate',
                     function($window,   $$rAF,   $$AnimateRunner,   $$forceReflow,   $$jqLite,   $timeout, $animate) {

      function init(element, options) {

        var temporaryStyles = [];
        var node = getDomNode(element);
        var areAnimationsAllowed = node && $animate.enabled();

        var hasCompleteStyles = false;
        var hasCompleteClasses = false;

        if (areAnimationsAllowed) {
          if (options.transitionStyle) {
            temporaryStyles.push([PREFIX + 'transition', options.transitionStyle]);
          }

          if (options.keyframeStyle) {
            temporaryStyles.push([PREFIX + 'animation', options.keyframeStyle]);
          }

          if (options.delay) {
            temporaryStyles.push([PREFIX + 'transition-delay', options.delay + 's']);
          }

          if (options.duration) {
            temporaryStyles.push([PREFIX + 'transition-duration', options.duration + 's']);
          }

          hasCompleteStyles = options.keyframeStyle ||
              (options.to && (options.duration > 0 || options.transitionStyle));
          hasCompleteClasses = !!options.addClass || !!options.removeClass;

          blockTransition(element, true);
        }

        var hasCompleteAnimation = areAnimationsAllowed && (hasCompleteStyles || hasCompleteClasses);

        applyAnimationFromStyles(element, options);

        var animationClosed = false;
        var events, eventFn;

        return {
          close: $window.close,
          start: function() {
            var runner = new $$AnimateRunner();
            waitUntilQuiet(function() {
              blockTransition(element, false);
              if (!hasCompleteAnimation) {
                return close();
              }

              forEach(temporaryStyles, function(entry) {
                var key = entry[0];
                var value = entry[1];
                node.style[camelCase(key)] = value;
              });

              applyClasses(element, options);

              var timings = computeTimings(element);
              if (timings.duration === 0) {
                return close();
              }

              var moreStyles = [];

              if (options.easing) {
                if (timings.transitionDuration) {
                  moreStyles.push([PREFIX + 'transition-timing-function', options.easing]);
                }
                if (timings.animationDuration) {
                  moreStyles.push([PREFIX + 'animation-timing-function', options.easing]);
                }
              }

              if (options.delay && timings.animationDelay) {
                moreStyles.push([PREFIX + 'animation-delay', options.delay + 's']);
              }

              if (options.duration && timings.animationDuration) {
                moreStyles.push([PREFIX + 'animation-duration', options.duration + 's']);
              }

              forEach(moreStyles, function(entry) {
                var key = entry[0];
                var value = entry[1];
                node.style[camelCase(key)] = value;
                temporaryStyles.push(entry);
              });

              var maxDelay = timings.delay;
              var maxDelayTime = maxDelay * 1000;
              var maxDuration = timings.duration;
              var maxDurationTime = maxDuration * 1000;
              var startTime = Date.now();

              events = [];
              if (timings.transitionDuration) {
                events.push(TRANSITION_EVENTS);
              }
              if (timings.animationDuration) {
                events.push(ANIMATION_EVENTS);
              }
              events = events.join(' ');
              eventFn = function(event) {
                event.stopPropagation();
                var ev = event.originalEvent || event;
                var timeStamp = ev.timeStamp || Date.now();
                var elapsedTime = parseFloat(ev.elapsedTime.toFixed(3));
                if (Math.max(timeStamp - startTime, 0) >= maxDelayTime && elapsedTime >= maxDuration) {
                  close();
                }
              };
              element.on(events, eventFn);

              applyAnimationToStyles(element, options);

              $timeout(close, maxDelayTime + maxDurationTime * 1.5, false);
            });

            return runner;

            function close() {
              if (animationClosed) return;
              animationClosed = true;

              if (events && eventFn) {
                element.off(events, eventFn);
              }
              applyClasses(element, options);
              applyAnimationStyles(element, options);
              forEach(temporaryStyles, function(entry) {
                node.style[camelCase(entry[0])] = '';
              });
              runner.complete(true);
              return runner;
            }
          }
        };
      }

      function applyClasses(element, options) {
        if (options.addClass) {
          $$jqLite.addClass(element, options.addClass);
          options.addClass = null;
        }
        if (options.removeClass) {
          $$jqLite.removeClass(element, options.removeClass);
          options.removeClass = null;
        }
      }

      function computeTimings(element) {
        var node = getDomNode(element);
        var cs = $window.getComputedStyle(node);
        var tdr = parseMaxTime(cs[prop('transitionDuration')]);
        var adr = parseMaxTime(cs[prop('animationDuration')]);
        var tdy = parseMaxTime(cs[prop('transitionDelay')]);
        var ady = parseMaxTime(cs[prop('animationDelay')]);

        adr *= (parseInt(cs[prop('animationIterationCount')], 10) || 1);
        var duration = Math.max(adr, tdr);
        var delay = Math.max(ady, tdy);

        return {
          duration: duration,
          delay: delay,
          animationDuration: adr,
          transitionDuration: tdr,
          animationDelay: ady,
          transitionDelay: tdy
        };

        function prop(key) {
          return WEBKIT ? 'Webkit' + key.charAt(0).toUpperCase() + key.substr(1)
                        : key;
        }
      }

      function parseMaxTime(str) {
        var maxValue = 0;
        var values = (str || "").split(/\s*,\s*/);
        forEach(values, function(value) {
          // it's always safe to consider only second values and omit `ms` values since
          // getComputedStyle will always handle the conversion for us
          if (value.charAt(value.length - 1) == 's') {
            value = value.substring(0, value.length - 1);
          }
          value = parseFloat(value) || 0;
          maxValue = maxValue ? Math.max(value, maxValue) : value;
        });
        return maxValue;
      }

      var cancelLastRAFRequest;
      var rafWaitQueue = [];
      function waitUntilQuiet(callback) {
        if (cancelLastRAFRequest) {
          cancelLastRAFRequest(); // cancels the request
        }
        rafWaitQueue.push(callback);
        cancelLastRAFRequest = $$rAF(function() {
          cancelLastRAFRequest = null;

          // DO NOT REMOVE THIS LINE OR REFACTOR OUT THE `pageWidth` variable.
          // PLEASE EXAMINE THE `$$forceReflow` service to understand why.
          var pageWidth = $$forceReflow();

          // we use a for loop to ensure that if the queue is changed
          // during this looping then it will consider new requests
          for (var i = 0; i < rafWaitQueue.length; i++) {
            rafWaitQueue[i](pageWidth);
          }
          rafWaitQueue.length = 0;
        });
      }

      function applyAnimationStyles(element, options) {
        applyAnimationFromStyles(element, options);
        applyAnimationToStyles(element, options);
      }

      function applyAnimationFromStyles(element, options) {
        if (options.from) {
          element.css(options.from);
          options.from = null;
        }
      }

      function applyAnimationToStyles(element, options) {
        if (options.to) {
          element.css(options.to);
          options.to = null;
        }
      }

      function getDomNode(element) {
        for (var i = 0; i < element.length; i++) {
          if (element[i].nodeType === 1) return element[i];
        }
      }

      function blockTransition(element, bool) {
        var node = getDomNode(element);
        var key = camelCase(PREFIX + 'transition-delay');
        node.style[key] = bool ? '-9999s' : '';
      }

      return init;
    }]);

  /**
   * Older browsers [FF31] expect camelCase
   * property keys.
   * e.g.
   *  animation-duration --> animationDuration
   */
  function camelCase(str) {
    return str.replace(/-[a-z]/g, function(str) {
      return str.charAt(1).toUpperCase();
    });
  }

})();

}

})();
(function(){
"use strict";

/**
 * @ngdoc module
 * @name material.core.aria
 * @description
 * Aria Expectations for AngularJS Material components.
 */
MdAriaService.$inject = ["$$rAF", "$log", "$window", "$interpolate"];
angular
  .module('material.core')
  .provider('$mdAria', MdAriaProvider);

/**
 * @ngdoc service
 * @name $mdAriaProvider
 * @module material.core.aria
 *
 * @description
 *
 * Modify options of the `$mdAria` service, which will be used by most of the AngularJS Material
 * components.
 *
 * You are able to disable `$mdAria` warnings, by using the following markup.
 *
 * <hljs lang="js">
 *   app.config(function($mdAriaProvider) {
 *     // Globally disables all ARIA warnings.
 *     $mdAriaProvider.disableWarnings();
 *   });
 * </hljs>
 *
 */
function MdAriaProvider() {

  var config = {
    /** Whether we should show ARIA warnings in the console if labels are missing on the element */
    showWarnings: true
  };

  return {
    disableWarnings: disableWarnings,
    $get: ["$$rAF", "$log", "$window", "$interpolate", function($$rAF, $log, $window, $interpolate) {
      return MdAriaService.apply(config, arguments);
    }]
  };

  /**
   * @ngdoc method
   * @name $mdAriaProvider#disableWarnings
   * @description Disables all ARIA warnings generated by AngularJS Material.
   */
  function disableWarnings() {
    config.showWarnings = false;
  }
}

/*
 * @ngInject
 */
function MdAriaService($$rAF, $log, $window, $interpolate) {

  // Load the showWarnings option from the current context and store it inside of a scope variable,
  // because the context will be probably lost in some function calls.
  var showWarnings = this.showWarnings;

  return {
    expect: expect,
    expectAsync: expectAsync,
    expectWithText: expectWithText,
    expectWithoutText: expectWithoutText,
    getText: getText,
    hasAriaLabel: hasAriaLabel,
    parentHasAriaLabel: parentHasAriaLabel
  };

  /**
   * Check if expected attribute has been specified on the target element or child
   * @param element
   * @param attrName
   * @param {optional} defaultValue What to set the attr to if no value is found
   */
  function expect(element, attrName, defaultValue) {

    var node = angular.element(element)[0] || element;

    // if node exists and neither it nor its children have the attribute
    if (node &&
       ((!node.hasAttribute(attrName) ||
        node.getAttribute(attrName).length === 0) &&
        !childHasAttribute(node, attrName))) {

      defaultValue = angular.isString(defaultValue) ? defaultValue.trim() : '';
      if (defaultValue.length) {
        element.attr(attrName, defaultValue);
      } else if (showWarnings) {
        $log.warn('ARIA: Attribute "', attrName, '", required for accessibility, is missing on node:', node);
      }

    }
  }

  function expectAsync(element, attrName, defaultValueGetter) {
    // Problem: when retrieving the element's contents synchronously to find the label,
    // the text may not be defined yet in the case of a binding.
    // There is a higher chance that a binding will be defined if we wait one frame.
    $$rAF(function() {
        expect(element, attrName, defaultValueGetter());
    });
  }

  function expectWithText(element, attrName) {
    var content = getText(element) || "";
    var hasBinding = content.indexOf($interpolate.startSymbol()) > -1;

    if (hasBinding) {
      expectAsync(element, attrName, function() {
        return getText(element);
      });
    } else {
      expect(element, attrName, content);
    }
  }

  function expectWithoutText(element, attrName) {
    var content = getText(element);
    var hasBinding = content.indexOf($interpolate.startSymbol()) > -1;

    if (!hasBinding && !content) {
      expect(element, attrName, content);
    }
  }

  function getText(element) {
    element = element[0] || element;
    var walker = document.createTreeWalker(element, NodeFilter.SHOW_TEXT, null, false);
    var text = '';

    var node;
    while (node = walker.nextNode()) {
      if (!isAriaHiddenNode(node)) {
        text += node.textContent;
      }
    }

    return text.trim() || '';

    function isAriaHiddenNode(node) {
      while (node.parentNode && (node = node.parentNode) !== element) {
        if (node.getAttribute && node.getAttribute('aria-hidden') === 'true') {
          return true;
        }
      }
    }
  }

  function childHasAttribute(node, attrName) {
    var hasChildren = node.hasChildNodes(),
        hasAttr = false;

    function isHidden(el) {
      var style = el.currentStyle ? el.currentStyle : $window.getComputedStyle(el);
      return (style.display === 'none');
    }

    if (hasChildren) {
      var children = node.childNodes;
      for (var i=0; i < children.length; i++) {
        var child = children[i];
        if (child.nodeType === 1 && child.hasAttribute(attrName)) {
          if (!isHidden(child)) {
            hasAttr = true;
          }
        }
      }
    }
    return hasAttr;
  }

  /**
   * Check if expected element has aria label attribute
   * @param element
   */
  function hasAriaLabel(element) {
    var node = angular.element(element)[0] || element;

    /* Check if compatible node type (ie: not HTML Document node) */
    if (!node.hasAttribute) {
      return false;
    }

    /* Check label or description attributes */
    return node.hasAttribute('aria-label') || node.hasAttribute('aria-labelledby') || node.hasAttribute('aria-describedby');
  }

  /**
   * Check if expected element's parent has aria label attribute and has valid role and tagName
   * @param element
   * @param {optional} level Number of levels deep search should be performed
   */
  function parentHasAriaLabel(element, level) {
    level = level || 1;
    var node = angular.element(element)[0] || element;
    if (!node.parentNode) {
      return false;
    }
    if (performCheck(node.parentNode)) {
      return true;
    }
    level--;
    if (level) {
      return parentHasAriaLabel(node.parentNode, level);
    }
    return false;

    function performCheck(parentNode) {
      if (!hasAriaLabel(parentNode)) {
        return false;
      }
      /* Perform role blacklist check */
      if (parentNode.hasAttribute('role')) {
        switch (parentNode.getAttribute('role').toLowerCase()) {
          case 'command':
          case 'definition':
          case 'directory':
          case 'grid':
          case 'list':
          case 'listitem':
          case 'log':
          case 'marquee':
          case 'menu':
          case 'menubar':
          case 'note':
          case 'presentation':
          case 'separator':
          case 'scrollbar':
          case 'status':
          case 'tablist':
            return false;
        }
      }
      /* Perform tagName blacklist check */
      switch (parentNode.tagName.toLowerCase()) {
        case 'abbr':
        case 'acronym':
        case 'address':
        case 'applet':
        case 'audio':
        case 'b':
        case 'bdi':
        case 'bdo':
        case 'big':
        case 'blockquote':
        case 'br':
        case 'canvas':
        case 'caption':
        case 'center':
        case 'cite':
        case 'code':
        case 'col':
        case 'data':
        case 'dd':
        case 'del':
        case 'dfn':
        case 'dir':
        case 'div':
        case 'dl':
        case 'em':
        case 'embed':
        case 'fieldset':
        case 'figcaption':
        case 'font':
        case 'h1':
        case 'h2':
        case 'h3':
        case 'h4':
        case 'h5':
        case 'h6':
        case 'hgroup':
        case 'html':
        case 'i':
        case 'ins':
        case 'isindex':
        case 'kbd':
        case 'keygen':
        case 'label':
        case 'legend':
        case 'li':
        case 'map':
        case 'mark':
        case 'menu':
        case 'object':
        case 'ol':
        case 'output':
        case 'pre':
        case 'presentation':
        case 'q':
        case 'rt':
        case 'ruby':
        case 'samp':
        case 'small':
        case 'source':
        case 'span':
        case 'status':
        case 'strike':
        case 'strong':
        case 'sub':
        case 'sup':
        case 'svg':
        case 'tbody':
        case 'td':
        case 'th':
        case 'thead':
        case 'time':
        case 'tr':
        case 'track':
        case 'tt':
        case 'ul':
        case 'var':
          return false;
      }
      return true;
    }
  }
}

})();
(function(){
"use strict";

/**
 * @ngdoc module
 * @name material.core.compiler
 * @description
 * AngularJS Material template and element compiler.
 */
angular
  .module('material.core')
  .provider('$mdCompiler', MdCompilerProvider);

/**
 * @ngdoc service
 * @name $mdCompilerProvider
 * @module material.core.compiler
 * @description
 * The `$mdCompiler` is able to respect the AngularJS `$compileProvider.preAssignBindingsEnabled`
 * state when using AngularJS versions greater than or equal to 1.5.10 and less than 1.7.0.
 * See the [AngularJS documentation for `$compileProvider.preAssignBindingsEnabled`
 * ](https://code.angularjs.org/1.6.10/docs/api/ng/provider/$compileProvider#preAssignBindingsEnabled)
 * for more information.
 *
 * To enable/disable whether the controllers of dynamic AngularJS Material components
 * (i.e. dialog, panel, toast, bottomsheet) respect the AngularJS
 * `$compileProvider.preAssignBindingsEnabled` flag, call the AngularJS Material method:
 * `$mdCompilerProvider.respectPreAssignBindingsEnabled(boolean)`.
 *
 * This AngularJS Material *flag* doesn't affect directives/components created via regular
 * AngularJS methods. These constitute the majority of AngularJS Material and user-created
 * components. Only dynamic construction of elements such as Dialogs, Panels, Toasts, BottomSheets,
 * etc. may be affected. Invoking `$mdCompilerProvider.respectPreAssignBindingsEnabled(true)`
 * will effect **bindings** in controllers created by AngularJS Material's services like
 * `$mdDialog`, `$mdPanel`, `$mdToast`, or `$mdBottomSheet`.
 *
 * See [$mdCompilerProvider.respectPreAssignBindingsEnabled](#mdcompilerprovider-respectpreassignbindingsenabled-respected)
 * for the details of how the different versions and settings of AngularJS affect this behavior.
 *
 * @usage
 *
 * Respect the AngularJS Compiler Setting
 *
 * <hljs lang="js">
 *   app.config(function($mdCompilerProvider) {
 *     $mdCompilerProvider.respectPreAssignBindingsEnabled(true);
 *   });
 * </hljs>
 *
 * @example
 * Using the default (backwards compatible) values for AngularJS 1.6
 * - AngularJS' `$compileProvider.preAssignBindingsEnabled(false)`
 * - AngularJS Material's `$mdCompilerProvider.respectPreAssignBindingsEnabled(false)`
 * <br><br>
 *
 * <hljs lang="js">
 * $mdDialog.show({
 *   locals: {
 *     myVar: true
 *   },
 *   controller: MyController,
 *   bindToController: true
 * }
 *
 * function MyController() {
 *   // Locals from Angular Material are available. e.g myVar is true.
 * }
 *
 * MyController.prototype.$onInit = function() {
 *   // Bindings are also available in the $onInit lifecycle hook.
 * }
 * </hljs>
 *
 * Recommended Settings for AngularJS 1.6
 * - AngularJS' `$compileProvider.preAssignBindingsEnabled(false)`
 * - AngularJS Material's `$mdCompilerProvider.respectPreAssignBindingsEnabled(true)`
 * <br><br>
 *
 * <hljs lang="js">
 * $mdDialog.show({
 *   locals: {
 *     myVar: true
 *   },
 *   controller: MyController,
 *   bindToController: true
 * }
 *
 * function MyController() {
 *   // No locals from Angular Material are available. e.g myVar is undefined.
 * }
 *
 * MyController.prototype.$onInit = function() {
 *   // Bindings are now available in the $onInit lifecycle hook.
 * }
 * </hljs>
 *
 */
MdCompilerProvider.$inject = ['$compileProvider'];
function MdCompilerProvider($compileProvider) {

  var provider = this;

  /**
   * @ngdoc method
   * @name $mdCompilerProvider#respectPreAssignBindingsEnabled
   *
   * @param {boolean=} respected update the `respectPreAssignBindingsEnabled` state if provided,
   *  otherwise just return the current Material `respectPreAssignBindingsEnabled` state.
   * @returns {boolean|MdCompilerProvider} current value, if used as a getter, or itself (chaining)
   *  if used as a setter.
   *
   * @description
   * Call this method to enable/disable whether Material-specific (dialog/panel/toast/bottomsheet)
   * controllers respect the AngularJS `$compileProvider.preAssignBindingsEnabled` flag. Note that
   * this doesn't affect directives/components created via regular AngularJS methods which
   * constitute most Material and user-created components.
   *
   * If disabled (`false`), the compiler assigns the value of each of the bindings to the
   * properties of the controller object before the constructor of this object is called.
   * The ability to disable this settings is **deprecated** and will be removed in
   * AngularJS Material 1.2.0.
   *
   * If enabled (`true`) the behavior depends on the AngularJS version used:
   *
   * - `<1.5.10`
   *  - Bindings are pre-assigned.
   * - `>=1.5.10 <1.7`
   *  - Respects whatever `$compileProvider.preAssignBindingsEnabled()` reports. If the
   *    `preAssignBindingsEnabled` flag wasn't set manually, it defaults to pre-assigning bindings
   *    with AngularJS `1.5` and to calling the constructor first with AngularJS `1.6`.
   * - `>=1.7`
   *  - The compiler calls the constructor first before assigning bindings and
   *    `$compileProvider.preAssignBindingsEnabled()` no longer exists.
   *
   * Defaults
   * - The default value is `false` in AngularJS 1.6 and earlier.
   *  - It is planned to fix this value to `true` and not allow the `false` value in
   *    AngularJS Material 1.2.0.
   *
   * It is recommended to set this flag to `true` when using AngularJS Material 1.1.x with
   * AngularJS versions >= 1.5.10. The only reason it's not set that way by default is backwards
   * compatibility.
   *
   * By not setting the flag to `true` when AngularJS' `$compileProvider.preAssignBindingsEnabled()`
   * is set to `false` (i.e. default behavior in AngularJS 1.6 or newer), unit testing of
   * Material Dialog/Panel/Toast/BottomSheet controllers using the `$controller` helper
   * is problematic as it always follows AngularJS' `$compileProvider.preAssignBindingsEnabled()`
   * value.
   */
  var respectPreAssignBindingsEnabled = false;
  this.respectPreAssignBindingsEnabled = function(respected) {
    if (angular.isDefined(respected)) {
      respectPreAssignBindingsEnabled = respected;
      return this;
    }

    return respectPreAssignBindingsEnabled;
  };

  /**
   * @private
   * @description
   * This function returns `true` if AngularJS Material-specific (dialog/panel/toast/bottomsheet)
   * controllers have bindings pre-assigned in controller constructors and `false` otherwise.
   *
   * Note that this doesn't affect directives/components created via regular AngularJS methods
   * which constitute most Material and user-created components; their behavior can be checked via
   * `$compileProvider.preAssignBindingsEnabled()` in AngularJS `>=1.5.10 <1.7.0`.
   *
   * @returns {*} current preAssignBindingsEnabled state
   */
  function getPreAssignBindingsEnabled() {
    if (!respectPreAssignBindingsEnabled) {
      // respectPreAssignBindingsEnabled === false
      // We're ignoring the AngularJS `$compileProvider.preAssignBindingsEnabled()` value in this case.
      return true;
    }

    // respectPreAssignBindingsEnabled === true

    // This check is needed because $compileProvider.preAssignBindingsEnabled does not exist prior
    // to AngularJS 1.5.10, is deprecated in AngularJS 1.6.x, and removed in AngularJS 1.7.x.
    if (typeof $compileProvider.preAssignBindingsEnabled === 'function') {
      return $compileProvider.preAssignBindingsEnabled();
    }

    // Flag respected but not present => apply logic based on AngularJS version used.
    if (angular.version.major === 1 && angular.version.minor < 6) {
      // AngularJS <1.5.10
      return true;
    }

    // AngularJS >=1.7.0
    return false;
  }

  this.$get = ["$q", "$templateRequest", "$injector", "$compile", "$controller",
    function($q, $templateRequest, $injector, $compile, $controller) {
      return new MdCompilerService($q, $templateRequest, $injector, $compile, $controller);
    }];

  /**
   * @ngdoc service
   * @name $mdCompiler
   * @module material.core.compiler
   * @description
   * The $mdCompiler service is an abstraction of AngularJS's compiler, that allows developers
   * to easily compile an element with options like in a Directive Definition Object.
   *
   * > The compiler powers a lot of components inside of AngularJS Material.
   * > Like the `$mdPanel` or `$mdDialog`.
   *
   * @usage
   *
   * Basic Usage with a template
   *
   * <hljs lang="js">
   *   $mdCompiler.compile({
   *     templateUrl: 'modal.html',
   *     controller: 'ModalCtrl',
   *     locals: {
   *       modal: myModalInstance;
   *     }
   *   }).then(function (compileData) {
   *     compileData.element; // Compiled DOM element
   *     compileData.link(myScope); // Instantiate controller and link element to scope.
   *   });
   * </hljs>
   *
   * Example with a content element
   *
   * <hljs lang="js">
   *
   *   // Create a virtual element and link it manually.
   *   // The compiler doesn't need to recompile the element each time.
   *   var myElement = $compile('<span>Test</span>')(myScope);
   *
   *   $mdCompiler.compile({
   *     contentElement: myElement
   *   }).then(function (compileData) {
   *     compileData.element // Content Element (same as above)
   *     compileData.link // This does nothing when using a contentElement.
   *   });
   * </hljs>
   *
   * > Content Element is a significant performance improvement when the developer already knows that the
   * > compiled element will be always the same and the scope will not change either.
   *
   * The `contentElement` option also supports DOM elements which will be temporary removed and restored
   * at its old position.
   *
   * <hljs lang="js">
   *   var domElement = document.querySelector('#myElement');
   *
   *   $mdCompiler.compile({
   *     contentElement: myElement
   *   }).then(function (compileData) {
   *     compileData.element // Content Element (same as above)
   *     compileData.link // This does nothing when using a contentElement.
   *   });
   * </hljs>
   *
   * The `$mdCompiler` can also query for the element in the DOM itself.
   *
   * <hljs lang="js">
   *   $mdCompiler.compile({
   *     contentElement: '#myElement'
   *   }).then(function (compileData) {
   *     compileData.element // Content Element (same as above)
   *     compileData.link // This does nothing when using a contentElement.
   *   });
   * </hljs>
   *
   */
  function MdCompilerService($q, $templateRequest, $injector, $compile, $controller) {

    /** @private @const {!angular.$q} */
    this.$q = $q;

    /** @private @const {!angular.$templateRequest} */
    this.$templateRequest = $templateRequest;

    /** @private @const {!angular.$injector} */
    this.$injector = $injector;

    /** @private @const {!angular.$compile} */
    this.$compile = $compile;

    /** @private @const {!angular.$controller} */
    this.$controller = $controller;
  }

  /**
   * @ngdoc method
   * @name $mdCompiler#compile
   * @description
   *
   * A method to compile a HTML template with the AngularJS compiler.
   * The `$mdCompiler` is wrapper around the AngularJS compiler and provides extra functionality
   * like controller instantiation or async resolves.
   *
   * @param {!Object} options An options object, with the following properties:
   *
   *    - `controller` - `{string|function}` Controller fn that should be associated with
   *         newly created scope or the name of a registered controller if passed as a string.
   *    - `controllerAs` - `{string=}` A controller alias name. If present the controller will be
   *         published to scope under the `controllerAs` name.
   *    - `contentElement` - `{string|Element}`: Instead of using a template, which will be
   *         compiled each time, you can also use a DOM element.<br/>
   *    - `template` - `{string=}` An html template as a string.
   *    - `templateUrl` - `{string=}` A path to an html template.
   *    - `transformTemplate` - `{function(template)=}` A function which transforms the template after
   *        it is loaded. It will be given the template string as a parameter, and should
   *        return a a new string representing the transformed template.
   *    - `resolve` - `{Object.<string, function>=}` - An optional map of dependencies which should
   *        be injected into the controller. If any of these dependencies are promises, the compiler
   *        will wait for them all to be resolved, or if one is rejected before the controller is
   *        instantiated `compile()` will fail..
   *      * `key` - `{string}`: a name of a dependency to be injected into the controller.
   *      * `factory` - `{string|function}`: If `string` then it is an alias for a service.
   *        Otherwise if function, then it is injected and the return value is treated as the
   *        dependency. If the result is a promise, it is resolved before its value is
   *        injected into the controller.
   *
   * @returns {Object} promise A promise, which will be resolved with a `compileData` object.
   * `compileData` has the following properties:
   *
   *   - `element` - `{Element}`: an uncompiled element matching the provided template.
   *   - `link` - `{function(scope)}`: A link function, which, when called, will compile
   *     the element and instantiate the provided controller (if given).
   *   - `locals` - `{Object}`: The locals which will be passed into the controller once `link` is
   *     called. If `bindToController` is true, they will be copied to the ctrl instead
   */
  MdCompilerService.prototype.compile = function(options) {

    if (options.contentElement) {
      return this._prepareContentElement(options);
    } else {
      return this._compileTemplate(options);
    }

  };

  /**
   * Instead of compiling any template, the compiler just fetches an existing HTML element from the DOM and
   * provides a restore function to put the element back it old DOM position.
   * @param {!Object} options Options to be used for the compiler.
   */
  MdCompilerService.prototype._prepareContentElement = function(options) {

    var contentElement = this._fetchContentElement(options);

    return this.$q.resolve({
      element: contentElement.element,
      cleanup: contentElement.restore,
      locals: {},
      link: function() {
        return contentElement.element;
      }
    });

  };

  /**
   * Compiles a template by considering all options and waiting for all resolves to be ready.
   * @param {!Object} options Compile options
   * @returns {!Object} Compile data with link function.
   */
  MdCompilerService.prototype._compileTemplate = function(options) {

    var self = this;
    var templateUrl = options.templateUrl;
    var template = options.template || '';
    var resolve = angular.extend({}, options.resolve);
    var locals = angular.extend({}, options.locals);
    var transformTemplate = options.transformTemplate || angular.identity;

    // Take resolve values and invoke them.
    // Resolves can either be a string (value: 'MyRegisteredAngularConst'),
    // or an invokable 'factory' of sorts: (value: function ValueGetter($dependency) {})
    angular.forEach(resolve, function(value, key) {
      if (angular.isString(value)) {
        resolve[key] = self.$injector.get(value);
      } else {
        resolve[key] = self.$injector.invoke(value);
      }
    });

    // Add the locals, which are just straight values to inject
    // eg locals: { three: 3 }, will inject three into the controller
    angular.extend(resolve, locals);

    if (templateUrl) {
      resolve.$$ngTemplate = this.$templateRequest(templateUrl);
    } else {
      resolve.$$ngTemplate = this.$q.when(template);
    }


    // Wait for all the resolves to finish if they are promises
    return this.$q.all(resolve).then(function(locals) {

      var template = transformTemplate(locals.$$ngTemplate, options);
      var element = options.element || angular.element('<div>').html(template.trim()).contents();

      return self._compileElement(locals, element, options);
    });

  };

  /**
   * Method to compile an element with the given options.
   * @param {!Object} locals Locals to be injected to the controller if present
   * @param {!JQLite} element Element to be compiled and linked
   * @param {!Object} options Options to be used for linking.
   * @returns {!Object} Compile data with link function.
   */
  MdCompilerService.prototype._compileElement = function(locals, element, options) {
    var self = this;
    var ngLinkFn = this.$compile(element);

    var compileData = {
      element: element,
      cleanup: element.remove.bind(element),
      locals: locals,
      link: linkFn
    };

    function linkFn(scope) {
      locals.$scope = scope;

      // Instantiate controller if the developer provided one.
      if (options.controller) {

        var injectLocals = angular.extend({}, locals, {
          $element: element
        });

        // Create the specified controller instance.
        var ctrl = self._createController(options, injectLocals, locals);

        // Unique identifier for AngularJS Route ngView controllers.
        element.data('$ngControllerController', ctrl);
        element.children().data('$ngControllerController', ctrl);

        // Expose the instantiated controller to the compile data
        compileData.controller = ctrl;
      }

      // Invoke the AngularJS $compile link function.
      return ngLinkFn(scope);
    }

    return compileData;

  };

  /**
   * Creates and instantiates a new controller with the specified options.
   * @param {!Object} options Options that include the controller function or string.
   * @param {!Object} injectLocals Locals to to be provided in the controller DI.
   * @param {!Object} locals Locals to be injected to the controller.
   * @returns {!Object} Created controller instance.
   */
  MdCompilerService.prototype._createController = function(options, injectLocals, locals) {
    var ctrl;
    var preAssignBindingsEnabled = getPreAssignBindingsEnabled();
    // The third argument to $controller is considered private and undocumented:
    // https://github.com/angular/angular.js/blob/v1.6.10/src/ng/controller.js#L102-L109.
    // TODO remove the use of this third argument in AngularJS Material 1.2.0.
    // Passing `true` as the third argument causes `$controller` to return a function that
    // gets the controller instance instead of returning the instance directly. When the
    // controller is defined as a function, `invokeCtrl.instance` is the *same instance* as
    // `invokeCtrl()`. However, when the controller is an ES6 class, `invokeCtrl.instance` is a
    // *different instance* from `invokeCtrl()`.
    if (preAssignBindingsEnabled) {
      var invokeCtrl = this.$controller(options.controller, injectLocals, true);

      if (options.bindToController) {
        angular.extend(invokeCtrl.instance, locals);
      }

      // Use the private API callback to instantiate and initialize the specified controller.
      ctrl = invokeCtrl();
    } else {
      // If we don't need to pre-assign bindings, avoid using the private API third argument and
      // related callback.
      ctrl = this.$controller(options.controller, injectLocals);

      if (options.bindToController) {
        angular.extend(ctrl, locals);
      }
    }

    if (options.controllerAs) {
      injectLocals.$scope[options.controllerAs] = ctrl;
    }

    // Call the $onInit hook if it's present on the controller.
    angular.isFunction(ctrl.$onInit) && ctrl.$onInit();

    return ctrl;
  };

  /**
   * Fetches an element removing it from the DOM and using it temporary for the compiler.
   * Elements which were fetched will be restored after use.
   * @param {!Object} options Options to be used for the compilation.
   * @returns {{element: !JQLite, restore: !function}}
   */
  MdCompilerService.prototype._fetchContentElement = function(options) {

    var contentEl = options.contentElement;
    var restoreFn = null;

    if (angular.isString(contentEl)) {
      contentEl = document.querySelector(contentEl);
      restoreFn = createRestoreFn(contentEl);
    } else {
      contentEl = contentEl[0] || contentEl;

      // When the element is visible in the DOM, then we restore it at close of the dialog.
      // Otherwise it will be removed from the DOM after close.
      if (document.contains(contentEl)) {
        restoreFn = createRestoreFn(contentEl);
      } else {
        restoreFn = function() {
          if (contentEl.parentNode) {
            contentEl.parentNode.removeChild(contentEl);
          }
        };
      }
    }

    return {
      element: angular.element(contentEl),
      restore: restoreFn
    };

    function createRestoreFn(element) {
      var parent = element.parentNode;
      var nextSibling = element.nextElementSibling;

      return function() {
        if (!nextSibling) {
          // When the element didn't had any sibling, then it can be simply appended to the
          // parent, because it plays no role, which index it had before.
          parent.appendChild(element);
        } else {
          // When the element had a sibling, which marks the previous position of the element
          // in the DOM, we insert it correctly before the sibling, to have the same index as
          // before.
          parent.insertBefore(element, nextSibling);
        }
      };
    }
  };
}


})();
(function(){
"use strict";


MdGesture.$inject = ["$$MdGestureHandler", "$$rAF", "$timeout"];
attachToDocument.$inject = ["$mdGesture", "$$MdGestureHandler"];var HANDLERS = {};

/**
 * The state of the current 'pointer'. The pointer represents the state of the current touch.
 * It contains normalized x and y coordinates from DOM events,
 * as well as other information abstracted from the DOM.
 */
var pointer, lastPointer, maxClickDistance = 6;
var forceSkipClickHijack = false, disableAllGestures = false;

/**
 * The position of the most recent click if that click was on a label element.
 * @type {{x: number, y: number}|null}
 */
var lastLabelClickPos = null;

// Used to attach event listeners once when multiple ng-apps are running.
var isInitialized = false;

var userAgent = navigator.userAgent || navigator.vendor || window.opera;
var isIos = userAgent.match(/ipad|iphone|ipod/i);
var isAndroid = userAgent.match(/android/i);

/**
 * @ngdoc module
 * @name material.core.gestures
 * @description
 * AngularJS Material Gesture handling for touch devices. This module replaced the usage of the hammerjs library.
 */
angular
  .module('material.core.gestures', [])
  .provider('$mdGesture', MdGestureProvider)
  .factory('$$MdGestureHandler', MdGestureHandler)
  .run(attachToDocument);

/**
 * @ngdoc service
 * @name $mdGestureProvider
 * @module material.core.gestures
 *
 * @description
 * In some scenarios on mobile devices (without jQuery), the click events should NOT be hijacked.
 * `$mdGestureProvider` is used to configure the Gesture module to ignore or skip click hijacking on mobile
 * devices.
 *
 * You can also change the max click distance, `6px` by default, if you have issues on some touch screens.
 *
 * <hljs lang="js">
 *   app.config(function($mdGestureProvider) {
 *
 *     // For mobile devices without jQuery loaded, do not
 *     // intercept click events during the capture phase.
 *     $mdGestureProvider.skipClickHijack();
 *
 *     // If hijacking clicks, you may want to change the default click distance
 *     $mdGestureProvider.setMaxClickDistance(12);
 *   });
 * </hljs>
 *
 */
function MdGestureProvider() { }

MdGestureProvider.prototype = {

  /**
   * @ngdoc method
   * @name $mdGestureProvider#disableAll
   *
   * @description
   * Disable all gesture detection. This can be beneficial to application performance
   * and memory usage.
   */
  disableAll: function () {
    disableAllGestures = true;
  },

  // Publish access to setter to configure a variable BEFORE the
  // $mdGesture service is instantiated...
  /**
   * @ngdoc method
   * @name $mdGestureProvider#skipClickHijack
   *
   * @description
   * Tell the AngularJS Material Gesture module to skip (or ignore) click hijacking on mobile devices.
   */
  skipClickHijack: function() {
    return forceSkipClickHijack = true;
  },

  /**
   * @ngdoc method
   * @name $mdGestureProvider#setMaxClickDistance
   * @param clickDistance {string} Distance in pixels. I.e. `12px`.
   * @description
   * Set the max distance from the origin of the touch event to trigger touch handlers.
   */
  setMaxClickDistance: function(clickDistance) {
    maxClickDistance = parseInt(clickDistance);
  },

  /**
   * $get is used to build an instance of $mdGesture
   * @ngInject
   */
  $get : ["$$MdGestureHandler", "$$rAF", "$timeout", function($$MdGestureHandler, $$rAF, $timeout) {
       return new MdGesture($$MdGestureHandler, $$rAF, $timeout);
  }]
};



/**
 * MdGesture factory construction function
 * @ngInject
 */
function MdGesture($$MdGestureHandler, $$rAF, $timeout) {
  var touchActionProperty = getTouchAction();
  var hasJQuery =  (typeof window.jQuery !== 'undefined') && (angular.element === window.jQuery);

  var self = {
    handler: addHandler,
    register: register,
    isAndroid: isAndroid,
    isIos: isIos,
    // On mobile w/out jQuery, we normally intercept clicks. Should we skip that?
    isHijackingClicks: (isIos || isAndroid) && !hasJQuery && !forceSkipClickHijack
  };

  if (self.isHijackingClicks) {
    self.handler('click', {
      options: {
        maxDistance: maxClickDistance
      },
      onEnd: checkDistanceAndEmit('click')
    });

    self.handler('focus', {
      options: {
        maxDistance: maxClickDistance
      },
      onEnd: function(ev, pointer) {
        if (pointer.distance < this.state.options.maxDistance && canFocus(ev.target)) {
          this.dispatchEvent(ev, 'focus', pointer);
          ev.target.focus();
        }
      }
    });

    self.handler('mouseup', {
      options: {
        maxDistance: maxClickDistance
      },
      onEnd: checkDistanceAndEmit('mouseup')
    });

    self.handler('mousedown', {
      onStart: function(ev) {
        this.dispatchEvent(ev, 'mousedown');
      }
    });
  }

  function checkDistanceAndEmit(eventName) {
    return function(ev, pointer) {
      if (pointer.distance < this.state.options.maxDistance) {
        this.dispatchEvent(ev, eventName, pointer);
      }
    };
  }

  /**
   * Register an element to listen for a handler.
   * This allows an element to override the default options for a handler.
   * Additionally, some handlers like drag and hold only dispatch events if
   * the domEvent happens inside an element that's registered to listen for these events.
   *
   * @see GestureHandler for how overriding of default options works.
   * @example $mdGesture.register(myElement, 'drag', { minDistance: 20, horizontal: false })
   */
  function register(element, handlerName, options) {
    var handler = HANDLERS[handlerName.replace(/^\$md./, '')];
    if (!handler) {
      throw new Error('Failed to register element with handler ' + handlerName + '. ' +
      'Available handlers: ' + Object.keys(HANDLERS).join(', '));
    }
    return handler.registerElement(element, options);
  }

  /*
   * add a handler to $mdGesture. see below.
   */
  function addHandler(name, definition) {
    var handler = new $$MdGestureHandler(name);
    angular.extend(handler, definition);
    HANDLERS[name] = handler;

    return self;
  }

  /**
   * Register handlers. These listen to touch/start/move events, interpret them,
   * and dispatch gesture events depending on options & conditions. These are all
   * instances of GestureHandler.
   * @see GestureHandler
   */
  return self
    /*
     * The press handler dispatches an event on touchdown/touchend.
     * It's a simple abstraction of touch/mouse/pointer start and end.
     */
    .handler('press', {
      onStart: function (ev, pointer) {
        this.dispatchEvent(ev, '$md.pressdown');
      },
      onEnd: function (ev, pointer) {
        this.dispatchEvent(ev, '$md.pressup');
      }
    })

    /*
     * The hold handler dispatches an event if the user keeps their finger within
     * the same <maxDistance> area for <delay> ms.
     * The hold handler will only run if a parent of the touch target is registered
     * to listen for hold events through $mdGesture.register()
     */
    .handler('hold', {
      options: {
        maxDistance: 6,
        delay: 500
      },
      onCancel: function () {
        $timeout.cancel(this.state.timeout);
      },
      onStart: function (ev, pointer) {
        // For hold, require a parent to be registered with $mdGesture.register()
        // Because we prevent scroll events, this is necessary.
        if (!this.state.registeredParent) return this.cancel();

        this.state.pos = {x: pointer.x, y: pointer.y};
        this.state.timeout = $timeout(angular.bind(this, function holdDelayFn() {
          this.dispatchEvent(ev, '$md.hold');
          this.cancel(); // we're done!
        }), this.state.options.delay, false);
      },
      onMove: function (ev, pointer) {
        // Don't scroll while waiting for hold.
        // If we don't preventDefault touchmove events here, Android will assume we don't
        // want to listen to anymore touch events. It will start scrolling and stop sending
        // touchmove events.
        if (!touchActionProperty && ev.type === 'touchmove') ev.preventDefault();

        // If the user moves greater than <maxDistance> pixels, stop the hold timer
        // set in onStart
        var dx = this.state.pos.x - pointer.x;
        var dy = this.state.pos.y - pointer.y;
        if (Math.sqrt(dx * dx + dy * dy) > this.options.maxDistance) {
          this.cancel();
        }
      },
      onEnd: function () {
        this.onCancel();
      }
    })

    /*
     * The drag handler dispatches a drag event if the user holds and moves his finger greater than
     * <minDistance> px in the x or y direction, depending on options.horizontal.
     * The drag will be cancelled if the user moves his finger greater than <minDistance>*<cancelMultiplier> in
     * the perpendicular direction. Eg if the drag is horizontal and the user moves his finger <minDistance>*<cancelMultiplier>
     * pixels vertically, this handler won't consider the move part of a drag.
     */
    .handler('drag', {
      options: {
        minDistance: 6,
        horizontal: true,
        cancelMultiplier: 1.5
      },
      onSetup: function(element, options) {
        if (touchActionProperty) {
          // We check for horizontal to be false, because otherwise we would overwrite the default opts.
          this.oldTouchAction = element[0].style[touchActionProperty];
          element[0].style[touchActionProperty] = options.horizontal ? 'pan-y' : 'pan-x';
        }
      },
      onCleanup: function(element) {
        if (this.oldTouchAction) {
          element[0].style[touchActionProperty] = this.oldTouchAction;
        }
      },
      onStart: function (ev) {
        // For drag, require a parent to be registered with $mdGesture.register()
        if (!this.state.registeredParent) this.cancel();
      },
      onMove: function (ev, pointer) {
        var shouldStartDrag, shouldCancel;
        // Don't scroll while deciding if this touchmove qualifies as a drag event.
        // If we don't preventDefault touchmove events here, Android will assume we don't
        // want to listen to anymore touch events. It will start scrolling and stop sending
        // touchmove events.
        if (!touchActionProperty && ev.type === 'touchmove') ev.preventDefault();

        if (!this.state.dragPointer) {
          if (this.state.options.horizontal) {
            shouldStartDrag = Math.abs(pointer.distanceX) > this.state.options.minDistance;
            shouldCancel = Math.abs(pointer.distanceY) > this.state.options.minDistance * this.state.options.cancelMultiplier;
          } else {
            shouldStartDrag = Math.abs(pointer.distanceY) > this.state.options.minDistance;
            shouldCancel = Math.abs(pointer.distanceX) > this.state.options.minDistance * this.state.options.cancelMultiplier;
          }

          if (shouldStartDrag) {
            // Create a new pointer representing this drag, starting at this point where the drag started.
            this.state.dragPointer = makeStartPointer(ev);
            updatePointerState(ev, this.state.dragPointer);
            this.dispatchEvent(ev, '$md.dragstart', this.state.dragPointer);

          } else if (shouldCancel) {
            this.cancel();
          }
        } else {
          this.dispatchDragMove(ev);
        }
      },
      // Only dispatch dragmove events every frame; any more is unnecessary
      dispatchDragMove: $$rAF.throttle(function (ev) {
        // Make sure the drag didn't stop while waiting for the next frame
        if (this.state.isRunning) {
          updatePointerState(ev, this.state.dragPointer);
          this.dispatchEvent(ev, '$md.drag', this.state.dragPointer);
        }
      }),
      onEnd: function (ev, pointer) {
        if (this.state.dragPointer) {
          updatePointerState(ev, this.state.dragPointer);
          this.dispatchEvent(ev, '$md.dragend', this.state.dragPointer);
        }
      }
    })

    /*
     * The swipe handler will dispatch a swipe event if, on the end of a touch,
     * the velocity and distance were high enough.
     */
    .handler('swipe', {
      options: {
        minVelocity: 0.65,
        minDistance: 10
      },
      onEnd: function (ev, pointer) {
        var eventType;

        if (Math.abs(pointer.velocityX) > this.state.options.minVelocity &&
          Math.abs(pointer.distanceX) > this.state.options.minDistance) {
          eventType = pointer.directionX == 'left' ? '$md.swipeleft' : '$md.swiperight';
          this.dispatchEvent(ev, eventType);
        }
        else if (Math.abs(pointer.velocityY) > this.state.options.minVelocity &&
          Math.abs(pointer.distanceY) > this.state.options.minDistance) {
          eventType = pointer.directionY == 'up' ? '$md.swipeup' : '$md.swipedown';
          this.dispatchEvent(ev, eventType);
        }
      }
    });

  function getTouchAction() {
    var testEl = document.createElement('div');
    var vendorPrefixes = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];

    for (var i = 0; i < vendorPrefixes.length; i++) {
      var prefix = vendorPrefixes[i];
      var property = prefix ? prefix + 'TouchAction' : 'touchAction';
      if (angular.isDefined(testEl.style[property])) {
        return property;
      }
    }
  }

}

/**
 * MdGestureHandler
 * A GestureHandler is an object which is able to dispatch custom dom events
 * based on native dom {touch,pointer,mouse}{start,move,end} events.
 *
 * A gesture will manage its lifecycle through the start,move,end, and cancel
 * functions, which are called by native dom events.
 *
 * A gesture has the concept of 'options' (eg a swipe's required velocity), which can be
 * overridden by elements registering through $mdGesture.register()
 */
function GestureHandler (name) {
  this.name = name;
  this.state = {};
}

function MdGestureHandler() {
  var hasJQuery =  (typeof window.jQuery !== 'undefined') && (angular.element === window.jQuery);

  GestureHandler.prototype = {
    options: {},
    // jQuery listeners don't work with custom DOMEvents, so we have to dispatch events
    // differently when jQuery is loaded
    dispatchEvent: hasJQuery ?  jQueryDispatchEvent : nativeDispatchEvent,

    // These are overridden by the registered handler
    onSetup: angular.noop,
    onCleanup: angular.noop,
    onStart: angular.noop,
    onMove: angular.noop,
    onEnd: angular.noop,
    onCancel: angular.noop,

    // onStart sets up a new state for the handler, which includes options from the
    // nearest registered parent element of ev.target.
    start: function (ev, pointer) {
      if (this.state.isRunning) return;
      var parentTarget = this.getNearestParent(ev.target);
      // Get the options from the nearest registered parent
      var parentTargetOptions = parentTarget && parentTarget.$mdGesture[this.name] || {};

      this.state = {
        isRunning: true,
        // Override the default options with the nearest registered parent's options
        options: angular.extend({}, this.options, parentTargetOptions),
        // Pass in the registered parent node to the state so the onStart listener can use
        registeredParent: parentTarget
      };
      this.onStart(ev, pointer);
    },
    move: function (ev, pointer) {
      if (!this.state.isRunning) return;
      this.onMove(ev, pointer);
    },
    end: function (ev, pointer) {
      if (!this.state.isRunning) return;
      this.onEnd(ev, pointer);
      this.state.isRunning = false;
    },
    cancel: function (ev, pointer) {
      this.onCancel(ev, pointer);
      this.state = {};
    },

    // Find and return the nearest parent element that has been registered to
    // listen for this handler via $mdGesture.register(element, 'handlerName').
    getNearestParent: function (node) {
      var current = node;
      while (current) {
        if ((current.$mdGesture || {})[this.name]) {
          return current;
        }
        current = current.parentNode;
      }
      return null;
    },

    // Called from $mdGesture.register when an element registers itself with a handler.
    // Store the options the user gave on the DOMElement itself. These options will
    // be retrieved with getNearestParent when the handler starts.
    registerElement: function (element, options) {
      var self = this;
      element[0].$mdGesture = element[0].$mdGesture || {};
      element[0].$mdGesture[this.name] = options || {};
      element.on('$destroy', onDestroy);

      self.onSetup(element, options || {});

      return onDestroy;

      function onDestroy() {
        delete element[0].$mdGesture[self.name];
        element.off('$destroy', onDestroy);

        self.onCleanup(element, options || {});
      }
    }
  };

  return GestureHandler;

  /**
   * Dispatch an event with jQuery
   * TODO: Make sure this sends bubbling events
   *
   * @param srcEvent the original DOM touch event that started this.
   * @param eventType the name of the custom event to send (eg 'click' or '$md.drag')
   * @param eventPointer the pointer object that matches this event.
   */
  function jQueryDispatchEvent(srcEvent, eventType, eventPointer) {
    eventPointer = eventPointer || pointer;
    var eventObj = new angular.element.Event(eventType);

    eventObj.$material = true;
    eventObj.pointer = eventPointer;
    eventObj.srcEvent = srcEvent;

    angular.extend(eventObj, {
      clientX: eventPointer.x,
      clientY: eventPointer.y,
      screenX: eventPointer.x,
      screenY: eventPointer.y,
      pageX: eventPointer.x,
      pageY: eventPointer.y,
      ctrlKey: srcEvent.ctrlKey,
      altKey: srcEvent.altKey,
      shiftKey: srcEvent.shiftKey,
      metaKey: srcEvent.metaKey
    });
    angular.element(eventPointer.target).trigger(eventObj);
  }

  /**
   * NOTE: nativeDispatchEvent is very performance sensitive.
   * @param srcEvent the original DOM touch event that started this.
   * @param eventType the name of the custom event to send (eg 'click' or '$md.drag')
   * @param eventPointer the pointer object that matches this event.
   */
  function nativeDispatchEvent(srcEvent, eventType, eventPointer) {
    eventPointer = eventPointer || pointer;
    var eventObj;

    if (eventType === 'click' || eventType === 'mouseup' || eventType === 'mousedown') {
      if (typeof window.MouseEvent === "function") {
        eventObj = new MouseEvent(eventType, {
          bubbles: true,
          cancelable: true,
          screenX: Number(srcEvent.screenX),
          screenY: Number(srcEvent.screenY),
          clientX: Number(eventPointer.x),
          clientY: Number(eventPointer.y),
          ctrlKey: srcEvent.ctrlKey,
          altKey: srcEvent.altKey,
          shiftKey: srcEvent.shiftKey,
          metaKey: srcEvent.metaKey,
          button: srcEvent.button,
          buttons: srcEvent.buttons,
          relatedTarget: srcEvent.relatedTarget || null
        });
      } else {
        eventObj = document.createEvent('MouseEvents');
        // This has been deprecated
        // https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/initMouseEvent
        eventObj.initMouseEvent(
          eventType, true, true, window, srcEvent.detail,
          eventPointer.x, eventPointer.y, eventPointer.x, eventPointer.y,
          srcEvent.ctrlKey, srcEvent.altKey, srcEvent.shiftKey, srcEvent.metaKey,
          srcEvent.button, srcEvent.relatedTarget || null
        );
      }
    } else {
      if (typeof window.CustomEvent === "function") {
        eventObj = new CustomEvent(eventType, {
          bubbles: true,
          cancelable: true,
          detail: {}
        });
      } else {
        // This has been deprecated
        // https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/initCustomEvent
        eventObj = document.createEvent('CustomEvent');
        eventObj.initCustomEvent(eventType, true, true, {});
      }
    }
    eventObj.$material = true;
    eventObj.pointer = eventPointer;
    eventObj.srcEvent = srcEvent;
    eventPointer.target.dispatchEvent(eventObj);
  }
}

/**
 * Attach Gestures: hook document and check shouldHijack clicks
 * @ngInject
 */
function attachToDocument($mdGesture, $$MdGestureHandler) {
  if (disableAllGestures) {
    return;
  }

  // Polyfill document.contains for IE11.
  // TODO: move to util
  document.contains || (document.contains = function (node) {
    return document.body.contains(node);
  });

  if (!isInitialized && $mdGesture.isHijackingClicks) {
    /*
     * If hijack clicks is true, we preventDefault any click that wasn't
     * sent by AngularJS Material. This is because on older Android & iOS, a false, or 'ghost',
     * click event will be sent ~400ms after a touchend event happens.
     * The only way to know if this click is real is to prevent any normal
     * click events, and add a flag to events sent by material so we know not to prevent those.
     *
     * Two exceptions to click events that should be prevented are:
     *  - click events sent by the keyboard (eg form submit)
     *  - events that originate from an Ionic app
     */
    document.addEventListener('click'    , clickHijacker     , true);
    document.addEventListener('mouseup'  , mouseInputHijacker, true);
    document.addEventListener('mousedown', mouseInputHijacker, true);
    document.addEventListener('focus'    , mouseInputHijacker, true);

    isInitialized = true;
  }

  function mouseInputHijacker(ev) {
    var isKeyClick = !ev.clientX && !ev.clientY;

    if (
      !isKeyClick &&
      !ev.$material &&
      !ev.isIonicTap &&
      !isInputEventFromLabelClick(ev) &&
      (ev.type !== 'mousedown' || (!canFocus(ev.target) && !canFocus(document.activeElement)))
    ) {
      ev.preventDefault();
      ev.stopPropagation();
    }
  }

  /**
   * Ignore click events that don't come from AngularJS Material, Ionic, Input Label clicks,
   * or key presses that generate click events. This helps to ignore the ghost tap events on
   * older mobile browsers that get sent after a 300-400ms delay.
   * @param ev MouseEvent or modified MouseEvent with $material, pointer, and other fields
   */
  function clickHijacker(ev) {
    var isKeyClick;
    if (isIos) {
      isKeyClick = angular.isDefined(ev.webkitForce) && ev.webkitForce === 0;
    } else {
      isKeyClick = ev.clientX === 0 && ev.clientY === 0;
    }
    if (!isKeyClick && !ev.$material && !ev.isIonicTap && !isInputEventFromLabelClick(ev)) {
      ev.preventDefault();
      ev.stopPropagation();
      lastLabelClickPos = null;
    } else {
      lastLabelClickPos = null;
      if (ev.target.tagName.toLowerCase() === 'label') {
        lastLabelClickPos = {x: ev.x, y: ev.y};
      }
    }
  }


  // Listen to all events to cover all platforms.
  var START_EVENTS = 'mousedown touchstart pointerdown';
  var MOVE_EVENTS = 'mousemove touchmove pointermove';
  var END_EVENTS = 'mouseup mouseleave touchend touchcancel pointerup pointercancel';

  angular.element(document)
    .on(START_EVENTS, gestureStart)
    .on(MOVE_EVENTS, gestureMove)
    .on(END_EVENTS, gestureEnd)
    // For testing
    .on('$$mdGestureReset', function gestureClearCache () {
      lastPointer = pointer = null;
    });

  /**
   * When a DOM event happens, run all registered gesture handlers' lifecycle
   * methods which match the DOM event.
   * Eg. when a 'touchstart' event happens, runHandlers('start') will call and
   * run `handler.cancel()` and `handler.start()` on all registered handlers.
   */
  function runHandlers(handlerEvent, event) {
    var handler;
    for (var name in HANDLERS) {
      handler = HANDLERS[name];
      if (handler instanceof $$MdGestureHandler) {

        if (handlerEvent === 'start') {
          // Run cancel to reset any handlers' state
          handler.cancel();
        }
        handler[handlerEvent](event, pointer);
      }
    }
  }

  /*
   * gestureStart vets if a start event is legitimate (and not part of a 'ghost click' from iOS/Android)
   * If it is legitimate, we initiate the pointer state and mark the current pointer's type
   * For example, for a touchstart event, mark the current pointer as a 'touch' pointer, so mouse events
   * won't effect it.
   */
  function gestureStart(ev) {
    // If we're already touched down, abort
    if (pointer) return;

    var now = +Date.now();

    // iOS & old android bug: after a touch event, a click event is sent 350 ms later.
    // If <400ms have passed, don't allow an event of a different type than the previous event
    if (lastPointer && !typesMatch(ev, lastPointer) && (now - lastPointer.endTime < 1500)) {
      return;
    }

    pointer = makeStartPointer(ev);

    runHandlers('start', ev);
  }

  /**
   * If a move event happens of the right type, update the pointer and run all the move handlers.
   * "of the right type": if a mousemove happens but our pointer started with a touch event, do
   * nothing.
   */
  function gestureMove(ev) {
    if (!pointer || !typesMatch(ev, pointer)) return;

    updatePointerState(ev, pointer);
    runHandlers('move', ev);
  }

  /**
   * If an end event happens of the right type, update the pointer, run endHandlers, and save the
   * pointer as 'lastPointer'.
   */
  function gestureEnd(ev) {
    if (!pointer || !typesMatch(ev, pointer)) return;

    updatePointerState(ev, pointer);
    pointer.endTime = +Date.now();

    if (ev.type !== 'pointercancel') {
      runHandlers('end', ev);
    }

    lastPointer = pointer;
    pointer = null;
  }

}

// ********************
// Module Functions
// ********************

/*
 * Initiate the pointer. x, y, and the pointer's type.
 */
function makeStartPointer(ev) {
  var point = getEventPoint(ev);
  var startPointer = {
    startTime: +Date.now(),
    target: ev.target,
    // 'p' for pointer events, 'm' for mouse, 't' for touch
    type: ev.type.charAt(0)
  };
  startPointer.startX = startPointer.x = point.pageX;
  startPointer.startY = startPointer.y = point.pageY;
  return startPointer;
}

/*
 * return whether the pointer's type matches the event's type.
 * Eg if a touch event happens but the pointer has a mouse type, return false.
 */
function typesMatch(ev, pointer) {
  return ev && pointer && ev.type.charAt(0) === pointer.type;
}

/**
 * Gets whether the given event is an input event that was caused by clicking on an
 * associated label element.
 *
 * This is necessary because the browser will, upon clicking on a label element, fire an
 * *extra* click event on its associated input (if any). mdGesture is able to flag the label
 * click as with `$material` correctly, but not the second input click.
 *
 * In order to determine whether an input event is from a label click, we compare the (x, y) for
 * the event to the (x, y) for the most recent label click (which is cleared whenever a non-label
 * click occurs). Unfortunately, there are no event properties that tie the input and the label
 * together (such as relatedTarget).
 *
 * @param {MouseEvent} event
 * @returns {boolean}
 */
function isInputEventFromLabelClick(event) {
  return lastLabelClickPos
      && lastLabelClickPos.x === event.x
      && lastLabelClickPos.y === event.y;
}

/*
 * Update the given pointer based upon the given DOMEvent.
 * Distance, velocity, direction, duration, etc
 */
function updatePointerState(ev, pointer) {
  var point = getEventPoint(ev);
  var x = pointer.x = point.pageX;
  var y = pointer.y = point.pageY;

  pointer.distanceX = x - pointer.startX;
  pointer.distanceY = y - pointer.startY;
  pointer.distance = Math.sqrt(
    pointer.distanceX * pointer.distanceX + pointer.distanceY * pointer.distanceY
  );

  pointer.directionX = pointer.distanceX > 0 ? 'right' : pointer.distanceX < 0 ? 'left' : '';
  pointer.directionY = pointer.distanceY > 0 ? 'down' : pointer.distanceY < 0 ? 'up' : '';

  pointer.duration = +Date.now() - pointer.startTime;
  pointer.velocityX = pointer.distanceX / pointer.duration;
  pointer.velocityY = pointer.distanceY / pointer.duration;
}

/**
 * Normalize the point where the DOM event happened whether it's touch or mouse.
 * @returns point event obj with pageX and pageY on it.
 */
function getEventPoint(ev) {
  ev = ev.originalEvent || ev; // support jQuery events
  return (ev.touches && ev.touches[0]) ||
    (ev.changedTouches && ev.changedTouches[0]) ||
    ev;
}

/** Checks whether an element can be focused. */
function canFocus(element) {
  return (
    !!element &&
    element.getAttribute('tabindex') !== '-1' &&
    !element.hasAttribute('disabled') &&
    (
      element.hasAttribute('tabindex') ||
      element.hasAttribute('href') ||
      element.isContentEditable ||
      ['INPUT', 'SELECT', 'BUTTON', 'TEXTAREA', 'VIDEO', 'AUDIO'].indexOf(element.nodeName) !== -1
    )
  );
}

})();
(function(){
"use strict";

/**
 * @ngdoc module
 * @name material.core.interaction
 * @description
 * User interaction detection to provide proper accessibility.
 */
MdInteractionService.$inject = ["$timeout", "$mdUtil", "$rootScope"];
angular
  .module('material.core.interaction', [])
  .service('$mdInteraction', MdInteractionService);


/**
 * @ngdoc service
 * @name $mdInteraction
 * @module material.core.interaction
 *
 * @description
 *
 * Service which keeps track of the last interaction type and validates them for several browsers.
 * The service hooks into the document's body and listens for touch, mouse and keyboard events.
 *
 * The most recent interaction type can be retrieved by calling the `getLastInteractionType` method.
 *
 * Here is an example markup for using the interaction service.
 *
 * <hljs lang="js">
 *   var lastType = $mdInteraction.getLastInteractionType();
 *
 *   if (lastType === 'keyboard') {
 *     // We only restore the focus for keyboard users.
 *     restoreFocus();
 *   }
 * </hljs>
 *
 */
function MdInteractionService($timeout, $mdUtil, $rootScope) {
  this.$timeout = $timeout;
  this.$mdUtil = $mdUtil;
  this.$rootScope = $rootScope;

  // IE browsers can also trigger pointer events, which also leads to an interaction.
  this.pointerEvent = 'MSPointerEvent' in window ? 'MSPointerDown' : 'PointerEvent' in window ? 'pointerdown' : null;
  this.bodyElement = angular.element(document.body);
  this.isBuffering = false;
  this.bufferTimeout = null;
  this.lastInteractionType = null;
  this.lastInteractionTime = null;
  this.inputHandler = this.onInputEvent.bind(this);
  this.bufferedInputHandler = this.onBufferInputEvent.bind(this);

  // Type Mappings for the different events
  // There will be three three interaction types
  // `keyboard`, `mouse` and `touch`
  // type `pointer` will be evaluated in `pointerMap` for IE Browser events
  this.inputEventMap = {
    'keydown': 'keyboard',
    'mousedown': 'mouse',
    'mouseenter': 'mouse',
    'touchstart': 'touch',
    'pointerdown': 'pointer',
    'MSPointerDown': 'pointer'
  };

  // IE PointerDown events will be validated in `touch` or `mouse`
  // Index numbers referenced here: https://msdn.microsoft.com/library/windows/apps/hh466130.aspx
  this.iePointerMap = {
    2: 'touch',
    3: 'touch',
    4: 'mouse'
  };

  this.initializeEvents();
  this.$rootScope.$on('$destroy', this.deregister.bind(this));
}

/**
 * Removes all event listeners created by $mdInteration on the
 * body element.
 */
MdInteractionService.prototype.deregister = function() {

    this.bodyElement.off('keydown mousedown', this.inputHandler);

    if ('ontouchstart' in document.documentElement) {
      this.bodyElement.off('touchstart', this.bufferedInputHandler);
    }

    if (this.pointerEvent) {
      this.bodyElement.off(this.pointerEvent, this.inputHandler);
    }

};

/**
 * Initializes the interaction service, by registering all interaction events to the
 * body element.
 */
MdInteractionService.prototype.initializeEvents = function() {

  this.bodyElement.on('keydown mousedown', this.inputHandler);

  if ('ontouchstart' in document.documentElement) {
    this.bodyElement.on('touchstart', this.bufferedInputHandler);
  }

  if (this.pointerEvent) {
    this.bodyElement.on(this.pointerEvent, this.inputHandler);
  }

};

/**
 * Event listener for normal interaction events, which should be tracked.
 * @param event {MouseEvent|KeyboardEvent|PointerEvent|TouchEvent}
 */
MdInteractionService.prototype.onInputEvent = function(event) {
  if (this.isBuffering) {
    return;
  }

  var type = this.inputEventMap[event.type];

  if (type === 'pointer') {
    type = this.iePointerMap[event.pointerType] || event.pointerType;
  }

  this.lastInteractionType = type;
  this.lastInteractionTime = this.$mdUtil.now();
};

/**
 * Event listener for interaction events which should be buffered (touch events).
 * @param event {TouchEvent}
 */
MdInteractionService.prototype.onBufferInputEvent = function(event) {
  this.$timeout.cancel(this.bufferTimeout);

  this.onInputEvent(event);
  this.isBuffering = true;

  // The timeout of 650ms is needed to delay the touchstart, because otherwise the touch will call
  // the `onInput` function multiple times.
  this.bufferTimeout = this.$timeout(function() {
    this.isBuffering = false;
  }.bind(this), 650, false);

};

/**
 * @ngdoc method
 * @name $mdInteraction#getLastInteractionType
 * @description Retrieves the last interaction type triggered in body.
 * @returns {string|null} Last interaction type.
 */
MdInteractionService.prototype.getLastInteractionType = function() {
  return this.lastInteractionType;
};

/**
 * @ngdoc method
 * @name $mdInteraction#isUserInvoked
 * @description Method to detect whether any interaction happened recently or not.
 * @param {number=} checkDelay Time to check for any interaction to have been triggered.
 * @returns {boolean} Whether there was any interaction or not.
 */
MdInteractionService.prototype.isUserInvoked = function(checkDelay) {
  var delay = angular.isNumber(checkDelay) ? checkDelay : 15;

  // Check for any interaction to be within the specified check time.
  return this.lastInteractionTime >= this.$mdUtil.now() - delay;
};

})();
(function(){
"use strict";

angular.module('material.core')
  .provider('$$interimElement', InterimElementProvider);

/*
 * @ngdoc service
 * @name $$interimElement
 * @module material.core
 *
 * @description
 *
 * Factory that constructs `$$interimElement.$service` services.
 * Used internally in material design for elements that appear on screen temporarily.
 * The service provides a promise-like API for interacting with the temporary
 * elements.
 *
 * ```js
 * app.service('$mdToast', function($$interimElement) {
 *   var $mdToast = $$interimElement(toastDefaultOptions);
 *   return $mdToast;
 * });
 * ```
 * @param {object=} defaultOptions Options used by default for the `show` method on the service.
 *
 * @returns {$$interimElement.$service}
 *
 */

function InterimElementProvider() {
  InterimElementFactory.$inject = ["$document", "$q", "$rootScope", "$timeout", "$rootElement", "$animate", "$mdUtil", "$mdCompiler", "$mdTheming", "$injector", "$exceptionHandler"];
  createInterimElementProvider.$get = InterimElementFactory;
  return createInterimElementProvider;

  /**
   * Returns a new provider which allows configuration of a new interimElement
   * service. Allows configuration of default options & methods for options,
   * as well as configuration of 'preset' methods (eg dialog.basic(): basic is a preset method)
   */
  function createInterimElementProvider(interimFactoryName) {
    factory.$inject = ["$$interimElement", "$injector"];
    var EXPOSED_METHODS = ['onHide', 'onShow', 'onRemove'];

    var customMethods = {};
    var providerConfig = {
      presets: {}
    };

    var provider = {
      setDefaults: setDefaults,
      addPreset: addPreset,
      addMethod: addMethod,
      $get: factory
    };

    /**
     * all interim elements will come with the 'build' preset
     */
    provider.addPreset('build', {
      methods: ['controller', 'controllerAs', 'resolve', 'multiple',
        'template', 'templateUrl', 'themable', 'transformTemplate', 'parent', 'contentElement']
    });

    return provider;

    /**
     * Save the configured defaults to be used when the factory is instantiated
     */
    function setDefaults(definition) {
      providerConfig.optionsFactory = definition.options;
      providerConfig.methods = (definition.methods || []).concat(EXPOSED_METHODS);
      return provider;
    }

    /**
     * Add a method to the factory that isn't specific to any interim element operations
     */

    function addMethod(name, fn) {
      customMethods[name] = fn;
      return provider;
    }

    /**
     * Save the configured preset to be used when the factory is instantiated
     */
    function addPreset(name, definition) {
      definition = definition || {};
      definition.methods = definition.methods || [];
      definition.options = definition.options || function() { return {}; };

      if (/^cancel|hide|show$/.test(name)) {
        throw new Error("Preset '" + name + "' in " + interimFactoryName + " is reserved!");
      }
      if (definition.methods.indexOf('_options') > -1) {
        throw new Error("Method '_options' in " + interimFactoryName + " is reserved!");
      }
      providerConfig.presets[name] = {
        methods: definition.methods.concat(EXPOSED_METHODS),
        optionsFactory: definition.options,
        argOption: definition.argOption
      };
      return provider;
    }

    function addPresetMethod(presetName, methodName, method) {
      providerConfig.presets[presetName][methodName] = method;
    }

    /**
     * Create a factory that has the given methods & defaults implementing interimElement
     */
    /* @ngInject */
    function factory($$interimElement, $injector) {
      var defaultMethods;
      var defaultOptions;
      var interimElementService = $$interimElement();

      /*
       * publicService is what the developer will be using.
       * It has methods hide(), cancel(), show(), build(), and any other
       * presets which were set during the config phase.
       */
      var publicService = {
        hide: interimElementService.hide,
        cancel: interimElementService.cancel,
        show: showInterimElement,

        // Special internal method to destroy an interim element without animations
        // used when navigation changes causes a $scope.$destroy() action
        destroy : destroyInterimElement
      };


      defaultMethods = providerConfig.methods || [];
      // This must be invoked after the publicService is initialized
      defaultOptions = invokeFactory(providerConfig.optionsFactory, {});

      // Copy over the simple custom methods
      angular.forEach(customMethods, function(fn, name) {
        publicService[name] = fn;
      });

      angular.forEach(providerConfig.presets, function(definition, name) {
        var presetDefaults = invokeFactory(definition.optionsFactory, {});
        var presetMethods = (definition.methods || []).concat(defaultMethods);

        // Every interimElement built with a preset has a field called `$type`,
        // which matches the name of the preset.
        // Eg in preset 'confirm', options.$type === 'confirm'
        angular.extend(presetDefaults, { $type: name });

        // This creates a preset class which has setter methods for every
        // method given in the `.addPreset()` function, as well as every
        // method given in the `.setDefaults()` function.
        //
        // @example
        // .setDefaults({
        //   methods: ['hasBackdrop', 'clickOutsideToClose', 'escapeToClose', 'targetEvent'],
        //   options: dialogDefaultOptions
        // })
        // .addPreset('alert', {
        //   methods: ['title', 'ok'],
        //   options: alertDialogOptions
        // })
        //
        // Set values will be passed to the options when interimElement.show() is called.
        function Preset(opts) {
          this._options = angular.extend({}, presetDefaults, opts);
        }
        angular.forEach(presetMethods, function(name) {
          Preset.prototype[name] = function(value) {
            this._options[name] = value;
            return this;
          };
        });

        // Create shortcut method for one-linear methods
        if (definition.argOption) {
          var methodName = 'show' + name.charAt(0).toUpperCase() + name.slice(1);
          publicService[methodName] = function(arg) {
            var config = publicService[name](arg);
            return publicService.show(config);
          };
        }

        // eg $mdDialog.alert() will return a new alert preset
        publicService[name] = function(arg) {
          // If argOption is supplied, eg `argOption: 'content'`, then we assume
          // if the argument is not an options object then it is the `argOption` option.
          //
          // @example `$mdToast.simple('hello')` // sets options.content to hello
          //                                     // because argOption === 'content'
          if (arguments.length && definition.argOption &&
              !angular.isObject(arg) && !angular.isArray(arg))  {

            return (new Preset())[definition.argOption](arg);

          } else {
            return new Preset(arg);
          }

        };
      });

      return publicService;

      /**
       *
       */
      function showInterimElement(opts) {
        // opts is either a preset which stores its options on an _options field,
        // or just an object made up of options
        opts = opts || { };
        if (opts._options) opts = opts._options;

        return interimElementService.show(
          angular.extend({}, defaultOptions, opts)
        );
      }

      /**
       *  Special method to hide and destroy an interimElement WITHOUT
       *  any 'leave` or hide animations ( an immediate force hide/remove )
       *
       *  NOTE: This calls the onRemove() subclass method for each component...
       *  which must have code to respond to `options.$destroy == true`
       */
      function destroyInterimElement(opts) {
          return interimElementService.destroy(opts);
      }

      /**
       * Helper to call $injector.invoke with a local of the factory name for
       * this provider.
       * If an $mdDialog is providing options for a dialog and tries to inject
       * $mdDialog, a circular dependency error will happen.
       * We get around that by manually injecting $mdDialog as a local.
       */
      function invokeFactory(factory, defaultVal) {
        var locals = {};
        locals[interimFactoryName] = publicService;
        return $injector.invoke(factory || function() { return defaultVal; }, {}, locals);
      }

    }

  }

  /* @ngInject */
  function InterimElementFactory($document, $q, $rootScope, $timeout, $rootElement, $animate,
                                 $mdUtil, $mdCompiler, $mdTheming, $injector, $exceptionHandler) {
    return function createInterimElementService() {
      var SHOW_CANCELLED = false;

      /*
       * @ngdoc service
       * @name $$interimElement.$service
       *
       * @description
       * A service used to control inserting and removing an element into the DOM.
       *
       */

      var service;

      var showPromises = []; // Promises for the interim's which are currently opening.
      var hidePromises = []; // Promises for the interim's which are currently hiding.
      var showingInterims = []; // Interim elements which are currently showing up.

      // Publish instance $$interimElement service;
      // ... used as $mdDialog, $mdToast, $mdMenu, and $mdSelect

      return service = {
        show: show,
        hide: waitForInterim(hide),
        cancel: waitForInterim(cancel),
        destroy : destroy,
        $injector_: $injector
      };

      /*
       * @ngdoc method
       * @name $$interimElement.$service#show
       * @kind function
       *
       * @description
       * Adds the `$interimElement` to the DOM and returns a special promise that will be resolved or rejected
       * with hide or cancel, respectively. To external cancel/hide, developers should use the
       *
       * @param {*} options is hashMap of settings
       * @returns a Promise
       *
       */
      function show(options) {
        options = options || {};
        var interimElement = new InterimElement(options || {});

        // When an interim element is currently showing, we have to cancel it.
        // Just hiding it, will resolve the InterimElement's promise, the promise should be
        // rejected instead.
        var hideAction = options.multiple ? $q.resolve() : $q.all(showPromises);

        if (!options.multiple) {
          // Wait for all opening interim's to finish their transition.
          hideAction = hideAction.then(function() {
            // Wait for all closing and showing interim's to be completely closed.
            var promiseArray = hidePromises.concat(showingInterims.map(service.cancel));
            return $q.all(promiseArray);
          });
        }

        var showAction = hideAction.then(function() {

          return interimElement
            .show()
            .then(function () {
              showingInterims.push(interimElement);
            })
            .catch(function (reason) {
              return reason;
            })
            .finally(function() {
              showPromises.splice(showPromises.indexOf(showAction), 1);
            });

        });

        showPromises.push(showAction);

        // In AngularJS 1.6+, exceptions inside promises will cause a rejection. We need to handle
        // the rejection and only log it if it's an error.
        interimElement.deferred.promise.catch(function(fault) {
          if (fault instanceof Error) {
            $exceptionHandler(fault);
          }

          return fault;
        });

        // Return a promise that will be resolved when the interim
        // element is hidden or cancelled...
        return interimElement.deferred.promise;
      }

      /*
       * @ngdoc method
       * @name $$interimElement.$service#hide
       * @kind function
       *
       * @description
       * Removes the `$interimElement` from the DOM and resolves the promise returned from `show`
       *
       * @param {*} resolveParam Data to resolve the promise with
       * @returns a Promise that will be resolved after the element has been removed.
       *
       */
      function hide(reason, options) {
        options = options || {};

        if (options.closeAll) {
          // We have to make a shallow copy of the array, because otherwise the map will break.
          return $q.all(showingInterims.slice().reverse().map(closeElement));
        } else if (options.closeTo !== undefined) {
          return $q.all(showingInterims.slice(options.closeTo).map(closeElement));
        }

        // Hide the latest showing interim element.
        return closeElement(showingInterims[showingInterims.length - 1]);

        function closeElement(interim) {

          if (!interim) {
            return $q.when(reason);
          }

          var hideAction = interim
            .remove(reason, false, options || { })
            .catch(function(reason) { return reason; })
            .finally(function() {
              hidePromises.splice(hidePromises.indexOf(hideAction), 1);
            });

          showingInterims.splice(showingInterims.indexOf(interim), 1);
          hidePromises.push(hideAction);

          return interim.deferred.promise;
        }
      }

      /*
       * @ngdoc method
       * @name $$interimElement.$service#cancel
       * @kind function
       *
       * @description
       * Removes the `$interimElement` from the DOM and rejects the promise returned from `show`
       *
       * @param {*} reason Data to reject the promise with
       * @returns Promise that will be resolved after the element has been removed.
       *
       */
      function cancel(reason, options) {
        var interim = showingInterims.pop();
        if (!interim) {
          return $q.when(reason);
        }

        var cancelAction = interim
          .remove(reason, true, options || {})
          .catch(function(reason) { return reason; })
          .finally(function() {
            hidePromises.splice(hidePromises.indexOf(cancelAction), 1);
          });

        hidePromises.push(cancelAction);

        // Since AngularJS 1.6.7, promises will be logged to $exceptionHandler when the promise
        // is not handling the rejection. We create a pseudo catch handler, which will prevent the
        // promise from being logged to the $exceptionHandler.
        return interim.deferred.promise.catch(angular.noop);
      }

      /**
       * Creates a function to wait for at least one interim element to be available.
       * @param callbackFn Function to be used as callback
       * @returns {Function}
       */
      function waitForInterim(callbackFn) {
        return function() {
          var fnArguments = arguments;

          if (!showingInterims.length) {
            // When there are still interim's opening, then wait for the first interim element to
            // finish its open animation.
            if (showPromises.length) {
              return showPromises[0].finally(function () {
                return callbackFn.apply(service, fnArguments);
              });
            }

            return $q.when("No interim elements currently showing up.");
          }

          return callbackFn.apply(service, fnArguments);
        };
      }

      /*
       * Special method to quick-remove the interim element without animations
       * Note: interim elements are in "interim containers"
       */
      function destroy(targetEl) {
        var interim = !targetEl ? showingInterims.shift() : null;

        var parentEl = angular.element(targetEl).length && angular.element(targetEl)[0].parentNode;

        if (parentEl) {
          // Try to find the interim in the stack which corresponds to the supplied DOM element.
          var filtered = showingInterims.filter(function(entry) {
            return entry.options.element[0] === parentEl;
          });

          // Note: This function might be called when the element already has been removed,
          // in which case we won't find any matches.
          if (filtered.length) {
            interim = filtered[0];
            showingInterims.splice(showingInterims.indexOf(interim), 1);
          }
        }

        return interim ? interim.remove(SHOW_CANCELLED, false, { '$destroy': true }) :
                         $q.when(SHOW_CANCELLED);
      }

      /*
       * Internal Interim Element Object
       * Used internally to manage the DOM element and related data
       */
      function InterimElement(options) {
        var self, element, showAction = $q.when(true);

        options = configureScopeAndTransitions(options);

        return self = {
          options : options,
          deferred: $q.defer(),
          show    : createAndTransitionIn,
          remove  : transitionOutAndRemove
        };

        /**
         * Compile, link, and show this interim element
         * Use optional autoHided and transition-in effects
         */
        function createAndTransitionIn() {
          return $q(function(resolve, reject) {

            // Trigger onCompiling callback before the compilation starts.
            // This is useful, when modifying options, which can be influenced by developers.
            options.onCompiling && options.onCompiling(options);

            compileElement(options)
              .then(function(compiledData) {
                element = linkElement(compiledData, options);

                // Expose the cleanup function from the compiler.
                options.cleanupElement = compiledData.cleanup;

                showAction = showElement(element, options, compiledData.controller)
                  .then(resolve, rejectAll);
              }).catch(rejectAll);

            function rejectAll(fault) {
              // Force the '$md<xxx>.show()' promise to reject
              self.deferred.reject(fault);

              // Continue rejection propagation
              reject(fault);
            }
          });
        }

        /**
         * After the show process has finished/rejected:
         * - announce 'removing',
         * - perform the transition-out, and
         * - perform optional clean up scope.
         */
        function transitionOutAndRemove(response, isCancelled, opts) {

          // abort if the show() and compile failed
          if (!element) return $q.when(false);

          options = angular.extend(options || {}, opts || {});
          options.cancelAutoHide && options.cancelAutoHide();
          options.element.triggerHandler('$mdInterimElementRemove');

          if (options.$destroy === true) {

            return hideElement(options.element, options).then(function(){
              (isCancelled && rejectAll(response)) || resolveAll(response);
            });

          } else {
            $q.when(showAction).finally(function() {
              hideElement(options.element, options).then(function() {
                isCancelled ? rejectAll(response) : resolveAll(response);
              }, rejectAll);
            });

            return self.deferred.promise;
          }


          /**
           * The `show()` returns a promise that will be resolved when the interim
           * element is hidden or cancelled...
           */
          function resolveAll(response) {
            self.deferred.resolve(response);
          }

          /**
           * Force the '$md<xxx>.show()' promise to reject
           */
          function rejectAll(fault) {
            self.deferred.reject(fault);
          }
        }

        /**
         * Prepare optional isolated scope and prepare $animate with default enter and leave
         * transitions for the new element instance.
         */
        function configureScopeAndTransitions(options) {
          options = options || { };
          if (options.template) {
            options.template = $mdUtil.processTemplate(options.template);
          }

          return angular.extend({
            preserveScope: false,
            cancelAutoHide : angular.noop,
            scope: options.scope || $rootScope.$new(options.isolateScope),

            /**
             * Default usage to enable $animate to transition-in; can be easily overridden via 'options'
             */
            onShow: function transitionIn(scope, element, options) {
              return $animate.enter(element, options.parent);
            },

            /**
             * Default usage to enable $animate to transition-out; can be easily overridden via 'options'
             */
            onRemove: function transitionOut(scope, element) {
              // Element could be undefined if a new element is shown before
              // the old one finishes compiling.
              return element && $animate.leave(element) || $q.when();
            }
          }, options);

        }

        /**
         * Compile an element with a templateUrl, controller, and locals
         */
        function compileElement(options) {

          var compiled = !options.skipCompile ? $mdCompiler.compile(options) : null;

          return compiled || $q(function (resolve) {
              resolve({
                locals: {},
                link: function () {
                  return options.element;
                }
              });
            });
        }

        /**
         *  Link an element with compiled configuration
         */
        function linkElement(compileData, options){
          angular.extend(compileData.locals, options);

          var element = compileData.link(options.scope);

          // Search for parent at insertion time, if not specified
          options.element = element;
          options.parent = findParent(element, options);
          if (options.themable) $mdTheming(element);

          return element;
        }

        /**
         * Search for parent at insertion time, if not specified
         */
        function findParent(element, options) {
          var parent = options.parent;

          // Search for parent at insertion time, if not specified
          if (angular.isFunction(parent)) {
            parent = parent(options.scope, element, options);
          } else if (angular.isString(parent)) {
            parent = angular.element($document[0].querySelector(parent));
          } else {
            parent = angular.element(parent);
          }

          // If parent querySelector/getter function fails, or it's just null,
          // find a default.
          if (!(parent || {}).length) {
            var el;
            if ($rootElement[0] && $rootElement[0].querySelector) {
              el = $rootElement[0].querySelector(':not(svg) > body');
            }
            if (!el) el = $rootElement[0];
            if (el.nodeName == '#comment') {
              el = $document[0].body;
            }
            return angular.element(el);
          }

          return parent;
        }

        /**
         * If auto-hide is enabled, start timer and prepare cancel function
         */
        function startAutoHide() {
          var autoHideTimer, cancelAutoHide = angular.noop;

          if (options.hideDelay) {
            autoHideTimer = $timeout(service.hide, options.hideDelay) ;
            cancelAutoHide = function() {
              $timeout.cancel(autoHideTimer);
            };
          }

          // Cache for subsequent use
          options.cancelAutoHide = function() {
            cancelAutoHide();
            options.cancelAutoHide = undefined;
          };
        }

        /**
         * Show the element ( with transitions), notify complete and start
         * optional auto-Hide
         */
        function showElement(element, options, controller) {
          // Trigger onShowing callback before the `show()` starts
          var notifyShowing = options.onShowing || angular.noop;
          // Trigger onComplete callback when the `show()` finishes
          var notifyComplete = options.onComplete || angular.noop;

          // Necessary for consistency between AngularJS 1.5 and 1.6.
          try {
            notifyShowing(options.scope, element, options, controller);
          } catch (e) {
            return $q.reject(e);
          }

          return $q(function (resolve, reject) {
            try {
              // Start transitionIn
              $q.when(options.onShow(options.scope, element, options, controller))
                .then(function () {
                  notifyComplete(options.scope, element, options);
                  startAutoHide();

                  resolve(element);
                }, reject);

            } catch (e) {
              reject(e.message);
            }
          });
        }

        function hideElement(element, options) {
          var announceRemoving = options.onRemoving || angular.noop;

          return $q(function (resolve, reject) {
            try {
              // Start transitionIn
              var action = $q.when(options.onRemove(options.scope, element, options) || true);

              // Trigger callback *before* the remove operation starts
              announceRemoving(element, action);

              if (options.$destroy) {
                // For $destroy, onRemove should be synchronous
                resolve(element);

                if (!options.preserveScope && options.scope) {
                  // scope destroy should still be be done after the current digest is done
                  action.then(function() { options.scope.$destroy(); });
                }
              } else {
                // Wait until transition-out is done
                action.then(function () {
                  if (!options.preserveScope && options.scope) {
                    options.scope.$destroy();
                  }

                  resolve(element);
                }, reject);
              }
            } catch (e) {
              reject(e.message);
            }
          });
        }

      }
    };

  }

}

})();
(function(){
"use strict";

(function() {
  'use strict';

  var $mdUtil, $interpolate, $log;

  var SUFFIXES = /(-gt)?-(sm|md|lg|print)/g;
  var WHITESPACE = /\s+/g;

  var FLEX_OPTIONS = ['grow', 'initial', 'auto', 'none', 'noshrink', 'nogrow'];
  var LAYOUT_OPTIONS = ['row', 'column'];
  var ALIGNMENT_MAIN_AXIS= ["", "start", "center", "end", "stretch", "space-around", "space-between"];
  var ALIGNMENT_CROSS_AXIS= ["", "start", "center", "end", "stretch"];

  var config = {
    /**
     * Enable directive attribute-to-class conversions
     * Developers can use `<body md-layout-css />` to quickly
     * disable the Layout directives and prohibit the injection of Layout classNames
     */
    enabled: true,

    /**
     * List of mediaQuery breakpoints and associated suffixes
     *
     *   [
     *    { suffix: "sm", mediaQuery: "screen and (max-width: 599px)" },
     *    { suffix: "md", mediaQuery: "screen and (min-width: 600px) and (max-width: 959px)" }
     *   ]
     */
    breakpoints: []
  };

  registerLayoutAPI(angular.module('material.core.layout', ['ng']));

  /**
   *   registerLayoutAPI()
   *
   *   The original AngularJS Material Layout solution used attribute selectors and CSS.
   *
   *  ```html
   *  <div layout="column"> My Content </div>
   *  ```
   *
   *  ```css
   *  [layout] {
   *    box-sizing: border-box;
   *    display:flex;
   *  }
   *  [layout=column] {
   *    flex-direction : column
   *  }
   *  ```
   *
   *  Use of attribute selectors creates significant performance impacts in some
   *  browsers... mainly IE.
   *
   *  This module registers directives that allow the same layout attributes to be
   *  interpreted and converted to class selectors. The directive will add equivalent classes to each element that
   *  contains a Layout directive.
   *
   * ```html
   *   <div layout="column" class="layout layout-column"> My Content </div>
   *```
   *
   *  ```css
   *  .layout {
   *    box-sizing: border-box;
   *    display:flex;
   *  }
   *  .layout-column {
   *    flex-direction : column
   *  }
   *  ```
   */
  function registerLayoutAPI(module){
    var PREFIX_REGEXP = /^((?:x|data)[:\-_])/i;
    var SPECIAL_CHARS_REGEXP = /([:\-_]+(.))/g;

    // NOTE: these are also defined in constants::MEDIA_PRIORITY and constants::MEDIA
    var BREAKPOINTS     = ["", "xs", "gt-xs", "sm", "gt-sm", "md", "gt-md", "lg", "gt-lg", "xl", "print"];
    var API_WITH_VALUES = ["layout", "flex", "flex-order", "flex-offset", "layout-align"];
    var API_NO_VALUES   = ["show", "hide", "layout-padding", "layout-margin"];


    // Build directive registration functions for the standard Layout API... for all breakpoints.
    angular.forEach(BREAKPOINTS, function(mqb) {

      // Attribute directives with expected, observable value(s)
      angular.forEach(API_WITH_VALUES, function(name){
        var fullName = mqb ? name + "-" + mqb : name;
        module.directive(directiveNormalize(fullName), attributeWithObserve(fullName));
      });

      // Attribute directives with no expected value(s)
      angular.forEach(API_NO_VALUES, function(name){
        var fullName = mqb ? name + "-" + mqb : name;
        module.directive(directiveNormalize(fullName), attributeWithoutValue(fullName));
      });

    });

    // Register other, special directive functions for the Layout features:
    module

      .provider('$$mdLayout'     , function() {
        // Publish internal service for Layouts
        return {
          $get : angular.noop,
          validateAttributeValue : validateAttributeValue,
          validateAttributeUsage : validateAttributeUsage,
          /**
           * Easy way to disable/enable the Layout API.
           * When disabled, this stops all attribute-to-classname generations
           */
          disableLayouts  : function(isDisabled) {
            config.enabled =  (isDisabled !== true);
          }
        };
      })

      .directive('mdLayoutCss'        , disableLayoutDirective)
      .directive('ngCloak'            , buildCloakInterceptor('ng-cloak'))

      .directive('layoutWrap'   , attributeWithoutValue('layout-wrap'))
      .directive('layoutNowrap' , attributeWithoutValue('layout-nowrap'))
      .directive('layoutNoWrap' , attributeWithoutValue('layout-no-wrap'))
      .directive('layoutFill'   , attributeWithoutValue('layout-fill'))

      // !! Deprecated attributes: use the `-lt` (aka less-than) notations

      .directive('layoutLtMd'     , warnAttrNotSupported('layout-lt-md', true))
      .directive('layoutLtLg'     , warnAttrNotSupported('layout-lt-lg', true))
      .directive('flexLtMd'       , warnAttrNotSupported('flex-lt-md', true))
      .directive('flexLtLg'       , warnAttrNotSupported('flex-lt-lg', true))

      .directive('layoutAlignLtMd', warnAttrNotSupported('layout-align-lt-md'))
      .directive('layoutAlignLtLg', warnAttrNotSupported('layout-align-lt-lg'))
      .directive('flexOrderLtMd'  , warnAttrNotSupported('flex-order-lt-md'))
      .directive('flexOrderLtLg'  , warnAttrNotSupported('flex-order-lt-lg'))
      .directive('offsetLtMd'     , warnAttrNotSupported('flex-offset-lt-md'))
      .directive('offsetLtLg'     , warnAttrNotSupported('flex-offset-lt-lg'))

      .directive('hideLtMd'       , warnAttrNotSupported('hide-lt-md'))
      .directive('hideLtLg'       , warnAttrNotSupported('hide-lt-lg'))
      .directive('showLtMd'       , warnAttrNotSupported('show-lt-md'))
      .directive('showLtLg'       , warnAttrNotSupported('show-lt-lg'))

      // Determine if
      .config(detectDisabledLayouts);

    /**
     * Converts snake_case to camelCase.
     * Also there is special case for Moz prefix starting with upper case letter.
     * @param name Name to normalize
     */
    function directiveNormalize(name) {
      return name
        .replace(PREFIX_REGEXP, '')
        .replace(SPECIAL_CHARS_REGEXP, function(_, separator, letter, offset) {
          return offset ? letter.toUpperCase() : letter;
        });
    }

  }


  /**
    * Detect if any of the HTML tags has a [md-layouts-disabled] attribute;
    * If yes, then immediately disable all layout API features
    *
    * Note: this attribute should be specified on either the HTML or BODY tags
    */
   /**
    * @ngInject
    */
   function detectDisabledLayouts() {
     var isDisabled = !!document.querySelector('[md-layouts-disabled]');
     config.enabled = !isDisabled;
   }

  /**
   * Special directive that will disable ALL Layout conversions of layout
   * attribute(s) to classname(s).
   *
   * <link rel="stylesheet" href="angular-material.min.css">
   * <link rel="stylesheet" href="angular-material.layout.css">
   *
   * <body md-layout-css>
   *  ...
   * </body>
   *
   * Note: Using md-layout-css directive requires the developer to load the Material
   * Layout Attribute stylesheet (which only uses attribute selectors):
   *
   *       `angular-material.layout.css`
   *
   * Another option is to use the LayoutProvider to configure and disable the attribute
   * conversions; this would obviate the use of the `md-layout-css` directive
   *
   */
  function disableLayoutDirective() {
    // Return a 1x-only, first-match attribute directive
    config.enabled = false;

    return {
      restrict : 'A',
      priority : '900'
    };
  }

  /**
   * Tail-hook ngCloak to delay the uncloaking while Layout transformers
   * finish processing. Eliminates flicker with Material.Layouts
   */
  function buildCloakInterceptor(className) {
    return ['$timeout', function($timeout){
      return {
        restrict : 'A',
        priority : -10,   // run after normal ng-cloak
        compile  : function(element) {
          if (!config.enabled) return angular.noop;

          // Re-add the cloak
          element.addClass(className);

          return function(scope, element) {
            // Wait while layout injectors configure, then uncloak
            // NOTE: $rAF does not delay enough... and this is a 1x-only event,
            //       $timeout is acceptable.
            $timeout(function(){
              element.removeClass(className);
            }, 10, false);
          };
        }
      };
    }];
  }


  // *********************************************************************************
  //
  // These functions create registration functions for AngularJS Material Layout attribute directives
  // This provides easy translation to switch AngularJS Material attribute selectors to
  // CLASS selectors and directives; which has huge performance implications
  // for IE Browsers
  //
  // *********************************************************************************

  /**
   * Creates a directive registration function where a possible dynamic attribute
   * value will be observed/watched.
   * @param {string} className attribute name; eg `layout-gt-md` with value ="row"
   */
  function attributeWithObserve(className) {

    return ['$mdUtil', '$interpolate', "$log", function(_$mdUtil_, _$interpolate_, _$log_) {
      $mdUtil = _$mdUtil_;
      $interpolate = _$interpolate_;
      $log = _$log_;

      return {
        restrict: 'A',
        compile: function(element, attr) {
          var linkFn;
          if (config.enabled) {
            // immediately replace static (non-interpolated) invalid values...

            validateAttributeUsage(className, attr, element, $log);

            validateAttributeValue(className,
              getNormalizedAttrValue(className, attr, ""),
              buildUpdateFn(element, className, attr)
            );

            linkFn = translateWithValueToCssClass;
          }

          // Use for postLink to account for transforms after ng-transclude.
          return linkFn || angular.noop;
        }
      };
    }];

    /**
     * Add as transformed class selector(s), then
     * remove the deprecated attribute selector
     */
    function translateWithValueToCssClass(scope, element, attrs) {
      var updateFn = updateClassWithValue(element, className, attrs);
      var unwatch = attrs.$observe(attrs.$normalize(className), updateFn);

      updateFn(getNormalizedAttrValue(className, attrs, ""));
      scope.$on("$destroy", function() { unwatch(); });
    }
  }

  /**
   * Creates a registration function for AngularJS Material Layout attribute directive.
   * This is a `simple` transpose of attribute usage to class usage; where we ignore
   * any attribute value
   */
  function attributeWithoutValue(className) {
    return ['$mdUtil', '$interpolate', "$log", function(_$mdUtil_, _$interpolate_, _$log_) {
      $mdUtil = _$mdUtil_;
      $interpolate = _$interpolate_;
      $log = _$log_;

      return {
        restrict: 'A',
        compile: function(element, attr) {
          var linkFn;
          if (config.enabled) {
            // immediately replace static (non-interpolated) invalid values...

            validateAttributeValue(className,
              getNormalizedAttrValue(className, attr, ""),
              buildUpdateFn(element, className, attr)
            );

            translateToCssClass(null, element);

            // Use for postLink to account for transforms after ng-transclude.
            linkFn = translateToCssClass;
          }

          return linkFn || angular.noop;
        }
      };
    }];

    /**
     * Add as transformed class selector, then
     * remove the deprecated attribute selector
     */
    function translateToCssClass(scope, element) {
      element.addClass(className);
    }
  }



  /**
   * After link-phase, do NOT remove deprecated layout attribute selector.
   * Instead watch the attribute so interpolated data-bindings to layout
   * selectors will continue to be supported.
   *
   * $observe() the className and update with new class (after removing the last one)
   *
   * e.g. `layout="{{layoutDemo.direction}}"` will update...
   *
   * NOTE: The value must match one of the specified styles in the CSS.
   * For example `flex-gt-md="{{size}}`  where `scope.size == 47` will NOT work since
   * only breakpoints for 0, 5, 10, 15... 100, 33, 34, 66, 67 are defined.
   *
   */
  function updateClassWithValue(element, className) {
    var lastClass;

    return function updateClassFn(newValue) {
      var value = validateAttributeValue(className, newValue || "");
      if (angular.isDefined(value)) {
        if (lastClass) element.removeClass(lastClass);
        lastClass = !value ? className : className + "-" + value.trim().replace(WHITESPACE, "-");
        element.addClass(lastClass);
      }
    };
  }

  /**
   * Provide console warning that this layout attribute has been deprecated
   *
   */
  function warnAttrNotSupported(className) {
    var parts = className.split("-");
    return ["$log", function($log) {
      $log.warn(className + "has been deprecated. Please use a `" + parts[0] + "-gt-<xxx>` variant.");
      return angular.noop;
    }];
  }

  /**
   * Centralize warnings for known flexbox issues (especially IE-related issues)
   */
  function validateAttributeUsage(className, attr, element, $log){
    var message, usage, url;
    var nodeName = element[0].nodeName.toLowerCase();

    switch (className.replace(SUFFIXES,"")) {
      case "flex":
        if ((nodeName == "md-button") || (nodeName == "fieldset")){
          // @see https://github.com/philipwalton/flexbugs#9-some-html-elements-cant-be-flex-containers
          // Use <div flex> wrapper inside (preferred) or outside

          usage = "<" + nodeName + " " + className + "></" + nodeName + ">";
          url = "https://github.com/philipwalton/flexbugs#9-some-html-elements-cant-be-flex-containers";
          message = "Markup '{0}' may not work as expected in IE Browsers. Consult '{1}' for details.";

          $log.warn($mdUtil.supplant(message, [usage, url]));
        }
    }

  }


  /**
   * For the Layout attribute value, validate or replace with default
   * fallback value
   */
  function validateAttributeValue(className, value, updateFn) {
    var origValue;

    if (!needsInterpolation(value)) {
      switch (className.replace(SUFFIXES,"")) {
        case 'layout'        :
          if (!findIn(value, LAYOUT_OPTIONS)) {
            value = LAYOUT_OPTIONS[0];    // 'row';
          }
          break;

        case 'flex'          :
          if (!findIn(value, FLEX_OPTIONS)) {
            if (isNaN(value)) {
              value = '';
            }
          }
          break;

        case 'flex-offset' :
        case 'flex-order'    :
          if (!value || isNaN(+value)) {
            value = '0';
          }
          break;

        case 'layout-align'  :
          var axis = extractAlignAxis(value);
          value = $mdUtil.supplant("{main}-{cross}",axis);
          break;

        case 'layout-padding' :
        case 'layout-margin'  :
        case 'layout-fill'    :
        case 'layout-wrap'    :
        case 'layout-nowrap' :
          value = '';
          break;
      }

      if (value != origValue) {
        (updateFn || angular.noop)(value);
      }
    }

    return value ? value.trim() : "";
  }

  /**
   * Replace current attribute value with fallback value
   */
  function buildUpdateFn(element, className, attrs) {
    return function updateAttrValue(fallback) {
      if (!needsInterpolation(fallback)) {
        // Do not modify the element's attribute value; so
        // uses '<ui-layout layout="/api/sidebar.html" />' will not
        // be affected. Just update the attrs value.
        attrs[attrs.$normalize(className)] = fallback;
      }
    };
  }

  /**
   * See if the original value has interpolation symbols:
   * e.g.  flex-gt-md="{{triggerPoint}}"
   */
  function needsInterpolation(value) {
    return (value || "").indexOf($interpolate.startSymbol()) > -1;
  }

  function getNormalizedAttrValue(className, attrs, defaultVal) {
    var normalizedAttr = attrs.$normalize(className);
    return attrs[normalizedAttr] ? attrs[normalizedAttr].trim().replace(WHITESPACE, "-") : defaultVal || null;
  }

  function findIn(item, list, replaceWith) {
    item = replaceWith && item ? item.replace(WHITESPACE, replaceWith) : item;

    var found = false;
    if (item) {
      list.forEach(function(it) {
        it = replaceWith ? it.replace(WHITESPACE, replaceWith) : it;
        found = found || (it === item);
      });
    }
    return found;
  }

  function extractAlignAxis(attrValue) {
    var axis = {
      main : "start",
      cross: "stretch"
    }, values;

    attrValue = (attrValue || "");

    if (attrValue.indexOf("-") === 0 || attrValue.indexOf(" ") === 0) {
      // For missing main-axis values
      attrValue = "none" + attrValue;
    }

    values = attrValue.toLowerCase().trim().replace(WHITESPACE, "-").split("-");
    if (values.length && (values[0] === "space")) {
      // for main-axis values of "space-around" or "space-between"
      values = [values[0]+"-"+values[1],values[2]];
    }

    if (values.length > 0) axis.main  = values[0] || axis.main;
    if (values.length > 1) axis.cross = values[1] || axis.cross;

    if (ALIGNMENT_MAIN_AXIS.indexOf(axis.main) < 0)   axis.main = "start";
    if (ALIGNMENT_CROSS_AXIS.indexOf(axis.cross) < 0) axis.cross = "stretch";

    return axis;
  }


})();

})();
(function(){
"use strict";

/**
 * @ngdoc module
 * @name material.core.liveannouncer
 * @description
 * AngularJS Material Live Announcer to provide accessibility for Voice Readers.
 */
MdLiveAnnouncer.$inject = ["$timeout"];
angular
  .module('material.core')
  .service('$mdLiveAnnouncer', MdLiveAnnouncer);

/**
 * @ngdoc service
 * @name $mdLiveAnnouncer
 * @module material.core.liveannouncer
 *
 * @description
 *
 * Service to announce messages to supported screenreaders.
 *
 * > The `$mdLiveAnnouncer` service is internally used for components to provide proper accessibility.
 *
 * <hljs lang="js">
 *   module.controller('AppCtrl', function($mdLiveAnnouncer) {
 *     // Basic announcement (Polite Mode)
 *     $mdLiveAnnouncer.announce('Hey Google');
 *
 *     // Custom announcement (Assertive Mode)
 *     $mdLiveAnnouncer.announce('Hey Google', 'assertive');
 *   });
 * </hljs>
 *
 */
function MdLiveAnnouncer($timeout) {
  /** @private @const @type {!angular.$timeout} */
  this._$timeout = $timeout;

  /** @private @const @type {!HTMLElement} */
  this._liveElement = this._createLiveElement();

  /** @private @const @type {!number} */
  this._announceTimeout = 100;
}

/**
 * @ngdoc method
 * @name $mdLiveAnnouncer#announce
 * @description Announces messages to supported screenreaders.
 * @param {string} message Message to be announced to the screenreader
 * @param {'off'|'polite'|'assertive'} politeness The politeness of the announcer element.
 */
MdLiveAnnouncer.prototype.announce = function(message, politeness) {
  if (!politeness) {
    politeness = 'polite';
  }

  var self = this;

  self._liveElement.textContent = '';
  self._liveElement.setAttribute('aria-live', politeness);

  // This 100ms timeout is necessary for some browser + screen-reader combinations:
  // - Both JAWS and NVDA over IE11 will not announce anything without a non-zero timeout.
  // - With Chrome and IE11 with NVDA or JAWS, a repeated (identical) message won't be read a
  //   second time without clearing and then using a non-zero delay.
  // (using JAWS 17 at time of this writing).
  self._$timeout(function() {
    self._liveElement.textContent = message;
  }, self._announceTimeout, false);
};

/**
 * Creates a live announcer element, which listens for DOM changes and announces them
 * to the screenreaders.
 * @returns {!HTMLElement}
 * @private
 */
MdLiveAnnouncer.prototype._createLiveElement = function() {
  var liveEl = document.createElement('div');

  liveEl.classList.add('md-visually-hidden');
  liveEl.setAttribute('role', 'status');
  liveEl.setAttribute('aria-atomic', 'true');
  liveEl.setAttribute('aria-live', 'polite');

  document.body.appendChild(liveEl);

  return liveEl;
};

})();
(function(){
"use strict";

/**
 * @ngdoc service
 * @name $$mdMeta
 * @module material.core.meta
 *
 * @description
 *
 * A provider and a service that simplifies meta tags access
 *
 * Note: This is intended only for use with dynamic meta tags such as browser color and title.
 * Tags that are only processed when the page is rendered (such as `charset`, and `http-equiv`)
 * will not work since `$$mdMeta` adds the tags after the page has already been loaded.
 *
 * ```js
 * app.config(function($$mdMetaProvider) {
 *   var removeMeta = $$mdMetaProvider.setMeta('meta-name', 'content');
 *   var metaValue  = $$mdMetaProvider.getMeta('meta-name'); // -> 'content'
 *
 *   removeMeta();
 * });
 *
 * app.controller('myController', function($$mdMeta) {
 *   var removeMeta = $$mdMeta.setMeta('meta-name', 'content');
 *   var metaValue  = $$mdMeta.getMeta('meta-name'); // -> 'content'
 *
 *   removeMeta();
 * });
 * ```
 *
 * @returns {$$mdMeta.$service}
 *
 */
angular.module('material.core.meta', [])
  .provider('$$mdMeta', function () {
    var head = angular.element(document.head);
    var metaElements = {};

    /**
     * Checks if the requested element was written manually and maps it
     *
     * @param {string} name meta tag 'name' attribute value
     * @returns {boolean} returns true if there is an element with the requested name
     */
    function mapExistingElement(name) {
      if (metaElements[name]) {
        return true;
      }

      var element = document.getElementsByName(name)[0];

      if (!element) {
        return false;
      }

      metaElements[name] = angular.element(element);

      return true;
    }

    /**
     * @ngdoc method
     * @name $$mdMeta#setMeta
     *
     * @description
     * Creates meta element with the 'name' and 'content' attributes,
     * if the meta tag is already created than we replace the 'content' value
     *
     * @param {string} name meta tag 'name' attribute value
     * @param {string} content meta tag 'content' attribute value
     * @returns {function} remove function
     *
     */
    function setMeta(name, content) {
      mapExistingElement(name);

      if (!metaElements[name]) {
        var newMeta = angular.element('<meta name="' + name + '" content="' + content + '"/>');
        head.append(newMeta);
        metaElements[name] = newMeta;
      }
      else {
        metaElements[name].attr('content', content);
      }

      return function () {
        metaElements[name].attr('content', '');
        metaElements[name].remove();
        delete metaElements[name];
      };
    }

    /**
     * @ngdoc method
     * @name $$mdMeta#getMeta
     *
     * @description
     * Gets the 'content' attribute value of the wanted meta element
     *
     * @param {string} name meta tag 'name' attribute value
     * @returns {string} content attribute value
     */
    function getMeta(name) {
      if (!mapExistingElement(name)) {
        throw Error('$$mdMeta: could not find a meta tag with the name \'' + name + '\'');
      }

      return metaElements[name].attr('content');
    }

    var module = {
      setMeta: setMeta,
      getMeta: getMeta
    };

    return angular.extend({}, module, {
      $get: function () {
        return module;
      }
    });
  });
})();
(function(){
"use strict";

  /**
   * @ngdoc module
   * @name material.core.componentRegistry
   *
   * @description
   * A component instance registration service.
   * Note: currently this as a private service in the SideNav component.
   */
  ComponentRegistry.$inject = ["$log", "$q"];
  angular.module('material.core')
    .factory('$mdComponentRegistry', ComponentRegistry);

  /*
   * @private
   * @ngdoc factory
   * @name ComponentRegistry
   * @module material.core.componentRegistry
   *
   */
  function ComponentRegistry($log, $q) {

    var self;
    var instances = [];
    var pendings = { };

    return self = {
      /**
       * Used to print an error when an instance for a handle isn't found.
       */
      notFoundError: function(handle, msgContext) {
        $log.error((msgContext || "") + 'No instance found for handle', handle);
      },
      /**
       * Return all registered instances as an array.
       */
      getInstances: function() {
        return instances;
      },

      /**
       * Get a registered instance.
       * @param handle the String handle to look up for a registered instance.
       */
      get: function(handle) {
        if (!isValidID(handle)) return null;

        var i, j, instance;
        for (i = 0, j = instances.length; i < j; i++) {
          instance = instances[i];
          if (instance.$$mdHandle === handle) {
            return instance;
          }
        }
        return null;
      },

      /**
       * Register an instance.
       * @param instance the instance to register
       * @param handle the handle to identify the instance under.
       */
      register: function(instance, handle) {
        if (!handle) return angular.noop;

        instance.$$mdHandle = handle;
        instances.push(instance);
        resolveWhen();

        return deregister;

        /**
         * Remove registration for an instance
         */
        function deregister() {
          var index = instances.indexOf(instance);
          if (index !== -1) {
            instances.splice(index, 1);
          }
        }

        /**
         * Resolve any pending promises for this instance
         */
        function resolveWhen() {
          var dfd = pendings[handle];
          if (dfd) {
            dfd.forEach(function (promise) {
              promise.resolve(instance);
            });
            delete pendings[handle];
          }
        }
      },

      /**
       * Async accessor to registered component instance
       * If not available then a promise is created to notify
       * all listeners when the instance is registered.
       */
      when : function(handle) {
        if (isValidID(handle)) {
          var deferred = $q.defer();
          var instance = self.get(handle);

          if (instance)  {
            deferred.resolve(instance);
          } else {
            if (pendings[handle] === undefined) {
              pendings[handle] = [];
            }
            pendings[handle].push(deferred);
          }

          return deferred.promise;
        }
        return $q.reject("Invalid `md-component-id` value.");
      }

    };

    function isValidID(handle){
      return handle && (handle !== "");
    }

  }

})();
(function(){
"use strict";

(function() {
  'use strict';

  /**
   * @ngdoc service
   * @name $mdButtonInkRipple
   * @module material.core
   *
   * @description
   * Provides ripple effects for md-button.  See $mdInkRipple service for all possible configuration options.
   *
   * @param {object=} scope Scope within the current context
   * @param {object=} element The element the ripple effect should be applied to
   * @param {object=} options (Optional) Configuration options to override the default ripple configuration
   */

  MdButtonInkRipple.$inject = ["$mdInkRipple"];
  angular.module('material.core')
    .factory('$mdButtonInkRipple', MdButtonInkRipple);

  function MdButtonInkRipple($mdInkRipple) {
    return {
      attach: function attachRipple(scope, element, options) {
        options = angular.extend(optionsForElement(element), options);

        return $mdInkRipple.attach(scope, element, options);
      }
    };

    function optionsForElement(element) {
      if (element.hasClass('md-icon-button')) {
        return {
          isMenuItem: element.hasClass('md-menu-item'),
          fitRipple: true,
          center: true
        };
      } else {
        return {
          isMenuItem: element.hasClass('md-menu-item'),
          dimBackground: true
        };
      }
    }
  }
})();

})();
(function(){
"use strict";

(function() {
  'use strict';

    /**
   * @ngdoc service
   * @name $mdCheckboxInkRipple
   * @module material.core
   *
   * @description
   * Provides ripple effects for md-checkbox.  See $mdInkRipple service for all possible configuration options.
   *
   * @param {object=} scope Scope within the current context
   * @param {object=} element The element the ripple effect should be applied to
   * @param {object=} options (Optional) Configuration options to override the defaultripple configuration
   */

  MdCheckboxInkRipple.$inject = ["$mdInkRipple"];
  angular.module('material.core')
    .factory('$mdCheckboxInkRipple', MdCheckboxInkRipple);

  function MdCheckboxInkRipple($mdInkRipple) {
    return {
      attach: attach
    };

    function attach(scope, element, options) {
      return $mdInkRipple.attach(scope, element, angular.extend({
        center: true,
        dimBackground: false,
        fitRipple: true
      }, options));
    }
  }
})();

})();
(function(){
"use strict";

(function() {
  'use strict';

  /**
   * @ngdoc service
   * @name $mdListInkRipple
   * @module material.core
   *
   * @description
   * Provides ripple effects for md-list.  See $mdInkRipple service for all possible configuration options.
   *
   * @param {object=} scope Scope within the current context
   * @param {object=} element The element the ripple effect should be applied to
   * @param {object=} options (Optional) Configuration options to override the defaultripple configuration
   */

  MdListInkRipple.$inject = ["$mdInkRipple"];
  angular.module('material.core')
    .factory('$mdListInkRipple', MdListInkRipple);

  function MdListInkRipple($mdInkRipple) {
    return {
      attach: attach
    };

    function attach(scope, element, options) {
      return $mdInkRipple.attach(scope, element, angular.extend({
        center: false,
        dimBackground: true,
        outline: false,
        rippleSize: 'full'
      }, options));
    }
  }
})();

})();
(function(){
"use strict";

/**
 * @ngdoc module
 * @name material.core.ripple
 * @description
 * Ripple
 */
InkRippleCtrl.$inject = ["$scope", "$element", "rippleOptions", "$window", "$timeout", "$mdUtil", "$mdColorUtil"];
InkRippleDirective.$inject = ["$mdButtonInkRipple", "$mdCheckboxInkRipple"];
angular.module('material.core')
    .provider('$mdInkRipple', InkRippleProvider)
    .directive('mdInkRipple', InkRippleDirective)
    .directive('mdNoInk', attrNoDirective)
    .directive('mdNoBar', attrNoDirective)
    .directive('mdNoStretch', attrNoDirective);

var DURATION = 450;

/**
 * @ngdoc directive
 * @name mdInkRipple
 * @module material.core.ripple
 *
 * @description
 * The `md-ink-ripple` directive allows you to specify the ripple color or if a ripple is allowed.
 *
 * @param {string|boolean} md-ink-ripple A color string `#FF0000` or boolean (`false` or `0`) for
 *  preventing ripple
 *
 * @usage
 * ### String values
 * <hljs lang="html">
 *   <ANY md-ink-ripple="#FF0000">
 *     Ripples in red
 *   </ANY>
 *
 *   <ANY md-ink-ripple="false">
 *     Not rippling
 *   </ANY>
 * </hljs>
 *
 * ### Interpolated values
 * <hljs lang="html">
 *   <ANY md-ink-ripple="{{ randomColor() }}">
 *     Ripples with the return value of 'randomColor' function
 *   </ANY>
 *
 *   <ANY md-ink-ripple="{{ canRipple() }}">
 *     Ripples if 'canRipple' function return value is not 'false' or '0'
 *   </ANY>
 * </hljs>
 */
function InkRippleDirective ($mdButtonInkRipple, $mdCheckboxInkRipple) {
  return {
    controller: angular.noop,
    link:       function (scope, element, attr) {
      attr.hasOwnProperty('mdInkRippleCheckbox')
          ? $mdCheckboxInkRipple.attach(scope, element)
          : $mdButtonInkRipple.attach(scope, element);
    }
  };
}

/**
 * @ngdoc service
 * @name $mdInkRipple
 * @module material.core.ripple
 *
 * @description
 * `$mdInkRipple` is a service for adding ripples to any element.
 *
 * @usage
 * <hljs lang="js">
 * app.factory('$myElementInkRipple', function($mdInkRipple) {
 *   return {
 *     attach: function (scope, element, options) {
 *       return $mdInkRipple.attach(scope, element, angular.extend({
 *         center: false,
 *         dimBackground: true
 *       }, options));
 *     }
 *   };
 * });
 *
 * app.controller('myController', function ($scope, $element, $myElementInkRipple) {
 *   $scope.onClick = function (ev) {
 *     $myElementInkRipple.attach($scope, angular.element(ev.target), { center: true });
 *   }
 * });
 * </hljs>
 */

/**
 * @ngdoc service
 * @name $mdInkRippleProvider
 * @module material.core.ripple
 *
 * @description
  * If you want to disable ink ripples globally, for all components, you can call the
 * `disableInkRipple` method in your app's config.
 *
 *
 * @usage
 * <hljs lang="js">
 * app.config(function ($mdInkRippleProvider) {
 *   $mdInkRippleProvider.disableInkRipple();
 * });
 * </hljs>
 */

function InkRippleProvider () {
  var isDisabledGlobally = false;

  return {
    disableInkRipple: disableInkRipple,
    $get: ["$injector", function($injector) {
      return { attach: attach };

      /**
       * @ngdoc method
       * @name $mdInkRipple#attach
       *
       * @description
       * Attaching given scope, element and options to inkRipple controller
       *
       * @param {object=} scope Scope within the current context
       * @param {object=} element The element the ripple effect should be applied to
       * @param {object=} options (Optional) Configuration options to override the defaultRipple configuration
       * * `center` -  Whether the ripple should start from the center of the container element
       * * `dimBackground` - Whether the background should be dimmed with the ripple color
       * * `colorElement` - The element the ripple should take its color from, defined by css property `color`
       * * `fitRipple` - Whether the ripple should fill the element
       */
      function attach (scope, element, options) {
        if (isDisabledGlobally || element.controller('mdNoInk')) return angular.noop;
        return $injector.instantiate(InkRippleCtrl, {
          $scope:        scope,
          $element:      element,
          rippleOptions: options
        });
      }
    }]
  };

  /**
   * @ngdoc method
   * @name $mdInkRippleProvider#disableInkRipple
   *
   * @description
   * A config-time method that, when called, disables ripples globally.
   */
  function disableInkRipple () {
    isDisabledGlobally = true;
  }
}

/**
 * Controller used by the ripple service in order to apply ripples
 * @ngInject
 */
function InkRippleCtrl ($scope, $element, rippleOptions, $window, $timeout, $mdUtil, $mdColorUtil) {
  this.$window    = $window;
  this.$timeout   = $timeout;
  this.$mdUtil    = $mdUtil;
  this.$mdColorUtil    = $mdColorUtil;
  this.$scope     = $scope;
  this.$element   = $element;
  this.options    = rippleOptions;
  this.mousedown  = false;
  this.ripples    = [];
  this.timeout    = null; // Stores a reference to the most-recent ripple timeout
  this.lastRipple = null;

  $mdUtil.valueOnUse(this, 'container', this.createContainer);

  this.$element.addClass('md-ink-ripple');

  // attach method for unit tests
  ($element.controller('mdInkRipple') || {}).createRipple = angular.bind(this, this.createRipple);
  ($element.controller('mdInkRipple') || {}).setColor = angular.bind(this, this.color);

  this.bindEvents();
}


/**
 * Either remove or unlock any remaining ripples when the user mouses off of the element (either by
 * mouseup or mouseleave event)
 */
function autoCleanup (self, cleanupFn) {
  if (self.mousedown || self.lastRipple) {
    self.mousedown = false;
    self.$mdUtil.nextTick(angular.bind(self, cleanupFn), false);
  }
}


/**
 * Returns the color that the ripple should be (either based on CSS or hard-coded)
 * @returns {string}
 */
InkRippleCtrl.prototype.color = function (value) {
  var self = this;

  // If assigning a color value, apply it to background and the ripple color
  if (angular.isDefined(value)) {
    self._color = self._parseColor(value);
  }

  // If color lookup, use assigned, defined, or inherited
  return self._color || self._parseColor(self.inkRipple()) || self._parseColor(getElementColor());

  /**
   * Finds the color element and returns its text color for use as default ripple color
   * @returns {string}
   */
  function getElementColor () {
    var items = self.options && self.options.colorElement ? self.options.colorElement : [];
    var elem =  items.length ? items[ 0 ] : self.$element[ 0 ];

    return elem ? self.$window.getComputedStyle(elem).color : 'rgb(0,0,0)';
  }
};

/**
 * Updating the ripple colors based on the current inkRipple value
 * or the element's computed style color
 */
InkRippleCtrl.prototype.calculateColor = function () {
  return this.color();
};


/**
 * Takes a string color and converts it to RGBA format
 * @param {string} color
 * @param {number} multiplier
 * @returns {string}
 */
InkRippleCtrl.prototype._parseColor = function parseColor (color, multiplier) {
  multiplier = multiplier || 1;
  var colorUtil = this.$mdColorUtil;

  if (!color) return;
  if (color.indexOf('rgba') === 0) return color.replace(/\d?\.?\d*\s*\)\s*$/, (0.1 * multiplier).toString() + ')');
  if (color.indexOf('rgb') === 0) return colorUtil.rgbToRgba(color);
  if (color.indexOf('#') === 0) return colorUtil.hexToRgba(color);

};

/**
 * Binds events to the root element for
 */
InkRippleCtrl.prototype.bindEvents = function () {
  this.$element.on('mousedown', angular.bind(this, this.handleMousedown));
  this.$element.on('mouseup touchend', angular.bind(this, this.handleMouseup));
  this.$element.on('mouseleave', angular.bind(this, this.handleMouseup));
  this.$element.on('touchmove', angular.bind(this, this.handleTouchmove));
};

/**
 * Create a new ripple on every mousedown event from the root element
 * @param event {MouseEvent}
 */
InkRippleCtrl.prototype.handleMousedown = function (event) {
  if (this.mousedown) return;

  // When jQuery is loaded, we have to get the original event
  if (event.hasOwnProperty('originalEvent')) event = event.originalEvent;
  this.mousedown = true;
  if (this.options.center) {
    this.createRipple(this.container.prop('clientWidth') / 2, this.container.prop('clientWidth') / 2);
  } else {

    // We need to calculate the relative coordinates if the target is a sublayer of the ripple element
    if (event.srcElement !== this.$element[0]) {
      var layerRect = this.$element[0].getBoundingClientRect();
      var layerX = event.clientX - layerRect.left;
      var layerY = event.clientY - layerRect.top;

      this.createRipple(layerX, layerY);
    } else {
      this.createRipple(event.offsetX, event.offsetY);
    }
  }
};

/**
 * Either remove or unlock any remaining ripples when the user mouses off of the element (either by
 * mouseup, touchend or mouseleave event)
 */
InkRippleCtrl.prototype.handleMouseup = function () {
  this.$timeout(function () {
    autoCleanup(this, this.clearRipples);
  }.bind(this));
};

/**
 * Either remove or unlock any remaining ripples when the user mouses off of the element (by
 * touchmove)
 */
InkRippleCtrl.prototype.handleTouchmove = function () {
  autoCleanup(this, this.deleteRipples);
};

/**
 * Cycles through all ripples and attempts to remove them.
 */
InkRippleCtrl.prototype.deleteRipples = function () {
  for (var i = 0; i < this.ripples.length; i++) {
    this.ripples[ i ].remove();
  }
};

/**
 * Cycles through all ripples and attempts to remove them with fade.
 * Depending on logic within `fadeInComplete`, some removals will be postponed.
 */
InkRippleCtrl.prototype.clearRipples = function () {
  for (var i = 0; i < this.ripples.length; i++) {
    this.fadeInComplete(this.ripples[ i ]);
  }
};

/**
 * Creates the ripple container element
 * @returns {*}
 */
InkRippleCtrl.prototype.createContainer = function () {
  var container = angular.element('<div class="md-ripple-container"></div>');
  this.$element.append(container);
  return container;
};

InkRippleCtrl.prototype.clearTimeout = function () {
  if (this.timeout) {
    this.$timeout.cancel(this.timeout);
    this.timeout = null;
  }
};

InkRippleCtrl.prototype.isRippleAllowed = function () {
  var element = this.$element[0];
  do {
    if (!element.tagName || element.tagName === 'BODY') break;

    if (element && angular.isFunction(element.hasAttribute)) {
      if (element.hasAttribute('disabled')) return false;
      if (this.inkRipple() === 'false' || this.inkRipple() === '0') return false;
    }

  } while (element = element.parentNode);
  return true;
};

/**
 * The attribute `md-ink-ripple` may be a static or interpolated
 * color value OR a boolean indicator (used to disable ripples)
 */
InkRippleCtrl.prototype.inkRipple = function () {
  return this.$element.attr('md-ink-ripple');
};

/**
 * Creates a new ripple and adds it to the container.  Also tracks ripple in `this.ripples`.
 * @param left
 * @param top
 */
InkRippleCtrl.prototype.createRipple = function (left, top) {
  if (!this.isRippleAllowed()) return;

  var ctrl        = this;
  var colorUtil   = ctrl.$mdColorUtil;
  var ripple      = angular.element('<div class="md-ripple"></div>');
  var width       = this.$element.prop('clientWidth');
  var height      = this.$element.prop('clientHeight');
  var x           = Math.max(Math.abs(width - left), left) * 2;
  var y           = Math.max(Math.abs(height - top), top) * 2;
  var size        = getSize(this.options.fitRipple, x, y);
  var color       = this.calculateColor();

  ripple.css({
    left:            left + 'px',
    top:             top + 'px',
    background:      'black',
    width:           size + 'px',
    height:          size + 'px',
    backgroundColor: colorUtil.rgbaToRgb(color),
    borderColor:     colorUtil.rgbaToRgb(color)
  });
  this.lastRipple = ripple;

  // we only want one timeout to be running at a time
  this.clearTimeout();
  this.timeout    = this.$timeout(function () {
    ctrl.clearTimeout();
    if (!ctrl.mousedown) ctrl.fadeInComplete(ripple);
  }, DURATION * 0.35, false);

  if (this.options.dimBackground) this.container.css({ backgroundColor: color });
  this.container.append(ripple);
  this.ripples.push(ripple);
  ripple.addClass('md-ripple-placed');

  this.$mdUtil.nextTick(function () {

    ripple.addClass('md-ripple-scaled md-ripple-active');
    ctrl.$timeout(function () {
      ctrl.clearRipples();
    }, DURATION, false);

  }, false);

  function getSize (fit, x, y) {
    return fit
        ? Math.max(x, y)
        : Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
  }
};



/**
 * After fadeIn finishes, either kicks off the fade-out animation or queues the element for removal on mouseup
 * @param ripple
 */
InkRippleCtrl.prototype.fadeInComplete = function (ripple) {
  if (this.lastRipple === ripple) {
    if (!this.timeout && !this.mousedown) {
      this.removeRipple(ripple);
    }
  } else {
    this.removeRipple(ripple);
  }
};

/**
 * Kicks off the animation for removing a ripple
 * @param ripple {Element}
 */
InkRippleCtrl.prototype.removeRipple = function (ripple) {
  var ctrl  = this;
  var index = this.ripples.indexOf(ripple);
  if (index < 0) return;
  this.ripples.splice(this.ripples.indexOf(ripple), 1);
  ripple.removeClass('md-ripple-active');
  ripple.addClass('md-ripple-remove');
  if (this.ripples.length === 0) this.container.css({ backgroundColor: '' });
  // use a 2-second timeout in order to allow for the animation to finish
  // we don't actually care how long the animation takes
  this.$timeout(function () {
    ctrl.fadeOutComplete(ripple);
  }, DURATION, false);
};

/**
 * Removes the provided ripple from the DOM
 * @param ripple
 */
InkRippleCtrl.prototype.fadeOutComplete = function (ripple) {
  ripple.remove();
  this.lastRipple = null;
};

/**
 * Used to create an empty directive.  This is used to track flag-directives whose children may have
 * functionality based on them.
 *
 * Example: `md-no-ink` will potentially be used by all child directives.
 */
function attrNoDirective () {
  return { controller: angular.noop };
}

})();
(function(){
"use strict";

(function() {
  'use strict';

    /**
   * @ngdoc service
   * @name $mdTabInkRipple
   * @module material.core
   *
   * @description
   * Provides ripple effects for md-tabs.  See $mdInkRipple service for all possible configuration options.
   *
   * @param {object=} scope Scope within the current context
   * @param {object=} element The element the ripple effect should be applied to
   * @param {object=} options (Optional) Configuration options to override the defaultripple configuration
   */

  MdTabInkRipple.$inject = ["$mdInkRipple"];
  angular.module('material.core')
    .factory('$mdTabInkRipple', MdTabInkRipple);

  function MdTabInkRipple($mdInkRipple) {
    return {
      attach: attach
    };

    function attach(scope, element, options) {
      return $mdInkRipple.attach(scope, element, angular.extend({
        center: false,
        dimBackground: true,
        outline: false,
        rippleSize: 'full'
      }, options));
    }
  }
})();

})();
(function(){
"use strict";

angular.module('material.core.theming.palette', [])
.constant('$mdColorPalette', {
  'red': {
    '50': '#ffebee',
    '100': '#ffcdd2',
    '200': '#ef9a9a',
    '300': '#e57373',
    '400': '#ef5350',
    '500': '#f44336',
    '600': '#e53935',
    '700': '#d32f2f',
    '800': '#c62828',
    '900': '#b71c1c',
    'A100': '#ff8a80',
    'A200': '#ff5252',
    'A400': '#ff1744',
    'A700': '#d50000',
    'contrastDefaultColor': 'light',
    'contrastDarkColors': '50 100 200 300 A100',
    'contrastStrongLightColors': '400 500 600 700 A200 A400 A700'
  },
  'pink': {
    '50': '#fce4ec',
    '100': '#f8bbd0',
    '200': '#f48fb1',
    '300': '#f06292',
    '400': '#ec407a',
    '500': '#e91e63',
    '600': '#d81b60',
    '700': '#c2185b',
    '800': '#ad1457',
    '900': '#880e4f',
    'A100': '#ff80ab',
    'A200': '#ff4081',
    'A400': '#f50057',
    'A700': '#c51162',
    'contrastDefaultColor': 'light',
    'contrastDarkColors': '50 100 200 A100',
    'contrastStrongLightColors': '500 600 A200 A400 A700'
  },
  'purple': {
    '50': '#f3e5f5',
    '100': '#e1bee7',
    '200': '#ce93d8',
    '300': '#ba68c8',
    '400': '#ab47bc',
    '500': '#9c27b0',
    '600': '#8e24aa',
    '700': '#7b1fa2',
    '800': '#6a1b9a',
    '900': '#4a148c',
    'A100': '#ea80fc',
    'A200': '#e040fb',
    'A400': '#d500f9',
    'A700': '#aa00ff',
    'contrastDefaultColor': 'light',
    'contrastDarkColors': '50 100 200 A100',
    'contrastStrongLightColors': '300 400 A200 A400 A700'
  },
  'deep-purple': {
    '50': '#ede7f6',
    '100': '#d1c4e9',
    '200': '#b39ddb',
    '300': '#9575cd',
    '400': '#7e57c2',
    '500': '#673ab7',
    '600': '#5e35b1',
    '700': '#512da8',
    '800': '#4527a0',
    '900': '#311b92',
    'A100': '#b388ff',
    'A200': '#7c4dff',
    'A400': '#651fff',
    'A700': '#6200ea',
    'contrastDefaultColor': 'light',
    'contrastDarkColors': '50 100 200 A100',
    'contrastStrongLightColors': '300 400 A200'
  },
  'indigo': {
    '50': '#e8eaf6',
    '100': '#c5cae9',
    '200': '#9fa8da',
    '300': '#7986cb',
    '400': '#5c6bc0',
    '500': '#3f51b5',
    '600': '#3949ab',
    '700': '#303f9f',
    '800': '#283593',
    '900': '#1a237e',
    'A100': '#8c9eff',
    'A200': '#536dfe',
    'A400': '#3d5afe',
    'A700': '#304ffe',
    'contrastDefaultColor': 'light',
    'contrastDarkColors': '50 100 200 A100',
    'contrastStrongLightColors': '300 400 A200 A400'
  },
  'blue': {
    '50': '#e3f2fd',
    '100': '#bbdefb',
    '200': '#90caf9',
    '300': '#64b5f6',
    '400': '#42a5f5',
    '500': '#2196f3',
    '600': '#1e88e5',
    '700': '#1976d2',
    '800': '#1565c0',
    '900': '#0d47a1',
    'A100': '#82b1ff',
    'A200': '#448aff',
    'A400': '#2979ff',
    'A700': '#2962ff',
    'contrastDefaultColor': 'light',
    'contrastDarkColors': '50 100 200 300 400 A100',
    'contrastStrongLightColors': '500 600 700 A200 A400 A700'
  },
  'light-blue': {
    '50': '#e1f5fe',
    '100': '#b3e5fc',
    '200': '#81d4fa',
    '300': '#4fc3f7',
    '400': '#29b6f6',
    '500': '#03a9f4',
    '600': '#039be5',
    '700': '#0288d1',
    '800': '#0277bd',
    '900': '#01579b',
    'A100': '#80d8ff',
    'A200': '#40c4ff',
    'A400': '#00b0ff',
    'A700': '#0091ea',
    'contrastDefaultColor': 'dark',
    'contrastLightColors': '600 700 800 900 A700',
    'contrastStrongLightColors': '600 700 800 A700'
  },
  'cyan': {
    '50': '#e0f7fa',
    '100': '#b2ebf2',
    '200': '#80deea',
    '300': '#4dd0e1',
    '400': '#26c6da',
    '500': '#00bcd4',
    '600': '#00acc1',
    '700': '#0097a7',
    '800': '#00838f',
    '900': '#006064',
    'A100': '#84ffff',
    'A200': '#18ffff',
    'A400': '#00e5ff',
    'A700': '#00b8d4',
    'contrastDefaultColor': 'dark',
    'contrastLightColors': '700 800 900',
    'contrastStrongLightColors': '700 800 900'
  },
  'teal': {
    '50': '#e0f2f1',
    '100': '#b2dfdb',
    '200': '#80cbc4',
    '300': '#4db6ac',
    '400': '#26a69a',
    '500': '#009688',
    '600': '#00897b',
    '700': '#00796b',
    '800': '#00695c',
    '900': '#004d40',
    'A100': '#a7ffeb',
    'A200': '#64ffda',
    'A400': '#1de9b6',
    'A700': '#00bfa5',
    'contrastDefaultColor': 'dark',
    'contrastLightColors': '500 600 700 800 900',
    'contrastStrongLightColors': '500 600 700'
  },
  'green': {
    '50': '#e8f5e9',
    '100': '#c8e6c9',
    '200': '#a5d6a7',
    '300': '#81c784',
    '400': '#66bb6a',
    '500': '#4caf50',
    '600': '#43a047',
    '700': '#388e3c',
    '800': '#2e7d32',
    '900': '#1b5e20',
    'A100': '#b9f6ca',
    'A200': '#69f0ae',
    'A400': '#00e676',
    'A700': '#00c853',
    'contrastDefaultColor': 'dark',
    'contrastLightColors': '500 600 700 800 900',
    'contrastStrongLightColors': '500 600 700'
  },
  'light-green': {
    '50': '#f1f8e9',
    '100': '#dcedc8',
    '200': '#c5e1a5',
    '300': '#aed581',
    '400': '#9ccc65',
    '500': '#8bc34a',
    '600': '#7cb342',
    '700': '#689f38',
    '800': '#558b2f',
    '900': '#33691e',
    'A100': '#ccff90',
    'A200': '#b2ff59',
    'A400': '#76ff03',
    'A700': '#64dd17',
    'contrastDefaultColor': 'dark',
    'contrastLightColors': '700 800 900',
    'contrastStrongLightColors': '700 800 900'
  },
  'lime': {
    '50': '#f9fbe7',
    '100': '#f0f4c3',
    '200': '#e6ee9c',
    '300': '#dce775',
    '400': '#d4e157',
    '500': '#cddc39',
    '600': '#c0ca33',
    '700': '#afb42b',
    '800': '#9e9d24',
    '900': '#827717',
    'A100': '#f4ff81',
    'A200': '#eeff41',
    'A400': '#c6ff00',
    'A700': '#aeea00',
    'contrastDefaultColor': 'dark',
    'contrastLightColors': '900',
    'contrastStrongLightColors': '900'
  },
  'yellow': {
    '50': '#fffde7',
    '100': '#fff9c4',
    '200': '#fff59d',
    '300': '#fff176',
    '400': '#ffee58',
    '500': '#ffeb3b',
    '600': '#fdd835',
    '700': '#fbc02d',
    '800': '#f9a825',
    '900': '#f57f17',
    'A100': '#ffff8d',
    'A200': '#ffff00',
    'A400': '#ffea00',
    'A700': '#ffd600',
    'contrastDefaultColor': 'dark'
  },
  'amber': {
    '50': '#fff8e1',
    '100': '#ffecb3',
    '200': '#ffe082',
    '300': '#ffd54f',
    '400': '#ffca28',
    '500': '#ffc107',
    '600': '#ffb300',
    '700': '#ffa000',
    '800': '#ff8f00',
    '900': '#ff6f00',
    'A100': '#ffe57f',
    'A200': '#ffd740',
    'A400': '#ffc400',
    'A700': '#ffab00',
    'contrastDefaultColor': 'dark'
  },
  'orange': {
    '50': '#fff3e0',
    '100': '#ffe0b2',
    '200': '#ffcc80',
    '300': '#ffb74d',
    '400': '#ffa726',
    '500': '#ff9800',
    '600': '#fb8c00',
    '700': '#f57c00',
    '800': '#ef6c00',
    '900': '#e65100',
    'A100': '#ffd180',
    'A200': '#ffab40',
    'A400': '#ff9100',
    'A700': '#ff6d00',
    'contrastDefaultColor': 'dark',
    'contrastLightColors': '800 900',
    'contrastStrongLightColors': '800 900'
  },
  'deep-orange': {
    '50': '#fbe9e7',
    '100': '#ffccbc',
    '200': '#ffab91',
    '300': '#ff8a65',
    '400': '#ff7043',
    '500': '#ff5722',
    '600': '#f4511e',
    '700': '#e64a19',
    '800': '#d84315',
    '900': '#bf360c',
    'A100': '#ff9e80',
    'A200': '#ff6e40',
    'A400': '#ff3d00',
    'A700': '#dd2c00',
    'contrastDefaultColor': 'light',
    'contrastDarkColors': '50 100 200 300 400 A100 A200',
    'contrastStrongLightColors': '500 600 700 800 900 A400 A700'
  },
  'brown': {
    '50': '#efebe9',
    '100': '#d7ccc8',
    '200': '#bcaaa4',
    '300': '#a1887f',
    '400': '#8d6e63',
    '500': '#795548',
    '600': '#6d4c41',
    '700': '#5d4037',
    '800': '#4e342e',
    '900': '#3e2723',
    'A100': '#d7ccc8',
    'A200': '#bcaaa4',
    'A400': '#8d6e63',
    'A700': '#5d4037',
    'contrastDefaultColor': 'light',
    'contrastDarkColors': '50 100 200 A100 A200',
    'contrastStrongLightColors': '300 400'
  },
  'grey': {
    '50': '#fafafa',
    '100': '#f5f5f5',
    '200': '#eeeeee',
    '300': '#e0e0e0',
    '400': '#bdbdbd',
    '500': '#9e9e9e',
    '600': '#757575',
    '700': '#616161',
    '800': '#424242',
    '900': '#212121',
    'A100': '#ffffff',
    'A200': '#000000',
    'A400': '#303030',
    'A700': '#616161',
    'contrastDefaultColor': 'dark',
    'contrastLightColors': '600 700 800 900 A200 A400 A700'
  },
  'blue-grey': {
    '50': '#eceff1',
    '100': '#cfd8dc',
    '200': '#b0bec5',
    '300': '#90a4ae',
    '400': '#78909c',
    '500': '#607d8b',
    '600': '#546e7a',
    '700': '#455a64',
    '800': '#37474f',
    '900': '#263238',
    'A100': '#cfd8dc',
    'A200': '#b0bec5',
    'A400': '#78909c',
    'A700': '#455a64',
    'contrastDefaultColor': 'light',
    'contrastDarkColors': '50 100 200 300 A100 A200',
    'contrastStrongLightColors': '400 500 700'
  }
});

})();
(function(){
"use strict";

(function(angular) {
  'use strict';
/**
 * @ngdoc module
 * @name material.core.theming
 * @description
 * Theming
 */
detectDisabledThemes.$inject = ["$mdThemingProvider"];
ThemingDirective.$inject = ["$mdTheming", "$interpolate", "$parse", "$mdUtil", "$q", "$log"];
ThemableDirective.$inject = ["$mdTheming"];
ThemingProvider.$inject = ["$mdColorPalette", "$$mdMetaProvider"];
generateAllThemes.$inject = ["$injector", "$mdTheming"];
angular.module('material.core.theming', ['material.core.theming.palette', 'material.core.meta'])
  .directive('mdTheme', ThemingDirective)
  .directive('mdThemable', ThemableDirective)
  .directive('mdThemesDisabled', disableThemesDirective)
  .provider('$mdTheming', ThemingProvider)
  .config(detectDisabledThemes)
  .run(generateAllThemes);

/**
 * Detect if the HTML or the BODY tags has a [md-themes-disabled] attribute
 * If yes, then immediately disable all theme stylesheet generation and DOM injection
 */
/**
 * @ngInject
 */
function detectDisabledThemes($mdThemingProvider) {
  var isDisabled = !!document.querySelector('[md-themes-disabled]');
  $mdThemingProvider.disableTheming(isDisabled);
}

/**
 * @ngdoc service
 * @name $mdThemingProvider
 * @module material.core.theming
 *
 * @description Provider to configure the `$mdTheming` service.
 *
 * ### Default Theme
 * The `$mdThemingProvider` uses by default the following theme configuration:
 *
 * - Primary Palette: `Blue`
 * - Accent Palette: `Pink`
 * - Warn Palette: `Deep-Orange`
 * - Background Palette: `Grey`
 *
 * If you don't want to use the `md-theme` directive on the elements itself, you may want to overwrite
 * the default theme.<br/>
 * This can be done by using the following markup.
 *
 * <hljs lang="js">
 *   myAppModule.config(function($mdThemingProvider) {
 *     $mdThemingProvider
 *       .theme('default')
 *       .primaryPalette('blue')
 *       .accentPalette('teal')
 *       .warnPalette('red')
 *       .backgroundPalette('grey');
 *   });
 * </hljs>
 *

 * ### Dynamic Themes
 *
 * By default, if you change a theme at runtime, the `$mdTheming` service will not detect those changes.<br/>
 * If you have an application, which changes its theme on runtime, you have to enable theme watching.
 *
 * <hljs lang="js">
 *   myAppModule.config(function($mdThemingProvider) {
 *     // Enable theme watching.
 *     $mdThemingProvider.alwaysWatchTheme(true);
 *   });
 * </hljs>
 *
 * ### Custom Theme Styles
 *
 * Sometimes you may want to use your own theme styles for some custom components.<br/>
 * You are able to register your own styles by using the following markup.
 *
 * <hljs lang="js">
 *   myAppModule.config(function($mdThemingProvider) {
 *     // Register our custom stylesheet into the theming provider.
 *     $mdThemingProvider.registerStyles(STYLESHEET);
 *   });
 * </hljs>
 *
 * The `registerStyles` method only accepts strings as value, so you're actually not able to load an external
 * stylesheet file into the `$mdThemingProvider`.
 *
 * If it's necessary to load an external stylesheet, we suggest using a bundler, which supports including raw content,
 * like [raw-loader](https://github.com/webpack/raw-loader) for `webpack`.
 *
 * <hljs lang="js">
 *   myAppModule.config(function($mdThemingProvider) {
 *     // Register your custom stylesheet into the theming provider.
 *     $mdThemingProvider.registerStyles(require('../styles/my-component.theme.css'));
 *   });
 * </hljs>
 *
 * ### Browser color
 *
 * Enables browser header coloring
 * for more info please visit:
 * https://developers.google.com/web/fundamentals/design-and-ui/browser-customization/theme-color
 *
 * Options parameter: <br/>
 * `theme`   - A defined theme via `$mdThemeProvider` to use the palettes from. Default is `default` theme. <br/>
 * `palette` - Can be any one of the basic material design palettes, extended defined palettes and 'primary',
 *             'accent', 'background' and 'warn'. Default is `primary`. <br/>
 * `hue`     - The hue from the selected palette. Default is `800`<br/>
 *
 * <hljs lang="js">
 *   myAppModule.config(function($mdThemingProvider) {
 *     // Enable browser color
 *     $mdThemingProvider.enableBrowserColor({
 *       theme: 'myTheme', // Default is 'default'
 *       palette: 'accent', // Default is 'primary', any basic material palette and extended palettes are available
 *       hue: '200' // Default is '800'
 *     });
 *   });
 * </hljs>
 */

/**
 * Some Example Valid Theming Expressions
 * =======================================
 *
 * Intention group expansion: (valid for primary, accent, warn, background)
 *
 * {{primary-100}} - grab shade 100 from the primary palette
 * {{primary-100-0.7}} - grab shade 100, apply opacity of 0.7
 * {{primary-100-contrast}} - grab shade 100's contrast color
 * {{primary-hue-1}} - grab the shade assigned to hue-1 from the primary palette
 * {{primary-hue-1-0.7}} - apply 0.7 opacity to primary-hue-1
 * {{primary-color}} - Generates .md-hue-1, .md-hue-2, .md-hue-3 with configured shades set for each hue
 * {{primary-color-0.7}} - Apply 0.7 opacity to each of the above rules
 * {{primary-contrast}} - Generates .md-hue-1, .md-hue-2, .md-hue-3 with configured contrast (ie. text) color shades set for each hue
 * {{primary-contrast-0.7}} - Apply 0.7 opacity to each of the above rules
 *
 * Foreground expansion: Applies rgba to black/white foreground text
 *
 * {{foreground-1}} - used for primary text
 * {{foreground-2}} - used for secondary text/divider
 * {{foreground-3}} - used for disabled text
 * {{foreground-4}} - used for dividers
 */

// In memory generated CSS rules; registered by theme.name
var GENERATED = { };

// In memory storage of defined themes and color palettes (both loaded by CSS, and user specified)
var PALETTES;

// Text Colors on light and dark backgrounds
// @see https://material.io/archive/guidelines/style/color.html#color-usability
var DARK_FOREGROUND = {
  name: 'dark',
  '1': 'rgba(0,0,0,0.87)',
  '2': 'rgba(0,0,0,0.54)',
  '3': 'rgba(0,0,0,0.38)',
  '4': 'rgba(0,0,0,0.12)'
};
var LIGHT_FOREGROUND = {
  name: 'light',
  '1': 'rgba(255,255,255,1.0)',
  '2': 'rgba(255,255,255,0.7)',
  '3': 'rgba(255,255,255,0.5)',
  '4': 'rgba(255,255,255,0.12)'
};

var DARK_SHADOW = '1px 1px 0px rgba(0,0,0,0.4), -1px -1px 0px rgba(0,0,0,0.4)';
var LIGHT_SHADOW = '';

var DARK_CONTRAST_COLOR = colorToRgbaArray('rgba(0,0,0,0.87)');
var LIGHT_CONTRAST_COLOR = colorToRgbaArray('rgba(255,255,255,0.87)');
var STRONG_LIGHT_CONTRAST_COLOR = colorToRgbaArray('rgb(255,255,255)');

var THEME_COLOR_TYPES = ['primary', 'accent', 'warn', 'background'];
var DEFAULT_COLOR_TYPE = 'primary';

// A color in a theme will use these hues by default, if not specified by user.
var LIGHT_DEFAULT_HUES = {
  'accent': {
    'default': 'A200',
    'hue-1': 'A100',
    'hue-2': 'A400',
    'hue-3': 'A700'
  },
  'background': {
    'default': '50',
    'hue-1': 'A100',
    'hue-2': '100',
    'hue-3': '300'
  }
};

var DARK_DEFAULT_HUES = {
  'background': {
    'default': 'A400',
    'hue-1': '800',
    'hue-2': '900',
    'hue-3': 'A200'
  }
};
THEME_COLOR_TYPES.forEach(function(colorType) {
  // Color types with unspecified default hues will use these default hue values
  var defaultDefaultHues = {
    'default': '500',
    'hue-1': '300',
    'hue-2': '800',
    'hue-3': 'A100'
  };
  if (!LIGHT_DEFAULT_HUES[colorType]) LIGHT_DEFAULT_HUES[colorType] = defaultDefaultHues;
  if (!DARK_DEFAULT_HUES[colorType]) DARK_DEFAULT_HUES[colorType] = defaultDefaultHues;
});

var VALID_HUE_VALUES = [
  '50', '100', '200', '300', '400', '500', '600',
  '700', '800', '900', 'A100', 'A200', 'A400', 'A700'
];

var themeConfig = {
  disableTheming : false,   // Generate our themes at run time; also disable stylesheet DOM injection
  generateOnDemand : false, // Whether or not themes are to be generated on-demand (vs. eagerly).
  registeredStyles : [],    // Custom styles registered to be used in the theming of custom components.
  nonce : null              // Nonce to be added as an attribute to the generated themes style tags.
};

/**
 *
 */
function ThemingProvider($mdColorPalette, $$mdMetaProvider) {
  ThemingService.$inject = ["$rootScope", "$mdUtil", "$q", "$log"];
  PALETTES = { };
  var THEMES = { };

  var themingProvider;

  var alwaysWatchTheme = false;
  var defaultTheme = 'default';

  // Load JS Defined Palettes
  angular.extend(PALETTES, $mdColorPalette);

  // Default theme defined in core.js

  /**
   * Adds `theme-color` and `msapplication-navbutton-color` meta tags with the color parameter
   * @param {string} color Hex value of the wanted browser color
   * @returns {function} Remove function of the meta tags
   */
  var setBrowserColor = function (color) {
    // Chrome, Firefox OS and Opera
    var removeChrome = $$mdMetaProvider.setMeta('theme-color', color);
    // Windows Phone
    var removeWindows = $$mdMetaProvider.setMeta('msapplication-navbutton-color', color);

    return function () {
      removeChrome();
      removeWindows();
    };
  };

  /**
   * @ngdoc method
   * @name $mdThemingProvider#enableBrowserColor
   * @description
   * Enables browser header coloring. For more info please visit
   * <a href="https://developers.google.com/web/fundamentals/design-and-ui/browser-customization/theme-color">
   *   Web Fundamentals</a>.
   * @param {object=} options Options for the browser color, which include:<br/>
   * - `theme` - `{string}`: A defined theme via `$mdThemeProvider` to use the palettes from. Default is `default` theme. <br/>
   * - `palette` - `{string}`:  Can be any one of the basic material design palettes, extended defined palettes, or `primary`,
   *  `accent`, `background`, and `warn`. Default is `primary`.<br/>
   * - `hue` -  `{string}`: The hue from the selected palette. Default is `800`.<br/>
   * @returns {function} Function that removes the browser coloring when called.
   */
  var enableBrowserColor = function (options) {
    options = angular.isObject(options) ? options : {};

    var theme = options.theme || 'default';
    var hue = options.hue || '800';

    var palette = PALETTES[options.palette] ||
      PALETTES[THEMES[theme].colors[options.palette || 'primary'].name];

    var color = angular.isObject(palette[hue]) ? palette[hue].hex : palette[hue];
    if (color.substr(0, 1) !== '#') color = '#' + color;

    return setBrowserColor(color);
  };

  return themingProvider = {
    definePalette: definePalette,
    extendPalette: extendPalette,
    theme: registerTheme,

    /**
     * return a read-only clone of the current theme configuration
     */
    configuration : function() {
      return angular.extend({ }, themeConfig, {
        defaultTheme : defaultTheme,
        alwaysWatchTheme : alwaysWatchTheme,
        registeredStyles : [].concat(themeConfig.registeredStyles)
      });
    },

    /**
     * @ngdoc method
     * @name $mdThemingProvider#disableTheming
     * @description
     * An easier way to disable theming without having to use `.constant("$MD_THEME_CSS","");`.
     * This disables all dynamic theme style sheet generations and injections.
     * @param {boolean=} isDisabled Disable all dynamic theme style sheet generations and injections
     *  if `true` or `undefined`.
     */
    disableTheming: function(isDisabled) {
      themeConfig.disableTheming = angular.isUndefined(isDisabled) || !!isDisabled;
    },

    /**
     * @ngdoc method
     * @name $mdThemingProvider#registerStyles
     * @param {string} styles The styles to be appended to AngularJS Material's built in theme CSS.
     */
    registerStyles: function(styles) {
      themeConfig.registeredStyles.push(styles);
    },

    /**
     * @ngdoc method
     * @name $mdThemingProvider#setNonce
     * @param {string} nonceValue The nonce to be added as an attribute to the theme style tags.
     * Setting a value allows the use of CSP policy without using the unsafe-inline directive.
     */
    setNonce: function(nonceValue) {
      themeConfig.nonce = nonceValue;
    },

    generateThemesOnDemand: function(onDemand) {
      themeConfig.generateOnDemand = onDemand;
    },

    /**
     * @ngdoc method
     * @name $mdThemingProvider#setDefaultTheme
     * @param {string} theme Default theme name to be applied to elements. Default value is `default`.
     */
    setDefaultTheme: function(theme) {
      defaultTheme = theme;
    },

    /**
     * @ngdoc method
     * @name $mdThemingProvider#alwaysWatchTheme
     * @param {boolean} alwaysWatch Whether or not to always watch themes for changes and re-apply
     * classes when they change. Default is `false`. Enabling can reduce performance.
     */
    alwaysWatchTheme: function(alwaysWatch) {
      alwaysWatchTheme = alwaysWatch;
    },

    enableBrowserColor: enableBrowserColor,

    $get: ThemingService,
    _LIGHT_DEFAULT_HUES: LIGHT_DEFAULT_HUES,
    _DARK_DEFAULT_HUES: DARK_DEFAULT_HUES,
    _PALETTES: PALETTES,
    _THEMES: THEMES,
    _parseRules: parseRules,
    _rgba: rgba
  };

  /**
   * @ngdoc method
   * @name $mdThemingProvider#definePalette
   * @description
   * In the event that you need to define a custom color palette, you can use this function to
   * make it available to your theme for use in its intention groups.<br>
   * Note that you must specify all hues in the definition map.
   * @param {string} name Name of palette being defined
   * @param {object} map Palette definition that includes hue definitions and contrast colors:
   * - `'50'` - `{string}`: HEX color
   * - `'100'` - `{string}`: HEX color
   * - `'200'` - `{string}`: HEX color
   * - `'300'` - `{string}`: HEX color
   * - `'400'` - `{string}`: HEX color
   * - `'500'` - `{string}`: HEX color
   * - `'600'` - `{string}`: HEX color
   * - `'700'` - `{string}`: HEX color
   * - `'800'` - `{string}`: HEX color
   * - `'900'` - `{string}`: HEX color
   * - `'A100'` - `{string}`: HEX color
   * - `'A200'` - `{string}`: HEX color
   * - `'A400'` - `{string}`: HEX color
   * - `'A700'` - `{string}`: HEX color
   * - `'contrastDefaultColor'` - `{string}`: `light` or `dark`
   * - `'contrastDarkColors'` - `{string[]}`: Hues which should use dark contrast colors (i.e. raised button text).
   *  For example: `['50', '100', '200', '300', '400', 'A100']`.
   * - `'contrastLightColors'` - `{string[]}`: Hues which should use light contrast colors (i.e. raised button text).
   *  For example: `['500', '600', '700', '800', '900', 'A200', 'A400', 'A700']`.
   */
  function definePalette(name, map) {
    map = map || {};
    PALETTES[name] = checkPaletteValid(name, map);
    return themingProvider;
  }

  /**
   * @ngdoc method
   * @name $mdThemingProvider#extendPalette
   * @description
   * Sometimes it is easier to extend an existing color palette and then change a few properties,
   * rather than defining a whole new palette.
   * @param {string} name Name of palette being extended
   * @param {object} map Palette definition that includes optional hue definitions and contrast colors:
   * - `'50'` - `{string}`: HEX color
   * - `'100'` - `{string}`: HEX color
   * - `'200'` - `{string}`: HEX color
   * - `'300'` - `{string}`: HEX color
   * - `'400'` - `{string}`: HEX color
   * - `'500'` - `{string}`: HEX color
   * - `'600'` - `{string}`: HEX color
   * - `'700'` - `{string}`: HEX color
   * - `'800'` - `{string}`: HEX color
   * - `'900'` - `{string}`: HEX color
   * - `'A100'` - `{string}`: HEX color
   * - `'A200'` - `{string}`: HEX color
   * - `'A400'` - `{string}`: HEX color
   * - `'A700'` - `{string}`: HEX color
   * - `'contrastDefaultColor'` - `{string}`: `light` or `dark`
   * - `'contrastDarkColors'` - `{string[]}`: Hues which should use dark contrast colors (i.e. raised button text).
   *  For example: `['50', '100', '200', '300', '400', 'A100']`.
   * - `'contrastLightColors'` - `{string[]}`: Hues which should use light contrast colors (i.e. raised button text).
   *  For example: `['500', '600', '700', '800', '900', 'A200', 'A400', 'A700']`.
   *  @returns {object} A new object which is a copy of the given palette, `name`,
   *    with variables from `map` overwritten.
   */
  function extendPalette(name, map) {
    return checkPaletteValid(name,  angular.extend({}, PALETTES[name] || {}, map));
  }

  // Make sure that palette has all required hues
  function checkPaletteValid(name, map) {
    var missingColors = VALID_HUE_VALUES.filter(function(field) {
      return !map[field];
    });
    if (missingColors.length) {
      throw new Error("Missing colors %1 in palette %2!"
                      .replace('%1', missingColors.join(', '))
                      .replace('%2', name));
    }

    return map;
  }

  /**
   * @ngdoc method
   * @name $mdThemingProvider#theme
   * @description
   * Register a theme (which is a collection of color palettes); i.e. `warn`, `accent`,
   * `background`, and `primary`.<br>
   * Optionally inherit from an existing theme.
   * @param {string} name Name of theme being registered
   * @param {string=} inheritFrom Existing theme name to inherit from
   */
  function registerTheme(name, inheritFrom) {
    if (THEMES[name]) return THEMES[name];

    inheritFrom = inheritFrom || 'default';

    var parentTheme = typeof inheritFrom === 'string' ? THEMES[inheritFrom] : inheritFrom;
    var theme = new Theme(name);

    if (parentTheme) {
      angular.forEach(parentTheme.colors, function(color, colorType) {
        theme.colors[colorType] = {
          name: color.name,
          // Make sure a COPY of the hues is given to the child color,
          // not the same reference.
          hues: angular.extend({}, color.hues)
        };
      });
    }
    THEMES[name] = theme;

    return theme;
  }

  function Theme(name) {
    var self = this;
    self.name = name;
    self.colors = {};

    self.dark = setDark;
    setDark(false);

    function setDark(isDark) {
      isDark = arguments.length === 0 ? true : !!isDark;

      // If no change, abort
      if (isDark === self.isDark) return;

      self.isDark = isDark;

      self.foregroundPalette = self.isDark ? LIGHT_FOREGROUND : DARK_FOREGROUND;
      self.foregroundShadow = self.isDark ? DARK_SHADOW : LIGHT_SHADOW;

      // Light and dark themes have different default hues.
      // Go through each existing color type for this theme, and for every
      // hue value that is still the default hue value from the previous light/dark setting,
      // set it to the default hue value from the new light/dark setting.
      var newDefaultHues = self.isDark ? DARK_DEFAULT_HUES : LIGHT_DEFAULT_HUES;
      var oldDefaultHues = self.isDark ? LIGHT_DEFAULT_HUES : DARK_DEFAULT_HUES;
      angular.forEach(newDefaultHues, function(newDefaults, colorType) {
        var color = self.colors[colorType];
        var oldDefaults = oldDefaultHues[colorType];
        if (color) {
          for (var hueName in color.hues) {
            if (color.hues[hueName] === oldDefaults[hueName]) {
              color.hues[hueName] = newDefaults[hueName];
            }
          }
        }
      });

      return self;
    }

    THEME_COLOR_TYPES.forEach(function(colorType) {
      var defaultHues = (self.isDark ? DARK_DEFAULT_HUES : LIGHT_DEFAULT_HUES)[colorType];
      self[colorType + 'Palette'] = function setPaletteType(paletteName, hues) {
        var color = self.colors[colorType] = {
          name: paletteName,
          hues: angular.extend({}, defaultHues, hues)
        };

        Object.keys(color.hues).forEach(function(name) {
          if (!defaultHues[name]) {
            throw new Error("Invalid hue name '%1' in theme %2's %3 color %4. Available hue names: %4"
              .replace('%1', name)
              .replace('%2', self.name)
              .replace('%3', paletteName)
              .replace('%4', Object.keys(defaultHues).join(', '))
            );
          }
        });
        Object.keys(color.hues).map(function(key) {
          return color.hues[key];
        }).forEach(function(hueValue) {
          if (VALID_HUE_VALUES.indexOf(hueValue) == -1) {
            throw new Error("Invalid hue value '%1' in theme %2's %3 color %4. Available hue values: %5"
              .replace('%1', hueValue)
              .replace('%2', self.name)
              .replace('%3', colorType)
              .replace('%4', paletteName)
              .replace('%5', VALID_HUE_VALUES.join(', '))
            );
          }
        });
        return self;
      };

      self[colorType + 'Color'] = function() {
        var args = Array.prototype.slice.call(arguments);
        // eslint-disable-next-line no-console
        console.warn('$mdThemingProviderTheme.' + colorType + 'Color() has been deprecated. ' +
                     'Use $mdThemingProviderTheme.' + colorType + 'Palette() instead.');
        return self[colorType + 'Palette'].apply(self, args);
      };
    });
  }

  /**
   * @ngdoc service
   * @name $mdTheming
   * @module material.core.theming
   * @description
   * Service that makes an element apply theming related <b>classes</b> to itself.
   *
   * For more information on the hue objects, their default values, as well as valid hue values, please visit <a ng-href="Theming/03_configuring_a_theme#specifying-custom-hues-for-color-intentions">the custom hues section of Configuring a Theme</a>.
   *
   * <hljs lang="js">
   * // Example component directive that we want to apply theming classes to.
   * app.directive('myFancyDirective', function($mdTheming) {
   *   return {
   *     restrict: 'AE',
   *     link: function(scope, element, attrs) {
   *       // Initialize the service using our directive's element
   *       $mdTheming(element);
   *
   *       $mdTheming.defineTheme('myTheme', {
   *         primary: 'blue',
   *         primaryHues: {
   *           default: '500',
   *           hue-1: '300',
   *           hue-2: '900',
   *           hue-3: 'A100'
   *         },
   *         accent: 'pink',
   *         accentHues: {
   *           default: '600',
   *           hue-1: '300',
   *           hue-2: '200',
   *           hue-3: 'A500'
   *         },
   *         warn: 'red',
   *         // It's not necessary to specify all hues in the object.
   *         warnHues: {
   *           default: '200',
   *           hue-3: 'A100'
   *         },
   *         // It's not necessary to specify custom hues at all.
   *         background: 'grey',
   *         dark: true
   *       });
   *       // Your directive's custom code here.
   *     }
   *   };
   * });
   * </hljs>
   * @param {element=} element Element that will have theming classes applied to it.
   */

  /**
   * @ngdoc property
   * @name $mdTheming#THEMES
   * @description
   * Property to get all the themes defined
   * @returns {object} All the themes defined with their properties.
   */

  /**
   * @ngdoc property
   * @name $mdTheming#PALETTES
   * @description
   * Property to get all the palettes defined
   * @returns {object} All the palettes defined with their colors.
   */

  /**
   * @ngdoc method
   * @name $mdTheming#registered
   * @description
   * Determine is specified theme name is a valid, registered theme
   * @param {string} themeName the theme to check if registered
   * @returns {boolean} whether the theme is registered or not
   */

  /**
   * @ngdoc method
   * @name $mdTheming#defaultTheme
   * @description
   * Returns the default theme
   * @returns {string} The default theme
   */

  /**
   * @ngdoc method
   * @name $mdTheming#generateTheme
   * @description
   * Lazy generate themes - by default, every theme is generated when defined.
   * You can disable this in the configuration section using the
   * `$mdThemingProvider.generateThemesOnDemand(true);`
   *
   * The theme name that is passed in must match the name of the theme that was defined as part of
   * the configuration block.
   *
   * @param {string} name theme name to generate
   */

  /**
   * @ngdoc method
   * @name $mdTheming#setBrowserColor
   * @description
   * Enables browser header coloring. For more info please visit
   * <a href="https://developers.google.com/web/fundamentals/design-and-ui/browser-customization/theme-color">
   *   Web Fundamentals</a>.
   * @param {object=} options Options for the browser color, which include:<br/>
   * - `theme` - `{string}`: A defined theme via `$mdThemeProvider` to use the palettes from.
   *    Default is `default` theme. <br/>
   * - `palette` - `{string}`:  Can be any one of the basic material design palettes, extended
   *    defined palettes, or `primary`, `accent`, `background`, and `warn`. Default is `primary`.
   * <br/>
   * - `hue` -  `{string}`: The hue from the selected palette. Default is `800`.<br/>
   * @returns {function} Function that removes the browser coloring when called.
   */

  /**
   * @ngdoc method
   * @name $mdTheming#defineTheme
   * @description
   * Dynamically define a theme by using an options object that contains palette names.
   *
   * @param {string} name Theme name to define
   * @param {object} options Theme definition options
   *
   * Options are:<br/>
   * - `primary` - `{string}`: The name of the primary palette to use in the theme.<br/>
   * - `primaryHues` - `{object=}`: Override hues for primary palette.<br/>
   * - `accent` - `{string}`: The name of the accent palette to use in the theme.<br/>
   * - `accentHues` - `{object=}`: Override hues for accent palette.<br/>
   * - `warn` - `{string}`: The name of the warn palette to use in the theme.<br/>
   * - `warnHues` - `{object=}`: Override hues for warn palette.<br/>
   * - `background` - `{string}`: The name of the background palette to use in the theme.<br/>
   * - `backgroundHues` - `{object=}`: Override hues for background palette.<br/>
   * - `dark` - `{boolean}`: Indicates if it's a dark theme.<br/>
   * @returns {Promise<string>} A resolved promise with the new theme name.
   */

  /* @ngInject */
  function ThemingService($rootScope, $mdUtil, $q, $log) {
    // Allow us to be invoked via a linking function signature.
    var applyTheme = function (scope, el) {
      if (el === undefined) { el = scope; scope = undefined; }
      if (scope === undefined) { scope = $rootScope; }
      applyTheme.inherit(el, el);
    };

    Object.defineProperty(applyTheme, 'THEMES', {
      get: function () {
        return angular.extend({}, THEMES);
      }
    });
    Object.defineProperty(applyTheme, 'PALETTES', {
      get: function () {
        return angular.extend({}, PALETTES);
      }
    });
    Object.defineProperty(applyTheme, 'ALWAYS_WATCH', {
      get: function () {
        return alwaysWatchTheme;
      }
    });
    applyTheme.inherit = inheritTheme;
    applyTheme.registered = registered;
    applyTheme.defaultTheme = function() { return defaultTheme; };
    applyTheme.generateTheme = function(name) { generateTheme(THEMES[name], name, themeConfig.nonce); };
    applyTheme.defineTheme = function(name, options) {
      options = options || {};

      var theme = registerTheme(name);

      if (options.primary) {
        theme.primaryPalette(options.primary, options.primaryHues);
      }
      if (options.accent) {
        theme.accentPalette(options.accent, options.accentHues);
      }
      if (options.warn) {
        theme.warnPalette(options.warn, options.warnHues);
      }
      if (options.background) {
        theme.backgroundPalette(options.background, options.backgroundHues);
      }
      if (options.dark){
        theme.dark();
      }

      this.generateTheme(name);

      return $q.resolve(name);
    };
    applyTheme.setBrowserColor = enableBrowserColor;

    return applyTheme;

    /**
     * Determine is specified theme name is a valid, registered theme
     */
    function registered(themeName) {
      if (themeName === undefined || themeName === '') return true;
      return applyTheme.THEMES[themeName] !== undefined;
    }

    /**
     * Get theme name for the element, then update with Theme CSS class
     */
    function inheritTheme (el, parent) {
      var ctrl = parent.controller('mdTheme') || el.data('$mdThemeController');
      var scope = el.scope();

      updateThemeClass(lookupThemeName());

      if (ctrl) {
        var watchTheme = alwaysWatchTheme ||
                         ctrl.$shouldWatch ||
                         $mdUtil.parseAttributeBoolean(el.attr('md-theme-watch'));

        if (watchTheme || ctrl.isAsyncTheme) {
          var clearNameWatcher = function () {
            if (unwatch) {
              unwatch();
              unwatch = undefined;
            }
          };

          var unwatch = ctrl.registerChanges(function(name) {
            updateThemeClass(name);

            if (!watchTheme) {
              clearNameWatcher();
            }
          });

          if (scope) {
            scope.$on('$destroy', clearNameWatcher);
          } else {
            el.on('$destroy', clearNameWatcher);
          }
        }
      }

      /**
       * Find the theme name from the parent controller or element data
       */
      function lookupThemeName() {
        // As a few components (dialog) add their controllers later, we should also watch for a controller init.
        return ctrl && ctrl.$mdTheme || (defaultTheme === 'default' ? '' : defaultTheme);
      }

      /**
       * Remove old theme class and apply a new one
       * NOTE: if not a valid theme name, then the current name is not changed
       */
      function updateThemeClass(theme) {
        if (!theme) return;
        if (!registered(theme)) {
          $log.warn('Attempted to use unregistered theme \'' + theme + '\'. ' +
                    'Register it with $mdThemingProvider.theme().');
        }

        var oldTheme = el.data('$mdThemeName');
        if (oldTheme) el.removeClass('md-' + oldTheme +'-theme');
        el.addClass('md-' + theme + '-theme');
        el.data('$mdThemeName', theme);
        if (ctrl) {
          el.data('$mdThemeController', ctrl);
        }
      }
    }

  }
}

function ThemingDirective($mdTheming, $interpolate, $parse, $mdUtil, $q, $log) {
  return {
    priority: 101, // has to be more than 100 to be before interpolation (issue on IE)
    link: {
      pre: function(scope, el, attrs) {
        var registeredCallbacks = [];

        var startSymbol = $interpolate.startSymbol();
        var endSymbol = $interpolate.endSymbol();

        var theme = attrs.mdTheme.trim();

        var hasInterpolation =
          theme.substr(0, startSymbol.length) === startSymbol &&
          theme.lastIndexOf(endSymbol) === theme.length - endSymbol.length;

        var oneTimeOperator = '::';
        var oneTimeBind = attrs.mdTheme
            .split(startSymbol).join('')
            .split(endSymbol).join('')
            .trim()
            .substr(0, oneTimeOperator.length) === oneTimeOperator;

        var getTheme = function () {
          var interpolation = $interpolate(attrs.mdTheme)(scope);
          return $parse(interpolation)(scope) || interpolation;
        };

        var ctrl = {
          isAsyncTheme: angular.isFunction(getTheme()) || angular.isFunction(getTheme().then),
          registerChanges: function (cb, context) {
            if (context) {
              cb = angular.bind(context, cb);
            }

            registeredCallbacks.push(cb);

            return function () {
              var index = registeredCallbacks.indexOf(cb);

              if (index > -1) {
                registeredCallbacks.splice(index, 1);
              }
            };
          },
          $setTheme: function (theme) {
            if (!$mdTheming.registered(theme)) {
              $log.warn('attempted to use unregistered theme \'' + theme + '\'');
            }

            ctrl.$mdTheme = theme;

            // Iterating backwards to support unregistering during iteration
            // http://stackoverflow.com/a/9882349/890293
            // we don't use `reverse()` of array because it mutates the array and we don't want it
            // to get re-indexed
            for (var i = registeredCallbacks.length; i--;) {
              registeredCallbacks[i](theme);
            }
          },
          $shouldWatch: $mdUtil.parseAttributeBoolean(el.attr('md-theme-watch')) ||
                        $mdTheming.ALWAYS_WATCH ||
                        (hasInterpolation && !oneTimeBind)
        };

        el.data('$mdThemeController', ctrl);

        var setParsedTheme = function (theme) {
          if (typeof theme === 'string') {
            return ctrl.$setTheme(theme);
          }

          $q.when(angular.isFunction(theme) ?  theme() : theme)
            .then(function(name) {
              ctrl.$setTheme(name);
            });
        };

        setParsedTheme(getTheme());

        var unwatch = scope.$watch(getTheme, function(theme) {
          if (theme) {
            setParsedTheme(theme);

            if (!ctrl.$shouldWatch) {
              unwatch();
            }
          }
        });
      }
    }
  };
}

/**
 * Special directive that will disable ALL runtime Theme style generation and DOM injection
 *
 * <link rel="stylesheet" href="angular-material.min.css">
 * <link rel="stylesheet" href="angular-material.themes.css">
 *
 * <body md-themes-disabled>
 *  ...
 * </body>
 *
 * Note: Using md-themes-css directive requires the developer to load external
 * theme stylesheets; e.g. custom themes from Material-Tools:
 *
 *       `angular-material.themes.css`
 *
 * Another option is to use the ThemingProvider to configure and disable the attribute
 * conversions; this would obviate the use of the `md-themes-css` directive
 *
 */
function disableThemesDirective() {
  themeConfig.disableTheming = true;

  // Return a 1x-only, first-match attribute directive
  return {
    restrict : 'A',
    priority : '900'
  };
}

function ThemableDirective($mdTheming) {
  return $mdTheming;
}

function parseRules(theme, colorType, rules) {
  checkValidPalette(theme, colorType);

  rules = rules.replace(/THEME_NAME/g, theme.name);
  var themeNameRegex = new RegExp('\\.md-' + theme.name + '-theme', 'g');
  var simpleVariableRegex = /'?"?\{\{\s*([a-zA-Z]+)-(A?\d+|hue-[0-3]|shadow|default)-?(\d\.?\d*)?(contrast)?\s*\}\}'?"?/g;

  // find and replace simple variables where we use a specific hue, not an entire palette
  // eg. "{{primary-100}}"
  // \(' + THEME_COLOR_TYPES.join('\|') + '\)'
  rules = rules.replace(simpleVariableRegex, function(match, colorType, hue, opacity, contrast) {
    if (colorType === 'foreground') {
      if (hue == 'shadow') {
        return theme.foregroundShadow;
      } else {
        return theme.foregroundPalette[hue] || theme.foregroundPalette['1'];
      }
    }

    // `default` is also accepted as a hue-value, because the background palettes are
    // using it as a name for the default hue.
    if (hue.indexOf('hue') === 0 || hue === 'default') {
      hue = theme.colors[colorType].hues[hue];
    }

    return rgba((PALETTES[ theme.colors[colorType].name ][hue] || '')[contrast ? 'contrast' : 'value'], opacity);
  });

  // Matches '{{ primary-color }}', etc
  var hueRegex = new RegExp('(\'|")?{{\\s*([a-zA-Z]+)-(color|contrast)-?(\\d\\.?\\d*)?\\s*}}("|\')?','g');
  var generatedRules = [];

  // For each type, generate rules for each hue (ie. default, md-hue-1, md-hue-2, md-hue-3)
  angular.forEach(['default', 'hue-1', 'hue-2', 'hue-3'], function(hueName) {
    var newRule = rules
      .replace(hueRegex, function(match, _, matchedColorType, hueType, opacity) {
        var color = theme.colors[matchedColorType];
        var palette = PALETTES[color.name];
        var hueValue = color.hues[hueName];
        return rgba(palette[hueValue][hueType === 'color' ? 'value' : 'contrast'], opacity);
      });
    if (hueName !== 'default') {
      newRule = newRule.replace(themeNameRegex, '.md-' + theme.name + '-theme.md-' + hueName);
    }

    // Don't apply a selector rule to the default theme, making it easier to override
    // styles of the base-component
    if (theme.name == 'default') {
      var themeRuleRegex = /((?:\s|>|\.|\w|-|:|\(|\)|\[|\]|"|'|=)*)\.md-default-theme((?:\s|>|\.|\w|-|:|\(|\)|\[|\]|"|'|=)*)/g;

      newRule = newRule.replace(themeRuleRegex, function(match, start, end) {
        return match + ', ' + start + end;
      });
    }
    generatedRules.push(newRule);
  });

  return generatedRules;
}

var rulesByType = {};

// Generate our themes at run time given the state of THEMES and PALETTES
function generateAllThemes($injector, $mdTheming) {
  var head = document.head;
  var firstChild = head ? head.firstElementChild : null;
  var themeCss = !themeConfig.disableTheming && $injector.has('$MD_THEME_CSS') ? $injector.get('$MD_THEME_CSS') : '';

  // Append our custom registered styles to the theme stylesheet.
  themeCss += themeConfig.registeredStyles.join('');

  if (!firstChild) return;
  if (themeCss.length === 0) return; // no rules, so no point in running this expensive task

  // Expose contrast colors for palettes to ensure that text is always readable
  angular.forEach(PALETTES, sanitizePalette);

  // MD_THEME_CSS is a string generated by the build process that includes all the themable
  // components as templates

  // Break the CSS into individual rules
  var rules = themeCss
                  .split(/\}(?!(\}|'|"|;))/)
                  .filter(function(rule) { return rule && rule.trim().length; })
                  .map(function(rule) { return rule.trim() + '}'; });

  THEME_COLOR_TYPES.forEach(function(type) {
    rulesByType[type] = '';
  });

  // Sort the rules based on type, allowing us to do color substitution on a per-type basis
  rules.forEach(function(rule) {
    // First: test that if the rule has '.md-accent', it goes into the accent set of rules
    for (var i = 0, type; type = THEME_COLOR_TYPES[i]; i++) {
      if (rule.indexOf('.md-' + type) > -1) {
        return rulesByType[type] += rule;
      }
    }

    // If no eg 'md-accent' class is found, try to just find 'accent' in the rule and guess from
    // there
    for (i = 0; type = THEME_COLOR_TYPES[i]; i++) {
      if (rule.indexOf(type) > -1) {
        return rulesByType[type] += rule;
      }
    }

    // Default to the primary array
    return rulesByType[DEFAULT_COLOR_TYPE] += rule;
  });

  // If themes are being generated on-demand, quit here. The user will later manually
  // call generateTheme to do this on a theme-by-theme basis.
  if (themeConfig.generateOnDemand) return;

  angular.forEach($mdTheming.THEMES, function(theme) {
    if (!GENERATED[theme.name] && !($mdTheming.defaultTheme() !== 'default' && theme.name === 'default')) {
      generateTheme(theme, theme.name, themeConfig.nonce);
    }
  });


  // *************************
  // Internal functions
  // *************************

  // The user specifies a 'default' contrast color as either light or dark,
  // then explicitly lists which hues are the opposite contrast (eg. A100 has dark, A200 has light)
  function sanitizePalette(palette, name) {
    var defaultContrast = palette.contrastDefaultColor;
    var lightColors = palette.contrastLightColors || [];
    var strongLightColors = palette.contrastStrongLightColors || [];
    var darkColors = palette.contrastDarkColors || [];

    // These colors are provided as space-separated lists
    if (typeof lightColors === 'string') lightColors = lightColors.split(' ');
    if (typeof strongLightColors === 'string') strongLightColors = strongLightColors.split(' ');
    if (typeof darkColors === 'string') darkColors = darkColors.split(' ');

    // Cleanup after ourselves
    delete palette.contrastDefaultColor;
    delete palette.contrastLightColors;
    delete palette.contrastStrongLightColors;
    delete palette.contrastDarkColors;

    // Change { 'A100': '#fffeee' } to { 'A100': { value: '#fffeee', contrast:DARK_CONTRAST_COLOR }
    angular.forEach(palette, function(hueValue, hueName) {
      if (angular.isObject(hueValue)) return; // Already converted
      // Map everything to rgb colors
      var rgbValue = colorToRgbaArray(hueValue);
      if (!rgbValue) {
        throw new Error("Color %1, in palette %2's hue %3, is invalid. Hex or rgb(a) color expected."
                        .replace('%1', hueValue)
                        .replace('%2', palette.name)
                        .replace('%3', hueName));
      }

      palette[hueName] = {
        hex: palette[hueName],
        value: rgbValue,
        contrast: getContrastColor()
      };
      function getContrastColor() {
        if (defaultContrast === 'light') {
          if (darkColors.indexOf(hueName) > -1) {
            return DARK_CONTRAST_COLOR;
          } else {
            return strongLightColors.indexOf(hueName) > -1 ? STRONG_LIGHT_CONTRAST_COLOR
              : LIGHT_CONTRAST_COLOR;
          }
        } else {
          if (lightColors.indexOf(hueName) > -1) {
            return strongLightColors.indexOf(hueName) > -1 ? STRONG_LIGHT_CONTRAST_COLOR
              : LIGHT_CONTRAST_COLOR;
          } else {
            return DARK_CONTRAST_COLOR;
          }
        }
      }
    });
  }
}

function generateTheme(theme, name, nonce) {
  var head = document.head;
  var firstChild = head ? head.firstElementChild : null;

  if (!GENERATED[name]) {
    // For each theme, use the color palettes specified for
    // `primary`, `warn` and `accent` to generate CSS rules.
    THEME_COLOR_TYPES.forEach(function(colorType) {
      var styleStrings = parseRules(theme, colorType, rulesByType[colorType]);
      while (styleStrings.length) {
        var styleContent = styleStrings.shift();
        if (styleContent) {
          var style = document.createElement('style');
          style.setAttribute('md-theme-style', '');
          if (nonce) {
            style.setAttribute('nonce', nonce);
          }
          style.appendChild(document.createTextNode(styleContent));
          head.insertBefore(style, firstChild);
        }
      }
    });

    GENERATED[theme.name] = true;
  }

}


function checkValidPalette(theme, colorType) {
  // If theme attempts to use a palette that doesnt exist, throw error
  if (!PALETTES[ (theme.colors[colorType] || {}).name ]) {
    throw new Error(
      "You supplied an invalid color palette for theme %1's %2 palette. Available palettes: %3"
                    .replace('%1', theme.name)
                    .replace('%2', colorType)
                    .replace('%3', Object.keys(PALETTES).join(', '))
    );
  }
}

function colorToRgbaArray(clr) {
  if (angular.isArray(clr) && clr.length == 3) return clr;
  if (/^rgb/.test(clr)) {
    return clr.replace(/(^\s*rgba?\(|\)\s*$)/g, '').split(',').map(function(value, i) {
      return i == 3 ? parseFloat(value, 10) : parseInt(value, 10);
    });
  }
  if (clr.charAt(0) == '#') clr = clr.substring(1);
  if (!/^([a-fA-F0-9]{3}){1,2}$/g.test(clr)) return;

  var dig = clr.length / 3;
  var red = clr.substr(0, dig);
  var grn = clr.substr(dig, dig);
  var blu = clr.substr(dig * 2);
  if (dig === 1) {
    red += red;
    grn += grn;
    blu += blu;
  }
  return [parseInt(red, 16), parseInt(grn, 16), parseInt(blu, 16)];
}

function rgba(rgbArray, opacity) {
  if (!rgbArray) return "rgb('0,0,0')";

  if (rgbArray.length == 4) {
    rgbArray = angular.copy(rgbArray);
    opacity ? rgbArray.pop() : opacity = rgbArray.pop();
  }
  return opacity && (typeof opacity == 'number' || (typeof opacity == 'string' && opacity.length)) ?
    'rgba(' + rgbArray.join(',') + ',' + opacity + ')' :
    'rgb(' + rgbArray.join(',') + ')';
}


})(window.angular);

})();
(function(){
"use strict";

/**
 * @ngdoc module
 * @name material.components.autocomplete
 */
/*
 * @see js folder for autocomplete implementation
 */
angular.module('material.components.autocomplete', [
  'material.core',
  'material.components.icon',
  'material.components.virtualRepeat'
]);

})();
(function(){
"use strict";


MdAutocompleteCtrl.$inject = ["$scope", "$element", "$mdUtil", "$mdConstant", "$mdTheming", "$window", "$animate", "$rootElement", "$attrs", "$q", "$log", "$mdLiveAnnouncer"];angular
    .module('material.components.autocomplete')
    .controller('MdAutocompleteCtrl', MdAutocompleteCtrl);

var ITEM_HEIGHT   = 48,
    MAX_ITEMS     = 5,
    MENU_PADDING  = 8,
    INPUT_PADDING = 2, // Padding provided by `md-input-container`
    MODE_STANDARD = 'standard',
    MODE_VIRTUAL = 'virtual';

function MdAutocompleteCtrl ($scope, $element, $mdUtil, $mdConstant, $mdTheming, $window,
                             $animate, $rootElement, $attrs, $q, $log, $mdLiveAnnouncer) {

  // Internal Variables.
  var ctrl                 = this,
      itemParts            = $scope.itemsExpr.split(/ in /i),
      itemExpr             = itemParts[ 1 ],
      elements             = null,
      cache                = {},
      noBlur               = false,
      selectedItemWatchers = [],
      hasFocus             = false,
      fetchesInProgress    = 0,
      enableWrapScroll     = null,
      inputModelCtrl       = null,
      debouncedOnResize    = $mdUtil.debounce(onWindowResize),
      mode                 = MODE_VIRTUAL; // default

  // Public Exported Variables with handlers
  defineProperty('hidden', handleHiddenChange, true);

  // Public Exported Variables
  ctrl.scope      = $scope;
  ctrl.parent     = $scope.$parent;
  ctrl.itemName   = itemParts[ 0 ];
  ctrl.matches    = [];
  ctrl.loading    = false;
  ctrl.hidden     = true;
  ctrl.index      = null;
  ctrl.id         = $mdUtil.nextUid();
  ctrl.isDisabled = null;
  ctrl.isRequired = null;
  ctrl.isReadonly = null;
  ctrl.hasNotFound = false;
  ctrl.selectedMessage = $scope.selectedMessage || 'selected';

  // Public Exported Methods
  ctrl.keydown                       = keydown;
  ctrl.blur                          = blur;
  ctrl.focus                         = focus;
  ctrl.clear                         = clearValue;
  ctrl.select                        = select;
  ctrl.listEnter                     = onListEnter;
  ctrl.listLeave                     = onListLeave;
  ctrl.mouseUp                       = onMouseup;
  ctrl.getCurrentDisplayValue        = getCurrentDisplayValue;
  ctrl.registerSelectedItemWatcher   = registerSelectedItemWatcher;
  ctrl.unregisterSelectedItemWatcher = unregisterSelectedItemWatcher;
  ctrl.notFoundVisible               = notFoundVisible;
  ctrl.loadingIsVisible              = loadingIsVisible;
  ctrl.positionDropdown              = positionDropdown;

  /**
   * Report types to be used for the $mdLiveAnnouncer
   * @enum {number} Unique flag id.
   */
  var ReportType = {
    Count: 1,
    Selected: 2
  };

  return init();

  // initialization methods

  /**
   * Initialize the controller, setup watchers, gather elements
   */
  function init () {

    $mdUtil.initOptionalProperties($scope, $attrs, {
      searchText: '',
      selectedItem: null,
      clearButton: false,
      disableVirtualRepeat: false,
    });

    $mdTheming($element);
    configureWatchers();
    $mdUtil.nextTick(function () {

      gatherElements();
      moveDropdown();

      // Forward all focus events to the input element when autofocus is enabled
      if ($scope.autofocus) {
        $element.on('focus', focusInputElement);
      }
      if ($scope.inputAriaDescribedBy) {
        elements.input.setAttribute('aria-describedby', $scope.inputAriaDescribedBy);
      }
      if (!$scope.floatingLabel) {
        if ($scope.inputAriaLabel) {
          elements.input.setAttribute('aria-label', $scope.inputAriaLabel);
        } else if ($scope.inputAriaLabelledBy) {
          elements.input.setAttribute('aria-labelledby', $scope.inputAriaLabelledBy);
        } else if ($scope.placeholder) {
          // If no aria-label or aria-labelledby references are defined, then just label using the
          // placeholder.
          elements.input.setAttribute('aria-label', $scope.placeholder);
        }
      }
    });
  }

  function updateModelValidators() {
    if (!$scope.requireMatch || !inputModelCtrl) return;

    inputModelCtrl.$setValidity('md-require-match', !!$scope.selectedItem || !$scope.searchText);
  }

  /**
   * Calculates the dropdown's position and applies the new styles to the menu element
   * @returns {*}
   */
  function positionDropdown () {
    if (!elements) {
      return $mdUtil.nextTick(positionDropdown, false, $scope);
    }

    var dropdownHeight = ($scope.dropdownItems || MAX_ITEMS) * ITEM_HEIGHT;
    var hrect  = elements.wrap.getBoundingClientRect(),
        vrect  = elements.snap.getBoundingClientRect(),
        root   = elements.root.getBoundingClientRect(),
        top    = vrect.bottom - root.top,
        bot    = root.bottom - vrect.top,
        left   = hrect.left - root.left,
        width  = hrect.width,
        offset = getVerticalOffset(),
        position = $scope.dropdownPosition,
        styles, enoughBottomSpace, enoughTopSpace;
    var bottomSpace = root.bottom - vrect.bottom - MENU_PADDING + $mdUtil.getViewportTop();
    var topSpace = vrect.top - MENU_PADDING;

    // Automatically determine dropdown placement based on available space in viewport.
    if (!position) {
      enoughTopSpace = topSpace > dropdownHeight;
      enoughBottomSpace = bottomSpace > dropdownHeight;
      if (enoughBottomSpace) {
        position = 'bottom';
      } else if (enoughTopSpace) {
        position = 'top';
      } else {
        position = topSpace > bottomSpace ? 'top' : 'bottom';
      }
    }
    // Adjust the width to account for the padding provided by `md-input-container`
    if ($attrs.mdFloatingLabel) {
      left += INPUT_PADDING;
      width -= INPUT_PADDING * 2;
    }
    styles = {
      left:     left + 'px',
      minWidth: width + 'px',
      maxWidth: Math.max(hrect.right - root.left, root.right - hrect.left) - MENU_PADDING + 'px'
    };

    if (position === 'top') {
      styles.top       = 'auto';
      styles.bottom    = bot + 'px';
      styles.maxHeight = Math.min(dropdownHeight, topSpace) + 'px';
    } else {
      bottomSpace = root.bottom - hrect.bottom - MENU_PADDING + $mdUtil.getViewportTop();

      styles.top       = (top - offset) + 'px';
      styles.bottom    = 'auto';
      styles.maxHeight = Math.min(dropdownHeight, bottomSpace) + 'px';
    }

    elements.$.scrollContainer.css(styles);
    $mdUtil.nextTick(correctHorizontalAlignment, false, $scope);

    /**
     * Calculates the vertical offset for floating label examples to account for ngMessages
     * @returns {number}
     */
    function getVerticalOffset () {
      var offset = 0;
      var inputContainer = $element.find('md-input-container');
      if (inputContainer.length) {
        var input = inputContainer.find('input');
        offset = inputContainer.prop('offsetHeight');
        offset -= input.prop('offsetTop');
        offset -= input.prop('offsetHeight');
        // add in the height left up top for the floating label text
        offset += inputContainer.prop('offsetTop');
      }
      return offset;
    }

    /**
     * Makes sure that the menu doesn't go off of the screen on either side.
     */
    function correctHorizontalAlignment () {
      var dropdown = elements.scrollContainer.getBoundingClientRect(),
          styles   = {};
      if (dropdown.right > root.right) {
        styles.left = (hrect.right - dropdown.width) + 'px';
      }
      elements.$.scrollContainer.css(styles);
    }
  }

  /**
   * Moves the dropdown menu to the body tag in order to avoid z-index and overflow issues.
   */
  function moveDropdown () {
    if (!elements.$.root.length) return;
    $mdTheming(elements.$.scrollContainer);
    elements.$.scrollContainer.detach();
    elements.$.root.append(elements.$.scrollContainer);
    if ($animate.pin) $animate.pin(elements.$.scrollContainer, $rootElement);
  }

  /**
   * Sends focus to the input element.
   */
  function focusInputElement () {
    elements.input.focus();
  }

  /**
   * Sets up any watchers used by autocomplete
   */
  function configureWatchers () {
    var wait = parseInt($scope.delay, 10) || 0;

    $attrs.$observe('disabled', function (value) { ctrl.isDisabled = $mdUtil.parseAttributeBoolean(value, false); });
    $attrs.$observe('required', function (value) { ctrl.isRequired = $mdUtil.parseAttributeBoolean(value, false); });
    $attrs.$observe('readonly', function (value) { ctrl.isReadonly = $mdUtil.parseAttributeBoolean(value, false); });

    $scope.$watch('searchText', wait ? $mdUtil.debounce(handleSearchText, wait) : handleSearchText);
    $scope.$watch('selectedItem', selectedItemChange);

    angular.element($window).on('resize', debouncedOnResize);

    $scope.$on('$destroy', cleanup);
  }

  /**
   * Removes any events or leftover elements created by this controller
   */
  function cleanup () {
    if (!ctrl.hidden) {
      $mdUtil.enableScrolling();
    }

    angular.element($window).off('resize', debouncedOnResize);

    if (elements){
      var items = ['ul', 'scroller', 'scrollContainer', 'input'];
      angular.forEach(items, function(key){
        elements.$[key].remove();
      });
    }
  }

  /**
   * Event handler to be called whenever the window resizes.
   */
  function onWindowResize() {
    if (!ctrl.hidden) {
      positionDropdown();
    }
  }

  /**
   * Gathers all of the elements needed for this controller
   */
  function gatherElements () {

    var snapWrap = gatherSnapWrap();

    elements = {
      main:  $element[0],
      scrollContainer: $element[0].querySelector('.md-virtual-repeat-container, .md-standard-list-container'),
      scroller: $element[0].querySelector('.md-virtual-repeat-scroller, .md-standard-list-scroller'),
      ul:    $element.find('ul')[0],
      input: $element.find('input')[0],
      wrap:  snapWrap.wrap,
      snap:  snapWrap.snap,
      root:  document.body,
    };

    elements.li   = elements.ul.getElementsByTagName('li');
    elements.$    = getAngularElements(elements);
    mode = elements.scrollContainer.classList.contains('md-standard-list-container') ? MODE_STANDARD : MODE_VIRTUAL;
    inputModelCtrl = elements.$.input.controller('ngModel');
  }

  /**
   * Gathers the snap and wrap elements
   *
   */
  function gatherSnapWrap() {
    var element;
    var value;
    for (element = $element; element.length; element = element.parent()) {
      value = element.attr('md-autocomplete-snap');
      if (angular.isDefined(value)) break;
    }

    if (element.length) {
      return {
        snap: element[0],
        wrap: (value.toLowerCase() === 'width') ? element[0] : $element.find('md-autocomplete-wrap')[0]
      };
    }

    var wrap = $element.find('md-autocomplete-wrap')[0];
    return {
      snap: wrap,
      wrap: wrap
    };
  }

  /**
   * Gathers angular-wrapped versions of each element
   * @param elements
   * @returns {{}}
   */
  function getAngularElements (elements) {
    var obj = {};
    for (var key in elements) {
      if (elements.hasOwnProperty(key)) obj[ key ] = angular.element(elements[ key ]);
    }
    return obj;
  }

  // event/change handlers

  /**
   * Handles changes to the `hidden` property.
   * @param hidden
   * @param oldHidden
   */
  function handleHiddenChange (hidden, oldHidden) {
    if (!hidden && oldHidden) {
      positionDropdown();

      // Report in polite mode, because the screen reader should finish the default description of
      // the input element.
      reportMessages(true, ReportType.Count | ReportType.Selected);

      if (elements) {
        $mdUtil.disableScrollAround(elements.ul);
        enableWrapScroll = disableElementScrollEvents(angular.element(elements.wrap));
      }
    } else if (hidden && !oldHidden) {
      $mdUtil.enableScrolling();

      if (enableWrapScroll) {
        enableWrapScroll();
        enableWrapScroll = null;
      }
    }
  }

  /**
   * Disables scrolling for a specific element
   */
  function disableElementScrollEvents(element) {

    function preventDefault(e) {
      e.preventDefault();
    }

    element.on('wheel', preventDefault);
    element.on('touchmove', preventDefault);

    return function() {
      element.off('wheel', preventDefault);
      element.off('touchmove', preventDefault);
    };
  }

  /**
   * When the user mouses over the dropdown menu, ignore blur events.
   */
  function onListEnter () {
    noBlur = true;
  }

  /**
   * When the user's mouse leaves the menu, blur events may hide the menu again.
   */
  function onListLeave () {
    if (!hasFocus && !ctrl.hidden) elements.input.focus();
    noBlur = false;
    ctrl.hidden = shouldHide();
  }

  /**
   * When the mouse button is released, send focus back to the input field.
   */
  function onMouseup () {
    elements.input.focus();
  }

  /**
   * Handles changes to the selected item.
   * @param selectedItem
   * @param previousSelectedItem
   */
  function selectedItemChange (selectedItem, previousSelectedItem) {

    updateModelValidators();

    if (selectedItem) {
      getDisplayValue(selectedItem).then(function (val) {
        $scope.searchText = val;
        handleSelectedItemChange(selectedItem, previousSelectedItem);
      });
    } else if (previousSelectedItem && $scope.searchText) {
      getDisplayValue(previousSelectedItem).then(function(displayValue) {
        // Clear the searchText, when the selectedItem is set to null.
        // Do not clear the searchText, when the searchText isn't matching with the previous
        // selected item.
        if (angular.isString($scope.searchText)
          && displayValue.toString().toLowerCase() === $scope.searchText.toLowerCase()) {
          $scope.searchText = '';
        }
      });
    }

    if (selectedItem !== previousSelectedItem) {
      announceItemChange();
    }
  }

  /**
   * Use the user-defined expression to announce changes each time a new item is selected
   */
  function announceItemChange () {
    angular.isFunction($scope.itemChange) &&
      $scope.itemChange(getItemAsNameVal($scope.selectedItem));
  }

  /**
   * Use the user-defined expression to announce changes each time the search text is changed
   */
  function announceTextChange () {
    angular.isFunction($scope.textChange) && $scope.textChange();
  }

  /**
   * Calls any external watchers listening for the selected item.  Used in conjunction with
   * `registerSelectedItemWatcher`.
   * @param selectedItem
   * @param previousSelectedItem
   */
  function handleSelectedItemChange (selectedItem, previousSelectedItem) {
    selectedItemWatchers.forEach(function (watcher) {
      watcher(selectedItem, previousSelectedItem);
    });
  }

  /**
   * Register a function to be called when the selected item changes.
   * @param cb
   */
  function registerSelectedItemWatcher (cb) {
    if (selectedItemWatchers.indexOf(cb) === -1) {
      selectedItemWatchers.push(cb);
    }
  }

  /**
   * Unregister a function previously registered for selected item changes.
   * @param cb
   */
  function unregisterSelectedItemWatcher (cb) {
    var i = selectedItemWatchers.indexOf(cb);
    if (i !== -1) {
      selectedItemWatchers.splice(i, 1);
    }
  }

  /**
   * Handles changes to the searchText property.
   * @param searchText
   * @param previousSearchText
   */
  function handleSearchText (searchText, previousSearchText) {
    ctrl.index = getDefaultIndex();

    // do nothing on init
    if (searchText === previousSearchText) return;

    updateModelValidators();

    getDisplayValue($scope.selectedItem).then(function (val) {
      // clear selected item if search text no longer matches it
      if (searchText !== val) {
        $scope.selectedItem = null;

        // trigger change event if available
        if (searchText !== previousSearchText) {
          announceTextChange();
        }

        // cancel results if search text is not long enough
        if (!isMinLengthMet()) {
          ctrl.matches = [];

          setLoading(false);
          reportMessages(true, ReportType.Count);

        } else {
          handleQuery();
        }
      }
    });

  }

  /**
   * Handles input blur event, determines if the dropdown should hide.
   */
  function blur($event) {
    hasFocus = false;

    if (!noBlur) {
      ctrl.hidden = shouldHide();
      evalAttr('ngBlur', { $event: $event });
    }
  }

  /**
   * Force blur on input element
   * @param forceBlur
   */
  function doBlur(forceBlur) {
    if (forceBlur) {
      noBlur = false;
      hasFocus = false;
    }
    elements.input.blur();
  }

  /**
   * Handles input focus event, determines if the dropdown should show.
   */
  function focus($event) {
    hasFocus = true;

    if (isSearchable() && isMinLengthMet()) {
      handleQuery();
    }

    ctrl.hidden = shouldHide();

    evalAttr('ngFocus', { $event: $event });
  }

  /**
   * Handles keyboard input.
   * @param event
   */
  function keydown (event) {
    switch (event.keyCode) {
      case $mdConstant.KEY_CODE.DOWN_ARROW:
        if (ctrl.loading || hasSelection()) return;
        event.stopPropagation();
        event.preventDefault();
        ctrl.index   = Math.min(ctrl.index + 1, ctrl.matches.length - 1);
        updateScroll();
        reportMessages(false, ReportType.Selected);
        break;
      case $mdConstant.KEY_CODE.UP_ARROW:
        if (ctrl.loading || hasSelection()) return;
        event.stopPropagation();
        event.preventDefault();
        ctrl.index   = ctrl.index < 0 ? ctrl.matches.length - 1 : Math.max(0, ctrl.index - 1);
        updateScroll();
        reportMessages(false, ReportType.Selected);
        break;
      case $mdConstant.KEY_CODE.TAB:
        // If we hit tab, assume that we've left the list so it will close
        onListLeave();

        if (ctrl.hidden || ctrl.loading || ctrl.index < 0 || ctrl.matches.length < 1) return;
        select(ctrl.index);
        break;
      case $mdConstant.KEY_CODE.ENTER:
        if (ctrl.hidden || ctrl.loading || ctrl.index < 0 || ctrl.matches.length < 1) return;
        if (hasSelection()) return;
        event.stopImmediatePropagation();
        event.preventDefault();
        select(ctrl.index);
        break;
      case $mdConstant.KEY_CODE.ESCAPE:
        event.preventDefault(); // Prevent browser from always clearing input
        if (!shouldProcessEscape()) return;
        event.stopPropagation();

        clearSelectedItem();
        if ($scope.searchText && hasEscapeOption('clear')) {
          clearSearchText();
        }

        // Manually hide (needed for mdNotFound support)
        ctrl.hidden = true;

        if (hasEscapeOption('blur')) {
          // Force the component to blur if they hit escape
          doBlur(true);
        }

        break;
      default:
    }
  }

  // getters

  /**
   * Returns the minimum length needed to display the dropdown.
   * @returns {*}
   */
  function getMinLength () {
    return angular.isNumber($scope.minLength) ? $scope.minLength : 1;
  }

  /**
   * Returns the display value for an item.
   * @param item
   * @returns {*}
   */
  function getDisplayValue (item) {
    return $q.when(getItemText(item) || item).then(function(itemText) {
      if (itemText && !angular.isString(itemText)) {
        $log.warn('md-autocomplete: Could not resolve display value to a string. ' +
          'Please check the `md-item-text` attribute.');
      }

      return itemText;
    });

    /**
     * Getter function to invoke user-defined expression (in the directive)
     * to convert your object to a single string.
     * @param item
     * @returns {string|null}
     */
    function getItemText (item) {
      return (item && $scope.itemText) ? $scope.itemText(getItemAsNameVal(item)) : null;
    }
  }

  /**
   * Returns the locals object for compiling item templates.
   * @param item
   * @returns {Object|undefined}
   */
  function getItemAsNameVal (item) {
    if (!item) {
      return undefined;
    }

    var locals = {};
    if (ctrl.itemName) {
      locals[ ctrl.itemName ] = item;
    }

    return locals;
  }

  /**
   * Returns the default index based on whether or not autoselect is enabled.
   * @returns {number} 0 if autoselect is enabled, -1 if not.
   */
  function getDefaultIndex () {
    return $scope.autoselect ? 0 : -1;
  }

  /**
   * Sets the loading parameter and updates the hidden state.
   * @param value {boolean} Whether or not the component is currently loading.
   */
  function setLoading(value) {
    if (ctrl.loading !== value) {
      ctrl.loading = value;
    }

    // Always refresh the hidden variable as something else might have changed
    ctrl.hidden = shouldHide();
  }

  /**
   * Determines if the menu should be hidden.
   * @returns {boolean} true if the menu should be hidden
   */
  function shouldHide () {
    return !shouldShow();
  }

  /**
   * Determines whether the autocomplete is able to query within the current state.
   * @returns {boolean} true if the query can be run
   */
  function isSearchable() {
    if (ctrl.loading && !hasMatches()) {
      // No query when query is in progress.
      return false;
    } else if (hasSelection()) {
      // No query if there is already a selection
      return false;
    }
    else if (!hasFocus) {
      // No query if the input does not have focus
      return false;
    }
    return true;
  }

  /**
   * @returns {boolean} if the escape keydown should be processed, return true.
   *  Otherwise return false.
   */
  function shouldProcessEscape() {
    return hasEscapeOption('blur') || !ctrl.hidden || ctrl.loading || hasEscapeOption('clear') && $scope.searchText;
  }

  /**
   * @param {string} option check if this option is set
   * @returns {boolean} if the specified escape option is set, return true. Return false otherwise.
   */
  function hasEscapeOption(option) {
    return !$scope.escapeOptions || $scope.escapeOptions.toLowerCase().indexOf(option) !== -1;
  }

  /**
   * Determines if the menu should be shown.
   * @returns {boolean} true if the menu should be shown
   */
  function shouldShow() {
    if (ctrl.isReadonly) {
      // Don't show if read only is set
      return false;
    } else if (!isSearchable()) {
      // Don't show if a query is in progress, there is already a selection,
      // or the input is not focused.
      return false;
    }
    return (isMinLengthMet() && hasMatches()) || notFoundVisible();
  }

  /**
   * @returns {boolean} true if the search text has matches.
   */
  function hasMatches() {
    return ctrl.matches.length ? true : false;
  }

  /**
   * @returns {boolean} true if the autocomplete has a valid selection.
   */
  function hasSelection() {
    return ctrl.scope.selectedItem ? true : false;
  }

  /**
   * @returns {boolean} true if the loading indicator is, or should be, visible.
   */
  function loadingIsVisible() {
    return ctrl.loading && !hasSelection();
  }

  /**
   * @returns {*} the display value of the current item.
   */
  function getCurrentDisplayValue () {
    return getDisplayValue(ctrl.matches[ ctrl.index ]);
  }

  /**
   * Determines if the minimum length is met by the search text.
   * @returns {*} true if the minimum length is met by the search text
   */
  function isMinLengthMet () {
    return ($scope.searchText || '').length >= getMinLength();
  }

  // actions

  /**
   * Defines a public property with a handler and a default value.
   * @param {string} key
   * @param {Function} handler function
   * @param {*} value default value
   */
  function defineProperty (key, handler, value) {
    Object.defineProperty(ctrl, key, {
      get: function () { return value; },
      set: function (newValue) {
        var oldValue = value;
        value        = newValue;
        handler(newValue, oldValue);
      }
    });
  }

  /**
   * Selects the item at the given index.
   * @param {number} index to select
   */
  function select (index) {
    // force form to update state for validation
    $mdUtil.nextTick(function () {
      getDisplayValue(ctrl.matches[ index ]).then(function (val) {
        var ngModel = elements.$.input.controller('ngModel');
        $mdLiveAnnouncer.announce(val + ' ' + ctrl.selectedMessage, 'assertive');
        ngModel.$setViewValue(val);
        ngModel.$render();
      }).finally(function () {
        $scope.selectedItem = ctrl.matches[ index ];
        setLoading(false);
      });
    }, false);
  }

  /**
   * Clears the searchText value and selected item.
   */
  function clearValue () {
    clearSelectedItem();
    clearSearchText();
  }

  /**
   * Clears the selected item
   */
  function clearSelectedItem () {
    // Reset our variables
    ctrl.index = 0;
    ctrl.matches = [];
  }

  /**
   * Clears the searchText value
   */
  function clearSearchText () {
    // Set the loading to true so we don't see flashes of content.
    // The flashing will only occur when an async request is running.
    // So the loading process will stop when the results had been retrieved.
    setLoading(true);

    $scope.searchText = '';

    // Normally, triggering the change / input event is unnecessary, because the browser detects it properly.
    // But some browsers are not detecting it properly, which means that we have to trigger the event.
    // Using the `input` is not working properly, because for example IE11 is not supporting the `input` event.
    // The `change` event is a good alternative and is supported by all supported browsers.
    var eventObj = document.createEvent('CustomEvent');
    eventObj.initCustomEvent('change', true, true, { value: '' });
    elements.input.dispatchEvent(eventObj);

    // For some reason, firing the above event resets the value of $scope.searchText if
    // $scope.searchText has a space character at the end, so we blank it one more time and then
    // focus.
    elements.input.blur();
    $scope.searchText = '';
    elements.input.focus();
  }

  /**
   * Fetches the results for the provided search text.
   * @param searchText
   */
  function fetchResults (searchText) {
    var items = $scope.$parent.$eval(itemExpr),
        term  = searchText.toLowerCase(),
        isList = angular.isArray(items),
        isPromise = !!items.then; // Every promise should contain a `then` property

    if (isList) onResultsRetrieved(items);
    else if (isPromise) handleAsyncResults(items);

    function handleAsyncResults(items) {
      if (!items) return;

      items = $q.when(items);
      fetchesInProgress++;
      setLoading(true);

      $mdUtil.nextTick(function () {
          items
            .then(onResultsRetrieved)
            .finally(function(){
              if (--fetchesInProgress === 0) {
                setLoading(false);
              }
            });
      },true, $scope);
    }

    function onResultsRetrieved(matches) {
      cache[term] = matches;

      // Just cache the results if the request is now outdated.
      // The request becomes outdated, when the new searchText has changed during the result fetching.
      if ((searchText || '') !== ($scope.searchText || '')) {
        return;
      }

      handleResults(matches);
    }
  }


  /**
   * Reports given message types to supported screen readers.
   * @param {boolean} isPolite Whether the announcement should be polite.
   * @param {!number} types Message flags to be reported to the screen reader.
   */
  function reportMessages(isPolite, types) {
    var politeness = isPolite ? 'polite' : 'assertive';
    var messages = [];

    if (types & ReportType.Selected && ctrl.index !== -1) {
      messages.push(getCurrentDisplayValue());
    }

    if (types & ReportType.Count) {
      messages.push($q.resolve(getCountMessage()));
    }

    $q.all(messages).then(function(data) {
      $mdLiveAnnouncer.announce(data.join(' '), politeness);
    });
  }

  /**
   * @returns {string} the ARIA message for how many results match the current query.
   */
  function getCountMessage () {
    switch (ctrl.matches.length) {
      case 0:
        return 'There are no matches available.';
      case 1:
        return 'There is 1 match available.';
      default:
        return 'There are ' + ctrl.matches.length + ' matches available.';
    }
  }

  /**
   * Makes sure that the focused element is within view.
   */
  function updateScroll () {
    if (!elements.li[0]) return;
    if (mode === MODE_STANDARD) {
      updateStandardScroll();
    } else {
      updateVirtualScroll();
    }
  }

  function updateVirtualScroll() {
    // elements in virtual scroll have consistent heights
    var optionHeight = elements.li[0].offsetHeight,
        top = optionHeight * ctrl.index,
        bottom = top + optionHeight,
        containerHeight = elements.scroller.clientHeight,
        scrollTop = elements.scroller.scrollTop;

    if (top < scrollTop) {
      scrollTo(top);
    } else if (bottom > scrollTop + containerHeight) {
      scrollTo(bottom - containerHeight);
    }
  }

  function updateStandardScroll() {
    // elements in standard scroll have variable heights
    var selected =  elements.li[ctrl.index] || elements.li[0];
    var containerHeight = elements.scrollContainer.offsetHeight,
        top = selected && selected.offsetTop || 0,
        bottom = top + selected.clientHeight,
        scrollTop = elements.scrollContainer.scrollTop;

    if (top < scrollTop) {
      scrollTo(top);
    } else if (bottom > scrollTop + containerHeight) {
      scrollTo(bottom - containerHeight);
    }
  }

  function isPromiseFetching() {
    return fetchesInProgress !== 0;
  }

  function scrollTo (offset) {
    if (mode === MODE_STANDARD) {
      elements.scrollContainer.scrollTop = offset;
    } else {
      elements.$.scrollContainer.controller('mdVirtualRepeatContainer').scrollTo(offset);
    }
  }

  function notFoundVisible () {
    var textLength = (ctrl.scope.searchText || '').length;

    return ctrl.hasNotFound && !hasMatches() && (!ctrl.loading || isPromiseFetching()) && textLength >= getMinLength() && (hasFocus || noBlur) && !hasSelection();
  }

  /**
   * Starts the query to gather the results for the current searchText.  Attempts to return cached
   * results first, then forwards the process to `fetchResults` if necessary.
   */
  function handleQuery () {
    var searchText = $scope.searchText || '';
    var term = searchText.toLowerCase();

    // If caching is enabled and the current searchText is stored in the cache
    if (!$scope.noCache && cache[term]) {
      // The results should be handled as same as a normal un-cached request does.
      handleResults(cache[term]);
    } else {
      fetchResults(searchText);
    }

    ctrl.hidden = shouldHide();
  }

  /**
   * Handles the retrieved results by showing them in the autocompletes dropdown.
   * @param results Retrieved results
   */
  function handleResults(results) {
    ctrl.matches = results;
    ctrl.hidden  = shouldHide();

    // If loading is in progress, then we'll end the progress. This is needed for example,
    // when the `clear` button was clicked, because there we always show the loading process, to prevent flashing.
    if (ctrl.loading) setLoading(false);

    if ($scope.selectOnMatch) selectItemOnMatch();

    positionDropdown();
    reportMessages(true, ReportType.Count);
  }

  /**
   * If there is only one matching item and the search text matches its display value exactly,
   * automatically select that item.  Note: This function is only called if the user uses the
   * `md-select-on-match` flag.
   */
  function selectItemOnMatch () {
    var searchText = $scope.searchText,
        matches    = ctrl.matches,
        item       = matches[ 0 ];
    if (matches.length === 1) getDisplayValue(item).then(function (displayValue) {
      var isMatching = searchText === displayValue;
      if ($scope.matchInsensitive && !isMatching) {
        isMatching = searchText.toLowerCase() === displayValue.toLowerCase();
      }

      if (isMatching) {
        select(0);
      }
    });
  }

  /**
   * Evaluates an attribute expression against the parent scope.
   * @param {String} attr Name of the attribute to be evaluated.
   * @param {Object?} locals Properties to be injected into the evaluation context.
   */
 function evalAttr(attr, locals) {
    if ($attrs[attr]) {
      $scope.$parent.$eval($attrs[attr], locals || {});
    }
  }

}

})();
(function(){
"use strict";


MdAutocomplete.$inject = ["$$mdSvgRegistry"];angular
    .module('material.components.autocomplete')
    .directive('mdAutocomplete', MdAutocomplete);

/**
 * @ngdoc directive
 * @name mdAutocomplete
 * @module material.components.autocomplete
 *
 * @description
 * `<md-autocomplete>` is a special input component with a drop-down of all possible matches to a
 *     custom query. This component allows you to provide real-time suggestions as the user types
 *     in the input area.
 *
 * To start, you will need to specify the required parameters and provide a template for your
 *     results. The content inside `md-autocomplete` will be treated as a template.
 *
 * In more complex cases, you may want to include other content such as a message to display when
 *     no matches were found.  You can do this by wrapping your template in `md-item-template` and
 *     adding a tag for `md-not-found`.  An example of this is shown below.
 *
 * To reset the displayed value you must clear both values for `md-search-text` and
 * `md-selected-item`.
 *
 * ### Validation
 *
 * You can use `ng-messages` to include validation the same way that you would normally validate;
 *     however, if you want to replicate a standard input with a floating label, you will have to
 *     do the following:
 *
 * - Make sure that your template is wrapped in `md-item-template`
 * - Add your `ng-messages` code inside of `md-autocomplete`
 * - Add your validation properties to `md-autocomplete` (ie. `required`)
 * - Add a `name` to `md-autocomplete` (to be used on the generated `input`)
 *
 * There is an example below of how this should look.
 *
 * ### Snapping Drop-Down
 *
 * You can cause the autocomplete drop-down to snap to an ancestor element by applying the
 *     `md-autocomplete-snap` attribute to that element. You can also snap to the width of
 *     the `md-autocomplete-snap` element by setting the attribute's value to `width`
 *     (ie. `md-autocomplete-snap="width"`).
 *
 * ### Notes
 *
 * **Autocomplete Dropdown Items Rendering**
 *
 * The `md-autocomplete` uses the the <a ng-href="api/directive/mdVirtualRepeat">
 *   mdVirtualRepeat</a> directive for displaying the results inside of the dropdown.<br/>
 *
 * > When encountering issues regarding the item template please take a look at the
 *   <a ng-href="api/directive/mdVirtualRepeatContainer">VirtualRepeatContainer</a> documentation.
 *
 * **Autocomplete inside of a Virtual Repeat**
 *
 * When using the `md-autocomplete` directive inside of a
 * <a ng-href="api/directive/mdVirtualRepeatContainer">VirtualRepeatContainer</a> the dropdown items
 * might not update properly, because caching of the results is enabled by default.
 *
 * The autocomplete will then show invalid dropdown items, because the Virtual Repeat only updates
 * the scope bindings rather than re-creating the `md-autocomplete`. This means that the previous
 * cached results will be used.
 *
 * > To avoid such problems, ensure that the autocomplete does not cache any results via
 * `md-no-cache="true"`:
 *
 * <hljs lang="html">
 *   <md-autocomplete
 *       md-no-cache="true"
 *       md-selected-item="selectedItem"
 *       md-items="item in items"
 *       md-search-text="searchText"
 *       md-item-text="item.display">
 *     <span>{{ item.display }}</span>
 *   </md-autocomplete>
 * </hljs>
 *
 *
 * @param {expression} md-items An expression in the format of `item in results` to iterate over
 *     matches for your search.<br/><br/>
 *     The `results` expression can be also a function, which returns the results synchronously
 *     or asynchronously (per Promise).
 * @param {expression=} md-selected-item-change An expression to be run each time a new item is
 *     selected.
 * @param {expression=} md-search-text-change An expression to be run each time the search text
 *     updates.
 * @param {expression=} md-search-text A model to bind the search query text to.
 * @param {object=} md-selected-item A model to bind the selected item to.
 * @param {expression=} md-item-text An expression that will convert your object to a single string.
 * @param {string=} placeholder Placeholder text that will be forwarded to the input.
 * @param {boolean=} md-no-cache Disables the internal caching that happens in autocomplete.
 * @param {boolean=} ng-disabled Determines whether or not to disable the input field.
 * @param {boolean=} md-require-match When set to true, the autocomplete will add a validator,
 *     which will evaluate to false, when no item is currently selected.
 * @param {number=} md-min-length Specifies the minimum length of text before autocomplete will
 *     make suggestions.
 * @param {number=} md-delay Specifies the amount of time (in milliseconds) to wait before looking
 *     for results.
 * @param {boolean=} md-clear-button Whether the clear button for the autocomplete input should show
 *     up or not.
 * @param {boolean=} md-autofocus If true, the autocomplete will be automatically focused when a
 *     `$mdDialog`, `$mdBottomsheet` or `$mdSidenav`, which contains the autocomplete, is opening.
 *     <br/><br/>
 *     Also the autocomplete will immediately focus the input element.
 * @param {boolean=} md-no-asterisk When present, asterisk will not be appended to the floating
 *     label.
 * @param {boolean=} md-autoselect If set to true, the first item will be automatically selected
 *     in the dropdown upon open.
 * @param {string=} md-input-name The name attribute given to the input element to be used with
 *     FormController.
 * @param {string=} md-menu-class This class will be applied to the dropdown menu for styling.
 * @param {string=} md-menu-container-class This class will be applied to the parent container
 *     of the dropdown panel.
 * @param {string=} md-input-class This will be applied to the input for styling. This attribute
 *     is only valid when a `md-floating-label` is defined.
 * @param {string=} md-floating-label This will add a floating label to autocomplete and wrap it in
 *     `md-input-container`.
 * @param {string=} md-select-on-focus When present the input's text will be automatically selected
 *     on focus.
 * @param {string=} md-input-id An ID to be added to the input element.
 * @param {number=} md-input-minlength The minimum length for the input's value for validation.
 * @param {number=} md-input-maxlength The maximum length for the input's value for validation.
 * @param {boolean=} md-select-on-match When set, autocomplete will automatically select
 *     the item if the search text is an exact match. <br/><br/>
 *     An exact match is when only one match is displayed.
 * @param {boolean=} md-match-case-insensitive When set and using `md-select-on-match`, autocomplete
 *     will select on case-insensitive match.
 * @param {string=} md-escape-options Override escape key logic. Default is `blur clear`.<br/>
 *     Options: `blur`, `clear`, `none`.
 * @param {string=} md-dropdown-items Specifies the maximum amount of items to be shown in
 *     the dropdown.<br/><br/>
 *     When the dropdown doesn't fit into the viewport, the dropdown will shrink
 *     as much as possible.
 * @param {string=} md-dropdown-position Overrides the default dropdown position. Options: `top`,
 *    `bottom`.
 * @param {string=} input-aria-describedby A space-separated list of element IDs. This should
 *     contain the IDs of any elements that describe this autocomplete. Screen readers will read the
 *     content of these elements at the end of announcing that the autocomplete has been selected
 *     and describing its current state. The descriptive elements do not need to be visible on the
 *     page.
 * @param {string=} input-aria-labelledby A space-separated list of element IDs. The ideal use case
 *     is that this would contain the ID of a `<label>` element that is associated with this
 *     autocomplete. This will only have affect when `md-floating-label` is not defined.<br><br>
 *     For `<label id="state">US State</label>`, you would set this to
 *     `input-aria-labelledby="state"`.
 * @param {string=} input-aria-label A label that will be applied to the autocomplete's input.
 *    This will be announced by screen readers before the placeholder.
 *    This will only have affect when `md-floating-label` is not defined. If you define both
 *    `input-aria-label` and `input-aria-labelledby`, then `input-aria-label` will take precedence.
 * @param {string=} md-selected-message Attribute to specify the text that the screen reader will
 *    announce after a value is selected. Default is: "selected". If `Alaska` is selected in the
 *    options panel, it will read "Alaska selected". You will want to override this when your app
 *    is running in a non-English locale.
 * @param {boolean=} ng-trim If set to false, the search text will be not trimmed automatically.
 *     Defaults to true.
 * @param {string=} ng-pattern Adds the pattern validator to the ngModel of the search text.
 *     See the [ngPattern Directive](https://docs.angularjs.org/api/ng/directive/ngPattern)
 *     for more details.
 * @param {string=} md-mode Specify the repeat mode for suggestion lists. Acceptable values include
 *     `virtual` (md-virtual-repeat) and `standard` (ng-repeat). See the
 *     `Specifying Repeat Mode` example for mode details. Default is `virtual`.
 *
 * @usage
 * ### Basic Example
 * <hljs lang="html">
 *   <md-autocomplete
 *       md-selected-item="selectedItem"
 *       md-search-text="searchText"
 *       md-items="item in getMatches(searchText)"
 *       md-item-text="item.display">
 *     <span md-highlight-text="searchText">{{item.display}}</span>
 *   </md-autocomplete>
 * </hljs>
 *
 * ### Example with "not found" message
 * <hljs lang="html">
 * <md-autocomplete
 *     md-selected-item="selectedItem"
 *     md-search-text="searchText"
 *     md-items="item in getMatches(searchText)"
 *     md-item-text="item.display">
 *   <md-item-template>
 *     <span md-highlight-text="searchText">{{item.display}}</span>
 *   </md-item-template>
 *   <md-not-found>
 *     No matches found.
 *   </md-not-found>
 * </md-autocomplete>
 * </hljs>
 *
 * In this example, our code utilizes `md-item-template` and `md-not-found` to specify the
 *     different parts that make up our component.
 *
 * ### Clear button for the input
 * By default, the clear button is displayed when there is input. This aligns with the spec's
 * [Search Pattern](https://material.io/archive/guidelines/patterns/search.html#search-in-app-search).
 * In floating label mode, when `md-floating-label="My Label"` is applied, the clear button is not
 * displayed by default (see the spec's
 * [Autocomplete Text Field](https://material.io/archive/guidelines/components/text-fields.html#text-fields-layout)).
 *
 * Nevertheless, developers are able to explicitly toggle the clear button for all autocomplete
 * components with `md-clear-button`.
 *
 * <hljs lang="html">
 *   <md-autocomplete ... md-clear-button="true"></md-autocomplete>
 *   <md-autocomplete ... md-clear-button="false"></md-autocomplete>
 * </hljs>
 *
 * In previous versions, the clear button was always hidden when the component was disabled.
 * This changed in `1.1.5` to give the developer control of this behavior. This example
 * will hide the clear button only when the component is disabled.
 *
 * <hljs lang="html">
 *   <md-autocomplete ... ng-disabled="disabled" md-clear-button="!disabled"></md-autocomplete>
 * </hljs>
 *
 * ### Example with validation
 * <hljs lang="html">
 * <form name="autocompleteForm">
 *   <md-autocomplete
 *       required
 *       md-input-name="autocomplete"
 *       md-selected-item="selectedItem"
 *       md-search-text="searchText"
 *       md-items="item in getMatches(searchText)"
 *       md-item-text="item.display">
 *     <md-item-template>
 *       <span md-highlight-text="searchText">{{item.display}}</span>
 *     </md-item-template>
 *     <div ng-messages="autocompleteForm.autocomplete.$error">
 *       <div ng-message="required">This field is required</div>
 *     </div>
 *   </md-autocomplete>
 * </form>
 * </hljs>
 *
 * In this example, our code utilizes `md-item-template` and `ng-messages` to specify
 *     input validation for the field.
 *
 * ### Asynchronous Results
 * The autocomplete items expression also supports promises, which will resolve with the query
 * results.
 *
 * <hljs lang="js">
 *   function AppController($scope, $http) {
 *     $scope.query = function(searchText) {
 *       return $http
 *         .get(BACKEND_URL + '/items/' + searchText)
 *         .then(function(data) {
 *           // Map the response object to the data object.
 *           return data;
 *         });
 *     };
 *   }
 * </hljs>
 *
 * <hljs lang="html">
 *   <md-autocomplete
 *       md-selected-item="selectedItem"
 *       md-search-text="searchText"
 *       md-items="item in query(searchText)">
 *     <md-item-template>
 *       <span md-highlight-text="searchText">{{item}}</span>
 *     </md-item-template>
 * </md-autocomplete>
 * </hljs>
 *
 * ### Specifying Repeat Mode
 * You can use `md-mode` to specify whether to use standard or virtual lists for
 * rendering autocomplete options.
 * The `md-mode` accepts two values:
 * - `virtual` (default) Uses `md-virtual-repeat` to render list items. Virtual
 *    mode requires you to have consistent heights for all suggestions.
 * - `standard` uses `ng-repeat` to render list items. This allows you to have
 *    options of varying heights.
 *
 * Note that using 'standard' mode will require you to address any list
 * performance issues (e.g. pagination) separately within your application.
 *
 * <hljs lang="html">
 *   <md-autocomplete
 *       md-selected-item="selectedItem"
 *       md-search-text="searchText"
 *       md-items="item in getMatches(searchText)"
 *       md-item-text="item.display"
 *       md-mode="standard">
 *     <span md-highlight-text="searchText">{{item.display}}</span>
 *   </md-autocomplete>
 * </hljs>
 */
function MdAutocomplete ($$mdSvgRegistry) {
  var REPEAT_STANDARD = 'standard';
  var REPEAT_VIRTUAL = 'virtual';
  var REPEAT_MODES = [REPEAT_STANDARD, REPEAT_VIRTUAL];

  /** get a valid repeat mode from an md-mode attribute string. */
  function getRepeatMode(modeStr) {
    if (!modeStr) { return REPEAT_VIRTUAL; }
    modeStr = modeStr.toLowerCase();
    return  REPEAT_MODES.indexOf(modeStr) > -1 ? modeStr : REPEAT_VIRTUAL;
  }

  return {
    controller:   'MdAutocompleteCtrl',
    controllerAs: '$mdAutocompleteCtrl',
    scope:        {
      inputName:          '@mdInputName',
      inputMinlength:     '@mdInputMinlength',
      inputMaxlength:     '@mdInputMaxlength',
      searchText:         '=?mdSearchText',
      selectedItem:       '=?mdSelectedItem',
      itemsExpr:          '@mdItems',
      itemText:           '&mdItemText',
      placeholder:        '@placeholder',
      inputAriaDescribedBy: '@?inputAriaDescribedby',
      inputAriaLabelledBy: '@?inputAriaLabelledby',
      inputAriaLabel:     '@?inputAriaLabel',
      noCache:            '=?mdNoCache',
      requireMatch:       '=?mdRequireMatch',
      selectOnMatch:      '=?mdSelectOnMatch',
      matchInsensitive:   '=?mdMatchCaseInsensitive',
      itemChange:         '&?mdSelectedItemChange',
      textChange:         '&?mdSearchTextChange',
      minLength:          '=?mdMinLength',
      delay:              '=?mdDelay',
      autofocus:          '=?mdAutofocus',
      floatingLabel:      '@?mdFloatingLabel',
      autoselect:         '=?mdAutoselect',
      menuClass:          '@?mdMenuClass',
      menuContainerClass: '@?mdMenuContainerClass',
      inputClass:         '@?mdInputClass',
      inputId:            '@?mdInputId',
      escapeOptions:      '@?mdEscapeOptions',
      dropdownItems:      '=?mdDropdownItems',
      dropdownPosition:   '@?mdDropdownPosition',
      clearButton:        '=?mdClearButton',
      selectedMessage:    '@?mdSelectedMessage',
      mdMode: '=?mdMode'
    },
    compile: function(tElement, tAttrs) {
      var attributes = ['md-select-on-focus', 'md-no-asterisk', 'ng-trim', 'ng-pattern'];
      var input = tElement.find('input');

      attributes.forEach(function(attribute) {
        var attrValue = tAttrs[tAttrs.$normalize(attribute)];

        if (attrValue !== null) {
          input.attr(attribute, attrValue);
        }
      });

      return function(scope, element, attrs, ctrl) {
        // Retrieve the state of using a md-not-found template by using our attribute, which will
        // be added to the element in the template function.
        ctrl.hasNotFound = !!element.attr('md-has-not-found');

        // By default the inset autocomplete should show the clear button when not explicitly
        // overwritten or in floating label mode.
        if (!angular.isDefined(attrs.mdClearButton) && !scope.floatingLabel) {
          scope.clearButton = true;
        }

        scope.mdMode = getRepeatMode(attrs.mdMode);
      };
    },
    template:     function (element, attr) {
      var noItemsTemplate = getNoItemsTemplate(),
          itemTemplate    = getItemTemplate(),
          leftover        = element.html(),
          tabindex        = attr.tabindex;

      // Set our attribute for the link function above which runs later.
      // We will set an attribute, because otherwise the stored variables will be trashed when
      // removing the element is hidden while retrieving the template. For example when using ngIf.
      if (noItemsTemplate) element.attr('md-has-not-found', true);

      // Always set our tabindex of the autocomplete directive to -1, because our input
      // will hold the actual tabindex.
      element.attr('tabindex', '-1');

      return '\
        <md-autocomplete-wrap\
            ng-class="{ \'md-whiteframe-z1\': !floatingLabel, \
                        \'md-menu-showing\': !$mdAutocompleteCtrl.hidden, \
                        \'md-show-clear-button\': !!clearButton }">\
          ' + getInputElement() + '\
          ' + getClearButton() + '\
          <md-progress-linear\
              class="' + (attr.mdFloatingLabel ? 'md-inline' : '') + '"\
              ng-if="$mdAutocompleteCtrl.loadingIsVisible()"\
              md-mode="indeterminate"></md-progress-linear>\
          ' + getContainer(attr.mdMenuContainerClass, attr.mdMode) + '\
            <ul class="md-autocomplete-suggestions"\
                ng-class="::menuClass"\
                id="ul-{{$mdAutocompleteCtrl.id}}"\
                ng-mouseenter="$mdAutocompleteCtrl.listEnter()"\
                ng-mouseleave="$mdAutocompleteCtrl.listLeave()"\
                ng-mouseup="$mdAutocompleteCtrl.mouseUp()"\
                role="listbox">\
              <li ' + getRepeatType(attr.mdMode) + ' ="item in $mdAutocompleteCtrl.matches"\
                  ng-class="{ selected: $index === $mdAutocompleteCtrl.index }"\
                  ng-attr-id="{{$index === $mdAutocompleteCtrl.index ? \'selected_option\' : undefined}}"\
                  ng-click="$mdAutocompleteCtrl.select($index)"\
                  role="option"\
                  aria-setsize="{{$mdAutocompleteCtrl.matches.length}}"\
                  aria-posinset="{{$index+1}}"\
                  aria-selected="{{$index === $mdAutocompleteCtrl.index ? true : false}}" \
                  md-extra-name="$mdAutocompleteCtrl.itemName">\
                  ' + itemTemplate + '\
                  </li>' + noItemsTemplate + '\
            </ul>\
          '  + getContainerClosingTags(attr.mdMode) + '\
        </md-autocomplete-wrap>';

      function getItemTemplate() {
        var templateTag = element.find('md-item-template').detach(),
            html = templateTag.length ? templateTag.html() : element.html();
        if (!templateTag.length) element.empty();
        return '<md-autocomplete-parent-scope md-autocomplete-replace>' + html +
               '</md-autocomplete-parent-scope>';
      }

      function getNoItemsTemplate() {
        var templateTag = element.find('md-not-found').detach(),
            template = templateTag.length ? templateTag.html() : '';
        return template
            ? '<li ng-if="$mdAutocompleteCtrl.notFoundVisible()"\
                         md-autocomplete-parent-scope>' + template + '</li>'
            : '';
      }

      function getContainer(menuContainerClass, repeatMode) {
        // prepend a space if needed
        menuContainerClass = menuContainerClass ? ' ' + menuContainerClass : '';

        if (isVirtualRepeatDisabled(repeatMode)) {
          return '\
            <div \
                ng-hide="$mdAutocompleteCtrl.hidden"\
                class="md-standard-list-container md-autocomplete-suggestions-container md-whiteframe-z1' + menuContainerClass + '"\
                ng-class="{ \'md-not-found\': $mdAutocompleteCtrl.notFoundVisible() }"\
                role="presentation">\
              <div class="md-standard-list-scroller" role="presentation">';
        }

        return '\
          <md-virtual-repeat-container\
              md-auto-shrink\
              md-auto-shrink-min="1"\
              ng-hide="$mdAutocompleteCtrl.hidden"\
              class="md-virtual-repeat-container md-autocomplete-suggestions-container md-whiteframe-z1' + menuContainerClass + '"\
              ng-class="{ \'md-not-found\': $mdAutocompleteCtrl.notFoundVisible() }"\
              role="presentation">';
      }

      function getContainerClosingTags(repeatMode) {
        return isVirtualRepeatDisabled(repeatMode) ?
            '   </div>\
              </div>\
            </div>' : '</md-virtual-repeat-container>';
      }

      function getRepeatType(repeatMode) {
        return isVirtualRepeatDisabled(repeatMode)  ?
          'ng-repeat' : 'md-virtual-repeat';
      }

      function isVirtualRepeatDisabled(repeatMode) {
        // ensure we have a valid repeat mode
        var correctedRepeatMode = getRepeatMode(repeatMode);
        return correctedRepeatMode !== REPEAT_VIRTUAL;
      }

      function getInputElement () {
        if (attr.mdFloatingLabel) {
          return '\
            <md-input-container ng-if="floatingLabel">\
              <label>{{floatingLabel}}</label>\
              <input type="search"\
                ' + (tabindex != null ? 'tabindex="' + tabindex + '"' : '') + '\
                id="{{ inputId || \'fl-input-\' + $mdAutocompleteCtrl.id }}"\
                name="{{inputName}}"\
                ng-class="::inputClass"\
                autocomplete="off"\
                ng-required="$mdAutocompleteCtrl.isRequired"\
                ng-readonly="$mdAutocompleteCtrl.isReadonly"\
                ng-minlength="inputMinlength"\
                ng-maxlength="inputMaxlength"\
                ng-disabled="$mdAutocompleteCtrl.isDisabled"\
                ng-model="$mdAutocompleteCtrl.scope.searchText"\
                ng-model-options="{ allowInvalid: true }"\
                ng-keydown="$mdAutocompleteCtrl.keydown($event)"\
                ng-blur="$mdAutocompleteCtrl.blur($event)"\
                ng-focus="$mdAutocompleteCtrl.focus($event)"\
                aria-label="{{floatingLabel}}"\
                aria-autocomplete="list"\
                role="combobox"\
                aria-haspopup="true"\
                aria-expanded="{{!$mdAutocompleteCtrl.hidden}}"\
                aria-owns="ul-{{$mdAutocompleteCtrl.id}}"\
                ng-attr-aria-activedescendant="{{$mdAutocompleteCtrl.index >= 0 ? \'selected_option\' : undefined}}">\
              <div md-autocomplete-parent-scope md-autocomplete-replace>' + leftover + '</div>\
            </md-input-container>';
        } else {
          return '\
            <input type="search"\
              ' + (tabindex != null ? 'tabindex="' + tabindex + '"' : '') + '\
              id="{{ inputId || \'input-\' + $mdAutocompleteCtrl.id }}"\
              name="{{inputName}}"\
              ng-class="::inputClass"\
              ng-if="!floatingLabel"\
              autocomplete="off"\
              ng-required="$mdAutocompleteCtrl.isRequired"\
              ng-disabled="$mdAutocompleteCtrl.isDisabled"\
              ng-readonly="$mdAutocompleteCtrl.isReadonly"\
              ng-minlength="inputMinlength"\
              ng-maxlength="inputMaxlength"\
              ng-model="$mdAutocompleteCtrl.scope.searchText"\
              ng-keydown="$mdAutocompleteCtrl.keydown($event)"\
              ng-blur="$mdAutocompleteCtrl.blur($event)"\
              ng-focus="$mdAutocompleteCtrl.focus($event)"\
              placeholder="{{placeholder}}"\
              aria-label="{{placeholder}}"\
              aria-autocomplete="list"\
              role="combobox"\
              aria-haspopup="true"\
              aria-expanded="{{!$mdAutocompleteCtrl.hidden}}"\
              aria-owns="ul-{{$mdAutocompleteCtrl.id}}"\
              ng-attr-aria-activedescendant="{{$mdAutocompleteCtrl.index >= 0 ? \'selected_option\' : undefined}}">';
        }
      }

      function getClearButton() {
        return '' +
          '<button ' +
              'type="button" ' +
              'aria-label="Clear Input" ' +
              'tabindex="-1" ' +
              'ng-if="clearButton && $mdAutocompleteCtrl.scope.searchText" ' +
              'ng-click="$mdAutocompleteCtrl.clear($event)">' +
            '<md-icon md-svg-src="' + $$mdSvgRegistry.mdClose + '"></md-icon>' +
          '</button>';
        }
    }
  };
}

})();
(function(){
"use strict";


MdAutocompleteItemScopeDirective.$inject = ["$compile", "$mdUtil"];angular
  .module('material.components.autocomplete')
  .directive('mdAutocompleteParentScope', MdAutocompleteItemScopeDirective);

function MdAutocompleteItemScopeDirective($compile, $mdUtil) {
  return {
    restrict: 'AE',
    compile: compile,
    terminal: true,
    transclude: 'element'
  };

  function compile(tElement, tAttr, transclude) {
    return function postLink(scope, element, attr) {
      var ctrl = scope.$mdAutocompleteCtrl;
      var newScope = ctrl.parent.$new();
      var itemName = ctrl.itemName;

      // Watch for changes to our scope's variables and copy them to the new scope
      watchVariable('$index', '$index');
      watchVariable('item', itemName);

      // Ensure that $digest calls on our scope trigger $digest on newScope.
      connectScopes();

      // Link the element against newScope.
      transclude(newScope, function(clone) {
        element.after(clone);
      });

      /**
       * Creates a watcher for variables that are copied from the parent scope
       * @param variable
       * @param alias
       */
      function watchVariable(variable, alias) {
        newScope[alias] = scope[variable];

        scope.$watch(variable, function(value) {
          $mdUtil.nextTick(function() {
            newScope[alias] = value;
          });
        });
      }

      /**
       * Creates watchers on scope and newScope that ensure that for any
       * $digest of scope, newScope is also $digested.
       */
      function connectScopes() {
        var scopeDigesting = false;
        var newScopeDigesting = false;

        scope.$watch(function() {
          if (newScopeDigesting || scopeDigesting) {
            return;
          }

          scopeDigesting = true;
          scope.$$postDigest(function() {
            if (!newScopeDigesting) {
              newScope.$digest();
            }

            scopeDigesting = newScopeDigesting = false;
          });
        });

        newScope.$watch(function() {
          newScopeDigesting = true;
        });
      }
    };
  }
}
})();
(function(){
"use strict";


MdHighlightCtrl.$inject = ["$scope", "$element", "$attrs"];angular
    .module('material.components.autocomplete')
    .controller('MdHighlightCtrl', MdHighlightCtrl);

function MdHighlightCtrl ($scope, $element, $attrs) {
  this.$scope = $scope;
  this.$element = $element;
  this.$attrs = $attrs;

  // Cache the Regex to avoid rebuilding each time.
  this.regex = null;
}

MdHighlightCtrl.prototype.init = function(unsafeTermFn, unsafeContentFn) {

  this.flags = this.$attrs.mdHighlightFlags || '';

  this.unregisterFn = this.$scope.$watch(function($scope) {
    return {
      term: unsafeTermFn($scope),
      contentText: unsafeContentFn($scope)
    };
  }.bind(this), this.onRender.bind(this), true);

  this.$element.on('$destroy', this.unregisterFn);
};

/**
 * Triggered once a new change has been recognized and the highlighted
 * text needs to be updated.
 */
MdHighlightCtrl.prototype.onRender = function(state, prevState) {

  var contentText = state.contentText;

  /* Update the regex if it's outdated, because we don't want to rebuilt it constantly. */
  if (this.regex === null || state.term !== prevState.term) {
    this.regex = this.createRegex(state.term, this.flags);
  }

  /* If a term is available apply the regex to the content */
  if (state.term) {
    this.applyRegex(contentText);
  } else {
    this.$element.text(contentText);
  }

};

/**
 * Decomposes the specified text into different tokens (whether match or not).
 * Breaking down the string guarantees proper XSS protection due to the native browser
 * escaping of unsafe text.
 */
MdHighlightCtrl.prototype.applyRegex = function(text) {
  var tokens = this.resolveTokens(text);

  this.$element.empty();

  tokens.forEach(function (token) {

    if (token.isMatch) {
      var tokenEl = angular.element('<span class="highlight">').text(token.text);

      this.$element.append(tokenEl);
    } else {
      this.$element.append(document.createTextNode(token));
    }

  }.bind(this));

};

  /**
 * Decomposes the specified text into different tokens by running the regex against the text.
 */
MdHighlightCtrl.prototype.resolveTokens = function(string) {
  var tokens = [];
  var lastIndex = 0;

  // Use replace here, because it supports global and single regular expressions at same time.
  string.replace(this.regex, function(match, index) {
    appendToken(lastIndex, index);

    tokens.push({
      text: match,
      isMatch: true
    });

    lastIndex = index + match.length;
  });

  // Append the missing text as a token.
  appendToken(lastIndex);

  return tokens;

  function appendToken(from, to) {
    var targetText = string.slice(from, to);
    targetText && tokens.push(targetText);
  }
};

/** Creates a regex for the specified text with the given flags. */
MdHighlightCtrl.prototype.createRegex = function(term, flags) {
  var startFlag = '', endFlag = '';
  var regexTerm = this.sanitizeRegex(term);

  if (flags.indexOf('^') >= 0) startFlag = '^';
  if (flags.indexOf('$') >= 0) endFlag = '$';

  return new RegExp(startFlag + regexTerm + endFlag, flags.replace(/[$^]/g, ''));
};

/** Sanitizes a regex by removing all common RegExp identifiers */
MdHighlightCtrl.prototype.sanitizeRegex = function(term) {
  return term && term.toString().replace(/[\\^$*+?.()|{}[\]]/g, '\\$&');
};

})();
(function(){
"use strict";


MdHighlight.$inject = ["$interpolate", "$parse"];angular
    .module('material.components.autocomplete')
    .directive('mdHighlightText', MdHighlight);

/**
 * @ngdoc directive
 * @name mdHighlightText
 * @module material.components.autocomplete
 *
 * @description
 * The `md-highlight-text` directive allows you to specify text that should be highlighted within
 *     an element.  Highlighted text will be wrapped in `<span class="highlight"></span>` which can
 *     be styled through CSS.  Please note that child elements may not be used with this directive.
 *
 * @param {string} md-highlight-text A model to be searched for
 * @param {string=} md-highlight-flags A list of flags (loosely based on JavaScript RexExp flags).
 * #### **Supported flags**:
 * - `g`: Find all matches within the provided text
 * - `i`: Ignore case when searching for matches
 * - `$`: Only match if the text ends with the search term
 * - `^`: Only match if the text begins with the search term
 *
 * @usage
 * <hljs lang="html">
 * <input placeholder="Enter a search term..." ng-model="searchTerm" type="text" />
 * <ul>
 *   <li ng-repeat="result in results" md-highlight-text="searchTerm" md-highlight-flags="i">
 *     {{result.text}}
 *   </li>
 * </ul>
 * </hljs>
 */

function MdHighlight ($interpolate, $parse) {
  return {
    terminal: true,
    controller: 'MdHighlightCtrl',
    compile: function mdHighlightCompile(tElement, tAttr) {
      var termExpr = $parse(tAttr.mdHighlightText);
      var unsafeContentExpr = $interpolate(tElement.html());

      return function mdHighlightLink(scope, element, attr, ctrl) {
        ctrl.init(termExpr, unsafeContentExpr);
      };
    }
  };
}

})();
(function(){
"use strict";

/*
 * @ngdoc module
 * @name material.components.backdrop
 * @description Backdrop
 */

/**
 * @ngdoc directive
 * @name mdBackdrop
 * @module material.components.backdrop
 *
 * @restrict E
 *
 * @description
 * `<md-backdrop>` is a backdrop element used by other components, such as dialog and bottom sheet.
 * Apply class `opaque` to make the backdrop use the theme backdrop color.
 *
 */

angular
  .module('material.components.backdrop', ['material.core'])
  .directive('mdBackdrop', ["$mdTheming", "$mdUtil", "$animate", "$rootElement", "$window", "$log", "$$rAF", "$document", function BackdropDirective($mdTheming, $mdUtil, $animate, $rootElement, $window, $log, $$rAF, $document) {
    var ERROR_CSS_POSITION = '<md-backdrop> may not work properly in a scrolled, static-positioned parent container.';

    return {
      restrict: 'E',
      link: postLink
    };

    function postLink(scope, element, attrs) {
      // backdrop may be outside the $rootElement, tell ngAnimate to animate regardless
      if ($animate.pin) $animate.pin(element, $rootElement);

      var bodyStyles;

      $$rAF(function() {
        // If body scrolling has been disabled using mdUtil.disableBodyScroll(),
        // adjust the 'backdrop' height to account for the fixed 'body' top offset.
        // Note that this can be pretty expensive and is better done inside the $$rAF.
        bodyStyles = $window.getComputedStyle($document[0].body);

        if (bodyStyles.position === 'fixed') {
          var resizeHandler = $mdUtil.debounce(function(){
            bodyStyles = $window.getComputedStyle($document[0].body);
            resize();
          }, 60, null, false);

          resize();
          angular.element($window).on('resize', resizeHandler);

          scope.$on('$destroy', function() {
            angular.element($window).off('resize', resizeHandler);
          });
        }

        // Often $animate.enter() is used to append the backDrop element
        // so let's wait until $animate is done...
        var parent = element.parent();

        if (parent.length) {
          if (parent[0].nodeName === 'BODY') {
            element.css('position', 'fixed');
          }

          var styles = $window.getComputedStyle(parent[0]);

          if (styles.position === 'static') {
            // backdrop uses position:absolute and will not work properly with parent position:static (default)
            $log.warn(ERROR_CSS_POSITION);
          }

          // Only inherit the parent if the backdrop has a parent.
          $mdTheming.inherit(element, parent);
        }
      });

      function resize() {
        var viewportHeight = parseInt(bodyStyles.height, 10) + Math.abs(parseInt(bodyStyles.top, 10));
        element.css('height', viewportHeight + 'px');
      }
    }

  }]);

})();
(function(){
"use strict";

/**
 * @ngdoc module
 * @name material.components.bottomSheet
 * @description
 * BottomSheet
 */
MdBottomSheetDirective.$inject = ["$mdBottomSheet"];
MdBottomSheetProvider.$inject = ["$$interimElementProvider"];
angular
  .module('material.components.bottomSheet', [
    'material.core',
    'material.components.backdrop'
  ])
  .directive('mdBottomSheet', MdBottomSheetDirective)
  .provider('$mdBottomSheet', MdBottomSheetProvider);

/* @ngInject */
function MdBottomSheetDirective($mdBottomSheet) {
  return {
    restrict: 'E',
    link : function postLink(scope, element) {
      element.addClass('_md');     // private md component indicator for styling

      // When navigation force destroys an interimElement, then
      // listen and $destroy() that interim instance...
      scope.$on('$destroy', function() {
        $mdBottomSheet.destroy();
      });
    }
  };
}


/**
 * @ngdoc service
 * @name $mdBottomSheet
 * @module material.components.bottomSheet
 *
 * @description
 * `$mdBottomSheet` opens a bottom sheet over the app and provides a simple promise API.
 *
 * ## Restrictions
 *
 * - The bottom sheet's template must have an outer `<md-bottom-sheet>` element.
 * - Add the `md-grid` class to the bottom sheet for a grid layout.
 * - Add the `md-list` class to the bottom sheet for a list layout.
 *
 * @usage
 * <hljs lang="html">
 * <div ng-controller="MyController">
 *   <md-button ng-click="openBottomSheet()">
 *     Open a Bottom Sheet!
 *   </md-button>
 * </div>
 * </hljs>
 * <hljs lang="js">
 * var app = angular.module('app', ['ngMaterial']);
 * app.controller('MyController', function($scope, $mdBottomSheet) {
 *   $scope.openBottomSheet = function() {
 *     $mdBottomSheet.show({
 *       template: '<md-bottom-sheet>' +
 *       'Hello! <md-button ng-click="closeBottomSheet()">Close</md-button>' +
 *       '</md-bottom-sheet>'
 *     })
 *
 *     // Fires when the hide() method is used
 *     .then(function() {
 *       console.log('You clicked the button to close the bottom sheet!');
 *     })
 *
 *     // Fires when the cancel() method is used
 *     .catch(function() {
 *       console.log('You hit escape or clicked the backdrop to close.');
 *     });
 *   };
 *
 *   $scope.closeBottomSheet = function($scope, $mdBottomSheet) {
 *     $mdBottomSheet.hide();
 *   }
 *
 * });
 * </hljs>
 *
 * ### Custom Presets
 * Developers are also able to create their own preset, which can be easily used without repeating
 * their options each time.
 *
 * <hljs lang="js">
 *   $mdBottomSheetProvider.addPreset('testPreset', {
 *     options: function() {
 *       return {
 *         template:
 *           '<md-bottom-sheet>' +
 *             'This is a custom preset' +
 *           '</md-bottom-sheet>',
 *         controllerAs: 'bottomSheet',
 *         bindToController: true,
 *         clickOutsideToClose: true,
 *         escapeToClose: true
 *       };
 *     }
 *   });
 * </hljs>
 *
 * After you create your preset during the config phase, you can easily access it.
 *
 * <hljs lang="js">
 *   $mdBottomSheet.show(
 *     $mdBottomSheet.testPreset()
 *   );
 * </hljs>
 */

 /**
 * @ngdoc method
 * @name $mdBottomSheet#show
 *
 * @description
 * Show a bottom sheet with the specified options.
 *
 * <em><b>Note:</b> You should <b>always</b> provide a `.catch()` method in case the user hits the
 * `esc` key or clicks the background to close. In this case, the `cancel()` method will
 * automatically be called on the bottom sheet which will `reject()` the promise. See the @usage
 * section above for an example.
 *
 * Newer versions of Angular will throw a `Possibly unhandled rejection` exception if you forget
 * this.</em>
 *
 * @param {object} optionsOrPreset Either provide an `$mdBottomSheetPreset` defined during the config phase or
 * an options object, with the following properties:
 *
 *   - `templateUrl` - `{string=}`: The url of an html template file that will
 *   be used as the content of the bottom sheet. Restrictions: the template must
 *   have an outer `md-bottom-sheet` element.
 *   - `template` - `{string=}`: Same as templateUrl, except this is an actual
 *   template string.
 *   - `scope` - `{object=}`: the scope to link the template / controller to. If none is specified, it will create a new child scope.
 *     This scope will be destroyed when the bottom sheet is removed unless `preserveScope` is set to true.
 *   - `preserveScope` - `{boolean=}`: whether to preserve the scope when the element is removed. Default is false
 *   - `controller` - `{string=}`: The controller to associate with this bottom sheet.
 *   - `locals` - `{string=}`: An object containing key/value pairs. The keys will
 *   be used as names of values to inject into the controller. For example,
 *   `locals: {three: 3}` would inject `three` into the controller with the value
 *   of 3.
 *   - `clickOutsideToClose` - `{boolean=}`: Whether the user can click outside the bottom sheet to
 *     close it. Default true.
 *   - `bindToController` - `{boolean=}`: When set to true, the locals will be bound to the controller instance.
 *   - `disableBackdrop` - `{boolean=}`: When set to true, the bottomsheet will not show a backdrop.
 *   - `escapeToClose` - `{boolean=}`: Whether the user can press escape to close the bottom sheet.
 *     Default true.
 *   - `isLockedOpen` - `{boolean=}`: Disables all default ways of closing the bottom sheet. **Note:** this will override
 *     the `clickOutsideToClose` and `escapeToClose` options, leaving only the `hide` and `cancel`
 *     methods as ways of closing the bottom sheet. Defaults to false.
 *   - `resolve` - `{object=}`: Similar to locals, except it takes promises as values
 *   and the bottom sheet will not open until the promises resolve.
 *   - `controllerAs` - `{string=}`: An alias to assign the controller to on the scope.
 *   - `parent` - `{element=}`: The element to append the bottom sheet to. The `parent` may be a `function`, `string`,
 *   `object`, or null. Defaults to appending to the body of the root element (or the root element) of the application.
 *   e.g. angular.element(document.getElementById('content')) or "#content"
 *   - `disableParentScroll` - `{boolean=}`: Whether to disable scrolling while the bottom sheet is open.
 *     Default true.
 *
 * @returns {promise} A promise that can be resolved with `$mdBottomSheet.hide()` or
 * rejected with `$mdBottomSheet.cancel()`.
 */

/**
 * @ngdoc method
 * @name $mdBottomSheet#hide
 *
 * @description
 * Hide the existing bottom sheet and resolve the promise returned from
 * `$mdBottomSheet.show()`. This call will close the most recently opened/current bottomsheet (if
 * any).
 *
 * <em><b>Note:</b> Use a `.then()` on your `.show()` to handle this callback.</em>
 *
 * @param {*=} response An argument for the resolved promise.
 *
 */

/**
 * @ngdoc method
 * @name $mdBottomSheet#cancel
 *
 * @description
 * Hide the existing bottom sheet and reject the promise returned from
 * `$mdBottomSheet.show()`.
 *
 * <em><b>Note:</b> Use a `.catch()` on your `.show()` to handle this callback.</em>
 *
 * @param {*=} response An argument for the rejected promise.
 *
 */

function MdBottomSheetProvider($$interimElementProvider) {
  // how fast we need to flick down to close the sheet, pixels/ms
  bottomSheetDefaults.$inject = ["$animate", "$mdConstant", "$mdUtil", "$mdTheming", "$mdBottomSheet", "$rootElement", "$mdGesture", "$log"];
  var CLOSING_VELOCITY = 0.5;
  var PADDING = 80; // same as css

  return $$interimElementProvider('$mdBottomSheet')
    .setDefaults({
      methods: ['disableParentScroll', 'escapeToClose', 'clickOutsideToClose'],
      options: bottomSheetDefaults
    });

  /* @ngInject */
  function bottomSheetDefaults($animate, $mdConstant, $mdUtil, $mdTheming, $mdBottomSheet, $rootElement,
                               $mdGesture, $log) {
    var backdrop;

    return {
      themable: true,
      onShow: onShow,
      onRemove: onRemove,
      disableBackdrop: false,
      escapeToClose: true,
      clickOutsideToClose: true,
      disableParentScroll: true,
      isLockedOpen: false
    };


    function onShow(scope, element, options, controller) {

      element = $mdUtil.extractElementByName(element, 'md-bottom-sheet');

      // prevent tab focus or click focus on the bottom-sheet container
      element.attr('tabindex', '-1');

      // Once the md-bottom-sheet has `ng-cloak` applied on his template the opening animation will not work properly.
      // This is a very common problem, so we have to notify the developer about this.
      if (element.hasClass('ng-cloak')) {
        var message = '$mdBottomSheet: using `<md-bottom-sheet ng-cloak>` will affect the bottom-sheet opening animations.';
        $log.warn(message, element[0]);
      }

      if (options.isLockedOpen) {
        options.clickOutsideToClose = false;
        options.escapeToClose = false;
      } else {
        options.cleanupGestures = registerGestures(element, options.parent);
      }

      if (!options.disableBackdrop) {
        // Add a backdrop that will close on click
        backdrop = $mdUtil.createBackdrop(scope, "md-bottom-sheet-backdrop md-opaque");

        // Prevent mouse focus on backdrop; ONLY programatic focus allowed.
        // This allows clicks on backdrop to propogate to the $rootElement and
        // ESC key events to be detected properly.
        backdrop[0].tabIndex = -1;

        if (options.clickOutsideToClose) {
          backdrop.on('click', function() {
            $mdUtil.nextTick($mdBottomSheet.cancel,true);
          });
        }

        $mdTheming.inherit(backdrop, options.parent);

        $animate.enter(backdrop, options.parent, null);
      }

      $mdTheming.inherit(element, options.parent);

      if (options.disableParentScroll) {
        options.restoreScroll = $mdUtil.disableScrollAround(element, options.parent);
      }

      return $animate.enter(element, options.parent, backdrop)
        .then(function() {
          var focusable = $mdUtil.findFocusTarget(element) || angular.element(
            element[0].querySelector('button') ||
            element[0].querySelector('a') ||
            element[0].querySelector($mdUtil.prefixer('ng-click', true))
          ) || backdrop;

          if (options.escapeToClose) {
            options.rootElementKeyupCallback = function(e) {
              if (e.keyCode === $mdConstant.KEY_CODE.ESCAPE) {
                $mdUtil.nextTick($mdBottomSheet.cancel,true);
              }
            };

            $rootElement.on('keyup', options.rootElementKeyupCallback);
            focusable && focusable.focus();
          }
        });

    }

    function onRemove(scope, element, options) {
      if (!options.disableBackdrop) $animate.leave(backdrop);

      return $animate.leave(element).then(function() {
        if (options.disableParentScroll) {
          options.restoreScroll();
          delete options.restoreScroll;
        }

        options.cleanupGestures && options.cleanupGestures();
      });
    }

    /**
     * Adds the drag gestures to the bottom sheet.
     */
    function registerGestures(element, parent) {
      var deregister = $mdGesture.register(parent, 'drag', { horizontal: false });
      parent.on('$md.dragstart', onDragStart)
        .on('$md.drag', onDrag)
        .on('$md.dragend', onDragEnd);

      return function cleanupGestures() {
        deregister();
        parent.off('$md.dragstart', onDragStart);
        parent.off('$md.drag', onDrag);
        parent.off('$md.dragend', onDragEnd);
      };

      function onDragStart() {
        // Disable transitions on transform so that it feels fast
        element.css($mdConstant.CSS.TRANSITION_DURATION, '0ms');
      }

      function onDrag(ev) {
        var transform = ev.pointer.distanceY;
        if (transform < 5) {
          // Slow down drag when trying to drag up, and stop after PADDING
          transform = Math.max(-PADDING, transform / 2);
        }
        element.css($mdConstant.CSS.TRANSFORM, 'translate3d(0,' + (PADDING + transform) + 'px,0)');
      }

      function onDragEnd(ev) {
        if (ev.pointer.distanceY > 0 &&
            (ev.pointer.distanceY > 20 || Math.abs(ev.pointer.velocityY) > CLOSING_VELOCITY)) {
          var distanceRemaining = element.prop('offsetHeight') - ev.pointer.distanceY;
          var transitionDuration = Math.min(distanceRemaining / ev.pointer.velocityY * 0.75, 500);
          element.css($mdConstant.CSS.TRANSITION_DURATION, transitionDuration + 'ms');
          $mdUtil.nextTick($mdBottomSheet.cancel,true);
        } else {
          element.css($mdConstant.CSS.TRANSITION_DURATION, '');
          element.css($mdConstant.CSS.TRANSFORM, '');
        }
      }
    }

  }

}

})();
(function(){
"use strict";

/**
 * @ngdoc module
 * @name material.components.button
 * @description
 *
 * Button
 */
MdButtonDirective.$inject = ["$mdButtonInkRipple", "$mdTheming", "$mdAria", "$mdInteraction"];
MdAnchorDirective.$inject = ["$mdTheming"];
angular
    .module('material.components.button', ['material.core'])
    .directive('mdButton', MdButtonDirective)
    .directive('a', MdAnchorDirective);


/**
 * @private
 * @restrict E
 *
 * @description
 * `a` is an anchor directive used to inherit theme colors for md-primary, md-accent, etc.
 *
 * @usage
 *
 * <hljs lang="html">
 *  <md-content md-theme="myTheme">
 *    <a href="#chapter1" class="md-accent"></a>
 *  </md-content>
 * </hljs>
 */
function MdAnchorDirective($mdTheming) {
  return {
    restrict : 'E',
    link : function postLink(scope, element) {
      // Make sure to inherit theme so stand-alone anchors
      // support theme colors for md-primary, md-accent, etc.
      $mdTheming(element);
    }
  };
}


/**
 * @ngdoc directive
 * @name mdButton
 * @module material.components.button
 *
 * @restrict E
 *
 * @description
 * `<md-button>` is a button directive with optional ink ripples (default enabled).
 *
 * If you supply a `href` or `ng-href` attribute, it will become an `<a>` element. Otherwise, it
 * will become a `<button>` element. As per the
 * [Material Design specifications](https://material.google.com/style/color.html#color-color-palette)
 * the FAB button background is filled with the accent color [by default]. The primary color palette
 * may be used with the `md-primary` class.
 *
 * Developers can also change the color palette of the button, by using the following classes
 * - `md-primary`
 * - `md-accent`
 * - `md-warn`
 *
 * See for example
 *
 * <hljs lang="html">
 *   <md-button class="md-primary">Primary Button</md-button>
 * </hljs>
 *
 * Button can be also raised, which means that they will use the current color palette to fill the button.
 *
 * <hljs lang="html">
 *   <md-button class="md-accent md-raised">Raised and Accent Button</md-button>
 * </hljs>
 *
 * It is also possible to disable the focus effect on the button, by using the following markup.
 *
 * <hljs lang="html">
 *   <md-button class="md-no-focus">No Focus Style</md-button>
 * </hljs>
 *
 * @param {string=} aria-label Adds alternative text to button for accessibility, useful for icon buttons.
 * If no default text is found, a warning will be logged.
 * @param {boolean=} md-no-ink If present, disable ink ripple effects.
 * @param {string=} md-ripple-size Overrides the default ripple size logic. Options: `full`, `partial`, `auto`.
 * @param {expression=} ng-disabled Disable the button when the expression is truthy.
 * @param {expression=} ng-blur Expression evaluated when focus is removed from the button.
 *
 * @usage
 *
 * Regular buttons:
 *
 * <hljs lang="html">
 *  <md-button> Flat Button </md-button>
 *  <md-button href="http://google.com"> Flat link </md-button>
 *  <md-button class="md-raised"> Raised Button </md-button>
 *  <md-button ng-disabled="true"> Disabled Button </md-button>
 *  <md-button>
 *    <md-icon md-svg-src="your/icon.svg"></md-icon>
 *    Register Now
 *  </md-button>
 * </hljs>
 *
 * FAB buttons:
 *
 * <hljs lang="html">
 *  <md-button class="md-fab" aria-label="FAB">
 *    <md-icon md-svg-src="your/icon.svg"></md-icon>
 *  </md-button>
 *  <!-- mini-FAB -->
 *  <md-button class="md-fab md-mini" aria-label="Mini FAB">
 *    <md-icon md-svg-src="your/icon.svg"></md-icon>
 *  </md-button>
 *  <!-- Button with SVG Icon -->
 *  <md-button class="md-icon-button" aria-label="Custom Icon Button">
 *    <md-icon md-svg-icon="path/to/your.svg"></md-icon>
 *  </md-button>
 * </hljs>
 */
function MdButtonDirective($mdButtonInkRipple, $mdTheming, $mdAria, $mdInteraction) {

  return {
    restrict: 'EA',
    replace: true,
    transclude: true,
    template: getTemplate,
    link: postLink
  };

  function isAnchor(attr) {
    return angular.isDefined(attr.href) || angular.isDefined(attr.ngHref) || angular.isDefined(attr.ngLink) || angular.isDefined(attr.uiSref);
  }

  function getTemplate(element, attr) {
    if (isAnchor(attr)) {
      return '<a class="md-button" ng-transclude></a>';
    } else {
      // If buttons don't have type="button", they will submit forms automatically.
      var btnType = (typeof attr.type === 'undefined') ? 'button' : attr.type;
      return '<button class="md-button" type="' + btnType + '" ng-transclude></button>';
    }
  }

  function postLink(scope, element, attr) {
    $mdTheming(element);
    $mdButtonInkRipple.attach(scope, element);

    // Use async expect to support possible bindings in the button label
    $mdAria.expectWithoutText(element, 'aria-label');

    // For anchor elements, we have to set tabindex manually when the element is disabled.
    // We don't do this for md-nav-bar anchors as the component manages its own tabindex values.
    if (isAnchor(attr) && angular.isDefined(attr.ngDisabled) &&
        !element.hasClass('_md-nav-button')) {
      scope.$watch(attr.ngDisabled, function(isDisabled) {
        element.attr('tabindex', isDisabled ? -1 : 0);
      });
    }

    // disabling click event when disabled is true
    element.on('click', function(e){
      if (attr.disabled === true) {
        e.preventDefault();
        e.stopImmediatePropagation();
      }
    });

    if (!element.hasClass('md-no-focus')) {

      element.on('focus', function() {

        // Only show the focus effect when being focused through keyboard interaction or programmatically
        if (!$mdInteraction.isUserInvoked() || $mdInteraction.getLastInteractionType() === 'keyboard') {
          element.addClass('md-focused');
        }

      });

      element.on('blur', function() {
        element.removeClass('md-focused');
      });
    }

  }

}

})();
(function(){
"use strict";

/**
 * @ngdoc module
 * @name material.components.card
 *
 * @description
 * Card components.
 */
mdCardDirective.$inject = ["$mdTheming"];
angular.module('material.components.card', [
    'material.core'
  ])
  .directive('mdCard', mdCardDirective);


/**
 * @ngdoc directive
 * @name mdCard
 * @module material.components.card
 *
 * @restrict E
 *
 * @description
 * The `<md-card>` directive is a container element used within `<md-content>` containers.
 *
 * An image included as a direct descendant will fill the card's width. If you want to avoid this,
 * you can add the `md-image-no-fill` class to the parent element. The `<md-card-content>`
 * container will wrap text content and provide padding. An `<md-card-footer>` element can be
 * optionally included to put content flush against the bottom edge of the card.
 *
 * Action buttons can be included in an `<md-card-actions>` element, similar to `<md-dialog-actions>`.
 * You can then position buttons using layout attributes.
 *
 * Card is built with:
 * * `<md-card-header>` - Header for the card, holds avatar, text and squared image
 *  - `<md-card-avatar>` - Card avatar
 *    - `md-user-avatar` - Class for user image
 *    - `<md-icon>`
 *  - `<md-card-header-text>` - Contains elements for the card description
 *    - `md-title` - Class for the card title
 *    - `md-subhead` - Class for the card sub header
 * * `<img>` - Image for the card
 * * `<md-card-title>` - Card content title
 *  - `<md-card-title-text>`
 *    - `md-headline` - Class for the card content title
 *    - `md-subhead` - Class for the card content sub header
 *  - `<md-card-title-media>` - Squared image within the title
 *    - `md-media-sm` - Class for small image
 *    - `md-media-md` - Class for medium image
 *    - `md-media-lg` - Class for large image
 *    - `md-media-xl` - Class for extra large image
 * * `<md-card-content>` - Card content
 * * `<md-card-actions>` - Card actions
 *  - `<md-card-icon-actions>` - Icon actions
 *
 * Cards have constant width and variable heights; where the maximum height is limited to what can
 * fit within a single view on a platform, but it can temporarily expand as needed.
 *
 * @usage
 * ### Card with optional footer
 * <hljs lang="html">
 * <md-card>
 *  <img src="card-image.png" class="md-card-image" alt="image caption">
 *  <md-card-content>
 *    <h2>Card headline</h2>
 *    <p>Card content</p>
 *  </md-card-content>
 *  <md-card-footer>
 *    Card footer
 *  </md-card-footer>
 * </md-card>
 * </hljs>
 *
 * ### Card with actions
 * <hljs lang="html">
 * <md-card>
 *  <img src="card-image.png" class="md-card-image" alt="image caption">
 *  <md-card-content>
 *    <h2>Card headline</h2>
 *    <p>Card content</p>
 *  </md-card-content>
 *  <md-card-actions layout="row" layout-align="end center">
 *    <md-button>Action 1</md-button>
 *    <md-button>Action 2</md-button>
 *  </md-card-actions>
 * </md-card>
 * </hljs>
 *
 * ### Card with header, image, title actions and content
 * <hljs lang="html">
 * <md-card>
 *   <md-card-header>
 *     <md-card-avatar>
 *       <img class="md-user-avatar" src="avatar.png"/>
 *     </md-card-avatar>
 *     <md-card-header-text>
 *       <span class="md-title">Title</span>
 *       <span class="md-subhead">Sub header</span>
 *     </md-card-header-text>
 *   </md-card-header>
 *   <img ng-src="card-image.png" class="md-card-image" alt="image caption">
 *   <md-card-title>
 *     <md-card-title-text>
 *       <span class="md-headline">Card headline</span>
 *       <span class="md-subhead">Card subheader</span>
 *     </md-card-title-text>
 *   </md-card-title>
 *   <md-card-actions layout="row" layout-align="start center">
 *     <md-button>Action 1</md-button>
 *     <md-button>Action 2</md-button>
 *     <md-card-icon-actions>
 *       <md-button class="md-icon-button" aria-label="icon">
 *         <md-icon md-svg-icon="icon"></md-icon>
 *       </md-button>
 *     </md-card-icon-actions>
 *   </md-card-actions>
 *   <md-card-content>
 *     <p>
 *      Card content
 *     </p>
 *   </md-card-content>
 * </md-card>
 * </hljs>
 */
function mdCardDirective($mdTheming) {
  return {
    restrict: 'E',
    link: function ($scope, $element, attr) {
      $element.addClass('_md');     // private md component indicator for styling
      $mdTheming($element);
    }
  };
}

})();
(function(){
"use strict";

/**
 * @ngdoc module
 * @name material.components.checkbox
 * @description Checkbox module!
 */
MdCheckboxDirective.$inject = ["inputDirective", "$mdAria", "$mdConstant", "$mdTheming", "$mdUtil", "$mdInteraction"];
angular
  .module('material.components.checkbox', ['material.core'])
  .directive('mdCheckbox', MdCheckboxDirective);

/**
 * @ngdoc directive
 * @name mdCheckbox
 * @module material.components.checkbox
 * @restrict E
 *
 * @description
 * The checkbox directive is used like the normal
 * [angular checkbox](https://docs.angularjs.org/api/ng/input/input%5Bcheckbox%5D).
 *
 * As per the [Material Design spec](https://material.io/archive/guidelines/style/color.html#color-color-palette)
 * the checkbox is in the accent color by default. The primary color palette may be used with
 * the `md-primary` class.
 *
 * @param {expression} ng-model Assignable angular expression to data-bind to.
 * @param {string=} name Property name of the form under which the control is published.
 * @param {expression=} ng-true-value The value to which the expression should be set when selected.
 * @param {expression=} ng-false-value The value to which the expression should be set when not
 *    selected.
 * @param {expression=} ng-change Expression to be executed when the model value changes.
 * @param {boolean=} md-no-ink If present, disable ink ripple effects.
 * @param {string=} aria-label Adds label to checkbox for accessibility.
 *    Defaults to checkbox's text. If no default text is found, a warning will be logged.
 * @param {expression=} md-indeterminate This determines when the checkbox should be rendered as
 *    'indeterminate'. If a truthy expression or no value is passed in the checkbox renders in the
 *    md-indeterminate state. If falsy expression is passed in it just looks like a normal unchecked
 *    checkbox. The indeterminate, checked, and unchecked states are mutually exclusive. A box
 *    cannot be in any two states at the same time. Adding the 'md-indeterminate' attribute
 *    overrides any checked/unchecked rendering logic. When using the 'md-indeterminate' attribute
 *    use 'ng-checked' to define rendering logic instead of using 'ng-model'.
 * @param {expression=} ng-checked If this expression evaluates as truthy, the 'md-checked' css
 *    class is added to the checkbox and it will appear checked.
 *
 * @usage
 * <hljs lang="html">
 * <md-checkbox ng-model="isChecked" aria-label="Finished?">
 *   Finished ?
 * </md-checkbox>
 *
 * <md-checkbox md-no-ink ng-model="hasInk" aria-label="No Ink Effects">
 *   No Ink Effects
 * </md-checkbox>
 *
 * <md-checkbox ng-disabled="true" ng-model="isDisabled" aria-label="Disabled">
 *   Disabled
 * </md-checkbox>
 *
 * </hljs>
 *
 */
function MdCheckboxDirective(inputDirective, $mdAria, $mdConstant, $mdTheming, $mdUtil, $mdInteraction) {
  inputDirective = inputDirective[0];

  return {
    restrict: 'E',
    transclude: true,
    require: ['^?mdInputContainer', '?ngModel', '?^form'],
    priority: $mdConstant.BEFORE_NG_ARIA,
    template:
      '<div class="md-container" md-ink-ripple md-ink-ripple-checkbox>' +
        '<div class="md-icon"></div>' +
      '</div>' +
      '<div ng-transclude class="md-label"></div>',
    compile: compile
  };

  // **********************************************************
  // Private Methods
  // **********************************************************

  function compile (tElement, tAttrs) {
    tAttrs.$set('tabindex', tAttrs.tabindex || '0');
    tAttrs.$set('type', 'checkbox');
    tAttrs.$set('role', tAttrs.type);

    return  {
      pre: function(scope, element) {
        // Attach a click handler during preLink, in order to immediately stop propagation
        // (especially for ng-click) when the checkbox is disabled.
        element.on('click', function(e) {
          if (this.hasAttribute('disabled')) {
            e.stopImmediatePropagation();
          }
        });
      },
      post: postLink
    };

    function postLink(scope, element, attr, ctrls) {
      var isIndeterminate;
      var containerCtrl = ctrls[0];
      var ngModelCtrl = ctrls[1] || $mdUtil.fakeNgModel();
      var formCtrl = ctrls[2];

      if (containerCtrl) {
        var isErrorGetter = containerCtrl.isErrorGetter || function() {
          return ngModelCtrl.$invalid && (ngModelCtrl.$touched || (formCtrl && formCtrl.$submitted));
        };

        containerCtrl.input = element;

        scope.$watch(isErrorGetter, containerCtrl.setInvalid);
      }

      $mdTheming(element);

      // Redirect focus events to the root element, because IE11 is always focusing the container element instead
      // of the md-checkbox element. This causes issues when using ngModelOptions: `updateOnBlur`
      element.children().on('focus', function() {
        element.focus();
      });

      if ($mdUtil.parseAttributeBoolean(attr.mdIndeterminate)) {
        setIndeterminateState();
        scope.$watch(attr.mdIndeterminate, setIndeterminateState);
      }

      if (attr.ngChecked) {
        scope.$watch(scope.$eval.bind(scope, attr.ngChecked), function(value) {
          ngModelCtrl.$setViewValue(value);
          ngModelCtrl.$render();
        });
      }

      $$watchExpr('ngDisabled', 'tabindex', {
        true: '-1',
        false: attr.tabindex
      });

      $mdAria.expectWithText(element, 'aria-label');

      // Reuse the original input[type=checkbox] directive from AngularJS core.
      // This is a bit hacky as we need our own event listener and own render
      // function.
      inputDirective.link.pre(scope, {
        on: angular.noop,
        0: {}
      }, attr, [ngModelCtrl]);

      element.on('click', listener)
        .on('keypress', keypressHandler)
        .on('focus', function() {
          if ($mdInteraction.getLastInteractionType() === 'keyboard') {
            element.addClass('md-focused');
          }
        })
        .on('blur', function() {
          element.removeClass('md-focused');
        });

      ngModelCtrl.$render = render;

      function $$watchExpr(expr, htmlAttr, valueOpts) {
        if (attr[expr]) {
          scope.$watch(attr[expr], function(val) {
            if (valueOpts[val]) {
              element.attr(htmlAttr, valueOpts[val]);
            }
          });
        }
      }

      /**
       * @param {KeyboardEvent} ev 'keypress' event to handle
       */
      function keypressHandler(ev) {
        var keyCode = ev.which || ev.keyCode;
        var submit, form;

        ev.preventDefault();
        switch (keyCode) {
          case $mdConstant.KEY_CODE.SPACE:
            element.addClass('md-focused');
            listener(ev);
            break;
          case $mdConstant.KEY_CODE.ENTER:
            // Match the behavior of the native <input type="checkbox">.
            // When the enter key is pressed while focusing a native checkbox inside a form,
            // the browser will trigger a `click` on the first non-disabled submit button/input
            // in the form. Note that this is different from text inputs, which
            // will directly submit the form without needing a submit button/input to be present.
            form = $mdUtil.getClosest(ev.target, 'form');
            if (form) {
              submit = form.querySelector('button[type="submit"]:enabled, input[type="submit"]:enabled');
              if (submit) {
                submit.click();
              }
            }
            break;
        }
      }

      function listener(ev) {
        // skipToggle boolean is used by the switch directive to prevent the click event
        // when releasing the drag. There will be always a click if releasing the drag over the checkbox
        if (element[0].hasAttribute('disabled') || scope.skipToggle) {
          return;
        }

        scope.$apply(function() {
          // Toggle the checkbox value...
          var viewValue = attr.ngChecked && attr.ngClick ? attr.checked : !ngModelCtrl.$viewValue;

          ngModelCtrl.$setViewValue(viewValue, ev && ev.type);
          ngModelCtrl.$render();
        });
      }

      function render() {
        // Cast the $viewValue to a boolean since it could be undefined
        element.toggleClass('md-checked', !!ngModelCtrl.$viewValue && !isIndeterminate);
      }

      function setIndeterminateState(newValue) {
        isIndeterminate = newValue !== false;
        if (isIndeterminate) {
          element.attr('aria-checked', 'mixed');
        }
        element.toggleClass('md-indeterminate', isIndeterminate);
      }
    }
  }
}

})();
(function(){
"use strict";

/**
 * @ngdoc module
 * @name material.components.chips
 */
/*
 * @see js folder for chips implementation
 */
angular.module('material.components.chips', [
  'material.core',
  'material.components.autocomplete'
]);

})();
(function(){
"use strict";


MdChipCtrl.$inject = ["$scope", "$element", "$mdConstant", "$timeout", "$mdUtil"];angular
  .module('material.components.chips')
  .controller('MdChipCtrl', MdChipCtrl);

/**
 * Controller for the MdChip component. Responsible for handling keyboard
 * events and editing the chip if needed.
 *
 * @param $scope
 * @param $element
 * @param $mdConstant
 * @param $timeout
 * @param $mdUtil
 * @constructor
 */
function MdChipCtrl ($scope, $element, $mdConstant, $timeout, $mdUtil) {
  /**
   * @type {$scope}
   */
  this.$scope = $scope;

  /**
   * @type {$element}
   */
  this.$element = $element;

  /**
   * @type {$mdConstant}
   */
  this.$mdConstant = $mdConstant;

  /**
   * @type {$timeout}
   */
  this.$timeout = $timeout;

  /**
   * @type {$mdUtil}
   */
  this.$mdUtil = $mdUtil;

  /**
   * @type {boolean}
   */
  this.isEditing = false;

  /**
   * @type {MdChipsCtrl}
   */
  this.parentController = undefined;

  /**
   * @type {boolean}
   */
  this.enableChipEdit = false;
}


/**
 * @param {MdChipsCtrl} controller
 */
MdChipCtrl.prototype.init = function(controller) {
  this.parentController = controller;
  this.enableChipEdit = this.parentController.enableChipEdit;

  if (this.enableChipEdit) {
    this.$element.on('keydown', this.chipKeyDown.bind(this));
    this.$element.on('dblclick', this.chipMouseDoubleClick.bind(this));
    this.getChipContent().addClass('_md-chip-content-edit-is-enabled');
  }
};


/**
 * @return {Object} first element with the md-chip-content class
 */
MdChipCtrl.prototype.getChipContent = function() {
  var chipContents = this.$element[0].getElementsByClassName('md-chip-content');
  return angular.element(chipContents[0]);
};


/**
 * When editing the chip, if the user modifies the existing contents, we'll get a span back and
 * need to ignore text elements as they only contain blank space.
 * `children()` ignores text elements.
 *
 * When editing the chip, if the user deletes the contents and then enters some new content
 * we'll only get a text element back.
 * @return {Object} jQuery object representing the content element of the chip
 */
MdChipCtrl.prototype.getContentElement = function() {
  var contentElement = angular.element(this.getChipContent().children()[0]);
  if (!contentElement || contentElement.length === 0) {
    contentElement = angular.element(this.getChipContent().contents()[0]);
  }
  return contentElement;
};


/**
 * @return {number} index of this chip
 */
MdChipCtrl.prototype.getChipIndex = function() {
  return parseInt(this.$element.attr('index'));
};


/**
 * Update the chip's contents, focus the chip if it's selected, and exit edit mode.
 * If the contents were updated to be empty, remove the chip and re-focus the input element.
 */
MdChipCtrl.prototype.goOutOfEditMode = function() {
  if (!this.isEditing) {
    return;
  }

  this.isEditing = false;
  this.$element.removeClass('_md-chip-editing');
  this.getChipContent()[0].contentEditable = 'false';
  var chipIndex = this.getChipIndex();

  var content = this.getContentElement().text();
  if (content) {
    this.parentController.updateChipContents(chipIndex, content);

    this.$mdUtil.nextTick(function() {
      if (this.parentController.selectedChip === chipIndex) {
        this.parentController.focusChip(chipIndex);
      }
    }.bind(this));
  } else {
    this.parentController.removeChipAndFocusInput(chipIndex);
  }
};


/**
 * Given an HTML element. Selects contents of it.
 * @param {Element} node
 */
MdChipCtrl.prototype.selectNodeContents = function(node) {
  var range, selection;
  if (document.body.createTextRange) {
    range = document.body.createTextRange();
    range.moveToElementText(node);
    range.select();
  } else if (window.getSelection) {
    selection = window.getSelection();
    range = document.createRange();
    range.selectNodeContents(node);
    selection.removeAllRanges();
    selection.addRange(range);
  }
};


/**
 * Presents an input element to edit the contents of the chip.
 */
MdChipCtrl.prototype.goInEditMode = function() {
  this.isEditing = true;
  this.$element.addClass('_md-chip-editing');
  this.getChipContent()[0].contentEditable = 'true';
  this.getChipContent().on('blur', function() {
    this.goOutOfEditMode();
  }.bind(this));

  this.selectNodeContents(this.getChipContent()[0]);
};


/**
 * Handles the keydown event on the chip element. If enable-chip-edit attribute is
 * set to true, space or enter keys can trigger going into edit mode. Enter can also
 * trigger submitting if the chip is already being edited.
 * @param {KeyboardEvent} event
 */
MdChipCtrl.prototype.chipKeyDown = function(event) {
  if (!this.isEditing &&
    (event.keyCode === this.$mdConstant.KEY_CODE.ENTER ||
      event.keyCode === this.$mdConstant.KEY_CODE.SPACE)) {
    event.preventDefault();
    this.goInEditMode();
  } else if (this.isEditing && event.keyCode === this.$mdConstant.KEY_CODE.ENTER) {
    event.preventDefault();
    this.goOutOfEditMode();
  }
};


/**
 * Enter edit mode if we're not already editing and the enable-chip-edit attribute is enabled.
 */
MdChipCtrl.prototype.chipMouseDoubleClick = function() {
  if (this.enableChipEdit && !this.isEditing) {
    this.goInEditMode();
  }
};

})();
(function(){
"use strict";


MdChip.$inject = ["$mdTheming", "$mdUtil", "$compile", "$timeout"];angular
  .module('material.components.chips')
  .directive('mdChip', MdChip);

/**
 * @ngdoc directive
 * @name mdChip
 * @module material.components.chips
 *
 * @description
 * `<md-chip>` is a component used within `<md-chips>`. It is responsible for rendering an
 * individual chip.
 *
 *
 * @usage
 * <hljs lang="html">
 *   <md-chips>
 *     <md-chip>{{$chip}}</md-chip>
 *   </md-chips>
 * </hljs>
 *
 */

/**
 * MDChip Directive Definition
 *
 * @param $mdTheming
 * @param $mdUtil
 * @param $compile
 * @param $timeout
 * @ngInject
 */
function MdChip($mdTheming, $mdUtil, $compile, $timeout) {
  return {
    restrict: 'E',
    require: ['^?mdChips', 'mdChip'],
    link: postLink,
    controller: 'MdChipCtrl'
  };

  function postLink(scope, element, attr, ctrls) {
    var chipsController = ctrls.shift();
    var chipController = ctrls.shift();
    var chipContentElement = angular.element(element[0].querySelector('.md-chip-content'));

    $mdTheming(element);

    if (chipsController) {
      chipController.init(chipsController);

      // When a chip is blurred, make sure to unset (or reset) the selected chip so that tabbing
      // through elements works properly
      chipContentElement.on('blur', function() {
        chipsController.resetSelectedChip();
        chipsController.$scope.$applyAsync();
      });
    }

    // Use $timeout to ensure we run AFTER the element has been added to the DOM so we can focus it.
    $timeout(function() {
      if (!chipsController) {
        return;
      }

      if (chipsController.shouldFocusLastChip) {
        chipsController.focusLastChipThenInput();
      }
    });
  }
}

})();
(function(){
"use strict";


MdChipRemove.$inject = ["$timeout"];angular
    .module('material.components.chips')
    .directive('mdChipRemove', MdChipRemove);

/**
 * @ngdoc directive
 * @name mdChipRemove
 * @restrict A
 * @module material.components.chips
 *
 * @description
 * Indicates that the associated element should be used as the delete button template for all chips.
 * The associated element must be a child of `md-chips`.
 *
 * The provided button template will be appended to each chip and will remove the associated chip
 * on click.
 *
 * The button is not styled or themed based on the theme set on the `md-chips` component. A theme
 * class and custom icon can be specified in your template.
 *
 * You can also specify the `type` of the button in your template.
 *
 * @usage
 * ### With Standard Chips
 * <hljs lang="html">
 *   <md-chips ...>
 *     <button md-chip-remove class="md-primary" type="button" aria-label="Remove {{$chip}}">
 *       <md-icon md-svg-icon="md-close"></md-icon>
 *     </button>
 *   </md-chips>
 * </hljs>
 *
 * ### With Object Chips
 * <hljs lang="html">
 *   <md-chips ...>
 *     <button md-chip-remove class="md-primary" type="button" aria-label="Remove {{$chip.name}}">
 *       <md-icon md-svg-icon="md-close"></md-icon>
 *     </button>
 *   </md-chips>
 * </hljs>
 */


/**
 * MdChipRemove Directive Definition.
 *
 * @param $timeout
 * @returns {{restrict: string, require: string[], link: Function, scope: boolean}}
 * @constructor
 */
function MdChipRemove ($timeout) {
  return {
    restrict: 'A',
    require: '^mdChips',
    scope: false,
    link: postLink
  };

  function postLink(scope, element, attr, ctrl) {
    element.on('click', function(event) {
      scope.$apply(function() {
        ctrl.removeChip(scope.$$replacedScope.$index);
      });
    });

    // Child elements aren't available until after a $timeout tick as they are hidden by an
    // `ng-if`. see http://goo.gl/zIWfuw
    $timeout(function() {
      element.attr({ 'tabindex': '-1', 'aria-hidden': 'true' });
      element.find('button').attr('tabindex', '-1');
    });
  }
}

})();
(function(){
"use strict";


MdChipTransclude.$inject = ["$compile"];angular
    .module('material.components.chips')
    .directive('mdChipTransclude', MdChipTransclude);

function MdChipTransclude ($compile) {
  return {
    restrict: 'EA',
    terminal: true,
    link: link,
    scope: false
  };
  function link (scope, element, attr) {
    var ctrl = scope.$parent.$mdChipsCtrl,
        newScope = ctrl.parent.$new(false, ctrl.parent);
    newScope.$$replacedScope = scope;
    newScope.$chip = scope.$chip;
    newScope.$index = scope.$index;
    newScope.$mdChipsCtrl = ctrl;

    var newHtml = ctrl.$scope.$eval(attr.mdChipTransclude);

    element.html(newHtml);
    $compile(element.contents())(newScope);
  }
}

})();
(function(){
"use strict";

/**
 * The default chip append delay.
 *
 * @type {number}
 */
MdChipsCtrl.$inject = ["$scope", "$attrs", "$mdConstant", "$log", "$element", "$timeout", "$mdUtil", "$mdLiveAnnouncer", "$exceptionHandler"];
var DEFAULT_CHIP_APPEND_DELAY = 300;

angular
    .module('material.components.chips')
    .controller('MdChipsCtrl', MdChipsCtrl);

/**
 * Controller for the MdChips component. Responsible for adding to and
 * removing from the list of chips, marking chips as selected, and binding to
 * the models of various input components.
 *
 * @param $scope
 * @param $attrs
 * @param $mdConstant
 * @param $log
 * @param $element
 * @param $timeout
 * @param $mdUtil
 * @param $mdLiveAnnouncer
 * @param $exceptionHandler
 * @constructor
 */
function MdChipsCtrl ($scope, $attrs, $mdConstant, $log, $element, $timeout, $mdUtil,
                      $mdLiveAnnouncer, $exceptionHandler) {
  /** @type {Function} **/
  this.$timeout = $timeout;

  /** @type {Object} */
  this.$mdConstant = $mdConstant;

  /** @type {angular.$scope} */
  this.$scope = $scope;

  /** @type {angular.$scope} */
  this.parent = $scope.$parent;

  /** @type {$mdUtil} */
  this.$mdUtil = $mdUtil;

  /** @type {$log} */
  this.$log = $log;

  /** @type {$mdLiveAnnouncer} */
  this.$mdLiveAnnouncer = $mdLiveAnnouncer;

  /** @type {$exceptionHandler} */
  this.$exceptionHandler = $exceptionHandler;

  /** @type {$element} */
  this.$element = $element;

  /** @type {$attrs} */
  this.$attrs = $attrs;

  /** @type {angular.NgModelController} */
  this.ngModelCtrl = null;

  /** @type {angular.NgModelController} */
  this.userInputNgModelCtrl = null;

  /** @type {MdAutocompleteCtrl} */
  this.autocompleteCtrl = null;

  /** @type {Element} */
  this.userInputElement = null;

  /** @type {Array.<Object>} */
  this.items = [];

  /** @type {number} */
  this.selectedChip = -1;

  /** @type {string} */
  this.enableChipEdit = $mdUtil.parseAttributeBoolean($attrs.mdEnableChipEdit);

  /** @type {string} */
  this.addOnBlur = $mdUtil.parseAttributeBoolean($attrs.mdAddOnBlur);

  /**
   * The text to be used as the aria-label for the input.
   * @type {string}
   */
  this.inputAriaLabel = 'Chips input.';

  /**
   * Label text to describe the chips container. Used to give context and instructions to screen
   * reader users when the chips container is selected.
   * @type {string}
   */
  this.containerHint = 'Chips container. Use arrow keys to select chips.';

  /**
   * Label text to describe the chips container when it is empty. Used to give context and
   * instructions to screen reader users when the chips container is selected and it contains
   * no chips.
   * @type {string}
   */
  this.containerEmptyHint =
    'Chips container. Enter the text area, then type text, and press enter to add a chip.';

  /**
   * Hidden hint text for how to delete a chip. Used to give context to screen readers.
   * @type {string}
   */
  this.deleteHint = 'Press delete to remove this chip.';

  /**
   * Hidden label for the delete button. Used to give context to screen readers.
   * @type {string}
   */
  this.deleteButtonLabel = 'Remove';

  /**
   * Model used by the input element.
   * @type {string}
   */
  this.chipBuffer = '';

  /**
   * Whether to use the transformChip expression to transform the chip buffer
   * before appending it to the list.
   * @type {boolean}
   */
  this.useTransformChip = false;

  /**
   * Whether to use the onAdd expression to notify of chip additions.
   * @type {boolean}
   */
  this.useOnAdd = false;

  /**
   * Whether to use the onRemove expression to notify of chip removals.
   * @type {boolean}
   */
  this.useOnRemove = false;

  /**
   * The ID of the chips wrapper which is used to build unique IDs for the chips and the aria-owns
   * attribute.
   *
   * Defaults to '_md-chips-wrapper-' plus a unique number.
   *
   * @type {string}
   */
  this.wrapperId = '';

  /**
   * Array of unique numbers which will be auto-generated any time the items change, and is used to
   * create unique IDs for the aria-owns attribute.
   *
   * @type {Array<number>}
   */
  this.contentIds = [];

  /**
   * The index of the chip that should have it's `tabindex` property set to `0` so it is selectable
   * via the keyboard.
   *
   * @type {number|null}
   */
  this.ariaTabIndex = null;

  /**
   * After appending a chip, the chip will be focused for this number of milliseconds before the
   * input is refocused.
   *
   * **Note:** This is **required** for compatibility with certain screen readers in order for
   * them to properly allow keyboard access.
   *
   * @type {number}
   */
  this.chipAppendDelay = DEFAULT_CHIP_APPEND_DELAY;

  /**
   * Collection of functions to call to un-register watchers
   *
   * @type {Array}
   */
  this.deRegister = [];

  /**
   * The screen reader will announce the chip content followed by this message when a chip is added.
   * @type {string}
   */
  this.addedMessage = 'added';

  /**
   * The screen reader will announce the chip content followed by this message when a chip is
   * removed.
   * @type {string}
   */
  this.removedMessage = 'removed';

  this.init();
}

/**
 * Initializes variables and sets up watchers
 */
MdChipsCtrl.prototype.init = function() {
  var ctrl = this;

  // Set the wrapper ID
  this.wrapperId = '_md-chips-wrapper-' + this.$mdUtil.nextUid();

  // If we're using static chips, then we need to initialize a few things.
  if (!this.$element.attr('ng-model')) {
    this.setupStaticChips();
  }

  // Setup a watcher which manages the role and aria-owns attributes.
  // This is never called for static chips since items is not defined.
  this.deRegister.push(
    this.$scope.$watchCollection('$mdChipsCtrl.items', function() {
      // Make sure our input and wrapper have the correct ARIA attributes
      ctrl.setupInputAria();
      ctrl.setupWrapperAria();
    })
  );

  this.deRegister.push(
    this.$attrs.$observe('mdChipAppendDelay', function(newValue) {
      ctrl.chipAppendDelay = parseInt(newValue) || DEFAULT_CHIP_APPEND_DELAY;
    })
  );
};

/**
 * Destructor for cleanup
 */
MdChipsCtrl.prototype.$onDestroy = function $onDestroy() {
  var $destroyFn;
  while (($destroyFn = this.deRegister.pop())) {
    $destroyFn.call(this);
  }
};

/**
 * If we have an input, ensure it has the appropriate ARIA attributes.
 */
MdChipsCtrl.prototype.setupInputAria = function() {
  var input = this.$element.find('input');

  // If we have no input, just return
  if (!input) {
    return;
  }

  input.attr('role', 'textbox');
  input.attr('aria-multiline', true);
  if (this.inputAriaDescribedBy) {
    input.attr('aria-describedby', this.inputAriaDescribedBy);
  }
  if (this.inputAriaLabelledBy) {
    input.attr('aria-labelledby', this.inputAriaLabelledBy);
    input.removeAttr('aria-label');
  } else {
    input.attr('aria-label', this.inputAriaLabel);
  }
};

/**
 * Ensure our wrapper has the appropriate ARIA attributes.
 */
MdChipsCtrl.prototype.setupWrapperAria = function() {
  var ctrl = this,
      wrapper = this.$element.find('md-chips-wrap');

  if (this.items && this.items.length) {
    // Dynamically add the listbox role on every change because it must be removed when there are
    // no items.
    wrapper.attr('role', 'listbox');

    // Generate some random (but unique) IDs for each chip
    this.contentIds = this.items.map(function() {
      return ctrl.wrapperId + '-chip-' + ctrl.$mdUtil.nextUid();
    });

    // Use the contentIDs above to generate the aria-owns attribute
    wrapper.attr('aria-owns', this.contentIds.join(' '));
    wrapper.attr('aria-label', this.containerHint);
  } else {
    // If we have no items, then the role and aria-owns attributes MUST be removed
    wrapper.removeAttr('role');
    wrapper.removeAttr('aria-owns');
    wrapper.attr('aria-label', this.containerEmptyHint);
  }
};

/**
 * Apply specific roles and aria attributes for static chips
 */
MdChipsCtrl.prototype.setupStaticChips = function() {
  var ctrl = this, i, staticChips;
  var wrapper = this.$element.find('md-chips-wrap');

  this.$timeout(function() {
    wrapper.attr('role', 'list');
    staticChips = wrapper[0].children;
    for (i = 0; i < staticChips.length; i++) {
      staticChips[i].setAttribute('role', 'listitem');
      staticChips[i].setAttribute('aria-setsize', staticChips.length);
    }
    if (ctrl.inputAriaDescribedBy) {
      wrapper.attr('aria-describedby', ctrl.inputAriaDescribedBy);
    }
    if (ctrl.inputAriaLabelledBy) {
      wrapper.attr('aria-labelledby', ctrl.inputAriaLabelledBy);
      wrapper.removeAttr('aria-label');
    } else {
      wrapper.attr('aria-label', ctrl.inputAriaLabel);
    }
  }, 10);
};

/**
 * Handles the keydown event on the input element: by default <enter> appends
 * the buffer to the chip list, while backspace removes the last chip in the
 * list if the current buffer is empty.
 * @param {jQuery.Event|KeyboardEvent} event
 */
MdChipsCtrl.prototype.inputKeydown = function(event) {
  var chipBuffer = this.getChipBuffer();

  // If we have an autocomplete, and it handled the event, we have nothing to do
  if (this.autocompleteCtrl && event.isDefaultPrevented && event.isDefaultPrevented()) {
    return;
  }

  if (event.keyCode === this.$mdConstant.KEY_CODE.BACKSPACE) {
    // Only select and focus the previous chip, if the current caret position of the
    // input element is at the beginning.
    if (this.getCursorPosition(event.target) !== 0) {
      return;
    }

    event.preventDefault();
    event.stopPropagation();

    if (this.items.length) {
      this.selectAndFocusChipSafe(this.items.length - 1);
    }

    return;
  }

  // By default <enter> appends the buffer to the chip list.
  if (!this.separatorKeys || this.separatorKeys.length < 1) {
    this.separatorKeys = [this.$mdConstant.KEY_CODE.ENTER];
  }

  // Support additional separator key codes in an array of `md-separator-keys`.
  if (this.separatorKeys.indexOf(event.keyCode) !== -1) {
    if ((this.autocompleteCtrl && this.requireMatch) || !chipBuffer) return;
    event.preventDefault();

    // Only append the chip and reset the chip buffer if the max chips limit isn't reached.
    if (this.hasMaxChipsReached()) return;

    this.appendChip(chipBuffer.trim());
    this.resetChipBuffer();

    return false;
  }
};

/**
 * Returns the cursor position of the specified input element.
 * @param {HTMLInputElement} element relevant input element
 * @returns {Number} Cursor Position of the input.
 */
MdChipsCtrl.prototype.getCursorPosition = function(element) {
  /*
   * Figure out whether the current input for the chips buffer is valid for using
   * the selectionStart / end property to retrieve the cursor position.
   * Some browsers do not allow the use of those attributes, on different input types.
   */
  try {
    if (element.selectionStart === element.selectionEnd) {
      return element.selectionStart;
    }
  } catch (e) {
    if (!element.value) {
      return 0;
    }
  }
};


/**
 * Updates the content of the chip at given index
 * @param {number} chipIndex
 * @param {string} chipContents
 */
MdChipsCtrl.prototype.updateChipContents = function(chipIndex, chipContents) {
  if (chipIndex >= 0 && chipIndex < this.items.length) {
    this.items[chipIndex] = chipContents;
    this.updateNgModel(true);
  }
};


/**
 * @return {boolean} true if a chip is currently being edited. False otherwise.
 */
MdChipsCtrl.prototype.isEditingChip = function() {
  return !!this.$element[0].querySelector('._md-chip-editing');
};

/**
 * @param {string|Object} chip contents of a single chip
 * @returns {boolean} true if the chip is an Object, false otherwise.
 * @private
 */
MdChipsCtrl.prototype._isChipObject = function(chip) {
  return angular.isObject(chip);
};

/**
 * @returns {boolean} true if chips can be removed, false otherwise.
 */
MdChipsCtrl.prototype.isRemovable = function() {
  // Return false if we have static chips
  if (!this.ngModelCtrl) {
    return false;
  }

  return this.readonly ? this.removable :
         angular.isDefined(this.removable) ? this.removable : true;
};

/**
 * Handles the keydown event on the chip elements: backspace removes the selected chip, arrow
 * keys switch which chip is active.
 * @param {KeyboardEvent} event
 */
MdChipsCtrl.prototype.chipKeydown = function (event) {
  if (this.getChipBuffer()) return;
  if (this.isEditingChip()) return;

  switch (event.keyCode) {
    case this.$mdConstant.KEY_CODE.BACKSPACE:
    case this.$mdConstant.KEY_CODE.DELETE:
      if (this.selectedChip < 0) return;
      event.preventDefault();
      // Cancel the delete action only after the event cancel. Otherwise the page will go back.
      if (!this.isRemovable()) return;
      this.removeAndSelectAdjacentChip(this.selectedChip, event);
      break;
    case this.$mdConstant.KEY_CODE.LEFT_ARROW:
      event.preventDefault();
      // By default, allow selection of -1 which will focus the input; if we're readonly, don't go
      // below 0.
      if (this.selectedChip < 0 || (this.readonly && this.selectedChip === 0)) {
        this.selectedChip = this.items.length;
      }
      if (this.items.length) this.selectAndFocusChipSafe(this.selectedChip - 1);
      break;
    case this.$mdConstant.KEY_CODE.RIGHT_ARROW:
      event.preventDefault();
      this.selectAndFocusChipSafe(this.selectedChip + 1);
      break;
    case this.$mdConstant.KEY_CODE.ESCAPE:
    case this.$mdConstant.KEY_CODE.TAB:
      if (this.selectedChip < 0) return;
      event.preventDefault();
      this.onFocus();
      break;
  }
};

/**
 * Get the input's placeholder - uses `placeholder` when list is empty and `secondary-placeholder`
 * when the list is non-empty. If `secondary-placeholder` is not provided, `placeholder` is used
 * always.
 * @returns {string}
 */
MdChipsCtrl.prototype.getPlaceholder = function() {
  // Allow `secondary-placeholder` to be blank.
  var useSecondary = (this.items && this.items.length &&
      (this.secondaryPlaceholder === '' || this.secondaryPlaceholder));
  return useSecondary ? this.secondaryPlaceholder : this.placeholder;
};

/**
 * Removes chip at {@code index} and selects the adjacent chip.
 * @param {number} index adjacent chip to select
 * @param {Event=} event
 */
MdChipsCtrl.prototype.removeAndSelectAdjacentChip = function(index, event) {
  var self = this;
  var selIndex = self.getAdjacentChipIndex(index);
  var wrap = this.$element[0].querySelector('md-chips-wrap');
  var chip = this.$element[0].querySelector('md-chip[index="' + index + '"]');

  self.removeChip(index, event);

  // The double-timeout is currently necessary to ensure that the DOM has finalized and the select()
  // will find the proper chip since the selection is index-based.
  //
  // TODO: Investigate calling from within chip $scope.$on('$destroy') to reduce/remove timeouts
  self.$timeout(function() {
    self.$timeout(function() {
      self.selectAndFocusChipSafe(selIndex);
    });
  });
};

/**
 * Sets the selected chip index to -1.
 */
MdChipsCtrl.prototype.resetSelectedChip = function() {
  this.selectedChip = -1;
  this.ariaTabIndex = null;
};

/**
 * Gets the index of an adjacent chip to select after deletion. Adjacency is
 * determined as the next chip in the list, unless the target chip is the
 * last in the list, then it is the chip immediately preceding the target. If
 * there is only one item in the list, -1 is returned (select none).
 * The number returned is the index to select AFTER the target has been removed.
 * If the current chip is not selected, then -1 is returned to select none.
 * @param {number} index
 * @returns {number}
 */
MdChipsCtrl.prototype.getAdjacentChipIndex = function(index) {
  var len = this.items.length - 1;
  return (len === 0) ? -1 :
      (index === len) ? index - 1 : index;
};

/**
 * Append the contents of the buffer to the chip list. This method will first
 * call out to the md-transform-chip method, if provided.
 * @param {string} newChip chip buffer contents that will be used to create the new chip
 */
MdChipsCtrl.prototype.appendChip = function(newChip) {
  this.shouldFocusLastChip = !this.addOnBlur;
  if (this.useTransformChip && this.transformChip) {
    var transformedChip = this.transformChip({'$chip': newChip});

    // Check to make sure the chip is defined before assigning it, otherwise, we'll just assume
    // they want the string version.
    if (angular.isDefined(transformedChip)) {
      newChip = transformedChip;
    }
  }

  // If items contains an identical object to newChip, do not append
  if (angular.isObject(newChip)) {
    var identical = this.items.some(function(item) {
      return angular.equals(newChip, item);
    });
    if (identical) return;
  }

  // Check for a null (but not undefined), or existing chip and cancel appending
  if (newChip == null || this.items.indexOf(newChip) + 1) return;

  // Append the new chip onto our list
  var length = this.items.push(newChip);
  var index = length - 1;

  this.updateNgModel();

  // Tell screen reader users that the chip was successfully added.
  // TODO add a way for developers to specify which field of the object should be announced here.
  var chipContent = angular.isObject(newChip) ? '' : newChip;
  this.$mdLiveAnnouncer.announce(chipContent + ' ' + this.addedMessage, 'assertive');

  // If the md-on-add attribute is specified, send a chip addition event
  if (this.useOnAdd && this.onAdd) {
    this.onAdd({ '$chip': newChip, '$index': index });
  }
};

/**
 * Sets whether to use the md-transform-chip expression. This expression is
 * bound to scope and controller in {@code MdChipsDirective} as
 * {@code transformChip}. Due to the nature of directive scope bindings, the
 * controller cannot know on its own/from the scope whether an expression was
 * actually provided.
 */
MdChipsCtrl.prototype.useTransformChipExpression = function() {
  this.useTransformChip = true;
};

/**
 * Sets whether to use the md-on-add expression. This expression is
 * bound to scope and controller in {@code MdChipsDirective} as
 * {@code onAdd}. Due to the nature of directive scope bindings, the
 * controller cannot know on its own/from the scope whether an expression was
 * actually provided.
 */
MdChipsCtrl.prototype.useOnAddExpression = function() {
  this.useOnAdd = true;
};

/**
 * Sets whether to use the md-on-remove expression. This expression is
 * bound to scope and controller in {@code MdChipsDirective} as
 * {@code onRemove}. Due to the nature of directive scope bindings, the
 * controller cannot know on its own/from the scope whether an expression was
 * actually provided.
 */
MdChipsCtrl.prototype.useOnRemoveExpression = function() {
  this.useOnRemove = true;
};

/**
 * Sets whether to use the md-on-select expression. This expression is
 * bound to scope and controller in {@code MdChipsDirective} as
 * {@code onSelect}. Due to the nature of directive scope bindings, the
 * controller cannot know on its own/from the scope whether an expression was
 * actually provided.
 */
MdChipsCtrl.prototype.useOnSelectExpression = function() {
  this.useOnSelect = true;
};

/**
 * Gets the input buffer. The input buffer can be the model bound to the
 * default input item {@code this.chipBuffer}, the {@code selectedItem}
 * model of an {@code md-autocomplete}, or, through some magic, the model
 * bound to any input or text area element found within a
 * {@code md-input-container} element.
 * @return {string} the input buffer
 */
MdChipsCtrl.prototype.getChipBuffer = function() {
  var chipBuffer =  !this.userInputElement ? this.chipBuffer :
                     this.userInputNgModelCtrl ? this.userInputNgModelCtrl.$viewValue :
                     this.userInputElement[0].value;

  // Ensure that the chip buffer is always a string. For example, the input element buffer
  // might be falsy.
  return angular.isString(chipBuffer) ? chipBuffer : '';
};

/**
 * Resets the input buffer for either the internal input or user provided input element.
 */
MdChipsCtrl.prototype.resetChipBuffer = function() {
  if (this.userInputElement) {
    if (this.userInputNgModelCtrl) {
      this.userInputNgModelCtrl.$setViewValue('');
      this.userInputNgModelCtrl.$render();
    } else {
      this.userInputElement[0].value = '';
    }
  } else {
    this.chipBuffer = '';
  }
};

/**
 * @returns {boolean} true if the max chips limit has been reached, false otherwise.
 */
MdChipsCtrl.prototype.hasMaxChipsReached = function() {
  if (angular.isString(this.maxChips)) this.maxChips = parseInt(this.maxChips, 10) || 0;

  return this.maxChips > 0 && this.items.length >= this.maxChips;
};

/**
 * Updates the validity properties for the ngModel.
 *
 * TODO add the md-max-chips validator to this.ngModelCtrl.validators so that the validation will
 * be performed automatically.
 */
MdChipsCtrl.prototype.validateModel = function() {
  this.ngModelCtrl.$setValidity('md-max-chips', !this.hasMaxChipsReached());
  this.ngModelCtrl.$validate(); // rerun any registered validators
};

/**
 * Function to handle updating the model, validation, and change notification when a chip
 * is added, removed, or changed.
 * @param {boolean=} skipValidation true to skip calling validateModel()
 */
MdChipsCtrl.prototype.updateNgModel = function(skipValidation) {
  if (!skipValidation) {
    this.validateModel();
  }
  // This will trigger ng-change to fire, even in cases where $setViewValue() would not.
  angular.forEach(this.ngModelCtrl.$viewChangeListeners, function(listener) {
    try {
      listener();
    } catch (e) {
      this.$exceptionHandler(e);
    }
  });
};

/**
 * Removes the chip at the given index.
 * @param {number} index of chip to remove
 * @param {Event=} event optionally passed to the onRemove callback
 */
MdChipsCtrl.prototype.removeChip = function(index, event) {
  var removed = this.items.splice(index, 1);

  this.updateNgModel();
  this.ngModelCtrl.$setDirty();

  // Tell screen reader users that the chip was successfully removed.
  // TODO add a way for developers to specify which field of the object should be announced here.
  var chipContent = angular.isObject(removed[0]) ? '' : removed[0];
  this.$mdLiveAnnouncer.announce(chipContent + ' ' + this.removedMessage, 'assertive');

  if (removed && removed.length && this.useOnRemove && this.onRemove) {
    this.onRemove({ '$chip': removed[0], '$index': index, '$event': event });
  }
};

/**
 * @param {number} index location of chip to remove
 * @param {Event=} $event
 */
MdChipsCtrl.prototype.removeChipAndFocusInput = function (index, $event) {
  this.removeChip(index, $event);

  if (this.autocompleteCtrl) {
    // Always hide the autocomplete dropdown before focusing the autocomplete input.
    // Wait for the input to move horizontally, because the chip was removed.
    // This can lead to an incorrect dropdown position.
    this.autocompleteCtrl.hidden = true;
    this.$mdUtil.nextTick(this.onFocus.bind(this));
  } else {
    this.onFocus();
  }

};
/**
 * Selects the chip at `index`,
 * @param {number} index location of chip to select and focus
 */
MdChipsCtrl.prototype.selectAndFocusChipSafe = function(index) {
  // If we have no chips, or are asked to select a chip before the first, just focus the input
  if (!this.items.length || index === -1) {
    return this.focusInput();
  }

  // If we are asked to select a chip greater than the number of chips...
  if (index >= this.items.length) {
    if (this.readonly) {
      // If we are readonly, jump back to the start (because we have no input)
      index = 0;
    } else {
      // If we are not readonly, we should attempt to focus the input
      return this.onFocus();
    }
  }

  index = Math.max(index, 0);
  index = Math.min(index, this.items.length - 1);

  this.selectChip(index);
  this.focusChip(index);
};

/**
 * Focus last chip, then focus the input. This is needed for screen reader support.
 */
MdChipsCtrl.prototype.focusLastChipThenInput = function() {
  var ctrl = this;

  ctrl.shouldFocusLastChip = false;

  ctrl.focusChip(this.items.length - 1);

  ctrl.$timeout(function() {
    ctrl.focusInput();
  }, ctrl.chipAppendDelay);
};

/**
 * Focus the input element.
 */
MdChipsCtrl.prototype.focusInput = function() {
  this.selectChip(-1);
  this.onFocus();
};

/**
 * Marks the chip at the given index as selected.
 * @param {number} index location of chip to select
 */
MdChipsCtrl.prototype.selectChip = function(index) {
  if (index >= -1 && index <= this.items.length) {
    this.selectedChip = index;

    // Fire the onSelect if provided
    if (this.useOnSelect && this.onSelect) {
      this.onSelect({'$chip': this.items[index] });
    }
  } else {
    this.$log.warn('Selected Chip index out of bounds; ignoring.');
  }
};

/**
 * Selects the chip at {@code index} and gives it focus.
 * @param {number} index location of chip to select and focus
 * @deprecated use MdChipsCtrl.selectAndFocusChipSafe. Will be removed in 1.2.
 */
MdChipsCtrl.prototype.selectAndFocusChip = function(index) {
  this.selectChip(index);
  if (index !== -1) {
    this.focusChip(index);
  }
};

/**
 * Call {@code focus()} on the chip at {@code index}
 * @param {number} index location of chip to focus
 */
MdChipsCtrl.prototype.focusChip = function(index) {
  var chipContent = this.$element[0].querySelector(
    'md-chip[index="' + index + '"] .md-chip-content'
  );

  this.ariaTabIndex = index;

  chipContent.focus();
};

/**
 * Configures the required interactions with the ngModel Controller.
 * Specifically, set {@code this.items} to the {@code NgModelController#$viewValue}.
 * @param {NgModelController} ngModelCtrl
 */
MdChipsCtrl.prototype.configureNgModel = function(ngModelCtrl) {
  this.ngModelCtrl = ngModelCtrl;

  var self = this;

  // in chips the meaning of $isEmpty changes
  ngModelCtrl.$isEmpty = function(value) {
    return !value || value.length === 0;
  };

  ngModelCtrl.$render = function() {
    // model is updated. do something.
    self.items = self.ngModelCtrl.$viewValue;
  };
};

MdChipsCtrl.prototype.onFocus = function () {
  var input = this.$element[0].querySelector('input');
  input && input.focus();
  this.resetSelectedChip();
};

MdChipsCtrl.prototype.onInputFocus = function () {
  this.inputHasFocus = true;

  // Make sure we have the appropriate ARIA attributes
  this.setupInputAria();

  // Make sure we don't have any chips selected
  this.resetSelectedChip();
};

MdChipsCtrl.prototype.onInputBlur = function () {
  this.inputHasFocus = false;

  if (this.shouldAddOnBlur()) {
    this.appendChip(this.getChipBuffer().trim());
    this.resetChipBuffer();
  }
};

/**
 * Configure event bindings on input element.
 * @param {angular.element} inputElement
 */
MdChipsCtrl.prototype.configureInput = function configureInput(inputElement) {
  // Find the NgModelCtrl for the input element
  var ngModelCtrl = inputElement.controller('ngModel');
  var ctrl = this;

  if (ngModelCtrl) {

    // sync touched-state from inner input to chips-element
    this.deRegister.push(
      this.$scope.$watch(
        function() {
          return ngModelCtrl.$touched;
        },
        function(isTouched) {
          isTouched && ctrl.ngModelCtrl.$setTouched();
        }
      )
    );

    // sync dirty-state from inner input to chips-element
    this.deRegister.push(
      this.$scope.$watch(
        function() {
          return ngModelCtrl.$dirty;
        },
        function(isDirty) {
          isDirty && ctrl.ngModelCtrl.$setDirty();
        }
      )
    );
  }
};

/**
 * Configure event bindings on a user-provided input element.
 * @param {angular.element} inputElement
 */
MdChipsCtrl.prototype.configureUserInput = function(inputElement) {
  this.userInputElement = inputElement;

  // Find the NgModelCtrl for the input element
  var ngModelCtrl = inputElement.controller('ngModel');
  // `.controller` will look in the parent as well.
  if (ngModelCtrl !== this.ngModelCtrl) {
    this.userInputNgModelCtrl = ngModelCtrl;
  }

  var scope = this.$scope;
  var ctrl = this;

  // Run all of the events using evalAsync because a focus may fire a blur in the same digest loop
  var scopeApplyFn = function(event, fn) {
    scope.$evalAsync(angular.bind(ctrl, fn, event));
  };

  // Bind to keydown and focus events of input
  inputElement
      .attr({ tabindex: 0 })
      .on('keydown', function(event) { scopeApplyFn(event, ctrl.inputKeydown); })
      .on('focus', function(event) { scopeApplyFn(event, ctrl.onInputFocus); })
      .on('blur', function(event) { scopeApplyFn(event, ctrl.onInputBlur); });
};

/**
 * @param {MdAutocompleteCtrl} ctrl controller from the autocomplete component
 */
MdChipsCtrl.prototype.configureAutocomplete = function(ctrl) {
  if (ctrl) {
    this.autocompleteCtrl = ctrl;
    // Update the default container empty hint when we're inside of an autocomplete.
    if (!this.$element.attr('container-empty-hint')) {
      this.containerEmptyHint = 'Chips container with autocompletion. Enter the text area, ' +
        'type text to search, and then use the up and down arrow keys to select an option. ' +
        'Press enter to add the selected option as a chip.';
      this.setupWrapperAria();
    }

    ctrl.registerSelectedItemWatcher(angular.bind(this, function (item) {
      if (item) {
        // Only append the chip and reset the chip buffer if the max chips limit isn't reached.
        if (this.hasMaxChipsReached()) return;

        this.appendChip(item);
        this.resetChipBuffer();
      }
    }));

    this.$element.find('input')
        .on('focus',angular.bind(this, this.onInputFocus))
        .on('blur', angular.bind(this, this.onInputBlur));
  }
};

/**
 * @returns {boolean} Whether the current chip buffer should be added on input blur or not.
 */
MdChipsCtrl.prototype.shouldAddOnBlur = function() {

  // Update the custom ngModel validators from the chips component.
  this.validateModel();

  var chipBuffer = this.getChipBuffer().trim();
  // If the model value is empty and required is set on the element, then the model will be invalid.
  // In that case, we still want to allow adding the chip. The main (but not only) case we want
  // to disallow is adding a chip on blur when md-max-chips validation fails.
  var isModelValid = this.ngModelCtrl.$isEmpty(this.ngModelCtrl.$modelValue) ||
    this.ngModelCtrl.$valid;
  var isAutocompleteShowing = this.autocompleteCtrl && !this.autocompleteCtrl.hidden;

  if (this.userInputNgModelCtrl) {
    isModelValid = isModelValid && this.userInputNgModelCtrl.$valid;
  }

  return this.addOnBlur && !this.requireMatch && chipBuffer && isModelValid &&
    !isAutocompleteShowing;
};

/**
 * @returns {boolean} true if the input or a chip is focused. False otherwise.
 */
MdChipsCtrl.prototype.hasFocus = function () {
  return this.inputHasFocus || this.selectedChip >= 0;
};

/**
 * @param {number} index location of content id
 * @returns {number} unique id for the aria-owns attribute
 */
MdChipsCtrl.prototype.contentIdFor = function(index) {
  return this.contentIds[index];
};

})();
(function(){
"use strict";

  
  MdChips.$inject = ["$mdTheming", "$mdUtil", "$compile", "$log", "$timeout", "$$mdSvgRegistry"];angular
      .module('material.components.chips')
      .directive('mdChips', MdChips);

  /**
   * @ngdoc directive
   * @name mdChips
   * @module material.components.chips
   *
   * @description
   * `<md-chips>` is an input component for building lists of strings or objects. The list items are
   * displayed as 'chips'. This component can make use of an `<input>` element or an
   * `<md-autocomplete>` element.
   *
   * ### Custom templates
   * A custom template may be provided to render the content of each chip. This is achieved by
   * specifying an `<md-chip-template>` element containing the custom content as a child of
   * `<md-chips>`.
   *
   * Note: Any attributes on
   * `<md-chip-template>` will be dropped as only the innerHTML is used for the chip template. The
   * variables `$chip` and `$index` are available in the scope of `<md-chip-template>`, representing
   * the chip object and its index in the list of chips, respectively.
   * To override the chip delete control, include an element (ideally a button) with the attribute
   * `md-chip-remove`. A click listener to remove the chip will be added automatically. The element
   * is also placed as a sibling to the chip content (on which there are also click listeners) to
   * avoid a nested ng-click situation.
   *
   * <!-- Note: We no longer want to include this in the site docs; but it should remain here for
   * future developers and those looking at the documentation.
   *
   * <h3> Pending Features </h3>
   * <ul style="padding-left:20px;">
   *
   *   <ul>Style
   *     <li>Colours for hover, press states (ripple?).</li>
   *   </ul>
   *
   *   <ul>Validation
   *     <li>allow a validation callback</li>
   *     <li>highlighting style for invalid chips</li>
   *   </ul>
   *
   *   <ul>Item mutation
   *     <li>Support `
   *       <md-chip-edit>` template, show/hide the edit element on tap/click? double tap/double
   *       click?
   *     </li>
   *   </ul>
   *
   *   <ul>Truncation and Disambiguation (?)
   *     <li>Truncate chip text where possible, but do not truncate entries such that two are
   *     indistinguishable.</li>
   *   </ul>
   *
   *   <ul>Drag and Drop
   *     <li>Drag and drop chips between related `<md-chips>` elements.
   *     </li>
   *   </ul>
   * </ul>
   *
   * //-->
   *
   * Sometimes developers want to limit the amount of possible chips.<br/>
   * You can specify the maximum amount of chips by using the following markup.
   *
   * <hljs lang="html">
   *   <md-chips
   *       ng-model="myItems"
   *       placeholder="Add an item"
   *       md-max-chips="5">
   *   </md-chips>
   * </hljs>
   *
   * In some cases, you have an autocomplete inside of the `md-chips`.<br/>
   * When the maximum amount of chips has been reached, you can also disable the autocomplete
   * selection.<br/>
   * Here is an example markup.
   *
   * <hljs lang="html">
   *   <md-chips ng-model="myItems" md-max-chips="5">
   *     <md-autocomplete ng-hide="myItems.length > 5" ...></md-autocomplete>
   *   </md-chips>
   * </hljs>
   *
   * ### Accessibility
   *
   * The `md-chips` component supports keyboard and screen reader users since Version 1.1.2. In
   * order to achieve this, we modified the chips behavior to select newly appended chips for
   * `300ms` before re-focusing the input and allowing the user to type.
   *
   * For most users, this delay is small enough that it will not be noticeable but allows certain
   * screen readers to function properly (JAWS and NVDA in particular).
   *
   * We introduced a new `md-chip-append-delay` option to allow developers to better control this
   * behavior.
   *
   * Please refer to the documentation of this option (below) for more information.
   *
   * @param {expression} ng-model Assignable AngularJS expression to be data-bound to the list of
   *    chips. The expression should evaluate to a `string` or `Object` Array. The type of this
   *    array should align with the return value of `md-transform-chip`.
   * @param {expression=} ng-change AngularJS expression to be executed on chip addition, removal,
   *    or content change.
   * @param {string=} placeholder Placeholder text that will be forwarded to the input.
   * @param {string=} secondary-placeholder Placeholder text that will be forwarded to the input,
   *    displayed when there is at least one item in the list
   * @param {boolean=} md-removable Enables or disables the deletion of chips through the
   *    removal icon or the Delete/Backspace key. Defaults to true.
   * @param {boolean=} readonly Disables list manipulation (deleting or adding list items), hiding
   *    the input and delete buttons. If no `ng-model` is provided, the chips will automatically be
   *    marked as readonly.<br/><br/>
   *    When `md-removable` is not defined, the `md-remove` behavior will be overwritten and
   *    disabled.
   * @param {boolean=} md-enable-chip-edit Set this to `"true"` to enable editing of chip contents.
   *    The user can go into edit mode by pressing the `space` or `enter` keys, or by double
   *    clicking on the chip. Chip editing is only supported for chips using the basic template.
   *    **Note:** This attribute is only evaluated once; it is not watched.
   * @param {boolean=} ng-required Whether ng-model is allowed to be empty or not.
   * @param {number=} md-max-chips The maximum number of chips allowed to add through user input.
   *    <br/><br/>The validation property `md-max-chips` can be used when the max chips
   *    amount is reached.
   * @param {boolean=} md-add-on-blur When set to `"true"`, the remaining text inside of the input
   *    will be converted into a new chip on blur.
   *    **Note:** This attribute is only evaluated once; it is not watched.
   * @param {expression} md-transform-chip An expression of form `myFunction($chip)` that when
   *    called expects one of the following return values:
   *    - an object representing the `$chip` input string
   *    - `undefined` to simply add the `$chip` input string, or
   *    - `null` to prevent the chip from being appended
   * @param {expression=} md-on-add An expression which will be called when a chip has been
   *    added with `$chip` and `$index` available as parameters.
   * @param {expression=} md-on-remove An expression which will be called when a chip has been
   *    removed with `$chip`, `$index`, and `$event` available as parameters.
   * @param {expression=} md-on-select An expression which will be called when a chip is selected.
   * @param {boolean=} md-require-match If true, and the chips template contains an autocomplete,
   *    only allow selection of pre-defined chips (i.e. you cannot add new ones).
   * @param {string=} input-aria-describedby A space-separated list of element IDs. This should
   *     contain the IDs of any elements that describe this autocomplete. Screen readers will read
   *     the content of these elements at the end of announcing that the chips input has been
   *     selected and describing its current state. The descriptive elements do not need to be
   *     visible on the page.
   * @param {string=} input-aria-labelledby A space-separated list of element IDs. The ideal use
   *    case is that this would contain the ID of a `<label>` element that is associated with these
   *    chips.<br><br>
   *    For `<label id="state">US State</label>`, you would set this to
   *    `input-aria-labelledby="state"`.
   * @param {string=} input-aria-label A string read by screen readers to identify the input.
   *    For static chips, this will be applied to the chips container.
   * @param {string=} container-hint A string read by screen readers informing users of how to
   *    navigate the chips when there are chips. Only applies when `ng-model` is defined.
   * @param {string=} container-empty-hint A string read by screen readers informing users of how to
   *    add chips when there are no chips. You will want to use this to override the default when
   *    in a non-English locale. Only applies when `ng-model` is defined.
   * @param {string=} delete-hint A string read by screen readers instructing users that pressing
   *    the delete key will remove the chip. You will want to use this to override the default when
   *    in a non-English locale.
   * @param {string=} delete-button-label <strong>Deprecated</strong> A label for the delete button.
   *    Used to be read by screen readers.
   * @param {string=} md-removed-message Screen readers will announce this message following the
   *    chips contents. The default is `"removed"`. If a chip with the content of "Apple" was
   *    removed, the screen reader would read "Apple removed". You will want to use this to override
   *    the default when in a non-English locale.
   * @param {string=} md-added-message Screen readers will announce this message following the
   *    chips contents. The default is `"added"`. If a chip with the content of "Apple" was
   *    created, the screen reader would read "Apple added". You will want to use this to override
   *    the default when in a non-English locale.
   * @param {expression=} md-separator-keys An array of key codes used to separate chips.
   * @param {string=} md-chip-append-delay The number of milliseconds that the component will select
   *    a newly appended chip before allowing a user to type into the input. This is **necessary**
   *    for keyboard accessibility for screen readers. It defaults to 300ms and any number less than
   *    300 can cause issues with screen readers (particularly JAWS and sometimes NVDA).
   *
   *    _Available since Version 1.1.2._
   *
   *    **Note:** You can safely set this to `0` in one of the following two instances:
   *
   *    1. You are targeting an iOS or Safari-only application (where users would use VoiceOver) or
   *    only ChromeVox users.
   *
   *    2. If you have utilized the `md-separator-keys` to disable the `enter` keystroke in
   *    favor of another one (such as `,` or `;`).
   *
   * @usage
   * <hljs lang="html">
   *   <md-chips
   *       ng-model="myItems"
   *       placeholder="Add an item"
   *       readonly="isReadOnly">
   *   </md-chips>
   * </hljs>
   *
   * <h3>Validation</h3>
   * When using [ngMessages](https://docs.angularjs.org/api/ngMessages), you can show errors based
   * on our custom validators.
   * <hljs lang="html">
   *   <form name="userForm">
   *     <md-chips
   *       name="fruits"
   *       ng-model="myItems"
   *       placeholder="Add an item"
   *       md-max-chips="5">
   *     </md-chips>
   *     <div ng-messages="userForm.fruits.$error" ng-if="userForm.$dirty">
   *       <div ng-message="md-max-chips">You reached the maximum amount of chips</div>
   *    </div>
   *   </form>
   * </hljs>
   *
   */

  // TODO add a way for developers to specify which field of the object should used in the
  // aria-label.
  var MD_CHIPS_TEMPLATE = '\
      <md-chips-wrap\
          id="{{$mdChipsCtrl.wrapperId}}"\
          tabindex="{{$mdChipsCtrl.readonly ? 0 : -1}}"\
          ng-keydown="$mdChipsCtrl.chipKeydown($event)"\
          ng-class="{ \'md-focused\': $mdChipsCtrl.hasFocus(), \
                      \'md-readonly\': !$mdChipsCtrl.ngModelCtrl || $mdChipsCtrl.readonly,\
                      \'md-removable\': $mdChipsCtrl.isRemovable() }"\
          class="md-chips">\
        <md-chip ng-repeat="$chip in $mdChipsCtrl.items"\
            index="{{$index}}" \
            ng-class="{\'md-focused\': $mdChipsCtrl.selectedChip == $index, \'md-readonly\': !$mdChipsCtrl.ngModelCtrl || $mdChipsCtrl.readonly}">\
          <div class="md-chip-content"\
              tabindex="{{$mdChipsCtrl.ariaTabIndex === $index ? 0 : -1}}"\
              id="{{$mdChipsCtrl.contentIdFor($index)}}"\
              role="option"\
              aria-selected="{{$mdChipsCtrl.selectedChip === $index}}"\
              aria-setsize="{{$mdChipsCtrl.items.length}}"\
              aria-posinset="{{$index+1}}"\
              ng-click="!$mdChipsCtrl.readonly && $mdChipsCtrl.focusChip($index)"\
              aria-label="{{$mdChipsCtrl._isChipObject($chip) ? \'\' : $chip + \'. \'}}{{$mdChipsCtrl.isRemovable() ? \'\' + $mdChipsCtrl.deleteHint : \'\'}}" \
              ng-focus="!$mdChipsCtrl.readonly && $mdChipsCtrl.selectChip($index)"\
              md-chip-transclude="$mdChipsCtrl.chipContentsTemplate"></div>\
          <div ng-if="$mdChipsCtrl.isRemovable()"\
               class="md-chip-remove-container"\
               tabindex="-1"\
               md-chip-transclude="$mdChipsCtrl.chipRemoveTemplate"></div>\
        </md-chip>\
        <div class="md-chip-input-container" ng-if="!$mdChipsCtrl.readonly && $mdChipsCtrl.ngModelCtrl">\
          <div md-chip-transclude="$mdChipsCtrl.chipInputTemplate"></div>\
        </div>\
      </md-chips-wrap>';

  var CHIP_INPUT_TEMPLATE = '\
        <input\
            class="md-input"\
            tabindex="0"\
            aria-label="{{$mdChipsCtrl.inputAriaLabel}}"\
            placeholder="{{$mdChipsCtrl.getPlaceholder()}}"\
            ng-model="$mdChipsCtrl.chipBuffer"\
            ng-focus="$mdChipsCtrl.onInputFocus()"\
            ng-blur="$mdChipsCtrl.onInputBlur()"\
            ng-keydown="$mdChipsCtrl.inputKeydown($event)">';

  var CHIP_DEFAULT_TEMPLATE = '\
      <span>{{$chip}}</span>';

  var CHIP_REMOVE_TEMPLATE = '\
      <button\
          class="md-chip-remove"\
          ng-if="$mdChipsCtrl.isRemovable()"\
          ng-click="$mdChipsCtrl.removeChipAndFocusInput($$replacedScope.$index, $event)"\
          type="button"\
          tabindex="-1"\
          aria-label="{{$mdChipsCtrl.deleteButtonLabel}}{{$mdChipsCtrl._isChipObject($chip) ? \'\' : \' \' + $chip}}">\
        <md-icon md-svg-src="{{$mdChipsCtrl.mdCloseIcon}}" aria-hidden="true"></md-icon>\
      </button>';

  /**
   * MDChips Directive Definition
   */
  function MdChips ($mdTheming, $mdUtil, $compile, $log, $timeout, $$mdSvgRegistry) {
    // Run our templates through $mdUtil.processTemplate() to allow custom start/end symbols
    var templates = getTemplates();

    return {
      template: function(element, attrs) {
        // Clone the element into an attribute. By prepending the attribute
        // name with '$', AngularJS won't write it into the DOM. The cloned
        // element propagates to the link function via the attrs argument,
        // where various contained-elements can be consumed.
        attrs['$mdUserTemplate'] = element.clone();
        return templates.chips;
      },
      require: ['mdChips'],
      restrict: 'E',
      controller: 'MdChipsCtrl',
      controllerAs: '$mdChipsCtrl',
      bindToController: true,
      compile: compile,
      scope: {
        readonly: '=?readonly',
        removable: '=?mdRemovable',
        placeholder: '@?',
        secondaryPlaceholder: '@?',
        maxChips: '@?mdMaxChips',
        transformChip: '&mdTransformChip',
        onAppend: '&?mdOnAppend',
        onAdd: '&?mdOnAdd',
        onRemove: '&?mdOnRemove',
        addedMessage: '@?mdAddedMessage',
        removedMessage: '@?mdRemovedMessage',
        onSelect: '&?mdOnSelect',
        inputAriaDescribedBy: '@?inputAriaDescribedby',
        inputAriaLabelledBy: '@?inputAriaLabelledby',
        inputAriaLabel: '@?',
        containerHint: '@?',
        containerEmptyHint: '@?',
        deleteHint: '@?',
        deleteButtonLabel: '@?',
        separatorKeys: '=?mdSeparatorKeys',
        requireMatch: '=?mdRequireMatch',
        chipAppendDelayString: '@?mdChipAppendDelay',
        ngChange: '&?'
      }
    };

    /**
     * Builds the final template for `md-chips` and returns the postLink function.
     *
     * Building the template involves 3 key components:
     * static chips
     * chip template
     * input control
     *
     * If no `ng-model` is provided, only the static chip work needs to be done.
     *
     * If no user-passed `md-chip-template` exists, the default template is used. This resulting
     * template is appended to the chip content element.
     *
     * The remove button may be overridden by passing an element with an md-chip-remove attribute.
     *
     * If an `input` or `md-autocomplete` element is provided by the caller, it is set aside for
     * transclusion later. The transclusion happens in `postLink` as the parent scope is required.
     * If no user input is provided, a default one is appended to the input container node in the
     * template.
     *
     * Static Chips (i.e. `md-chip` elements passed from the caller) are gathered and set aside for
     * transclusion in the `postLink` function.
     *
     *
     * @param element
     * @param attr
     * @returns {Function}
     */
    function compile(element, attr) {
      // Grab the user template from attr and reset the attribute to null.
      var userTemplate = attr['$mdUserTemplate'];
      attr['$mdUserTemplate'] = null;

      var chipTemplate = getTemplateByQuery('md-chips>md-chip-template');

      var chipRemoveSelector = $mdUtil
        .prefixer()
        .buildList('md-chip-remove')
        .map(function(attr) {
          return 'md-chips>*[' + attr + ']';
        })
        .join(',');

      // Set the chip remove, chip contents and chip input templates. The link function will put
      // them on the scope for transclusion later.
      var chipRemoveTemplate   = getTemplateByQuery(chipRemoveSelector) || templates.remove,
          chipContentsTemplate = chipTemplate || templates.default,
          chipInputTemplate    = getTemplateByQuery('md-chips>md-autocomplete')
              || getTemplateByQuery('md-chips>input')
              || templates.input,
          staticChips = userTemplate.find('md-chip');

      // Warn of malformed template. See #2545
      if (userTemplate[0].querySelector('md-chip-template>*[md-chip-remove]')) {
        $log.warn('invalid placement of md-chip-remove within md-chip-template.');
      }

      function getTemplateByQuery (query) {
        if (!attr.ngModel) return;
        var element = userTemplate[0].querySelector(query);
        return element && element.outerHTML;
      }

      /**
       * Configures controller and transcludes.
       */
      return function postLink(scope, element, attrs, controllers) {
        $mdUtil.initOptionalProperties(scope, attr);

        $mdTheming(element);
        var mdChipsCtrl = controllers[0];
        if (chipTemplate) {
          // Chip editing functionality assumes we are using the default chip template.
          mdChipsCtrl.enableChipEdit = false;
        }

        mdChipsCtrl.chipContentsTemplate = chipContentsTemplate;
        mdChipsCtrl.chipRemoveTemplate   = chipRemoveTemplate;
        mdChipsCtrl.chipInputTemplate    = chipInputTemplate;

        mdChipsCtrl.mdCloseIcon = $$mdSvgRegistry.mdClose;

        element
            .attr({ tabindex: -1 })
            .on('focus', function () { mdChipsCtrl.onFocus(); })
            .on('click', function () {
              if (!mdChipsCtrl.readonly && mdChipsCtrl.selectedChip === -1) {
                mdChipsCtrl.onFocus();
              }
            });

        if (attr.ngModel) {
          mdChipsCtrl.configureNgModel(element.controller('ngModel'));

          // If an `md-transform-chip` attribute was set, tell the controller to use the expression
          // before appending chips.
          if (attrs.mdTransformChip) mdChipsCtrl.useTransformChipExpression();

          // If an `md-on-append` attribute was set, tell the controller to use the expression
          // when appending chips.
          //
          // TODO: Remove this now that 1.0 is long since released
          // DEPRECATED: Will remove in official 1.0 release
          if (attrs.mdOnAppend) mdChipsCtrl.useOnAppendExpression();

          // If an `md-on-add` attribute was set, tell the controller to use the expression
          // when adding chips.
          if (attrs.mdOnAdd) mdChipsCtrl.useOnAddExpression();

          // If an `md-on-remove` attribute was set, tell the controller to use the expression
          // when removing chips.
          if (attrs.mdOnRemove) mdChipsCtrl.useOnRemoveExpression();

          // If an `md-on-select` attribute was set, tell the controller to use the expression
          // when selecting chips.
          if (attrs.mdOnSelect) mdChipsCtrl.useOnSelectExpression();

          // The md-autocomplete and input elements won't be compiled until after this directive
          // is complete (due to their nested nature). Wait a tick before looking for them to
          // configure the controller.
          if (chipInputTemplate !== templates.input) {
            // The autocomplete will not appear until the readonly attribute is not true (i.e.
            // false or undefined), so we have to watch the readonly and then on the next tick
            // after the chip transclusion has run, we can configure the autocomplete and user
            // input.
            scope.$watch('$mdChipsCtrl.readonly', function(readonly) {
              if (!readonly) {

                $mdUtil.nextTick(function(){

                  if (chipInputTemplate.indexOf('<md-autocomplete') === 0) {
                    var autocompleteEl = element.find('md-autocomplete');
                    mdChipsCtrl.configureAutocomplete(autocompleteEl.controller('mdAutocomplete'));
                  }

                  mdChipsCtrl.configureUserInput(element.find('input'));
                });
              }
            });
          }

          // At the next tick, if we find an input, make sure it has the md-input class
          $mdUtil.nextTick(function() {
            var input = element.find('input');

            if (input) {
              mdChipsCtrl.configureInput(input);
              input.toggleClass('md-input', true);
            }
          });
        }

        // Compile with the parent's scope and prepend any static chips to the wrapper.
        if (staticChips.length > 0) {
          var compiledStaticChips = $compile(staticChips.clone())(scope.$parent);
          $timeout(function() { element.find('md-chips-wrap').prepend(compiledStaticChips); });
        }
      };
    }

    function getTemplates() {
      return {
        chips: $mdUtil.processTemplate(MD_CHIPS_TEMPLATE),
        input: $mdUtil.processTemplate(CHIP_INPUT_TEMPLATE),
        default: $mdUtil.processTemplate(CHIP_DEFAULT_TEMPLATE),
        remove: $mdUtil.processTemplate(CHIP_REMOVE_TEMPLATE)
      };
    }
  }

})();
(function(){
"use strict";


MdContactChipsCtrl.$inject = ["$attrs", "$element", "$timeout"];angular
    .module('material.components.chips')
    .controller('MdContactChipsCtrl', MdContactChipsCtrl);

/**
 * Controller for the MdContactChips component
 * @constructor
 */
function MdContactChipsCtrl ($attrs, $element, $timeout) {
  /** @type {$element} */
  this.$element = $element;

  /** @type {$attrs} */
  this.$attrs = $attrs;

  /** @type {Function} */
  this.$timeout = $timeout;

  /** @type {Object} */
  this.selectedItem = null;

  /** @type {string} */
  this.searchText = '';

  /**
   * Collection of functions to call to un-register watchers
   * @type {Array}
   */
  this.deRegister = [];

  this.init();
}

MdContactChipsCtrl.prototype.init = function() {
  var ctrl = this;
  var deRegister = this.deRegister;
  var element = this.$element;

  // Setup a watcher which manages chips a11y messages and autocomplete aria.
  // Timeout required to allow the child elements to be compiled.
  this.$timeout(function() {
    deRegister.push(
      element.find('md-chips').scope().$watchCollection('$mdChipsCtrl.items', function() {
        // Make sure our input and wrapper have the correct ARIA attributes
        ctrl.setupChipsAria();
        ctrl.setupAutocompleteAria();
      })
    );
  });
};

MdContactChipsCtrl.prototype.setupChipsAria = function() {
  var chips = this.$element.find('md-chips');
  var chipsCtrl = chips.controller('mdChips');

  // Configure MdChipsCtrl
  if (this.removedMessage) {
    chipsCtrl.removedMessage = this.removedMessage;
  }
  if (this.containerHint) {
    chipsCtrl.containerHint = this.containerHint;
  }
  if (this.containerEmptyHint) {
    // Apply attribute to avoid the hint being overridden by MdChipsCtrl.configureAutocomplete()
    chips.attr('container-empty-hint', this.containerEmptyHint);
    chipsCtrl.containerEmptyHint = this.containerEmptyHint;
  }
  if (this.deleteHint) {
    chipsCtrl.deleteHint = this.deleteHint;
  }
  if (this.inputAriaLabel) {
    chipsCtrl.inputAriaLabel = this.inputAriaLabel;
  }
};

MdContactChipsCtrl.prototype.setupAutocompleteAria = function() {
  var autocompleteInput = this.$element.find('md-chips-wrap').find('md-autocomplete').find('input');

  // Set attributes on the input of the md-autocomplete
  if (this.inputAriaDescribedBy) {
    autocompleteInput.attr('aria-describedby', this.inputAriaDescribedBy);
  }
  if (this.inputAriaLabelledBy) {
    autocompleteInput.removeAttr('aria-label');
    autocompleteInput.attr('aria-labelledby', this.inputAriaLabelledBy);
  }
};

MdContactChipsCtrl.prototype.queryContact = function(searchText) {
  return this.contactQuery({'$query': searchText});
};

MdContactChipsCtrl.prototype.inputKeydown = function(event) {
  if (!this.separatorKeys || this.separatorKeys.indexOf(event.keyCode) < 0) {
    return;
  }

  event.stopPropagation();
  event.preventDefault();

  var autocompleteCtrl = angular.element(event.target).controller('mdAutocomplete');
  autocompleteCtrl.select(autocompleteCtrl.index);
};

MdContactChipsCtrl.prototype.itemName = function(item) {
  return item[this.contactName];
};

/**
 * Destructor for cleanup
 */
MdContactChipsCtrl.prototype.$onDestroy = function $onDestroy() {
  var $destroyFn;
  while (($destroyFn = this.deRegister.pop())) {
    $destroyFn.call(this);
  }
};

})();
(function(){
"use strict";


MdContactChips.$inject = ["$mdTheming", "$mdUtil"];angular
  .module('material.components.chips')
  .directive('mdContactChips', MdContactChips);

/**
 * @ngdoc directive
 * @name mdContactChips
 * @module material.components.chips
 *
 * @description
 * `<md-contact-chips>` is an input component based on `md-chips` and makes use of an
 * `md-autocomplete` element. The component allows the caller to supply a query expression which
 * returns  a list of possible contacts. The user can select one of these and add it to the list of
 * chips.
 *
 * You may also use the <a ng-href="api/directive/mdHighlightText">md-highlight-flags</a> attribute
 * along with its parameters to control the appearance of the matched text inside of the contacts'
 * autocomplete popup.
 *
 * @param {expression} ng-model Assignable AngularJS expression to be data-bound to the list of
 *    contact chips. The expression should evaluate to an `Object` Array.
 * @param {expression=} ng-change AngularJS expression to be executed on chip addition, removal,
 *    or content change.
 * @param {string=} placeholder Placeholder text that will be forwarded to the input.
 * @param {string=} secondary-placeholder Placeholder text that will be forwarded to the input,
 *    displayed when there is at least on item in the list
 * @param {expression} md-contacts An expression expected to return contacts matching the search
 *    test, `$query`. If this expression involves a promise, a loading bar is displayed while
 *    waiting for it to resolve.
 * @param {string} md-contact-name The field name of the contact object representing the
 *    contact's name.
 * @param {string} md-contact-email The field name of the contact object representing the
 *    contact's email address.
 * @param {string} md-contact-image The field name of the contact object representing the
 *    contact's image.
 * @param {number=} md-min-length Specifies the minimum length of text before autocomplete will
 *    make suggestions
 * @param {string=} input-aria-describedby A space-separated list of element IDs. This should
 *     contain the IDs of any elements that describe this autocomplete. Screen readers will read
 *     the content of these elements at the end of announcing that the chips input has been
 *     selected and describing its current state. The descriptive elements do not need to be
 *     visible on the page.
 * @param {string=} input-aria-labelledby A space-separated list of element IDs. The ideal use
 *    case is that this would contain the ID of a `<label>` element that is associated with these
 *    chips.<br><br>
 *    For `<label id="state">US State</label>`, you would set this to
 *    `input-aria-labelledby="state"`.
 * @param {string=} input-aria-label A string read by screen readers to identify the input.
 *    For static chips, this will be applied to the chips container.
 * @param {string=} container-hint A string read by screen readers informing users of how to
 *    navigate the chips when there are chips.
 * @param {string=} container-empty-hint A string read by screen readers informing users of how to
 *    add chips when there are no chips. You will want to use this to override the default when
 *    in a non-English locale.
 * @param {string=} delete-hint A string read by screen readers instructing users that pressing
 *    the delete key will remove the chip. You will want to use this to override the default when
 *    in a non-English locale.
 * @param {string=} md-removed-message Screen readers will announce this message following the
 *    chips contents. The default is `"removed"`. If a chip with the content of "Apple" was
 *    removed, the screen reader would read "Apple removed". You will want to use this to override
 *    the default when in a non-English locale.
 *
 *
 * @usage
 * <hljs lang="html">
 *   <md-contact-chips
 *       ng-model="ctrl.contacts"
 *       md-contacts="ctrl.querySearch($query)"
 *       md-contact-name="name"
 *       md-contact-image="image"
 *       md-contact-email="email"
 *       placeholder="To">
 *   </md-contact-chips>
 * </hljs>
 *
 */


var MD_CONTACT_CHIPS_TEMPLATE = '\
      <md-chips class="md-contact-chips"\
          ng-model="$mdContactChipsCtrl.contacts"\
          ng-change="$mdContactChipsCtrl.ngChange($mdContactChipsCtrl.contacts)"\
          md-require-match="$mdContactChipsCtrl.requireMatch"\
          md-chip-append-delay="{{$mdContactChipsCtrl.chipAppendDelay}}"\
          md-separator-keys="$mdContactChipsCtrl.separatorKeys"\
          md-autocomplete-snap>\
          <md-autocomplete\
              md-menu-class="md-contact-chips-suggestions"\
              md-selected-item="$mdContactChipsCtrl.selectedItem"\
              md-search-text="$mdContactChipsCtrl.searchText"\
              md-items="item in $mdContactChipsCtrl.queryContact($mdContactChipsCtrl.searchText)"\
              md-item-text="$mdContactChipsCtrl.itemName(item)"\
              md-no-cache="true"\
              md-min-length="$mdContactChipsCtrl.minLength"\
              md-autoselect\
              ng-keydown="$mdContactChipsCtrl.inputKeydown($event)"\
              placeholder="{{$mdContactChipsCtrl.contacts.length === 0 ?\
                  $mdContactChipsCtrl.placeholder : $mdContactChipsCtrl.secondaryPlaceholder}}">\
            <div class="md-contact-suggestion">\
              <img \
                  ng-src="{{item[$mdContactChipsCtrl.contactImage]}}"\
                  alt="{{item[$mdContactChipsCtrl.contactName]}}"\
                  ng-if="item[$mdContactChipsCtrl.contactImage]" />\
              <span class="md-contact-name" md-highlight-text="$mdContactChipsCtrl.searchText"\
                    md-highlight-flags="{{$mdContactChipsCtrl.highlightFlags}}">\
                {{item[$mdContactChipsCtrl.contactName]}}\
              </span>\
              <span class="md-contact-email" >{{item[$mdContactChipsCtrl.contactEmail]}}</span>\
            </div>\
          </md-autocomplete>\
          <md-chip-template>\
            <div class="md-contact-avatar">\
              <img \
                  ng-src="{{$chip[$mdContactChipsCtrl.contactImage]}}"\
                  alt="{{$chip[$mdContactChipsCtrl.contactName]}}"\
                  ng-if="$chip[$mdContactChipsCtrl.contactImage]" />\
            </div>\
            <div class="md-contact-name">\
              {{$chip[$mdContactChipsCtrl.contactName]}}\
            </div>\
          </md-chip-template>\
      </md-chips>';


/**
 * MDContactChips Directive Definition
 *
 * @param $mdTheming
 * @param $mdUtil
 * @returns {*}
 * @ngInject
 */
function MdContactChips($mdTheming, $mdUtil) {
  return {
    template: function(element, attrs) {
      return MD_CONTACT_CHIPS_TEMPLATE;
    },
    restrict: 'E',
    controller: 'MdContactChipsCtrl',
    controllerAs: '$mdContactChipsCtrl',
    bindToController: true,
    compile: compile,
    scope: {
      contactQuery: '&mdContacts',
      placeholder: '@?',
      secondaryPlaceholder: '@?',
      contactName: '@mdContactName',
      contactImage: '@mdContactImage',
      contactEmail: '@mdContactEmail',
      contacts: '=ngModel',
      ngChange: '&?',
      requireMatch: '=?mdRequireMatch',
      minLength: '=?mdMinLength',
      highlightFlags: '@?mdHighlightFlags',
      chipAppendDelay: '@?mdChipAppendDelay',
      separatorKeys: '=?mdSeparatorKeys',
      removedMessage: '@?mdRemovedMessage',
      inputAriaDescribedBy: '@?inputAriaDescribedby',
      inputAriaLabelledBy: '@?inputAriaLabelledby',
      inputAriaLabel: '@?',
      containerHint: '@?',
      containerEmptyHint: '@?',
      deleteHint: '@?'
    }
  };

  function compile(element, attr) {
    return function postLink(scope, element, attrs, controllers) {
      var contactChipsController = controllers;

      $mdUtil.initOptionalProperties(scope, attr);
      $mdTheming(element);

      element.attr('tabindex', '-1');

      attrs.$observe('mdChipAppendDelay', function(newValue) {
        contactChipsController.chipAppendDelay = newValue;
      });
    };
  }
}

})();
(function(){
"use strict";

(function () {
  "use strict";

  /**
   *  Use a RegExp to check if the `md-colors="<expression>"` is static string
   *  or one that should be observed and dynamically interpolated.
   */
  MdColorsDirective.$inject = ["$mdColors", "$mdUtil", "$log", "$parse"];
  MdColorsService.$inject = ["$mdTheming", "$mdUtil", "$log"];
  var STATIC_COLOR_EXPRESSION = /^{((\s|,)*?["'a-zA-Z-]+?\s*?:\s*?('|")[a-zA-Z0-9-.]*('|"))+\s*}$/;
  var colorPalettes = null;

  /**
   * @ngdoc module
   * @name material.components.colors
   *
   * @description
   * Define $mdColors service and a `md-colors=""` attribute directive
   */
  angular
    .module('material.components.colors', ['material.core'])
    .directive('mdColors', MdColorsDirective)
    .service('$mdColors', MdColorsService);

  /**
   * @ngdoc service
   * @name $mdColors
   * @module material.components.colors
   *
   * @description
   * By default, defining a theme does not make its colors available for applying to non AngularJS
   * Material elements. The `$mdColors` service is used by the `md-color` directive to convert a
   * set of color expressions to RGBA values and then apply those values to the element as CSS
   * property values.
   *
   * @usage
   * Getting a color based on a theme
   *
   *  <hljs lang="js">
   *    angular.controller('myCtrl', function ($mdColors) {
   *      var color = $mdColors.getThemeColor('myTheme-primary-900-0.5');
   *      ...
   *    });
   *  </hljs>
   *
   * Applying a color from a palette to an element
   * <hljs lang="js">
   *   app.directive('myDirective', function($mdColors) {
   *     return {
   *       ...
   *       link: function (scope, elem) {
   *         $mdColors.applyThemeColors(elem, {color: 'red-A200-0.2'});
   *       }
   *    }
   *   });
   * </hljs>
   */
  function MdColorsService($mdTheming, $mdUtil, $log) {
    colorPalettes = colorPalettes || Object.keys($mdTheming.PALETTES);

    // Publish service instance
    return {
      applyThemeColors: applyThemeColors,
      getThemeColor: getThemeColor,
      hasTheme: hasTheme
    };

    // ********************************************
    // Internal Methods
    // ********************************************

    /**
     * @ngdoc method
     * @name $mdColors#applyThemeColors
     *
     * @description
     * Lookup a set of colors by hue, theme, and palette, then apply those colors
     * with the provided opacity (via `rgba()`) to the specified CSS property.
     *
     * @param {angular.element} element the element to apply the styles to
     * @param {Object} colorExpression Keys are CSS properties and values are strings representing
     * the `theme-palette-hue-opacity` of the desired color. For example:
     * `{'color': 'red-A200-0.3', 'background-color': 'myTheme-primary-700-0.8'}`. Theme, hue, and
     * opacity are optional.
     */
    function applyThemeColors(element, colorExpression) {
      try {
        if (colorExpression) {
          // Assign the calculate RGBA color values directly as inline CSS
          element.css(interpolateColors(colorExpression));
        }
      } catch (e) {
        $log.error(e.message);
      }
    }

    /**
     * @ngdoc method
     * @name $mdColors#getThemeColor
     *
     * @description
     * Get a parsed RGBA color using a string representing the `theme-palette-hue-opacity` of the
     * desired color.
     *
     * @param {string} expression color expression like `'red-A200-0.3'` or
     *  `'myTheme-primary-700-0.8'`. Theme, hue, and opacity are optional.
     * @returns {string} a CSS color value like `rgba(211, 47, 47, 0.8)`
     */
    function getThemeColor(expression) {
      var color = extractColorOptions(expression);

      return parseColor(color);
    }

    /**
     * Return the parsed color
     * @param {{hue: *, theme: any, palette: *, opacity: (*|string|number)}} color hash map of color
     *  definitions
     * @param {boolean=} contrast whether use contrast color for foreground. Defaults to false.
     * @returns {string} rgba color string
     */
    function parseColor(color, contrast) {
      contrast = contrast || false;
      var rgbValues = $mdTheming.PALETTES[color.palette][color.hue];

      rgbValues = contrast ? rgbValues.contrast : rgbValues.value;

      return $mdUtil.supplant('rgba({0}, {1}, {2}, {3})',
        [rgbValues[0], rgbValues[1], rgbValues[2], rgbValues[3] || color.opacity]
      );
    }

    /**
     * Convert the color expression into an object with scope-interpolated values
     * Then calculate the rgba() values based on the theme color parts
     * @param {Object} themeColors json object, keys are css properties and values are string of
     * the wanted color, for example: `{color: 'red-A200-0.3'}`.
     * @return {Object} Hashmap of CSS properties with associated `rgba()` string values
     */
    function interpolateColors(themeColors) {
      var rgbColors = {};

      var hasColorProperty = themeColors.hasOwnProperty('color');

      angular.forEach(themeColors, function (value, key) {
        var color = extractColorOptions(value);
        var hasBackground = key.indexOf('background') > -1;

        rgbColors[key] = parseColor(color);
        if (hasBackground && !hasColorProperty) {
          rgbColors.color = parseColor(color, true);
        }
      });

      return rgbColors;
    }

    /**
     * Check if expression has defined theme
     * For instance:
     *   'myTheme-primary' => true
     *   'red-800' => false
     * @param {string} expression color expression like 'red-800', 'red-A200-0.3',
     *   'myTheme-primary', or 'myTheme-primary-400'
     * @return {boolean} true if the expression has a theme part, false otherwise.
     */
    function hasTheme(expression) {
      return angular.isDefined($mdTheming.THEMES[expression.split('-')[0]]);
    }

    /**
     * For the evaluated expression, extract the color parts into a hash map
     * @param {string} expression color expression like 'red-800', 'red-A200-0.3',
     *   'myTheme-primary', or 'myTheme-primary-400'
     * @returns {{hue: *, theme: any, palette: *, opacity: (*|string|number)}}
     */
    function extractColorOptions(expression) {
      var parts = expression.split('-');
      var hasTheme = angular.isDefined($mdTheming.THEMES[parts[0]]);
      var theme = hasTheme ? parts.splice(0, 1)[0] : $mdTheming.defaultTheme();

      return {
        theme: theme,
        palette: extractPalette(parts, theme),
        hue: extractHue(parts, theme),
        opacity: parts[2] || 1
      };
    }

    /**
     * Calculate the theme palette name
     * @param {Array} parts
     * @param {string} theme name
     * @return {string}
     */
    function extractPalette(parts, theme) {
      // If the next section is one of the palettes we assume it's a two word palette
      // Two word palette can be also written in camelCase, forming camelCase to dash-case

      var isTwoWord = parts.length > 1 && colorPalettes.indexOf(parts[1]) !== -1;
      var palette = parts[0].replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();

      if (isTwoWord)  palette = parts[0] + '-' + parts.splice(1, 1);

      if (colorPalettes.indexOf(palette) === -1) {
        // If the palette is not in the palette list it's one of primary/accent/warn/background
        var scheme = $mdTheming.THEMES[theme].colors[palette];
        if (!scheme) {
          throw new Error($mdUtil.supplant(
            'mdColors: couldn\'t find \'{palette}\' in the palettes.',
            {palette: palette}));
        }
        palette = scheme.name;
      }

      return palette;
    }

    /**
     * @param {Array} parts
     * @param {string} theme name
     * @return {*}
     */
    function extractHue(parts, theme) {
      var themeColors = $mdTheming.THEMES[theme].colors;

      if (parts[1] === 'hue') {
        var hueNumber = parseInt(parts.splice(2, 1)[0], 10);

        if (hueNumber < 1 || hueNumber > 3) {
          throw new Error($mdUtil.supplant(
            'mdColors: \'hue-{hueNumber}\' is not a valid hue, can be only \'hue-1\', \'hue-2\' and \'hue-3\'',
            {hueNumber: hueNumber}));
        }
        parts[1] = 'hue-' + hueNumber;

        if (!(parts[0] in themeColors)) {
          throw new Error($mdUtil.supplant(
            'mdColors: \'hue-x\' can only be used with [{availableThemes}], but was used with \'{usedTheme}\'',
            {
            availableThemes: Object.keys(themeColors).join(', '),
            usedTheme: parts[0]
          }));
        }

        return themeColors[parts[0]].hues[parts[1]];
      }

      return parts[1] || themeColors[parts[0] in themeColors ? parts[0] : 'primary'].hues['default'];
    }
  }

  /**
   * @ngdoc directive
   * @name mdColors
   * @module material.components.colors
   *
   * @restrict A
   *
   * @description
   * `mdColors` directive will apply the theme-based color expression as RGBA CSS style values.
   *
   *   The format will be similar to the colors defined in the Sass files:
   *
   *   ## `[?theme]-[palette]-[?hue]-[?opacity]`
   *   - [theme]    - default value is the default theme
   *   - [palette]  - can be either palette name or primary/accent/warn/background
   *   - [hue]      - default is 500 (hue-x can be used with primary/accent/warn/background)
   *   - [opacity]  - default is 1
   *
   *
   *   > `?` indicates optional parameter
   *
   * @usage
   * <hljs lang="html">
   *   <div md-colors="{background: 'myTheme-accent-900-0.43'}">
   *     <div md-colors="{color: 'red-A100', 'border-color': 'primary-600'}">
   *       <span>Color demo</span>
   *     </div>
   *   </div>
   * </hljs>
   *
   * The `mdColors` directive will automatically watch for changes in the expression if it recognizes
   * an interpolation expression or a function. For performance options, you can use `::` prefix to
   * the `md-colors` expression to indicate a one-time data binding.
   *
   * <hljs lang="html">
   *   <md-card md-colors="::{background: '{{theme}}-primary-700'}">
   *   </md-card>
   * </hljs>
   */
  function MdColorsDirective($mdColors, $mdUtil, $log, $parse) {
    return {
      restrict: 'A',
      require: ['^?mdTheme'],
      compile: function (tElem, tAttrs) {
        var shouldWatch = shouldColorsWatch();

        return function (scope, element, attrs, ctrl) {
          var mdThemeController = ctrl[0];

          var lastColors = {};

          /**
           * @param {string=} theme
           * @return {Object} colors found in the specified theme
           */
          var parseColors = function (theme) {
            if (typeof theme !== 'string') {
              theme = '';
            }

            if (!attrs.mdColors) {
              attrs.mdColors = '{}';
            }

            /**
             * Json.parse() does not work because the keys are not quoted;
             * use $parse to convert to a hash map
             */
            var colors = $parse(attrs.mdColors)(scope);

            /**
             * If mdTheme is defined higher up the DOM tree,
             * we add mdTheme's theme to the colors which don't specify a theme.
             *
             * @example
             * <hljs lang="html">
             *   <div md-theme="myTheme">
             *     <div md-colors="{background: 'primary-600'}">
             *       <span md-colors="{background: 'mySecondTheme-accent-200'}">Color demo</span>
             *     </div>
             *   </div>
             * </hljs>
             *
             * 'primary-600' will be changed to 'myTheme-primary-600',
             * but 'mySecondTheme-accent-200' will not be changed since it has a theme defined.
             */
            if (mdThemeController) {
              Object.keys(colors).forEach(function (prop) {
                var color = colors[prop];
                if (!$mdColors.hasTheme(color)) {
                  colors[prop] = (theme || mdThemeController.$mdTheme) + '-' + color;
                }
              });
            }

            cleanElement(colors);

            return colors;
          };

          /**
           * @param {Object} colors
           */
          var cleanElement = function (colors) {
            if (!angular.equals(colors, lastColors)) {
              var keys = Object.keys(lastColors);

              if (lastColors.background && !keys.color) {
                keys.push('color');
              }

              keys.forEach(function (key) {
                element.css(key, '');
              });
            }

            lastColors = colors;
          };

          /**
           * Registering for mgTheme changes and asking mdTheme controller run our callback whenever
           * a theme changes.
           */
          var unregisterChanges = angular.noop;

          if (mdThemeController) {
            unregisterChanges = mdThemeController.registerChanges(function (theme) {
              $mdColors.applyThemeColors(element, parseColors(theme));
            });
          }

          scope.$on('$destroy', function () {
            unregisterChanges();
          });

          try {
            if (shouldWatch) {
              scope.$watch(parseColors, angular.bind(this,
                $mdColors.applyThemeColors, element
              ), true);
            }
            else {
              $mdColors.applyThemeColors(element, parseColors());
            }

          }
          catch (e) {
            $log.error(e.message);
          }

        };

        /**
         * @return {boolean}
         */
        function shouldColorsWatch() {
          // Simulate 1x binding and mark mdColorsWatch == false
          var rawColorExpression = tAttrs.mdColors;
          var bindOnce = rawColorExpression.indexOf('::') > -1;
          var isStatic = bindOnce ? true : STATIC_COLOR_EXPRESSION.test(tAttrs.mdColors);

          // Remove it for the postLink...
          tAttrs.mdColors = rawColorExpression.replace('::', '');

          var hasWatchAttr = angular.isDefined(tAttrs.mdColorsWatch);

          return (bindOnce || isStatic) ? false :
            hasWatchAttr ? $mdUtil.parseAttributeBoolean(tAttrs.mdColorsWatch) : true;
        }
      }
    };
  }
})();

})();
(function(){
"use strict";

/**
 * @ngdoc module
 * @name material.components.content
 *
 * @description
 * Scrollable content
 */
mdContentDirective.$inject = ["$mdTheming"];
angular.module('material.components.content', [
  'material.core'
])
  .directive('mdContent', mdContentDirective);

/**
 * @ngdoc directive
 * @name mdContent
 * @module material.components.content
 *
 * @restrict E
 *
 * @description
 *
 * The `<md-content>` directive is a container element useful for scrollable content. It achieves
 * this by setting the CSS `overflow` property to `auto` so that content can properly scroll.
 *
 * In general, `<md-content>` components are not designed to be nested inside one another. If
 * possible, it is better to make them siblings. This often results in a better user experience as
 * having nested scrollbars may confuse the user.
 *
 * ## Troubleshooting
 *
 * In some cases, you may wish to apply the `md-no-momentum` class to ensure that Safari's
 * momentum scrolling is disabled. Momentum scrolling can cause flickering issues while scrolling
 * SVG icons and some other components.
 *
 * Additionally, we now also offer the `md-no-flicker` class which can be applied to any element
 * and uses a Webkit-specific filter of `blur(0px)` that forces GPU rendering of all elements
 * inside (which eliminates the flicker on iOS devices).
 *
 * _<b>Note:</b> Forcing an element to render on the GPU can have unintended side-effects, especially
 * related to the z-index of elements. Please use with caution and only on the elements needed._
 *
 * @usage
 *
 * Add the `[layout-padding]` attribute to make the content padded.
 *
 * <hljs lang="html">
 *  <md-content layout-padding>
 *      Lorem ipsum dolor sit amet, ne quod novum mei.
 *  </md-content>
 * </hljs>
 */

function mdContentDirective($mdTheming) {
  return {
    restrict: 'E',
    controller: ['$scope', '$element', ContentController],
    link: function(scope, element) {
      element.addClass('_md');     // private md component indicator for styling

      $mdTheming(element);
      scope.$broadcast('$mdContentLoaded', element);

      iosScrollFix(element[0]);
    }
  };

  function ContentController($scope, $element) {
    this.$scope = $scope;
    this.$element = $element;
  }
}

function iosScrollFix(node) {
  // IOS FIX:
  // If we scroll where there is no more room for the webview to scroll,
  // by default the webview itself will scroll up and down, this looks really
  // bad.  So if we are scrolling to the very top or bottom, add/subtract one
  angular.element(node).on('$md.pressdown', function(ev) {
    // Only touch events
    if (ev.pointer.type !== 't') return;
    // Don't let a child content's touchstart ruin it for us.
    if (ev.$materialScrollFixed) return;
    ev.$materialScrollFixed = true;

    if (node.scrollTop === 0) {
      node.scrollTop = 1;
    } else if (node.scrollHeight === node.scrollTop + node.offsetHeight) {
      node.scrollTop -= 1;
    }
  });
}

})();
(function(){
"use strict";

/**
 * @ngdoc module
 * @name material.components.datepicker
 * @description Module for the datepicker component.
 */

angular.module('material.components.datepicker', [
  'material.core',
  'material.components.icon',
  'material.components.virtualRepeat'
]);

})();
(function(){
"use strict";

(function() {
  'use strict';

  /**
   * @ngdoc directive
   * @name mdCalendar
   * @module material.components.datepicker
   *
   * @param {Date} ng-model The component's model. Should be a Date object.
   * @param {Date=} md-min-date Expression representing the minimum date.
   * @param {Date=} md-max-date Expression representing the maximum date.
   * @param {(function(Date): boolean)=} md-date-filter Function expecting a date and returning a
   *  boolean whether it can be selected or not.
   * @param {String=} md-current-view Current view of the calendar. Can be either "month" or "year".
   * @param {String=} md-mode Restricts the user to only selecting a value from a particular view.
   *  This option can be used if the user is only supposed to choose from a certain date type
   *  (e.g. only selecting the month). Can be either "month" or "day". **Note** that this will
   *  overwrite the `md-current-view` value.
   *
   * @description
   * `<md-calendar>` is a component that renders a calendar that can be used to select a date.
   * It is a part of the `<md-datepicker>` pane, however it can also be used on it's own.
   *
   * @usage
   *
   * <hljs lang="html">
   *   <md-calendar ng-model="birthday"></md-calendar>
   * </hljs>
   */
  CalendarCtrl.$inject = ["$element", "$scope", "$$mdDateUtil", "$mdUtil", "$mdConstant", "$mdTheming", "$$rAF", "$attrs", "$mdDateLocale"];
  angular.module('material.components.datepicker')
    .directive('mdCalendar', calendarDirective);

  // POST RELEASE
  // TODO(jelbourn): Mac Cmd + left / right == Home / End
  // TODO(jelbourn): Refactor month element creation to use cloneNode (performance).
  // TODO(jelbourn): Define virtual scrolling constants (compactness) users can override.
  // TODO(jelbourn): Animated month transition on ng-model change (virtual-repeat)
  // TODO(jelbourn): Scroll snapping (virtual repeat)
  // TODO(jelbourn): Remove superfluous row from short months (virtual-repeat)
  // TODO(jelbourn): Month headers stick to top when scrolling.
  // TODO(jelbourn): Previous month opacity is lowered when partially scrolled out of view.
  // TODO(jelbourn): Support md-calendar standalone on a page (as a tabstop w/ aria-live
  //     announcement and key handling).
  // Read-only calendar (not just date-picker).

  function calendarDirective() {
    return {
      template: function(tElement, tAttr) {
        // TODO(crisbeto): This is a workaround that allows the calendar to work, without
        // a datepicker, until issue #8585 gets resolved. It can safely be removed
        // afterwards. This ensures that the virtual repeater scrolls to the proper place on load by
        // deferring the execution until the next digest. It's necessary only if the calendar is used
        // without a datepicker, otherwise it's already wrapped in an ngIf.
        var extraAttrs = tAttr.hasOwnProperty('ngIf') ? '' : 'ng-if="calendarCtrl.isInitialized"';
        var template = '' +
          '<div ng-switch="calendarCtrl.currentView" ' + extraAttrs + '>' +
            '<md-calendar-year ng-switch-when="year"></md-calendar-year>' +
            '<md-calendar-month ng-switch-default></md-calendar-month>' +
          '</div>';

        return template;
      },
      scope: {
        minDate: '=mdMinDate',
        maxDate: '=mdMaxDate',
        dateFilter: '=mdDateFilter',

        // These need to be prefixed, because Angular resets
        // any changes to the value due to bindToController.
        _mode: '@mdMode',
        _currentView: '@mdCurrentView'
      },
      require: ['ngModel', 'mdCalendar'],
      controller: CalendarCtrl,
      controllerAs: 'calendarCtrl',
      bindToController: true,
      link: function(scope, element, attrs, controllers) {
        var ngModelCtrl = controllers[0];
        var mdCalendarCtrl = controllers[1];
        mdCalendarCtrl.configureNgModel(ngModelCtrl);
      }
    };
  }

  /**
   * Occasionally the hideVerticalScrollbar method might read an element's
   * width as 0, because it hasn't been laid out yet. This value will be used
   * as a fallback, in order to prevent scenarios where the element's width
   * would otherwise have been set to 0. This value is the "usual" width of a
   * calendar within a floating calendar pane.
   */
  var FALLBACK_WIDTH = 340;

  /** Next identifier for calendar instance. */
  var nextUniqueId = 0;

  /** Maps the `md-mode` values to their corresponding calendar views. */
  var MODE_MAP = {
    day: 'month',
    month: 'year'
  };

  /**
   * Controller for the mdCalendar component.
   * @ngInject @constructor
   */
  function CalendarCtrl($element, $scope, $$mdDateUtil, $mdUtil,
    $mdConstant, $mdTheming, $$rAF, $attrs, $mdDateLocale) {

    $mdTheming($element);

    /** @final {!angular.JQLite} */
    this.$element = $element;

    /** @final {!angular.Scope} */
    this.$scope = $scope;

    /** @final */
    this.dateUtil = $$mdDateUtil;

    /** @final */
    this.$mdUtil = $mdUtil;

    /** @final */
    this.keyCode = $mdConstant.KEY_CODE;

    /** @final */
    this.$$rAF = $$rAF;

    /** @final */
    this.$mdDateLocale = $mdDateLocale;

    /** @final {Date} */
    this.today = this.dateUtil.createDateAtMidnight();

    /** @type {!angular.NgModelController} */
    this.ngModelCtrl = null;

    /** @type {String} Class applied to the selected date cell. */
    this.SELECTED_DATE_CLASS = 'md-calendar-selected-date';

    /** @type {String} Class applied to the cell for today. */
    this.TODAY_CLASS = 'md-calendar-date-today';

    /** @type {String} Class applied to the focused cell. */
    this.FOCUSED_DATE_CLASS = 'md-focus';

    /** @final {number} Unique ID for this calendar instance. */
    this.id = nextUniqueId++;

    /**
     * The date that is currently focused or showing in the calendar. This will initially be set
     * to the ng-model value if set, otherwise to today. It will be updated as the user navigates
     * to other months. The cell corresponding to the displayDate does not necesarily always have
     * focus in the document (such as for cases when the user is scrolling the calendar).
     * @type {Date}
     */
    this.displayDate = null;

    /**
     * The selected date. Keep track of this separately from the ng-model value so that we
     * can know, when the ng-model value changes, what the previous value was before it's updated
     * in the component's UI.
     *
     * @type {Date}
     */
    this.selectedDate = null;

    /**
     * The first date that can be rendered by the calendar. The default is taken
     * from the mdDateLocale provider and is limited by the mdMinDate.
     * @type {Date}
     */
    this.firstRenderableDate = null;

    /**
     * The last date that can be rendered by the calendar. The default comes
     * from the mdDateLocale provider and is limited by the maxDate.
     * @type {Date}
     */
    this.lastRenderableDate = null;

    /**
     * Used to toggle initialize the root element in the next digest.
     * @type {Boolean}
     */
    this.isInitialized = false;

    /**
     * Cache for the  width of the element without a scrollbar. Used to hide the scrollbar later on
     * and to avoid extra reflows when switching between views.
     * @type {Number}
     */
    this.width = 0;

    /**
     * Caches the width of the scrollbar in order to be used when hiding it and to avoid extra reflows.
     * @type {Number}
     */
    this.scrollbarWidth = 0;

    // Unless the user specifies so, the calendar should not be a tab stop.
    // This is necessary because ngAria might add a tabindex to anything with an ng-model
    // (based on whether or not the user has turned that particular feature on/off).
    if (!$attrs.tabindex) {
      $element.attr('tabindex', '-1');
    }

    var boundKeyHandler = angular.bind(this, this.handleKeyEvent);

    // If use the md-calendar directly in the body without datepicker,
    // handleKeyEvent will disable other inputs on the page.
    // So only apply the handleKeyEvent on the body when the md-calendar inside datepicker,
    // otherwise apply on the calendar element only.

    var handleKeyElement;
    if ($element.parent().hasClass('md-datepicker-calendar')) {
      handleKeyElement = angular.element(document.body);
    } else {
      handleKeyElement = $element;
    }

    // Bind the keydown handler to the body, in order to handle cases where the focused
    // element gets removed from the DOM and stops propagating click events.
    handleKeyElement.on('keydown', boundKeyHandler);

    $scope.$on('$destroy', function() {
      handleKeyElement.off('keydown', boundKeyHandler);
    });

    // For AngularJS 1.4 and older, where there are no lifecycle hooks but bindings are pre-assigned,
    // manually call the $onInit hook.
    if (angular.version.major === 1 && angular.version.minor <= 4) {
      this.$onInit();
    }

  }

  /**
   * AngularJS Lifecycle hook for newer AngularJS versions.
   * Bindings are not guaranteed to have been assigned in the controller, but they are in the $onInit hook.
   */
  CalendarCtrl.prototype.$onInit = function() {
    /**
     * The currently visible calendar view. Note the prefix on the scope value,
     * which is necessary, because the datepicker seems to reset the real one value if the
     * calendar is open, but the `currentView` on the datepicker's scope is empty.
     * @type {String}
     */
    if (this._mode && MODE_MAP.hasOwnProperty(this._mode)) {
      this.currentView = MODE_MAP[this._mode];
      this.mode = this._mode;
    } else {
      this.currentView = this._currentView || 'month';
      this.mode = null;
    }

    var dateLocale = this.$mdDateLocale;

    if (this.minDate && this.minDate > dateLocale.firstRenderableDate) {
      this.firstRenderableDate = this.minDate;
    } else {
      this.firstRenderableDate = dateLocale.firstRenderableDate;
    }

    if (this.maxDate && this.maxDate < dateLocale.lastRenderableDate) {
      this.lastRenderableDate = this.maxDate;
    } else {
      this.lastRenderableDate = dateLocale.lastRenderableDate;
    }
  };

  /**
   * Sets up the controller's reference to ngModelController.
   * @param {!angular.NgModelController} ngModelCtrl
   */
  CalendarCtrl.prototype.configureNgModel = function(ngModelCtrl) {
    var self = this;

    self.ngModelCtrl = ngModelCtrl;

    self.$mdUtil.nextTick(function() {
      self.isInitialized = true;
    });

    ngModelCtrl.$render = function() {
      var value = this.$viewValue;

      // Notify the child scopes of any changes.
      self.$scope.$broadcast('md-calendar-parent-changed', value);

      // Set up the selectedDate if it hasn't been already.
      if (!self.selectedDate) {
        self.selectedDate = value;
      }

      // Also set up the displayDate.
      if (!self.displayDate) {
        self.displayDate = self.selectedDate || self.today;
      }
    };
  };

  /**
   * Sets the ng-model value for the calendar and emits a change event.
   * @param {Date} date
   */
  CalendarCtrl.prototype.setNgModelValue = function(date) {
    var value = this.dateUtil.createDateAtMidnight(date);
    this.focus(value);
    this.$scope.$emit('md-calendar-change', value);
    this.ngModelCtrl.$setViewValue(value);
    this.ngModelCtrl.$render();
    return value;
  };

  /**
   * Sets the current view that should be visible in the calendar
   * @param {string} newView View name to be set.
   * @param {number|Date} time Date object or a timestamp for the new display date.
   */
  CalendarCtrl.prototype.setCurrentView = function(newView, time) {
    var self = this;

    self.$mdUtil.nextTick(function() {
      self.currentView = newView;

      if (time) {
        self.displayDate = angular.isDate(time) ? time : new Date(time);
      }
    });
  };

  /**
   * Focus the cell corresponding to the given date.
   * @param {Date} date The date to be focused.
   */
  CalendarCtrl.prototype.focus = function(date) {
    if (this.dateUtil.isValidDate(date)) {
      var previousFocus = this.$element[0].querySelector('.' + this.FOCUSED_DATE_CLASS);
      if (previousFocus) {
        previousFocus.classList.remove(this.FOCUSED_DATE_CLASS);
      }

      var cellId = this.getDateId(date, this.currentView);
      var cell = document.getElementById(cellId);
      if (cell) {
        cell.classList.add(this.FOCUSED_DATE_CLASS);
        cell.focus();
        this.displayDate = date;
      }
    } else {
      var rootElement = this.$element[0].querySelector('[ng-switch]');

      if (rootElement) {
        rootElement.focus();
      }
    }
  };

  /**
   * Highlights a date cell on the calendar and changes the selected date.
   * @param {Date=} date Date to be marked as selected.
   */
  CalendarCtrl.prototype.changeSelectedDate = function(date) {
    var selectedDateClass = this.SELECTED_DATE_CLASS;
    var prevDateCell = this.$element[0].querySelector('.' + selectedDateClass);

    // Remove the selected class from the previously selected date, if any.
    if (prevDateCell) {
      prevDateCell.classList.remove(selectedDateClass);
      prevDateCell.setAttribute('aria-selected', 'false');
    }

    // Apply the select class to the new selected date if it is set.
    if (date) {
      var dateCell = document.getElementById(this.getDateId(date, this.currentView));
      if (dateCell) {
        dateCell.classList.add(selectedDateClass);
        dateCell.setAttribute('aria-selected', 'true');
      }
    }

    this.selectedDate = date;
  };

  /**
   * Normalizes the key event into an action name. The action will be broadcast
   * to the child controllers.
   * @param {KeyboardEvent} event
   * @returns {String} The action that should be taken, or null if the key
   * does not match a calendar shortcut.
   */
  CalendarCtrl.prototype.getActionFromKeyEvent = function(event) {
    var keyCode = this.keyCode;

    switch (event.which) {
      case keyCode.ENTER: return 'select';

      case keyCode.RIGHT_ARROW: return 'move-right';
      case keyCode.LEFT_ARROW: return 'move-left';

      case keyCode.DOWN_ARROW: return event.metaKey ? 'move-page-down' : 'move-row-down';
      case keyCode.UP_ARROW: return event.metaKey ? 'move-page-up' : 'move-row-up';

      case keyCode.PAGE_DOWN: return 'move-page-down';
      case keyCode.PAGE_UP: return 'move-page-up';

      case keyCode.HOME: return 'start';
      case keyCode.END: return 'end';

      default: return null;
    }
  };

  /**
   * Handles a key event in the calendar with the appropriate action. The action will either
   * be to select the focused date or to navigate to focus a new date.
   * @param {KeyboardEvent} event
   */
  CalendarCtrl.prototype.handleKeyEvent = function(event) {
    var self = this;

    this.$scope.$apply(function() {
      // Capture escape and emit back up so that a wrapping component
      // (such as a date-picker) can decide to close.
      if (event.which == self.keyCode.ESCAPE || event.which == self.keyCode.TAB) {
        self.$scope.$emit('md-calendar-close');

        if (event.which == self.keyCode.TAB) {
          event.preventDefault();
        }

        return;
      }

      // Broadcast the action that any child controllers should take.
      var action = self.getActionFromKeyEvent(event);
      if (action) {
        event.preventDefault();
        event.stopPropagation();
        self.$scope.$broadcast('md-calendar-parent-action', action);
      }
    });
  };

  /**
   * Hides the vertical scrollbar on the calendar scroller of a child controller by
   * setting the width on the calendar scroller and the `overflow: hidden` wrapper
   * around the scroller, and then setting a padding-right on the scroller equal
   * to the width of the browser's scrollbar.
   *
   * This will cause a reflow.
   *
   * @param {object} childCtrl The child controller whose scrollbar should be hidden.
   */
  CalendarCtrl.prototype.hideVerticalScrollbar = function(childCtrl) {
    var self = this;
    var element = childCtrl.$element[0];
    var scrollMask = element.querySelector('.md-calendar-scroll-mask');

    if (self.width > 0) {
      setWidth();
    } else {
      self.$$rAF(function() {
        var scroller = childCtrl.calendarScroller;

        self.scrollbarWidth = scroller.offsetWidth - scroller.clientWidth;
        self.width = element.querySelector('table').offsetWidth;
        setWidth();
      });
    }

    function setWidth() {
      var width = self.width || FALLBACK_WIDTH;
      var scrollbarWidth = self.scrollbarWidth;
      var scroller = childCtrl.calendarScroller;

      scrollMask.style.width = width + 'px';
      scroller.style.width = (width + scrollbarWidth) + 'px';
      scroller.style.paddingRight = scrollbarWidth + 'px';
    }
  };

  /**
   * Gets an identifier for a date unique to the calendar instance for internal
   * purposes. Not to be displayed.
   * @param {Date} date The date for which the id is being generated
   * @param {string} namespace Namespace for the id. (month, year etc.)
   * @returns {string}
   */
  CalendarCtrl.prototype.getDateId = function(date, namespace) {
    if (!namespace) {
      throw new Error('A namespace for the date id has to be specified.');
    }

    return [
      'md',
      this.id,
      namespace,
      date.getFullYear(),
      date.getMonth(),
      date.getDate()
    ].join('-');
  };

  /**
   * Util to trigger an extra digest on a parent scope, in order to to ensure that
   * any child virtual repeaters have updated. This is necessary, because the virtual
   * repeater doesn't update the $index the first time around since the content isn't
   * in place yet. The case, in which this is an issue, is when the repeater has less
   * than a page of content (e.g. a month or year view has a min or max date).
   */
  CalendarCtrl.prototype.updateVirtualRepeat = function() {
    var scope = this.$scope;
    var virtualRepeatResizeListener = scope.$on('$md-resize-enable', function() {
      if (!scope.$$phase) {
        scope.$apply();
      }

      virtualRepeatResizeListener();
    });
  };
})();

})();
(function(){
"use strict";

(function() {
  'use strict';

  CalendarMonthCtrl.$inject = ["$element", "$scope", "$animate", "$q", "$$mdDateUtil", "$mdDateLocale"];
  angular.module('material.components.datepicker')
    .directive('mdCalendarMonth', calendarDirective);

  /**
   * Height of one calendar month tbody. This must be made known to the virtual-repeat and is
   * subsequently used for scrolling to specific months.
   */
  var TBODY_HEIGHT = 265;

  /**
   * Height of a calendar month with a single row. This is needed to calculate the offset for
   * rendering an extra month in virtual-repeat that only contains one row.
   */
  var TBODY_SINGLE_ROW_HEIGHT = 45;

  /** Private directive that represents a list of months inside the calendar. */
  function calendarDirective() {
    return {
      template:
        '<table aria-hidden="true" class="md-calendar-day-header"><thead></thead></table>' +
        '<div class="md-calendar-scroll-mask">' +
        '<md-virtual-repeat-container class="md-calendar-scroll-container" ' +
              'md-offset-size="' + (TBODY_SINGLE_ROW_HEIGHT - TBODY_HEIGHT) + '">' +
            '<table role="grid" tabindex="0" class="md-calendar" aria-readonly="true">' +
              '<tbody ' +
                  'md-calendar-month-body ' +
                  'role="rowgroup" ' +
                  'md-virtual-repeat="i in monthCtrl.items" ' +
                  'md-month-offset="$index" ' +
                  'class="md-calendar-month" ' +
                  'md-start-index="monthCtrl.getSelectedMonthIndex()" ' +
                  'md-item-size="' + TBODY_HEIGHT + '">' +

                // The <tr> ensures that the <tbody> will always have the
                // proper height, even if it's empty. If it's content is
                // compiled, the <tr> will be overwritten.
                '<tr aria-hidden="true" md-force-height="\'' + TBODY_HEIGHT + 'px\'"></tr>' +
              '</tbody>' +
            '</table>' +
          '</md-virtual-repeat-container>' +
        '</div>',
      require: ['^^mdCalendar', 'mdCalendarMonth'],
      controller: CalendarMonthCtrl,
      controllerAs: 'monthCtrl',
      bindToController: true,
      link: function(scope, element, attrs, controllers) {
        var calendarCtrl = controllers[0];
        var monthCtrl = controllers[1];
        monthCtrl.initialize(calendarCtrl);
      }
    };
  }

  /**
   * Controller for the calendar month component.
   * @ngInject @constructor
   */
  function CalendarMonthCtrl($element, $scope, $animate, $q,
    $$mdDateUtil, $mdDateLocale) {

    /** @final {!angular.JQLite} */
    this.$element = $element;

    /** @final {!angular.Scope} */
    this.$scope = $scope;

    /** @final {!angular.$animate} */
    this.$animate = $animate;

    /** @final {!angular.$q} */
    this.$q = $q;

    /** @final */
    this.dateUtil = $$mdDateUtil;

    /** @final */
    this.dateLocale = $mdDateLocale;

    /** @final {HTMLElement} */
    this.calendarScroller = $element[0].querySelector('.md-virtual-repeat-scroller');

    /** @type {boolean} */
    this.isInitialized = false;

    /** @type {boolean} */
    this.isMonthTransitionInProgress = false;

    var self = this;

    /**
     * Handles a click event on a date cell.
     * Created here so that every cell can use the same function instance.
     * @this {HTMLTableCellElement} The cell that was clicked.
     */
    this.cellClickHandler = function() {
      var timestamp = $$mdDateUtil.getTimestampFromNode(this);
      self.$scope.$apply(function() {
        self.calendarCtrl.setNgModelValue(timestamp);
      });
    };

    /**
     * Handles click events on the month headers. Switches
     * the calendar to the year view.
     * @this {HTMLTableCellElement} The cell that was clicked.
     */
    this.headerClickHandler = function() {
      self.calendarCtrl.setCurrentView('year', $$mdDateUtil.getTimestampFromNode(this));
    };
  }

  /** Initialization **/

  /**
   * Initialize the controller by saving a reference to the calendar and
   * setting up the object that will be iterated by the virtual repeater.
   */
  CalendarMonthCtrl.prototype.initialize = function(calendarCtrl) {
    /**
     * Dummy array-like object for virtual-repeat to iterate over. The length is the total
     * number of months that can be viewed. We add 2 months: one to include the current month
     * and one for the last dummy month.
     *
     * This is shorter than ideal because of a (potential) Firefox bug
     * https://bugzilla.mozilla.org/show_bug.cgi?id=1181658.
     */

    this.items = {
      length: this.dateUtil.getMonthDistance(
        calendarCtrl.firstRenderableDate,
        calendarCtrl.lastRenderableDate
      ) + 2
    };

    this.calendarCtrl = calendarCtrl;
    this.attachScopeListeners();
    calendarCtrl.updateVirtualRepeat();

    // Fire the initial render, since we might have missed it the first time it fired.
    calendarCtrl.ngModelCtrl && calendarCtrl.ngModelCtrl.$render();
  };

  /**
   * Gets the "index" of the currently selected date as it would be in the virtual-repeat.
   * @returns {number}
   */
  CalendarMonthCtrl.prototype.getSelectedMonthIndex = function() {
    var calendarCtrl = this.calendarCtrl;

    return this.dateUtil.getMonthDistance(
      calendarCtrl.firstRenderableDate,
      calendarCtrl.displayDate || calendarCtrl.selectedDate || calendarCtrl.today
    );
  };

  /**
   * Change the date that is being shown in the calendar. If the given date is in a different
   * month, the displayed month will be transitioned.
   * @param {Date} date
   */
  CalendarMonthCtrl.prototype.changeDisplayDate = function(date) {
    // Initialization is deferred until this function is called because we want to reflect
    // the starting value of ngModel.
    if (!this.isInitialized) {
      this.buildWeekHeader();
      this.calendarCtrl.hideVerticalScrollbar(this);
      this.isInitialized = true;
      return this.$q.when();
    }

    // If trying to show an invalid date or a transition is in progress, do nothing.
    if (!this.dateUtil.isValidDate(date) || this.isMonthTransitionInProgress) {
      return this.$q.when();
    }

    this.isMonthTransitionInProgress = true;
    var animationPromise = this.animateDateChange(date);

    this.calendarCtrl.displayDate = date;

    var self = this;
    animationPromise.then(function() {
      self.isMonthTransitionInProgress = false;
    });

    return animationPromise;
  };

  /**
   * Animates the transition from the calendar's current month to the given month.
   * @param {Date} date
   * @returns {angular.$q.Promise} The animation promise.
   */
  CalendarMonthCtrl.prototype.animateDateChange = function(date) {
    if (this.dateUtil.isValidDate(date)) {
      var monthDistance = this.dateUtil.getMonthDistance(this.calendarCtrl.firstRenderableDate, date);
      this.calendarScroller.scrollTop = monthDistance * TBODY_HEIGHT;
    }

    return this.$q.when();
  };

  /**
   * Builds and appends a day-of-the-week header to the calendar.
   * This should only need to be called once during initialization.
   */
  CalendarMonthCtrl.prototype.buildWeekHeader = function() {
    var firstDayOfWeek = this.dateLocale.firstDayOfWeek;
    var shortDays = this.dateLocale.shortDays;

    var row = document.createElement('tr');
    for (var i = 0; i < 7; i++) {
      var th = document.createElement('th');
      th.textContent = shortDays[(i + firstDayOfWeek) % 7];
      row.appendChild(th);
    }

    this.$element.find('thead').append(row);
  };

  /**
   * Attaches listeners for the scope events that are broadcast by the calendar.
   */
  CalendarMonthCtrl.prototype.attachScopeListeners = function() {
    var self = this;

    self.$scope.$on('md-calendar-parent-changed', function(event, value) {
      self.calendarCtrl.changeSelectedDate(value);
      self.changeDisplayDate(value);
    });

    self.$scope.$on('md-calendar-parent-action', angular.bind(this, this.handleKeyEvent));
  };

  /**
   * Handles the month-specific keyboard interactions.
   * @param {Object} event Scope event object passed by the calendar.
   * @param {String} action Action, corresponding to the key that was pressed.
   */
  CalendarMonthCtrl.prototype.handleKeyEvent = function(event, action) {
    var calendarCtrl = this.calendarCtrl;
    var displayDate = calendarCtrl.displayDate;

    if (action === 'select') {
      calendarCtrl.setNgModelValue(displayDate);
    } else {
      var date = null;
      var dateUtil = this.dateUtil;

      switch (action) {
        case 'move-right': date = dateUtil.incrementDays(displayDate, 1); break;
        case 'move-left': date = dateUtil.incrementDays(displayDate, -1); break;

        case 'move-page-down': date = dateUtil.incrementMonths(displayDate, 1); break;
        case 'move-page-up': date = dateUtil.incrementMonths(displayDate, -1); break;

        case 'move-row-down': date = dateUtil.incrementDays(displayDate, 7); break;
        case 'move-row-up': date = dateUtil.incrementDays(displayDate, -7); break;

        case 'start': date = dateUtil.getFirstDateOfMonth(displayDate); break;
        case 'end': date = dateUtil.getLastDateOfMonth(displayDate); break;
      }

      if (date) {
        date = this.dateUtil.clampDate(date, calendarCtrl.minDate, calendarCtrl.maxDate);

        this.changeDisplayDate(date).then(function() {
          calendarCtrl.focus(date);
        });
      }
    }
  };
})();

})();
(function(){
"use strict";

(function() {
  'use strict';

  mdCalendarMonthBodyDirective.$inject = ["$compile", "$$mdSvgRegistry"];
  CalendarMonthBodyCtrl.$inject = ["$element", "$$mdDateUtil", "$mdDateLocale"];
  angular.module('material.components.datepicker')
      .directive('mdCalendarMonthBody', mdCalendarMonthBodyDirective);

  /**
   * Private directive consumed by md-calendar-month. Having this directive lets the calender use
   * md-virtual-repeat and also cleanly separates the month DOM construction functions from
   * the rest of the calendar controller logic.
   * @ngInject
   */
  function mdCalendarMonthBodyDirective($compile, $$mdSvgRegistry) {
    var ARROW_ICON = $compile('<md-icon md-svg-src="' +
      $$mdSvgRegistry.mdTabsArrow + '"></md-icon>')({})[0];

    return {
      require: ['^^mdCalendar', '^^mdCalendarMonth', 'mdCalendarMonthBody'],
      scope: { offset: '=mdMonthOffset' },
      controller: CalendarMonthBodyCtrl,
      controllerAs: 'mdMonthBodyCtrl',
      bindToController: true,
      link: function(scope, element, attrs, controllers) {
        var calendarCtrl = controllers[0];
        var monthCtrl = controllers[1];
        var monthBodyCtrl = controllers[2];

        monthBodyCtrl.calendarCtrl = calendarCtrl;
        monthBodyCtrl.monthCtrl = monthCtrl;
        monthBodyCtrl.arrowIcon = ARROW_ICON.cloneNode(true);

        // The virtual-repeat re-uses the same DOM elements, so there are only a limited number
        // of repeated items that are linked, and then those elements have their bindings updated.
        // Since the months are not generated by bindings, we simply regenerate the entire thing
        // when the binding (offset) changes.
        scope.$watch(function() { return monthBodyCtrl.offset; }, function(offset) {
          if (angular.isNumber(offset)) {
            monthBodyCtrl.generateContent();
          }
        });
      }
    };
  }

  /**
   * Controller for a single calendar month.
   * @ngInject @constructor
   */
  function CalendarMonthBodyCtrl($element, $$mdDateUtil, $mdDateLocale) {
    /** @final {!angular.JQLite} */
    this.$element = $element;

    /** @final */
    this.dateUtil = $$mdDateUtil;

    /** @final */
    this.dateLocale = $mdDateLocale;

    /** @type {Object} Reference to the month view. */
    this.monthCtrl = null;

    /** @type {Object} Reference to the calendar. */
    this.calendarCtrl = null;

    /**
     * Number of months from the start of the month "items" that the currently rendered month
     * occurs. Set via angular data binding.
     * @type {number}
     */
    this.offset = null;

    /**
     * Date cell to focus after appending the month to the document.
     * @type {HTMLElement}
     */
    this.focusAfterAppend = null;
  }

  /** Generate and append the content for this month to the directive element. */
  CalendarMonthBodyCtrl.prototype.generateContent = function() {
    var date = this.dateUtil.incrementMonths(this.calendarCtrl.firstRenderableDate, this.offset);

    this.$element
      .empty()
      .append(this.buildCalendarForMonth(date));

    if (this.focusAfterAppend) {
      this.focusAfterAppend.classList.add(this.calendarCtrl.FOCUSED_DATE_CLASS);
      this.focusAfterAppend.focus();
      this.focusAfterAppend = null;
    }
  };

  /**
   * Creates a single cell to contain a date in the calendar with all appropriate
   * attributes and classes added. If a date is given, the cell content will be set
   * based on the date.
   * @param {Date=} opt_date
   * @returns {HTMLElement}
   */
  CalendarMonthBodyCtrl.prototype.buildDateCell = function(opt_date) {
    var monthCtrl = this.monthCtrl;
    var calendarCtrl = this.calendarCtrl;

    // TODO(jelbourn): cloneNode is likely a faster way of doing this.
    var cell = document.createElement('td');
    cell.tabIndex = -1;
    cell.classList.add('md-calendar-date');
    cell.setAttribute('role', 'gridcell');

    if (opt_date) {
      cell.setAttribute('tabindex', '-1');
      cell.setAttribute('aria-label', this.dateLocale.longDateFormatter(opt_date));
      cell.id = calendarCtrl.getDateId(opt_date, 'month');

      // Use `data-timestamp` attribute because IE10 does not support the `dataset` property.
      cell.setAttribute('data-timestamp', opt_date.getTime());

      // TODO(jelourn): Doing these comparisons for class addition during generation might be slow.
      // It may be better to finish the construction and then query the node and add the class.
      if (this.dateUtil.isSameDay(opt_date, calendarCtrl.today)) {
        cell.classList.add(calendarCtrl.TODAY_CLASS);
      }

      if (this.dateUtil.isValidDate(calendarCtrl.selectedDate) &&
          this.dateUtil.isSameDay(opt_date, calendarCtrl.selectedDate)) {
        cell.classList.add(calendarCtrl.SELECTED_DATE_CLASS);
        cell.setAttribute('aria-selected', 'true');
      }

      var cellText = this.dateLocale.dates[opt_date.getDate()];

      if (this.isDateEnabled(opt_date)) {
        // Add a indicator for select, hover, and focus states.
        var selectionIndicator = document.createElement('span');
        selectionIndicator.classList.add('md-calendar-date-selection-indicator');
        selectionIndicator.textContent = cellText;
        cell.appendChild(selectionIndicator);
        cell.addEventListener('click', monthCtrl.cellClickHandler);

        if (calendarCtrl.displayDate && this.dateUtil.isSameDay(opt_date, calendarCtrl.displayDate)) {
          this.focusAfterAppend = cell;
        }
      } else {
        cell.classList.add('md-calendar-date-disabled');
        cell.textContent = cellText;
      }
    }

    return cell;
  };

  /**
   * Check whether date is in range and enabled
   * @param {Date=} opt_date
   * @return {boolean} Whether the date is enabled.
   */
  CalendarMonthBodyCtrl.prototype.isDateEnabled = function(opt_date) {
    return this.dateUtil.isDateWithinRange(opt_date,
          this.calendarCtrl.minDate, this.calendarCtrl.maxDate) &&
          (!angular.isFunction(this.calendarCtrl.dateFilter)
           || this.calendarCtrl.dateFilter(opt_date));
  };

  /**
   * Builds a `tr` element for the calendar grid.
   * @param rowNumber The week number within the month.
   * @returns {HTMLElement}
   */
  CalendarMonthBodyCtrl.prototype.buildDateRow = function(rowNumber) {
    var row = document.createElement('tr');
    row.setAttribute('role', 'row');

    // Because of an NVDA bug (with Firefox), the row needs an aria-label in order
    // to prevent the entire row being read aloud when the user moves between rows.
    // See http://community.nvda-project.org/ticket/4643.
    row.setAttribute('aria-label', this.dateLocale.weekNumberFormatter(rowNumber));

    return row;
  };

  /**
   * Builds the <tbody> content for the given date's month.
   * @param {Date=} opt_dateInMonth
   * @returns {DocumentFragment} A document fragment containing the <tr> elements.
   */
  CalendarMonthBodyCtrl.prototype.buildCalendarForMonth = function(opt_dateInMonth) {
    var date = this.dateUtil.isValidDate(opt_dateInMonth) ? opt_dateInMonth : new Date();

    var firstDayOfMonth = this.dateUtil.getFirstDateOfMonth(date);
    var firstDayOfTheWeek = this.getLocaleDay_(firstDayOfMonth);
    var numberOfDaysInMonth = this.dateUtil.getNumberOfDaysInMonth(date);

    // Store rows for the month in a document fragment so that we can append them all at once.
    var monthBody = document.createDocumentFragment();

    var rowNumber = 1;
    var row = this.buildDateRow(rowNumber);
    monthBody.appendChild(row);

    // If this is the final month in the list of items, only the first week should render,
    // so we should return immediately after the first row is complete and has been
    // attached to the body.
    var isFinalMonth = this.offset === this.monthCtrl.items.length - 1;

    // Add a label for the month. If the month starts on a Sun/Mon/Tues, the month label
    // goes on a row above the first of the month. Otherwise, the month label takes up the first
    // two cells of the first row.
    var blankCellOffset = 0;
    var monthLabelCell = document.createElement('td');
    var monthLabelCellContent = document.createElement('span');
    var calendarCtrl = this.calendarCtrl;

    monthLabelCellContent.textContent = this.dateLocale.monthHeaderFormatter(date);
    monthLabelCell.appendChild(monthLabelCellContent);
    monthLabelCell.classList.add('md-calendar-month-label');
    // If the entire month is after the max date, render the label as a disabled state.
    if (calendarCtrl.maxDate && firstDayOfMonth > calendarCtrl.maxDate) {
      monthLabelCell.classList.add('md-calendar-month-label-disabled');
    // If the user isn't supposed to be able to change views, render the
    // label as usual, but disable the clicking functionality.
    } else if (!calendarCtrl.mode) {
      monthLabelCell.addEventListener('click', this.monthCtrl.headerClickHandler);
      monthLabelCell.setAttribute('data-timestamp', firstDayOfMonth.getTime());
      monthLabelCell.setAttribute('aria-label', this.dateLocale.monthFormatter(date));
      monthLabelCell.classList.add('md-calendar-label-clickable');
      monthLabelCell.appendChild(this.arrowIcon.cloneNode(true));
    }

    if (firstDayOfTheWeek <= 2) {
      monthLabelCell.setAttribute('colspan', '7');

      var monthLabelRow = this.buildDateRow();
      monthLabelRow.appendChild(monthLabelCell);
      monthBody.insertBefore(monthLabelRow, row);

      if (isFinalMonth) {
        return monthBody;
      }
    } else {
      blankCellOffset = 3;
      monthLabelCell.setAttribute('colspan', '3');
      row.appendChild(monthLabelCell);
    }

    // Add a blank cell for each day of the week that occurs before the first of the month.
    // For example, if the first day of the month is a Tuesday, add blank cells for Sun and Mon.
    // The blankCellOffset is needed in cases where the first N cells are used by the month label.
    for (var i = blankCellOffset; i < firstDayOfTheWeek; i++) {
      row.appendChild(this.buildDateCell());
    }

    // Add a cell for each day of the month, keeping track of the day of the week so that
    // we know when to start a new row.
    var dayOfWeek = firstDayOfTheWeek;
    var iterationDate = firstDayOfMonth;
    for (var d = 1; d <= numberOfDaysInMonth; d++) {
      // If we've reached the end of the week, start a new row.
      if (dayOfWeek === 7) {
        // We've finished the first row, so we're done if this is the final month.
        if (isFinalMonth) {
          return monthBody;
        }
        dayOfWeek = 0;
        rowNumber++;
        row = this.buildDateRow(rowNumber);
        monthBody.appendChild(row);
      }

      iterationDate.setDate(d);
      var cell = this.buildDateCell(iterationDate);
      row.appendChild(cell);

      dayOfWeek++;
    }

    // Ensure that the last row of the month has 7 cells.
    while (row.childNodes.length < 7) {
      row.appendChild(this.buildDateCell());
    }

    // Ensure that all months have 6 rows. This is necessary for now because the virtual-repeat
    // requires that all items have exactly the same height.
    while (monthBody.childNodes.length < 6) {
      var whitespaceRow = this.buildDateRow();
      for (var j = 0; j < 7; j++) {
        whitespaceRow.appendChild(this.buildDateCell());
      }
      monthBody.appendChild(whitespaceRow);
    }

    return monthBody;
  };

  /**
   * Gets the day-of-the-week index for a date for the current locale.
   * @private
   * @param {Date} date
   * @returns {number} The column index of the date in the calendar.
   */
  CalendarMonthBodyCtrl.prototype.getLocaleDay_ = function(date) {
    return (date.getDay() + (7 - this.dateLocale.firstDayOfWeek)) % 7;
  };
})();

})();
(function(){
"use strict";

(function() {
  'use strict';

  CalendarYearCtrl.$inject = ["$element", "$scope", "$animate", "$q", "$$mdDateUtil", "$mdUtil"];
  angular.module('material.components.datepicker')
    .directive('mdCalendarYear', calendarDirective);

  /**
   * Height of one calendar year tbody. This must be made known to the virtual-repeat and is
   * subsequently used for scrolling to specific years.
   */
  var TBODY_HEIGHT = 88;

  /** Private component, representing a list of years in the calendar. */
  function calendarDirective() {
    return {
      template:
        '<div class="md-calendar-scroll-mask">' +
          '<md-virtual-repeat-container class="md-calendar-scroll-container">' +
            '<table role="grid" tabindex="0" class="md-calendar" aria-readonly="true">' +
              '<tbody ' +
                  'md-calendar-year-body ' +
                  'role="rowgroup" ' +
                  'md-virtual-repeat="i in yearCtrl.items" ' +
                  'md-year-offset="$index" class="md-calendar-year" ' +
                  'md-start-index="yearCtrl.getFocusedYearIndex()" ' +
                  'md-item-size="' + TBODY_HEIGHT + '">' +
                // The <tr> ensures that the <tbody> will have the proper
                // height, even though it may be empty.
                '<tr aria-hidden="true" md-force-height="\'' + TBODY_HEIGHT + 'px\'"></tr>' +
              '</tbody>' +
            '</table>' +
          '</md-virtual-repeat-container>' +
        '</div>',
      require: ['^^mdCalendar', 'mdCalendarYear'],
      controller: CalendarYearCtrl,
      controllerAs: 'yearCtrl',
      bindToController: true,
      link: function(scope, element, attrs, controllers) {
        var calendarCtrl = controllers[0];
        var yearCtrl = controllers[1];
        yearCtrl.initialize(calendarCtrl);
      }
    };
  }

  /**
   * Controller for the mdCalendar component.
   * @ngInject @constructor
   */
  function CalendarYearCtrl($element, $scope, $animate, $q,
    $$mdDateUtil, $mdUtil) {

    /** @final {!angular.JQLite} */
    this.$element = $element;

    /** @final {!angular.Scope} */
    this.$scope = $scope;

    /** @final {!angular.$animate} */
    this.$animate = $animate;

    /** @final {!angular.$q} */
    this.$q = $q;

    /** @final */
    this.dateUtil = $$mdDateUtil;

    /** @final {HTMLElement} */
    this.calendarScroller = $element[0].querySelector('.md-virtual-repeat-scroller');

    /** @type {boolean} */
    this.isInitialized = false;

    /** @type {boolean} */
    this.isMonthTransitionInProgress = false;

    /** @final */
    this.$mdUtil = $mdUtil;

    var self = this;

    /**
     * Handles a click event on a date cell.
     * Created here so that every cell can use the same function instance.
     * @this {HTMLTableCellElement} The cell that was clicked.
     */
    this.cellClickHandler = function() {
      self.onTimestampSelected($$mdDateUtil.getTimestampFromNode(this));
    };
  }

  /**
   * Initialize the controller by saving a reference to the calendar and
   * setting up the object that will be iterated by the virtual repeater.
   */
  CalendarYearCtrl.prototype.initialize = function(calendarCtrl) {
    /**
     * Dummy array-like object for virtual-repeat to iterate over. The length is the total
     * number of years that can be viewed. We add 1 extra in order to include the current year.
     */

    this.items = {
      length: this.dateUtil.getYearDistance(
        calendarCtrl.firstRenderableDate,
        calendarCtrl.lastRenderableDate
      ) + 1
    };

    this.calendarCtrl = calendarCtrl;
    this.attachScopeListeners();
    calendarCtrl.updateVirtualRepeat();

    // Fire the initial render, since we might have missed it the first time it fired.
    calendarCtrl.ngModelCtrl && calendarCtrl.ngModelCtrl.$render();
  };

  /**
   * Gets the "index" of the currently selected date as it would be in the virtual-repeat.
   * @returns {number}
   */
  CalendarYearCtrl.prototype.getFocusedYearIndex = function() {
    var calendarCtrl = this.calendarCtrl;

    return this.dateUtil.getYearDistance(
      calendarCtrl.firstRenderableDate,
      calendarCtrl.displayDate || calendarCtrl.selectedDate || calendarCtrl.today
    );
  };

  /**
   * Change the date that is highlighted in the calendar.
   * @param {Date} date
   */
  CalendarYearCtrl.prototype.changeDate = function(date) {
    // Initialization is deferred until this function is called because we want to reflect
    // the starting value of ngModel.
    if (!this.isInitialized) {
      this.calendarCtrl.hideVerticalScrollbar(this);
      this.isInitialized = true;
      return this.$q.when();
    } else if (this.dateUtil.isValidDate(date) && !this.isMonthTransitionInProgress) {
      var self = this;
      var animationPromise = this.animateDateChange(date);

      self.isMonthTransitionInProgress = true;
      self.calendarCtrl.displayDate = date;

      return animationPromise.then(function() {
        self.isMonthTransitionInProgress = false;
      });
    }
  };

  /**
   * Animates the transition from the calendar's current month to the given month.
   * @param {Date} date
   * @returns {angular.$q.Promise} The animation promise.
   */
  CalendarYearCtrl.prototype.animateDateChange = function(date) {
    if (this.dateUtil.isValidDate(date)) {
      var monthDistance = this.dateUtil.getYearDistance(this.calendarCtrl.firstRenderableDate, date);
      this.calendarScroller.scrollTop = monthDistance * TBODY_HEIGHT;
    }

    return this.$q.when();
  };

  /**
   * Handles the year-view-specific keyboard interactions.
   * @param {Object} event Scope event object passed by the calendar.
   * @param {String} action Action, corresponding to the key that was pressed.
   */
  CalendarYearCtrl.prototype.handleKeyEvent = function(event, action) {
    var self = this;
    var calendarCtrl = self.calendarCtrl;
    var displayDate = calendarCtrl.displayDate;

    if (action === 'select') {
      self.changeDate(displayDate).then(function() {
        self.onTimestampSelected(displayDate);
      });
    } else {
      var date = null;
      var dateUtil = self.dateUtil;

      switch (action) {
        case 'move-right': date = dateUtil.incrementMonths(displayDate, 1); break;
        case 'move-left': date = dateUtil.incrementMonths(displayDate, -1); break;

        case 'move-row-down': date = dateUtil.incrementMonths(displayDate, 6); break;
        case 'move-row-up': date = dateUtil.incrementMonths(displayDate, -6); break;
      }

      if (date) {
        var min = calendarCtrl.minDate ? dateUtil.getFirstDateOfMonth(calendarCtrl.minDate) : null;
        var max = calendarCtrl.maxDate ? dateUtil.getFirstDateOfMonth(calendarCtrl.maxDate) : null;
        date = dateUtil.getFirstDateOfMonth(self.dateUtil.clampDate(date, min, max));

        self.changeDate(date).then(function() {
          calendarCtrl.focus(date);
        });
      }
    }
  };

  /**
   * Attaches listeners for the scope events that are broadcast by the calendar.
   */
  CalendarYearCtrl.prototype.attachScopeListeners = function() {
    var self = this;

    self.$scope.$on('md-calendar-parent-changed', function(event, value) {
      self.calendarCtrl.changeSelectedDate(value ? self.dateUtil.getFirstDateOfMonth(value) : value);
      self.changeDate(value);
    });

    self.$scope.$on('md-calendar-parent-action', angular.bind(self, self.handleKeyEvent));
  };

  /**
   * Handles the behavior when a date is selected. Depending on the `mode`
   * of the calendar, this can either switch back to the calendar view or
   * set the model value.
   * @param {number} timestamp The selected timestamp.
   */
  CalendarYearCtrl.prototype.onTimestampSelected = function(timestamp) {
    var calendarCtrl = this.calendarCtrl;

    if (calendarCtrl.mode) {
      this.$mdUtil.nextTick(function() {
        calendarCtrl.setNgModelValue(timestamp);
      });
    } else {
      calendarCtrl.setCurrentView('month', timestamp);
    }
  };
})();

})();
(function(){
"use strict";

(function() {
  'use strict';

  CalendarYearBodyCtrl.$inject = ["$element", "$$mdDateUtil", "$mdDateLocale"];
  angular.module('material.components.datepicker')
      .directive('mdCalendarYearBody', mdCalendarYearDirective);

  /**
   * Private component, consumed by the md-calendar-year, which separates the DOM construction logic
   * and allows for the year view to use md-virtual-repeat.
   */
  function mdCalendarYearDirective() {
    return {
      require: ['^^mdCalendar', '^^mdCalendarYear', 'mdCalendarYearBody'],
      scope: { offset: '=mdYearOffset' },
      controller: CalendarYearBodyCtrl,
      controllerAs: 'mdYearBodyCtrl',
      bindToController: true,
      link: function(scope, element, attrs, controllers) {
        var calendarCtrl = controllers[0];
        var yearCtrl = controllers[1];
        var yearBodyCtrl = controllers[2];

        yearBodyCtrl.calendarCtrl = calendarCtrl;
        yearBodyCtrl.yearCtrl = yearCtrl;

        scope.$watch(function() { return yearBodyCtrl.offset; }, function(offset) {
          if (angular.isNumber(offset)) {
            yearBodyCtrl.generateContent();
          }
        });
      }
    };
  }

  /**
   * Controller for a single year.
   * @ngInject @constructor
   */
  function CalendarYearBodyCtrl($element, $$mdDateUtil, $mdDateLocale) {
    /** @final {!angular.JQLite} */
    this.$element = $element;

    /** @final */
    this.dateUtil = $$mdDateUtil;

    /** @final */
    this.dateLocale = $mdDateLocale;

    /** @type {Object} Reference to the calendar. */
    this.calendarCtrl = null;

    /** @type {Object} Reference to the year view. */
    this.yearCtrl = null;

    /**
     * Number of months from the start of the month "items" that the currently rendered month
     * occurs. Set via angular data binding.
     * @type {number}
     */
    this.offset = null;

    /**
     * Date cell to focus after appending the month to the document.
     * @type {HTMLElement}
     */
    this.focusAfterAppend = null;
  }

  /** Generate and append the content for this year to the directive element. */
  CalendarYearBodyCtrl.prototype.generateContent = function() {
    var date = this.dateUtil.incrementYears(this.calendarCtrl.firstRenderableDate, this.offset);

    this.$element
      .empty()
      .append(this.buildCalendarForYear(date));

    if (this.focusAfterAppend) {
      this.focusAfterAppend.classList.add(this.calendarCtrl.FOCUSED_DATE_CLASS);
      this.focusAfterAppend.focus();
      this.focusAfterAppend = null;
    }
  };

  /**
   * Creates a single cell to contain a year in the calendar.
   * @param {number} year Four-digit year.
   * @param {number} month Zero-indexed month.
   * @returns {HTMLElement}
   */
  CalendarYearBodyCtrl.prototype.buildMonthCell = function(year, month) {
    var calendarCtrl = this.calendarCtrl;
    var yearCtrl = this.yearCtrl;
    var cell = this.buildBlankCell();

    // Represent this month/year as a date.
    var firstOfMonth = new Date(year, month, 1);
    cell.setAttribute('aria-label', this.dateLocale.monthFormatter(firstOfMonth));
    cell.id = calendarCtrl.getDateId(firstOfMonth, 'year');

    // Use `data-timestamp` attribute because IE10 does not support the `dataset` property.
    cell.setAttribute('data-timestamp', String(firstOfMonth.getTime()));

    if (this.dateUtil.isSameMonthAndYear(firstOfMonth, calendarCtrl.today)) {
      cell.classList.add(calendarCtrl.TODAY_CLASS);
    }

    if (this.dateUtil.isValidDate(calendarCtrl.selectedDate) &&
        this.dateUtil.isSameMonthAndYear(firstOfMonth, calendarCtrl.selectedDate)) {
      cell.classList.add(calendarCtrl.SELECTED_DATE_CLASS);
      cell.setAttribute('aria-selected', 'true');
    }

    var cellText = this.dateLocale.shortMonths[month];

    if (this.dateUtil.isMonthWithinRange(
          firstOfMonth, calendarCtrl.minDate, calendarCtrl.maxDate) &&
      (!angular.isFunction(this.calendarCtrl.dateFilter) ||
        this.calendarCtrl.dateFilter(firstOfMonth))) {
      var selectionIndicator = document.createElement('span');
      selectionIndicator.classList.add('md-calendar-date-selection-indicator');
      selectionIndicator.textContent = cellText;
      cell.appendChild(selectionIndicator);
      cell.addEventListener('click', yearCtrl.cellClickHandler);

      if (calendarCtrl.displayDate &&
          this.dateUtil.isSameMonthAndYear(firstOfMonth, calendarCtrl.displayDate)) {
        this.focusAfterAppend = cell;
      }
    } else {
      cell.classList.add('md-calendar-date-disabled');
      cell.textContent = cellText;
    }

    return cell;
  };

  /**
   * Builds a blank cell.
   * @return {HTMLElement}
   */
  CalendarYearBodyCtrl.prototype.buildBlankCell = function() {
    var cell = document.createElement('td');
    cell.tabIndex = -1;
    cell.classList.add('md-calendar-date');
    cell.setAttribute('role', 'gridcell');

    cell.setAttribute('tabindex', '-1');
    return cell;
  };

  /**
   * Builds the <tbody> content for the given year.
   * @param {Date} date Date for which the content should be built.
   * @returns {DocumentFragment} A document fragment containing the months within the year.
   */
  CalendarYearBodyCtrl.prototype.buildCalendarForYear = function(date) {
    // Store rows for the month in a document fragment so that we can append them all at once.
    var year = date.getFullYear();
    var yearBody = document.createDocumentFragment();

    var monthCell, i;
    // First row contains label and Jan-Jun.
    var firstRow = document.createElement('tr');
    var labelCell = document.createElement('td');
    labelCell.className = 'md-calendar-month-label';
    labelCell.textContent = year;
    firstRow.appendChild(labelCell);

    for (i = 0; i < 6; i++) {
      firstRow.appendChild(this.buildMonthCell(year, i));
    }
    yearBody.appendChild(firstRow);

    // Second row contains a blank cell and Jul-Dec.
    var secondRow = document.createElement('tr');
    secondRow.appendChild(this.buildBlankCell());
    for (i = 6; i < 12; i++) {
      secondRow.appendChild(this.buildMonthCell(year, i));
    }
    yearBody.appendChild(secondRow);

    return yearBody;
  };
})();

})();
(function(){
"use strict";

(function() {
  'use strict';

  /**
   * @ngdoc service
   * @name $mdDateLocaleProvider
   * @module material.components.datepicker
   *
   * @description
   * The `$mdDateLocaleProvider` is the provider that creates the `$mdDateLocale` service.
   * This provider that allows the user to specify messages, formatters, and parsers for date
   * internationalization. The `$mdDateLocale` service itself is consumed by AngularJS Material
   * components that deal with dates (i.e. {@link api/directive/mdDatepicker mdDatepicker}).
   *
   * @property {Array<string>} months Array of month names (in order).
   * @property {Array<string>} shortMonths Array of abbreviated month names.
   * @property {Array<string>} days Array of the days of the week (in order).
   * @property {Array<string>} shortDays Array of abbreviated days of the week.
   * @property {Array<string>} dates Array of dates of the month. Only necessary for locales
   *  using a numeral system other than [1, 2, 3...].
   * @property {Array<string>} firstDayOfWeek The first day of the week. Sunday = 0, Monday = 1,
   *  etc.
   * @property {function(string): Date} parseDate Function that converts a date string to a Date
   *  object (the date portion).
   * @property {function(Date, string): string} formatDate Function to format a date object to a
   *  string. The datepicker directive also provides the time zone, if it was specified.
   * @property {function(Date): string} monthHeaderFormatter Function that returns the label for
   *  a month given a date.
   * @property {function(Date): string} monthFormatter Function that returns the full name of a month
   *  for a given date.
   * @property {function(number): string} weekNumberFormatter Function that returns a label for
   *  a week given the week number.
   * @property {function(Date): string} longDateFormatter Function that formats a date into a long
   *  `aria-label` that is read by the screen reader when the focused date changes.
   * @property {string} msgCalendar Translation of the label "Calendar" for the current locale.
   * @property {string} msgOpenCalendar Translation of the button label "Open calendar" for the
   *  current locale.
   * @property {Date} firstRenderableDate The date from which the datepicker calendar will begin
   *  rendering. Note that this will be ignored if a minimum date is set.
   *  Defaults to January 1st 1880.
   * @property {Date} lastRenderableDate The last date that will be rendered by the datepicker
   *  calendar. Note that this will be ignored if a maximum date is set.
   *  Defaults to January 1st 2130.
   * @property {function(string): boolean} isDateComplete Function to determine whether a string
   *  makes sense to be parsed to a `Date` object. Returns `true` if the date appears to be complete
   *  and parsing should occur. By default, this checks for 3 groups of text or numbers separated
   *  by delimiters. This means that by default, date strings must include a month, day, and year
   *  to be parsed and for the model to be updated.
   *
   * @usage
   * <hljs lang="js">
   * myAppModule.config(function($mdDateLocaleProvider) {
   *
   *     // Example of a French localization.
   *     $mdDateLocaleProvider.months = ['janvier', 'février', 'mars', ...];
   *     $mdDateLocaleProvider.shortMonths = ['janv', 'févr', 'mars', ...];
   *     $mdDateLocaleProvider.days = ['dimanche', 'lundi', 'mardi', ...];
   *     $mdDateLocaleProvider.shortDays = ['Di', 'Lu', 'Ma', ...];
   *
   *     // Can change week display to start on Monday.
   *     $mdDateLocaleProvider.firstDayOfWeek = 1;
   *
   *     // Optional.
   *     $mdDateLocaleProvider.dates = [1, 2, 3, 4, 5, 6, ...];
   *
   *     // Example uses moment.js to parse and format dates.
   *     $mdDateLocaleProvider.parseDate = function(dateString) {
   *       var m = moment(dateString, 'L', true);
   *       return m.isValid() ? m.toDate() : new Date(NaN);
   *     };
   *
   *     $mdDateLocaleProvider.formatDate = function(date) {
   *       var m = moment(date);
   *       return m.isValid() ? m.format('L') : '';
   *     };
   *
   *     // Allow only a day and month to be specified.
   *     // This is required if using the 'M/D' format with moment.js.
   *     $mdDateLocaleProvider.isDateComplete = function(dateString) {
   *       dateString = dateString.trim();
   *
   *       // Look for two chunks of content (either numbers or text) separated by delimiters.
   *       var re = /^(([a-zA-Z]{3,}|[0-9]{1,4})([ .,]+|[/-]))([a-zA-Z]{3,}|[0-9]{1,4})/;
   *       return re.test(dateString);
   *     };
   *
   *     $mdDateLocaleProvider.monthHeaderFormatter = function(date) {
   *       return myShortMonths[date.getMonth()] + ' ' + date.getFullYear();
   *     };
   *
   *     // In addition to date display, date components also need localized messages
   *     // for aria-labels for screen-reader users.
   *
   *     $mdDateLocaleProvider.weekNumberFormatter = function(weekNumber) {
   *       return 'Semaine ' + weekNumber;
   *     };
   *
   *     $mdDateLocaleProvider.msgCalendar = 'Calendrier';
   *     $mdDateLocaleProvider.msgOpenCalendar = 'Ouvrir le calendrier';
   *
   *     // You can also set when your calendar begins and ends.
   *     $mdDateLocaleProvider.firstRenderableDate = new Date(1776, 6, 4);
   *     $mdDateLocaleProvider.lastRenderableDate = new Date(2012, 11, 21);
   * });
   * </hljs>
   *
   */
  angular.module('material.components.datepicker').config(["$provide", function($provide) {
    // TODO(jelbourn): Assert provided values are correctly formatted. Need assertions.

    /** @constructor */
    function DateLocaleProvider() {
      /** Array of full month names. E.g., ['January', 'February', ...] */
      this.months = null;

      /** Array of abbreviated month names. E.g., ['Jan', 'Feb', ...] */
      this.shortMonths = null;

      /** Array of full day of the week names. E.g., ['Monday', 'Tuesday', ...] */
      this.days = null;

      /** Array of abbreviated dat of the week names. E.g., ['M', 'T', ...] */
      this.shortDays = null;

      /** Array of dates of a month (1 - 31). Characters might be different in some locales. */
      this.dates = null;

      /** Index of the first day of the week. 0 = Sunday, 1 = Monday, etc. */
      this.firstDayOfWeek = 0;

      /**
       * Function that converts the date portion of a Date to a string.
       * @type {(function(Date): string)}
       */
      this.formatDate = null;

      /**
       * Function that converts a date string to a Date object (the date portion)
       * @type {function(string): Date}
       */
      this.parseDate = null;

      /**
       * Function that formats a Date into a month header string.
       * @type {function(Date): string}
       */
      this.monthHeaderFormatter = null;

      /**
       * Function that formats a week number into a label for the week.
       * @type {function(number): string}
       */
      this.weekNumberFormatter = null;

      /**
       * Function that formats a date into a long aria-label that is read
       * when the focused date changes.
       * @type {function(Date): string}
       */
      this.longDateFormatter = null;

      /**
       * Function to determine whether a string makes sense to be
       * parsed to a Date object.
       * @type {function(string): boolean}
       */
      this.isDateComplete = null;

      /**
       * ARIA label for the calendar "dialog" used in the datepicker.
       * @type {string}
       */
      this.msgCalendar = '';

      /**
       * ARIA label for the datepicker's "Open calendar" buttons.
       * @type {string}
       */
      this.msgOpenCalendar = '';
    }

    /**
     * Factory function that returns an instance of the dateLocale service.
     * @ngInject
     * @param $locale
     * @returns {DateLocale}
     */
    DateLocaleProvider.prototype.$get = function($locale, $filter) {
      /**
       * Default date-to-string formatting function.
       * @param {!Date} date
       * @param {string=} timezone
       * @returns {string}
       */
      function defaultFormatDate(date, timezone) {
        if (!date) {
          return '';
        }

        // All of the dates created through ng-material *should* be set to midnight.
        // If we encounter a date where the localeTime shows at 11pm instead of midnight,
        // we have run into an issue with DST where we need to increment the hour by one:
        // var d = new Date(1992, 9, 8, 0, 0, 0);
        // d.toLocaleString(); // == "10/7/1992, 11:00:00 PM"
        var localeTime = date.toLocaleTimeString();
        var formatDate = date;
        if (date.getHours() === 0 &&
            (localeTime.indexOf('11:') !== -1 || localeTime.indexOf('23:') !== -1)) {
          formatDate = new Date(date.getFullYear(), date.getMonth(), date.getDate(), 1, 0, 0);
        }

        return $filter('date')(formatDate, 'M/d/yyyy', timezone);
      }

      /**
       * Default string-to-date parsing function.
       * @param {string} dateString
       * @returns {!Date}
       */
      function defaultParseDate(dateString) {
        return new Date(dateString);
      }

      /**
       * Default function to determine whether a string makes sense to be
       * parsed to a Date object.
       *
       * This is very permissive and is just a basic sanity check to ensure that
       * things like single integers aren't able to be parsed into dates.
       * @param {string} dateString
       * @returns {boolean}
       */
      function defaultIsDateComplete(dateString) {
        dateString = dateString.trim();

        // Looks for three chunks of content (either numbers or text) separated
        // by delimiters.
        var re = /^(([a-zA-Z]{3,}|[0-9]{1,4})([ .,]+|[/-])){2}([a-zA-Z]{3,}|[0-9]{1,4})$/;
        return re.test(dateString);
      }

      /**
       * Default date-to-string formatter to get a month header.
       * @param {!Date} date
       * @returns {string}
       */
      function defaultMonthHeaderFormatter(date) {
        return service.shortMonths[date.getMonth()] + ' ' + date.getFullYear();
      }

      /**
       * Default formatter for a month.
       * @param {!Date} date
       * @returns {string}
       */
      function defaultMonthFormatter(date) {
        return service.months[date.getMonth()] + ' ' + date.getFullYear();
      }

      /**
       * Default week number formatter.
       * @param number
       * @returns {string}
       */
      function defaultWeekNumberFormatter(number) {
        return 'Week ' + number;
      }

      /**
       * Default formatter for date cell aria-labels.
       * @param {!Date} date
       * @returns {string}
       */
      function defaultLongDateFormatter(date) {
        // Example: 'Thursday June 18 2015'
        return [
          service.days[date.getDay()],
          service.months[date.getMonth()],
          service.dates[date.getDate()],
          date.getFullYear()
        ].join(' ');
      }

      // The default "short" day strings are the first character of each day,
      // e.g., "Monday" => "M".
      var defaultShortDays = $locale.DATETIME_FORMATS.SHORTDAY.map(function(day) {
        return day.substring(0, 1);
      });

      // The default dates are simply the numbers 1 through 31.
      var defaultDates = Array(32);
      for (var i = 1; i <= 31; i++) {
        defaultDates[i] = i;
      }

      // Default ARIA messages are in English (US).
      var defaultMsgCalendar = 'Calendar';
      var defaultMsgOpenCalendar = 'Open calendar';

      // Default start/end dates that are rendered in the calendar.
      var defaultFirstRenderableDate = new Date(1880, 0, 1);
      var defaultLastRendereableDate = new Date(defaultFirstRenderableDate.getFullYear() + 250, 0, 1);

      var service = {
        months: this.months || $locale.DATETIME_FORMATS.MONTH,
        shortMonths: this.shortMonths || $locale.DATETIME_FORMATS.SHORTMONTH,
        days: this.days || $locale.DATETIME_FORMATS.DAY,
        shortDays: this.shortDays || defaultShortDays,
        dates: this.dates || defaultDates,
        firstDayOfWeek: this.firstDayOfWeek || 0,
        formatDate: this.formatDate || defaultFormatDate,
        parseDate: this.parseDate || defaultParseDate,
        isDateComplete: this.isDateComplete || defaultIsDateComplete,
        monthHeaderFormatter: this.monthHeaderFormatter || defaultMonthHeaderFormatter,
        monthFormatter: this.monthFormatter || defaultMonthFormatter,
        weekNumberFormatter: this.weekNumberFormatter || defaultWeekNumberFormatter,
        longDateFormatter: this.longDateFormatter || defaultLongDateFormatter,
        msgCalendar: this.msgCalendar || defaultMsgCalendar,
        msgOpenCalendar: this.msgOpenCalendar || defaultMsgOpenCalendar,
        firstRenderableDate: this.firstRenderableDate || defaultFirstRenderableDate,
        lastRenderableDate: this.lastRenderableDate || defaultLastRendereableDate
      };

      return service;
    };
    DateLocaleProvider.prototype.$get.$inject = ["$locale", "$filter"];

    $provide.provider('$mdDateLocale', new DateLocaleProvider());
  }]);
})();

})();
(function(){
"use strict";

(function() {
  'use strict';

  /**
   * Utility for performing date calculations to facilitate operation of the calendar and
   * datepicker.
   */
  angular.module('material.components.datepicker').factory('$$mdDateUtil', function() {
    return {
      getFirstDateOfMonth: getFirstDateOfMonth,
      getNumberOfDaysInMonth: getNumberOfDaysInMonth,
      getDateInNextMonth: getDateInNextMonth,
      getDateInPreviousMonth: getDateInPreviousMonth,
      isInNextMonth: isInNextMonth,
      isInPreviousMonth: isInPreviousMonth,
      getDateMidpoint: getDateMidpoint,
      isSameMonthAndYear: isSameMonthAndYear,
      getWeekOfMonth: getWeekOfMonth,
      incrementDays: incrementDays,
      incrementMonths: incrementMonths,
      getLastDateOfMonth: getLastDateOfMonth,
      isSameDay: isSameDay,
      getMonthDistance: getMonthDistance,
      isValidDate: isValidDate,
      setDateTimeToMidnight: setDateTimeToMidnight,
      createDateAtMidnight: createDateAtMidnight,
      isDateWithinRange: isDateWithinRange,
      incrementYears: incrementYears,
      getYearDistance: getYearDistance,
      clampDate: clampDate,
      getTimestampFromNode: getTimestampFromNode,
      isMonthWithinRange: isMonthWithinRange
    };

    /**
     * Gets the first day of the month for the given date's month.
     * @param {Date} date
     * @returns {Date}
     */
    function getFirstDateOfMonth(date) {
      return new Date(date.getFullYear(), date.getMonth(), 1);
    }

    /**
     * Gets the number of days in the month for the given date's month.
     * @param date
     * @returns {number}
     */
    function getNumberOfDaysInMonth(date) {
      return new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate();
    }

    /**
     * Get an arbitrary date in the month after the given date's month.
     * @param date
     * @returns {Date}
     */
    function getDateInNextMonth(date) {
      return new Date(date.getFullYear(), date.getMonth() + 1, 1);
    }

    /**
     * Get an arbitrary date in the month before the given date's month.
     * @param date
     * @returns {Date}
     */
    function getDateInPreviousMonth(date) {
      return new Date(date.getFullYear(), date.getMonth() - 1, 1);
    }

    /**
     * Gets whether two dates have the same month and year.
     * @param {Date} d1
     * @param {Date} d2
     * @returns {boolean}
     */
    function isSameMonthAndYear(d1, d2) {
      return d1.getFullYear() === d2.getFullYear() && d1.getMonth() === d2.getMonth();
    }

    /**
     * Gets whether two dates are the same day (not not necesarily the same time).
     * @param {Date} d1
     * @param {Date} d2
     * @returns {boolean}
     */
    function isSameDay(d1, d2) {
      return d1.getDate() == d2.getDate() && isSameMonthAndYear(d1, d2);
    }

    /**
     * Gets whether a date is in the month immediately after some date.
     * @param {Date} startDate The date from which to compare.
     * @param {Date} endDate The date to check.
     * @returns {boolean}
     */
    function isInNextMonth(startDate, endDate) {
      var nextMonth = getDateInNextMonth(startDate);
      return isSameMonthAndYear(nextMonth, endDate);
    }

    /**
     * Gets whether a date is in the month immediately before some date.
     * @param {Date} startDate The date from which to compare.
     * @param {Date} endDate The date to check.
     * @returns {boolean}
     */
    function isInPreviousMonth(startDate, endDate) {
      var previousMonth = getDateInPreviousMonth(startDate);
      return isSameMonthAndYear(endDate, previousMonth);
    }

    /**
     * Gets the midpoint between two dates.
     * @param {Date} d1
     * @param {Date} d2
     * @returns {Date}
     */
    function getDateMidpoint(d1, d2) {
      return createDateAtMidnight((d1.getTime() + d2.getTime()) / 2);
    }

    /**
     * Gets the week of the month that a given date occurs in.
     * @param {Date} date
     * @returns {number} Index of the week of the month (zero-based).
     */
    function getWeekOfMonth(date) {
      var firstDayOfMonth = getFirstDateOfMonth(date);
      return Math.floor((firstDayOfMonth.getDay() + date.getDate() - 1) / 7);
    }

    /**
     * Gets a new date incremented by the given number of days. Number of days can be negative.
     * @param {Date} date
     * @param {number} numberOfDays
     * @returns {Date}
     */
    function incrementDays(date, numberOfDays) {
      return new Date(date.getFullYear(), date.getMonth(), date.getDate() + numberOfDays);
    }

    /**
     * Gets a new date incremented by the given number of months. Number of months can be negative.
     * If the date of the given month does not match the target month, the date will be set to the
     * last day of the month.
     * @param {Date} date
     * @param {number} numberOfMonths
     * @returns {Date}
     */
    function incrementMonths(date, numberOfMonths) {
      // If the same date in the target month does not actually exist, the Date object will
      // automatically advance *another* month by the number of missing days.
      // For example, if you try to go from Jan. 30 to Feb. 30, you'll end up on March 2.
      // So, we check if the month overflowed and go to the last day of the target month instead.
      var dateInTargetMonth = new Date(date.getFullYear(), date.getMonth() + numberOfMonths, 1);
      var numberOfDaysInMonth = getNumberOfDaysInMonth(dateInTargetMonth);
      if (numberOfDaysInMonth < date.getDate()) {
        dateInTargetMonth.setDate(numberOfDaysInMonth);
      } else {
        dateInTargetMonth.setDate(date.getDate());
      }

      return dateInTargetMonth;
    }

    /**
     * Get the integer distance between two months. This *only* considers the month and year
     * portion of the Date instances.
     *
     * @param {Date} start
     * @param {Date} end
     * @returns {number} Number of months between `start` and `end`. If `end` is before `start`
     *     chronologically, this number will be negative.
     */
    function getMonthDistance(start, end) {
      return (12 * (end.getFullYear() - start.getFullYear())) + (end.getMonth() - start.getMonth());
    }

    /**
     * Gets the last day of the month for the given date.
     * @param {Date} date
     * @returns {Date}
     */
    function getLastDateOfMonth(date) {
      return new Date(date.getFullYear(), date.getMonth(), getNumberOfDaysInMonth(date));
    }

    /**
     * Checks whether a date is valid.
     * @param {Date} date
     * @return {boolean} Whether the date is a valid Date.
     */
    function isValidDate(date) {
      return date && date.getTime && !isNaN(date.getTime());
    }

    /**
     * Sets a date's time to midnight.
     * @param {Date} date
     */
    function setDateTimeToMidnight(date) {
      if (isValidDate(date)) {
        date.setHours(0, 0, 0, 0);
      }
    }

    /**
     * Creates a date with the time set to midnight.
     * Drop-in replacement for two forms of the Date constructor:
     * 1. No argument for Date representing now.
     * 2. Single-argument value representing number of seconds since Unix Epoch
     * or a Date object.
     * @param {number|Date=} opt_value
     * @return {Date} New date with time set to midnight.
     */
    function createDateAtMidnight(opt_value) {
      var date;
      if (angular.isUndefined(opt_value)) {
        date = new Date();
      } else {
        date = new Date(opt_value);
      }
      setDateTimeToMidnight(date);
      return date;
    }

     /**
      * Checks if a date is within a min and max range, ignoring the time component.
      * If minDate or maxDate are not dates, they are ignored.
      * @param {Date} date
      * @param {Date} minDate
      * @param {Date} maxDate
      */
     function isDateWithinRange(date, minDate, maxDate) {
       var dateAtMidnight = createDateAtMidnight(date);
       var minDateAtMidnight = isValidDate(minDate) ? createDateAtMidnight(minDate) : null;
       var maxDateAtMidnight = isValidDate(maxDate) ? createDateAtMidnight(maxDate) : null;
       return (!minDateAtMidnight || minDateAtMidnight <= dateAtMidnight) &&
           (!maxDateAtMidnight || maxDateAtMidnight >= dateAtMidnight);
     }

    /**
     * Gets a new date incremented by the given number of years. Number of years can be negative.
     * See `incrementMonths` for notes on overflow for specific dates.
     * @param {Date} date
     * @param {number} numberOfYears
     * @returns {Date}
     */
     function incrementYears(date, numberOfYears) {
       return incrementMonths(date, numberOfYears * 12);
     }

     /**
      * Get the integer distance between two years. This *only* considers the year portion of the
      * Date instances.
      *
      * @param {Date} start
      * @param {Date} end
      * @returns {number} Number of months between `start` and `end`. If `end` is before `start`
      *     chronologically, this number will be negative.
      */
     function getYearDistance(start, end) {
       return end.getFullYear() - start.getFullYear();
     }

     /**
      * Clamps a date between a minimum and a maximum date.
      * @param {Date} date Date to be clamped
      * @param {Date=} minDate Minimum date
      * @param {Date=} maxDate Maximum date
      * @return {Date}
      */
     function clampDate(date, minDate, maxDate) {
       var boundDate = date;
       if (minDate && date < minDate) {
         boundDate = new Date(minDate.getTime());
       }
       if (maxDate && date > maxDate) {
         boundDate = new Date(maxDate.getTime());
       }
       return boundDate;
     }

     /**
      * Extracts and parses the timestamp from a DOM node.
      * @param  {HTMLElement} node Node from which the timestamp will be extracted.
      * @return {number} Time since epoch.
      */
     function getTimestampFromNode(node) {
       if (node && node.hasAttribute('data-timestamp')) {
         return Number(node.getAttribute('data-timestamp'));
       }
     }

     /**
      * Checks if a month is within a min and max range, ignoring the date and time components.
      * If minDate or maxDate are not dates, they are ignored.
      * @param {Date} date
      * @param {Date} minDate
      * @param {Date} maxDate
      */
     function isMonthWithinRange(date, minDate, maxDate) {
       var month = date.getMonth();
       var year = date.getFullYear();

       return (!minDate || minDate.getFullYear() < year || minDate.getMonth() <= month) &&
        (!maxDate || maxDate.getFullYear() > year || maxDate.getMonth() >= month);
     }
  });
})();

})();
(function(){
"use strict";

(function() {
  'use strict';

  // TODO(jelbourn): forward more attributes to the internal input (required, autofocus, etc.)
  // TODO(jelbourn): something better for mobile (calendar panel takes up entire screen?)
  // TODO(jelbourn): input behavior (masking? auto-complete?)

  DatePickerCtrl.$inject = ["$scope", "$element", "$attrs", "$window", "$mdConstant", "$mdTheming", "$mdUtil", "$mdDateLocale", "$$mdDateUtil", "$$rAF", "$filter", "$timeout"];
  datePickerDirective.$inject = ["$$mdSvgRegistry", "$mdUtil", "$mdAria", "inputDirective"];
  angular.module('material.components.datepicker')
      .directive('mdDatepicker', datePickerDirective);

  /**
   * @ngdoc directive
   * @name mdDatepicker
   * @module material.components.datepicker
   *
   * @param {Date} ng-model The component's model. Expects either a JavaScript Date object or a
   *  value that can be parsed into one (e.g. a ISO 8601 string).
   * @param {Object=} ng-model-options Allows tuning of the way in which `ng-model` is being
   *  updated. Also allows for a timezone to be specified.
   *  <a href="https://docs.angularjs.org/api/ng/directive/ngModelOptions#usage">
   *    Read more at the ngModelOptions docs.</a>
   * @param {expression=} ng-change Expression evaluated when the model value changes.
   * @param {expression=} ng-focus Expression evaluated when the input is focused or the calendar
   *  is opened.
   * @param {expression=} ng-blur Expression evaluated when focus is removed from the input or the
   *  calendar is closed.
   * @param {boolean=} ng-disabled Whether the datepicker is disabled.
   * @param {boolean=} ng-required Whether a value is required for the datepicker.
   * @param {Date=} md-min-date Expression representing a min date (inclusive).
   * @param {Date=} md-max-date Expression representing a max date (inclusive).
   * @param {(function(Date): boolean)=} md-date-filter Function expecting a date and returning a
   *  boolean whether it can be selected or not.
   * @param {String=} md-placeholder The date input placeholder value.
   * @param {String=} md-open-on-focus When present, the calendar will be opened when the input
   *  is focused.
   * @param {Boolean=} md-is-open Expression that can be used to open the datepicker's calendar
   *  on-demand.
   * @param {String=} md-current-view Default open view of the calendar pane. Can be either
   *  "month" or "year".
   * @param {String=} md-mode Restricts the user to only selecting a value from a particular view.
   *  This option can be used if the user is only supposed to choose from a certain date type
   *  (e.g. only selecting the month).
   * Can be either "month" or "day". **Note** that this will overwrite the `md-current-view` value.
   *
   * @param {String=} md-hide-icons Determines which datepicker icons should be hidden. Note that
   *  this may cause the datepicker to not align properly with other components.
   *  **Use at your own risk.** Possible values are:
   * * `"all"` - Hides all icons.
   * * `"calendar"` - Only hides the calendar icon.
   * * `"triangle"` - Only hides the triangle icon.
   * @param {Object=} md-date-locale Allows for the values from the `$mdDateLocaleProvider` to be
   * ovewritten on a per-element basis (e.g. `msgOpenCalendar` can be overwritten with
   * `md-date-locale="{ msgOpenCalendar: 'Open a special calendar' }"`).
   *
   * @description
   * `<md-datepicker>` is a component used to select a single date.
   * For information on how to configure internationalization for the date picker,
   * see {@link api/service/$mdDateLocaleProvider $mdDateLocaleProvider}.
   *
   * This component supports
   * [ngMessages](https://docs.angularjs.org/api/ngMessages/directive/ngMessages).
   * Supported attributes are:
   * * `required`: whether a required date is not set.
   * * `mindate`: whether the selected date is before the minimum allowed date.
   * * `maxdate`: whether the selected date is after the maximum allowed date.
   * * `debounceInterval`: ms to delay input processing (since last debounce reset);
   *    default value 500ms
   *
   * @usage
   * <hljs lang="html">
   *   <md-datepicker ng-model="birthday"></md-datepicker>
   * </hljs>
   *
   */

  function datePickerDirective($$mdSvgRegistry, $mdUtil, $mdAria, inputDirective) {
    return {
      template: function(tElement, tAttrs) {
        // Buttons are not in the tab order because users can open the calendar via keyboard
        // interaction on the text input, and multiple tab stops for one component (picker)
        // may be confusing.
        var hiddenIcons = tAttrs.mdHideIcons;
        var ariaLabelValue = tAttrs.ariaLabel || tAttrs.mdPlaceholder;

        var calendarButton = (hiddenIcons === 'all' || hiddenIcons === 'calendar') ? '' :
          '<md-button class="md-datepicker-button md-icon-button" type="button" ' +
              'tabindex="-1" aria-hidden="true" ' +
              'ng-click="ctrl.openCalendarPane($event)">' +
            '<md-icon class="md-datepicker-calendar-icon" aria-label="md-calendar" ' +
                     'md-svg-src="' + $$mdSvgRegistry.mdCalendar + '"></md-icon>' +
          '</md-button>';

        var triangleButton = '';

        if (hiddenIcons !== 'all' && hiddenIcons !== 'triangle') {
          triangleButton = '' +
            '<md-button type="button" md-no-ink ' +
              'class="md-datepicker-triangle-button md-icon-button" ' +
              'ng-click="ctrl.openCalendarPane($event)" ' +
              'aria-label="{{::ctrl.locale.msgOpenCalendar}}">' +
            '<div class="md-datepicker-expand-triangle"></div>' +
          '</md-button>';

          tElement.addClass(HAS_TRIANGLE_ICON_CLASS);
        }

        return calendarButton +
        '<div class="md-datepicker-input-container" ng-class="{\'md-datepicker-focused\': ctrl.isFocused}">' +
          '<input ' +
            (ariaLabelValue ? 'aria-label="' + ariaLabelValue + '" ' : '') +
            'class="md-datepicker-input" ' +
            'aria-haspopup="true" ' +
            'aria-expanded="{{ctrl.isCalendarOpen}}" ' +
            'ng-focus="ctrl.setFocused(true)" ' +
            'ng-blur="ctrl.setFocused(false)"> ' +
            triangleButton +
        '</div>' +

        // This pane will be detached from here and re-attached to the document body.
        '<div class="md-datepicker-calendar-pane md-whiteframe-z1" id="{{::ctrl.calendarPaneId}}">' +
          '<div class="md-datepicker-input-mask">' +
            '<div class="md-datepicker-input-mask-opaque"></div>' +
          '</div>' +
          '<div class="md-datepicker-calendar">' +
            '<md-calendar role="dialog" aria-label="{{::ctrl.locale.msgCalendar}}" ' +
                'md-current-view="{{::ctrl.currentView}}" ' +
                'md-mode="{{::ctrl.mode}}" ' +
                'md-min-date="ctrl.minDate" ' +
                'md-max-date="ctrl.maxDate" ' +
                'md-date-filter="ctrl.dateFilter" ' +
                'ng-model="ctrl.date" ng-if="ctrl.isCalendarOpen">' +
            '</md-calendar>' +
          '</div>' +
        '</div>';
      },
      require: ['ngModel', 'mdDatepicker', '?^mdInputContainer', '?^form'],
      scope: {
        minDate: '=mdMinDate',
        maxDate: '=mdMaxDate',
        placeholder: '@mdPlaceholder',
        currentView: '@mdCurrentView',
        mode: '@mdMode',
        dateFilter: '=mdDateFilter',
        isOpen: '=?mdIsOpen',
        debounceInterval: '=mdDebounceInterval',
        dateLocale: '=mdDateLocale'
      },
      controller: DatePickerCtrl,
      controllerAs: 'ctrl',
      bindToController: true,
      link: function(scope, element, attr, controllers) {
        var ngModelCtrl = controllers[0];
        var mdDatePickerCtrl = controllers[1];
        var mdInputContainer = controllers[2];
        var parentForm = controllers[3];
        var mdNoAsterisk = $mdUtil.parseAttributeBoolean(attr.mdNoAsterisk);

        mdDatePickerCtrl.configureNgModel(ngModelCtrl, mdInputContainer, inputDirective);

        if (mdInputContainer) {
          // We need to move the spacer after the datepicker itself,
          // because md-input-container adds it after the
          // md-datepicker-input by default. The spacer gets wrapped in a
          // div, because it floats and gets aligned next to the datepicker.
          // There are easier ways of working around this with CSS (making the
          // datepicker 100% wide, change the `display` etc.), however they
          // break the alignment with any other form controls.
          var spacer = element[0].querySelector('.md-errors-spacer');

          if (spacer) {
            element.after(angular.element('<div>').append(spacer));
          }

          mdInputContainer.setHasPlaceholder(attr.mdPlaceholder);
          mdInputContainer.input = element;
          mdInputContainer.element
            .addClass(INPUT_CONTAINER_CLASS)
            .toggleClass(HAS_CALENDAR_ICON_CLASS, attr.mdHideIcons !== 'calendar' && attr.mdHideIcons !== 'all');

          if (!mdInputContainer.label) {
            $mdAria.expect(element, 'aria-label', attr.mdPlaceholder);
          } else if (!mdNoAsterisk) {
            attr.$observe('required', function(value) {
              mdInputContainer.label.toggleClass('md-required', !!value);
            });
          }

          scope.$watch(mdInputContainer.isErrorGetter || function() {
            return ngModelCtrl.$invalid && (ngModelCtrl.$touched || (parentForm && parentForm.$submitted));
          }, mdInputContainer.setInvalid);
        } else if (parentForm) {
          // If invalid, highlights the input when the parent form is submitted.
          var parentSubmittedWatcher = scope.$watch(function() {
            return parentForm.$submitted;
          }, function(isSubmitted) {
            if (isSubmitted) {
              mdDatePickerCtrl.updateErrorState();
              parentSubmittedWatcher();
            }
          });
        }
      }
    };
  }

  /** Additional offset for the input's `size` attribute, which is updated based on its content. */
  var EXTRA_INPUT_SIZE = 3;

  /** Class applied to the container if the date is invalid. */
  var INVALID_CLASS = 'md-datepicker-invalid';

  /** Class applied to the datepicker when it's open. */
  var OPEN_CLASS = 'md-datepicker-open';

  /** Class applied to the md-input-container, if a datepicker is placed inside it */
  var INPUT_CONTAINER_CLASS = '_md-datepicker-floating-label';

  /** Class to be applied when the calendar icon is enabled. */
  var HAS_CALENDAR_ICON_CLASS = '_md-datepicker-has-calendar-icon';

  /** Class to be applied when the triangle icon is enabled. */
  var HAS_TRIANGLE_ICON_CLASS = '_md-datepicker-has-triangle-icon';

  /** Default time in ms to debounce input event by. */
  var DEFAULT_DEBOUNCE_INTERVAL = 500;

  /**
   * Height of the calendar pane used to check if the pane is going outside the boundary of
   * the viewport. See calendar.scss for how $md-calendar-height is computed; an extra 20px is
   * also added to space the pane away from the exact edge of the screen.
   *
   *  This is computed statically now, but can be changed to be measured if the circumstances
   *  of calendar sizing are changed.
   */
  var CALENDAR_PANE_HEIGHT = 368;

  /**
   * Width of the calendar pane used to check if the pane is going outside the boundary of
   * the viewport. See calendar.scss for how $md-calendar-width is computed; an extra 20px is
   * also added to space the pane away from the exact edge of the screen.
   *
   *  This is computed statically now, but can be changed to be measured if the circumstances
   *  of calendar sizing are changed.
   */
  var CALENDAR_PANE_WIDTH = 360;

  /** Used for checking whether the current user agent is on iOS or Android. */
  var IS_MOBILE_REGEX = /ipad|iphone|ipod|android/i;

  /**
   * Controller for md-datepicker.
   *
   * @ngInject @constructor
   */
  function DatePickerCtrl($scope, $element, $attrs, $window, $mdConstant, $mdTheming, $mdUtil,
                          $mdDateLocale, $$mdDateUtil, $$rAF, $filter, $timeout) {

    /** @final */
    this.$window = $window;

    /** @final */
    this.dateUtil = $$mdDateUtil;

    /** @final */
    this.$mdConstant = $mdConstant;

    /** @final */
    this.$mdUtil = $mdUtil;

    /** @final */
    this.$$rAF = $$rAF;

    /** @final */
    this.$mdDateLocale = $mdDateLocale;

    /** @final */
    this.$timeout = $timeout;

    /**
     * The root document element. This is used for attaching a top-level click handler to
     * close the calendar panel when a click outside said panel occurs. We use `documentElement`
     * instead of body because, when scrolling is disabled, some browsers consider the body element
     * to be completely off the screen and propagate events directly to the html element.
     * @type {!angular.JQLite}
     */
    this.documentElement = angular.element(document.documentElement);

    /** @type {!angular.NgModelController} */
    this.ngModelCtrl = null;

    /** @type {HTMLInputElement} */
    this.inputElement = $element[0].querySelector('input');

    /** @final {!angular.JQLite} */
    this.ngInputElement = angular.element(this.inputElement);

    /** @type {HTMLElement} */
    this.inputContainer = $element[0].querySelector('.md-datepicker-input-container');

    /** @type {HTMLElement} Floating calendar pane. */
    this.calendarPane = $element[0].querySelector('.md-datepicker-calendar-pane');

    /** @type {HTMLElement} Calendar icon button. */
    this.calendarButton = $element[0].querySelector('.md-datepicker-button');

    /**
     * Element covering everything but the input in the top of the floating calendar pane.
     * @type {!angular.JQLite}
     */
    this.inputMask = angular.element($element[0].querySelector('.md-datepicker-input-mask-opaque'));

    /** @final {!angular.JQLite} */
    this.$element = $element;

    /** @final {!angular.Attributes} */
    this.$attrs = $attrs;

    /** @final {!angular.Scope} */
    this.$scope = $scope;

    /** @type {Date} */
    this.date = null;

    /** @type {boolean} */
    this.isFocused = false;

    /** @type {boolean} */
    this.isDisabled;
    this.setDisabled($element[0].disabled || angular.isString($attrs.disabled));

    /** @type {boolean} Whether the date-picker's calendar pane is open. */
    this.isCalendarOpen = false;

    /** @type {boolean} Whether the calendar should open when the input is focused. */
    this.openOnFocus = $attrs.hasOwnProperty('mdOpenOnFocus');

    /** @final */
    this.mdInputContainer = null;

    /**
     * Element from which the calendar pane was opened. Keep track of this so that we can return
     * focus to it when the pane is closed.
     * @type {HTMLElement}
     */
    this.calendarPaneOpenedFrom = null;

    /** @type {String} Unique id for the calendar pane. */
    this.calendarPaneId = 'md-date-pane-' + $mdUtil.nextUid();

    /** Pre-bound click handler is saved so that the event listener can be removed. */
    this.bodyClickHandler = angular.bind(this, this.handleBodyClick);

    /**
     * Name of the event that will trigger a close. Necessary to sniff the browser, because
     * the resize event doesn't make sense on mobile and can have a negative impact since it
     * triggers whenever the browser zooms in on a focused input.
     */
    this.windowEventName = IS_MOBILE_REGEX.test(
      navigator.userAgent || navigator.vendor || window.opera
    ) ? 'orientationchange' : 'resize';

    /** Pre-bound close handler so that the event listener can be removed. */
    this.windowEventHandler = $mdUtil.debounce(angular.bind(this, this.closeCalendarPane), 100);

    /** Pre-bound handler for the window blur event. Allows for it to be removed later. */
    this.windowBlurHandler = angular.bind(this, this.handleWindowBlur);

    /** The built-in AngularJS date filter. */
    this.ngDateFilter = $filter('date');

    /** @type {Number} Extra margin for the left side of the floating calendar pane. */
    this.leftMargin = 20;

    /** @type {Number} Extra margin for the top of the floating calendar. Gets determined on the first open. */
    this.topMargin = null;

    // Unless the user specifies so, the datepicker should not be a tab stop.
    // This is necessary because ngAria might add a tabindex to anything with an ng-model
    // (based on whether or not the user has turned that particular feature on/off).
    if ($attrs.tabindex) {
      this.ngInputElement.attr('tabindex', $attrs.tabindex);
      $attrs.$set('tabindex', null);
    } else {
      $attrs.$set('tabindex', '-1');
    }

    $attrs.$set('aria-owns', this.calendarPaneId);

    $mdTheming($element);
    $mdTheming(angular.element(this.calendarPane));

    var self = this;

    $scope.$on('$destroy', function() {
      self.detachCalendarPane();
    });

    if ($attrs.mdIsOpen) {
      $scope.$watch('ctrl.isOpen', function(shouldBeOpen) {
        if (shouldBeOpen) {
          self.openCalendarPane({
            target: self.inputElement
          });
        } else {
          self.closeCalendarPane();
        }
      });
    }

    // For AngularJS 1.4 and older, where there are no lifecycle hooks but bindings are pre-assigned,
    // manually call the $onInit hook.
    if (angular.version.major === 1 && angular.version.minor <= 4) {
      this.$onInit();
    }

  }

  /**
   * AngularJS Lifecycle hook for newer AngularJS versions.
   * Bindings are not guaranteed to have been assigned in the controller, but they are in the $onInit hook.
   */
  DatePickerCtrl.prototype.$onInit = function() {

    /**
     * Holds locale-specific formatters, parsers, labels etc. Allows
     * the user to override specific ones from the $mdDateLocale provider.
     * @type {!Object}
     */
    this.locale = this.dateLocale ? angular.extend({}, this.$mdDateLocale, this.dateLocale) : this.$mdDateLocale;

    this.installPropertyInterceptors();
    this.attachChangeListeners();
    this.attachInteractionListeners();
  };

  /**
   * Sets up the controller's reference to ngModelController and
   * applies AngularJS's `input[type="date"]` directive.
   * @param {!angular.NgModelController} ngModelCtrl Instance of the ngModel controller.
   * @param {Object} mdInputContainer Instance of the mdInputContainer controller.
   * @param {Object} inputDirective Config for AngularJS's `input` directive.
   */
  DatePickerCtrl.prototype.configureNgModel = function(ngModelCtrl, mdInputContainer, inputDirective) {
    this.ngModelCtrl = ngModelCtrl;
    this.mdInputContainer = mdInputContainer;

    // The input needs to be [type="date"] in order to be picked up by AngularJS.
    this.$attrs.$set('type', 'date');

    // Invoke the `input` directive link function, adding a stub for the element.
    // This allows us to re-use AngularJS's logic for setting the timezone via ng-model-options.
    // It works by calling the link function directly which then adds the proper `$parsers` and
    // `$formatters` to the ngModel controller.
    inputDirective[0].link.pre(this.$scope, {
      on: angular.noop,
      val: angular.noop,
      0: {}
    }, this.$attrs, [ngModelCtrl]);

    var self = this;

    // Responds to external changes to the model value.
    self.ngModelCtrl.$formatters.push(function(value) {
      var parsedValue = angular.isDefined(value) ? value : null;

      if (!(value instanceof Date)) {
        parsedValue = Date.parse(value);

        // `parsedValue` is the time since epoch if valid or `NaN` if invalid.
        if (!isNaN(parsedValue) && angular.isNumber(parsedValue)) {
          value = new Date(parsedValue);
        }

        if (value && !(value instanceof Date)) {
          throw Error(
            'The ng-model for md-datepicker must be a Date instance or a value ' +
              'that can be parsed into a date. Currently the model is of type: ' + typeof value
          );
        }
      }

      self.onExternalChange(value);

      return value;
    });

    // Responds to external error state changes (e.g. ng-required based on another input).
    ngModelCtrl.$viewChangeListeners.unshift(angular.bind(this, this.updateErrorState));

    // Forwards any events from the input to the root element. This is necessary to get `updateOn`
    // working for events that don't bubble (e.g. 'blur') since AngularJS binds the handlers to
    // the `<md-datepicker>`.
    var updateOn = self.$mdUtil.getModelOption(ngModelCtrl, 'updateOn');

    if (updateOn) {
      this.ngInputElement.on(
        updateOn,
        angular.bind(this.$element, this.$element.triggerHandler, updateOn)
      );
    }
  };

  /**
   * Attach event listeners for both the text input and the md-calendar.
   * Events are used instead of ng-model so that updates don't infinitely update the other
   * on a change. This should also be more performant than using a $watch.
   */
  DatePickerCtrl.prototype.attachChangeListeners = function() {
    var self = this;

    self.$scope.$on('md-calendar-change', function(event, date) {
      self.setModelValue(date);
      self.onExternalChange(date);
      self.closeCalendarPane();
    });

    self.ngInputElement.on('input', angular.bind(self, self.resizeInputElement));

    var debounceInterval = angular.isDefined(this.debounceInterval) ?
        this.debounceInterval : DEFAULT_DEBOUNCE_INTERVAL;
    self.ngInputElement.on('input', self.$mdUtil.debounce(self.handleInputEvent,
        debounceInterval, self));
  };

  /** Attach event listeners for user interaction. */
  DatePickerCtrl.prototype.attachInteractionListeners = function() {
    var self = this;
    var $scope = this.$scope;
    var keyCodes = this.$mdConstant.KEY_CODE;

    // Add event listener through angular so that we can triggerHandler in unit tests.
    self.ngInputElement.on('keydown', function(event) {
      if (event.altKey && event.keyCode === keyCodes.DOWN_ARROW) {
        self.openCalendarPane(event);
        $scope.$digest();
      }
    });

    if (self.openOnFocus) {
      self.ngInputElement.on('focus', angular.bind(self, self.openCalendarPane));
      self.ngInputElement.on('click', function(event) {
        event.stopPropagation();
      });
      self.ngInputElement.on('pointerdown',function(event) {
        if (event.target && event.target.setPointerCapture) {
          event.target.setPointerCapture(event.pointerId);
        }
      });

      angular.element(self.$window).on('blur', self.windowBlurHandler);

      $scope.$on('$destroy', function() {
        angular.element(self.$window).off('blur', self.windowBlurHandler);
      });
    }

    $scope.$on('md-calendar-close', function() {
      self.closeCalendarPane();
    });
  };

  /**
   * Capture properties set to the date-picker and imperatively handle internal changes.
   * This is done to avoid setting up additional $watches.
   */
  DatePickerCtrl.prototype.installPropertyInterceptors = function() {
    var self = this;

    if (this.$attrs.ngDisabled) {
      // The expression is to be evaluated against the directive element's scope and not
      // the directive's isolate scope.
      var scope = this.$scope.$parent;

      if (scope) {
        scope.$watch(this.$attrs.ngDisabled, function(isDisabled) {
          self.setDisabled(isDisabled);
        });
      }
    }

    Object.defineProperty(this, 'placeholder', {
      get: function() { return self.inputElement.placeholder; },
      set: function(value) { self.inputElement.placeholder = value || ''; }
    });
  };

  /**
   * Sets whether the date-picker is disabled.
   * @param {boolean} isDisabled
   */
  DatePickerCtrl.prototype.setDisabled = function(isDisabled) {
    this.isDisabled = isDisabled;
    this.inputElement.disabled = isDisabled;

    if (this.calendarButton) {
      this.calendarButton.disabled = isDisabled;
    }
  };

  /**
   * Sets the custom ngModel.$error flags to be consumed by ngMessages. Flags are:
   *   - mindate: whether the selected date is before the minimum date.
   *   - maxdate: whether the selected flag is after the maximum date.
   *   - filtered: whether the selected date is allowed by the custom filtering function.
   *   - valid: whether the entered text input is a valid date
   *
   * The 'required' flag is handled automatically by ngModel.
   *
   * @param {Date=} opt_date Date to check. If not given, defaults to the datepicker's model value.
   */
  DatePickerCtrl.prototype.updateErrorState = function(opt_date) {
    var date = opt_date || this.date;

    // Clear any existing errors to get rid of anything that's no longer relevant.
    this.clearErrorState();

    if (this.dateUtil.isValidDate(date)) {
      // Force all dates to midnight in order to ignore the time portion.
      date = this.dateUtil.createDateAtMidnight(date);

      if (this.dateUtil.isValidDate(this.minDate)) {
        var minDate = this.dateUtil.createDateAtMidnight(this.minDate);
        this.ngModelCtrl.$setValidity('mindate', date >= minDate);
      }

      if (this.dateUtil.isValidDate(this.maxDate)) {
        var maxDate = this.dateUtil.createDateAtMidnight(this.maxDate);
        this.ngModelCtrl.$setValidity('maxdate', date <= maxDate);
      }

      if (angular.isFunction(this.dateFilter)) {
        this.ngModelCtrl.$setValidity('filtered', this.dateFilter(date));
      }
    } else {
      // The date is seen as "not a valid date" if there is *something* set
      // (i.e.., not null or undefined), but that something isn't a valid date.
      this.ngModelCtrl.$setValidity('valid', date == null);
    }

    var input = this.inputElement.value;
    var parsedDate = this.locale.parseDate(input);

    if (!this.isInputValid(input, parsedDate) && this.ngModelCtrl.$valid) {
      this.ngModelCtrl.$setValidity('valid', date == null);
    }

    angular.element(this.inputContainer).toggleClass(INVALID_CLASS, !this.ngModelCtrl.$valid);
  };

  /**
   * Check to see if the input is valid as the validation should fail if the model is invalid
   *
   * @param {String} inputString
   * @param {Date} parsedDate
   * @return {boolean} Whether the input is valid
   */
  DatePickerCtrl.prototype.isInputValid = function (inputString, parsedDate) {
    return inputString === '' || (
      this.dateUtil.isValidDate(parsedDate) &&
      this.locale.isDateComplete(inputString) &&
      this.isDateEnabled(parsedDate)
    );
  };

  /** Clears any error flags set by `updateErrorState`. */
  DatePickerCtrl.prototype.clearErrorState = function() {
    this.inputContainer.classList.remove(INVALID_CLASS);
    ['mindate', 'maxdate', 'filtered', 'valid'].forEach(function(field) {
      this.ngModelCtrl.$setValidity(field, true);
    }, this);
  };

  /** Resizes the input element based on the size of its content. */
  DatePickerCtrl.prototype.resizeInputElement = function() {
    this.inputElement.size = this.inputElement.value.length + EXTRA_INPUT_SIZE;
  };

  /**
   * Sets the model value if the user input is a valid date.
   * Adds an invalid class to the input element if not.
   */
  DatePickerCtrl.prototype.handleInputEvent = function() {
    var inputString = this.inputElement.value;
    var parsedDate = inputString ? this.locale.parseDate(inputString) : null;
    this.dateUtil.setDateTimeToMidnight(parsedDate);

    // An input string is valid if it is either empty (representing no date)
    // or if it parses to a valid date that the user is allowed to select.
    var isValidInput = this.isInputValid(inputString, parsedDate);

    // The datepicker's model is only updated when there is a valid input.
    if (isValidInput) {
      this.setModelValue(parsedDate);
      this.date = parsedDate;
    }

    this.updateErrorState(parsedDate);
  };

  /**
   * Check whether date is in range and enabled
   * @param {Date=} opt_date
   * @return {boolean} Whether the date is enabled.
   */
  DatePickerCtrl.prototype.isDateEnabled = function(opt_date) {
    return this.dateUtil.isDateWithinRange(opt_date, this.minDate, this.maxDate) &&
          (!angular.isFunction(this.dateFilter) || this.dateFilter(opt_date));
  };

  /** Position and attach the floating calendar to the document. */
  DatePickerCtrl.prototype.attachCalendarPane = function() {
    var calendarPane = this.calendarPane;
    var body = document.body;

    calendarPane.style.transform = '';
    this.$element.addClass(OPEN_CLASS);
    this.mdInputContainer && this.mdInputContainer.element.addClass(OPEN_CLASS);
    angular.element(body).addClass('md-datepicker-is-showing');

    var elementRect = this.inputContainer.getBoundingClientRect();
    var bodyRect = body.getBoundingClientRect();

    if (!this.topMargin || this.topMargin < 0) {
      this.topMargin = (this.inputMask.parent().prop('clientHeight') - this.ngInputElement.prop('clientHeight')) / 2;
    }

    // Check to see if the calendar pane would go off the screen. If so, adjust position
    // accordingly to keep it within the viewport.
    var paneTop = elementRect.top - bodyRect.top - this.topMargin;
    var paneLeft = elementRect.left - bodyRect.left - this.leftMargin;

    // If ng-material has disabled body scrolling (for example, if a dialog is open),
    // then it's possible that the already-scrolled body has a negative top/left. In this case,
    // we want to treat the "real" top as (0 - bodyRect.top). In a normal scrolling situation,
    // though, the top of the viewport should just be the body's scroll position.
    var viewportTop = (bodyRect.top < 0 && document.body.scrollTop == 0) ?
        -bodyRect.top :
        document.body.scrollTop;

    var viewportLeft = (bodyRect.left < 0 && document.body.scrollLeft == 0) ?
        -bodyRect.left :
        document.body.scrollLeft;

    var viewportBottom = viewportTop + this.$window.innerHeight;
    var viewportRight = viewportLeft + this.$window.innerWidth;

    // Creates an overlay with a hole the same size as element. We remove a pixel or two
    // on each end to make it overlap slightly. The overlay's background is added in
    // the theme in the form of a box-shadow with a huge spread.
    this.inputMask.css({
      position: 'absolute',
      left: this.leftMargin + 'px',
      top: this.topMargin + 'px',
      width: (elementRect.width - 1) + 'px',
      height: (elementRect.height - 2) + 'px'
    });

    // If the right edge of the pane would be off the screen and shifting it left by the
    // difference would not go past the left edge of the screen. If the calendar pane is too
    // big to fit on the screen at all, move it to the left of the screen and scale the entire
    // element down to fit.
    if (paneLeft + CALENDAR_PANE_WIDTH > viewportRight) {
      if (viewportRight - CALENDAR_PANE_WIDTH > 0) {
        paneLeft = viewportRight - CALENDAR_PANE_WIDTH;
      } else {
        paneLeft = viewportLeft;
        var scale = this.$window.innerWidth / CALENDAR_PANE_WIDTH;
        calendarPane.style.transform = 'scale(' + scale + ')';
      }

      calendarPane.classList.add('md-datepicker-pos-adjusted');
    }

    // If the bottom edge of the pane would be off the screen and shifting it up by the
    // difference would not go past the top edge of the screen.
    if (paneTop + CALENDAR_PANE_HEIGHT > viewportBottom &&
        viewportBottom - CALENDAR_PANE_HEIGHT > viewportTop) {
      paneTop = viewportBottom - CALENDAR_PANE_HEIGHT;
      calendarPane.classList.add('md-datepicker-pos-adjusted');
    }

    calendarPane.style.left = paneLeft + 'px';
    calendarPane.style.top = paneTop + 'px';
    document.body.appendChild(calendarPane);

    // Add CSS class after one frame to trigger open animation.
    this.$$rAF(function() {
      calendarPane.classList.add('md-pane-open');
    });
  };

  /** Detach the floating calendar pane from the document. */
  DatePickerCtrl.prototype.detachCalendarPane = function() {
    this.$element.removeClass(OPEN_CLASS);
    this.mdInputContainer && this.mdInputContainer.element.removeClass(OPEN_CLASS);
    angular.element(document.body).removeClass('md-datepicker-is-showing');
    this.calendarPane.classList.remove('md-pane-open');
    this.calendarPane.classList.remove('md-datepicker-pos-adjusted');

    if (this.isCalendarOpen) {
      this.$mdUtil.enableScrolling();
    }

    if (this.calendarPane.parentNode) {
      // Use native DOM removal because we do not want any of the
      // angular state of this element to be disposed.
      this.calendarPane.parentNode.removeChild(this.calendarPane);
    }
  };

  /**
   * Open the floating calendar pane.
   * @param {Event} event
   */
  DatePickerCtrl.prototype.openCalendarPane = function(event) {
    if (!this.isCalendarOpen && !this.isDisabled && !this.inputFocusedOnWindowBlur) {
      this.isCalendarOpen = this.isOpen = true;
      this.calendarPaneOpenedFrom = event.target;

      // Because the calendar pane is attached directly to the body, it is possible that the
      // rest of the component (input, etc) is in a different scrolling container, such as
      // an md-content. This means that, if the container is scrolled, the pane would remain
      // stationary. To remedy this, we disable scrolling while the calendar pane is open, which
      // also matches the native behavior for things like `<select>` on Mac and Windows.
      this.$mdUtil.disableScrollAround(this.calendarPane);

      this.attachCalendarPane();
      this.focusCalendar();
      this.evalAttr('ngFocus');

      // Attach click listener inside of a timeout because, if this open call was triggered by a
      // click, we don't want it to be immediately propagated up to the body and handled.
      var self = this;
      this.$mdUtil.nextTick(function() {
        // Use 'touchstart` in addition to click in order to work on iOS Safari, where click
        // events aren't propagated under most circumstances.
        // See http://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html
        self.documentElement.on('click touchstart', self.bodyClickHandler);
      }, false);

      window.addEventListener(this.windowEventName, this.windowEventHandler);
    }
  };

  /** Close the floating calendar pane. */
  DatePickerCtrl.prototype.closeCalendarPane = function() {
    if (this.isCalendarOpen) {
      var self = this;

      self.detachCalendarPane();
      self.ngModelCtrl.$setTouched();
      self.evalAttr('ngBlur');

      self.documentElement.off('click touchstart', self.bodyClickHandler);
      window.removeEventListener(self.windowEventName, self.windowEventHandler);

      self.calendarPaneOpenedFrom.focus();
      self.calendarPaneOpenedFrom = null;

      if (self.openOnFocus) {
        // Ensures that all focus events have fired before resetting
        // the calendar. Prevents the calendar from reopening immediately
        // in IE when md-open-on-focus is set. Also it needs to trigger
        // a digest, in order to prevent issues where the calendar wasn't
        // showing up on the next open.
        self.$timeout(reset);
      } else {
        reset();
      }
    }

    function reset(){
      self.isCalendarOpen = self.isOpen = false;
    }
  };

  /** Gets the controller instance for the calendar in the floating pane. */
  DatePickerCtrl.prototype.getCalendarCtrl = function() {
    return angular.element(this.calendarPane.querySelector('md-calendar')).controller('mdCalendar');
  };

  /** Focus the calendar in the floating pane. */
  DatePickerCtrl.prototype.focusCalendar = function() {
    // Use a timeout in order to allow the calendar to be rendered, as it is gated behind an ng-if.
    var self = this;
    this.$mdUtil.nextTick(function() {
      self.getCalendarCtrl().focus();
    }, false);
  };

  /**
   * Sets whether the input is currently focused.
   * @param {boolean} isFocused
   */
  DatePickerCtrl.prototype.setFocused = function(isFocused) {
    if (!isFocused) {
      this.ngModelCtrl.$setTouched();
    }

    // The ng* expressions shouldn't be evaluated when mdOpenOnFocus is on,
    // because they also get called when the calendar is opened/closed.
    if (!this.openOnFocus) {
      this.evalAttr(isFocused ? 'ngFocus' : 'ngBlur');
    }

    this.isFocused = isFocused;
  };

  /**
   * Handles a click on the document body when the floating calendar pane is open.
   * Closes the floating calendar pane if the click is not inside of it.
   * @param {MouseEvent} event
   */
  DatePickerCtrl.prototype.handleBodyClick = function(event) {
    if (this.isCalendarOpen) {
      var isInCalendar = this.$mdUtil.getClosest(event.target, 'md-calendar');

      if (!isInCalendar) {
        this.closeCalendarPane();
      }

      this.$scope.$digest();
    }
  };

  /**
   * Handles the event when the user navigates away from the current tab. Keeps track of
   * whether the input was focused when the event happened, in order to prevent the calendar
   * from re-opening.
   */
  DatePickerCtrl.prototype.handleWindowBlur = function() {
    this.inputFocusedOnWindowBlur = document.activeElement === this.inputElement;
  };

  /**
   * Evaluates an attribute expression against the parent scope.
   * @param {String} attr Name of the attribute to be evaluated.
   */
  DatePickerCtrl.prototype.evalAttr = function(attr) {
    if (this.$attrs[attr]) {
      this.$scope.$parent.$eval(this.$attrs[attr]);
    }
  };

  /**
   * Sets the ng-model value by first converting the date object into a string. Converting it
   * is necessary, in order to pass AngularJS's `input[type="date"]` validations. AngularJS turns
   * the value into a Date object afterwards, before setting it on the model.
   * @param {Date=} value Date to be set as the model value.
   */
  DatePickerCtrl.prototype.setModelValue = function(value) {
    var timezone = this.$mdUtil.getModelOption(this.ngModelCtrl, 'timezone');
    this.ngModelCtrl.$setViewValue(this.ngDateFilter(value, 'yyyy-MM-dd', timezone));
  };

  /**
   * Updates the datepicker when a model change occurred externally.
   * @param {Date=} value Value that was set to the model.
   */
  DatePickerCtrl.prototype.onExternalChange = function(value) {
    var timezone = this.$mdUtil.getModelOption(this.ngModelCtrl, 'timezone');

    this.date = value;
    this.inputElement.value = this.locale.formatDate(value, timezone);
    this.mdInputContainer && this.mdInputContainer.setHasValue(!!value);
    this.resizeInputElement();
    this.updateErrorState();
  };
})();

})();
(function(){
"use strict";

/**
 * @ngdoc module
 * @name material.components.dialog
 */
MdDialogDirective.$inject = ["$$rAF", "$mdTheming", "$mdDialog"];
MdDialogProvider.$inject = ["$$interimElementProvider"];
angular
  .module('material.components.dialog', [
    'material.core',
    'material.components.backdrop'
  ])
  .directive('mdDialog', MdDialogDirective)
  .provider('$mdDialog', MdDialogProvider);

/**
 * @ngdoc directive
 * @name mdDialog
 * @module material.components.dialog
 *
 * @restrict E
 *
 * @description
 * `<md-dialog>` - The dialog's template must be inside this element.
 *
 * Inside, use an `<md-dialog-content>` element for the dialog's content, and use
 * an `<md-dialog-actions>` element for the dialog's actions.
 *
 * ## CSS
 * - `.md-dialog-content` - class that sets the padding on the content as the spec file
 *
 * ## Notes
 * - If you specify an `id` for the `<md-dialog>`, the `<md-dialog-content>` will have the same `id`
 * prefixed with `dialogContent_`.
 *
 * @usage
 * ### Dialog template
 * <hljs lang="html">
 * <md-dialog aria-label="List dialog">
 *   <md-dialog-content>
 *     <md-list>
 *       <md-list-item ng-repeat="item in items">
 *         <p>Number {{item}}</p>
 *       </md-list-item>
 *     </md-list>
 *   </md-dialog-content>
 *   <md-dialog-actions>
 *     <md-button ng-click="closeDialog()" class="md-primary">Close Dialog</md-button>
 *   </md-dialog-actions>
 * </md-dialog>
 * </hljs>
 */
function MdDialogDirective($$rAF, $mdTheming, $mdDialog) {
  return {
    restrict: 'E',
    link: function(scope, element) {
      element.addClass('_md');     // private md component indicator for styling

      $mdTheming(element);
      $$rAF(function() {
        var images;
        var content = element[0].querySelector('md-dialog-content');

        if (content) {
          images = content.getElementsByTagName('img');
          addOverflowClass();
          // delayed image loading may impact scroll height, check after images are loaded
          angular.element(images).on('load', addOverflowClass);
        }

        scope.$on('$destroy', function() {
          $mdDialog.destroy(element);
        });

        /**
         *
         */
        function addOverflowClass() {
          element.toggleClass('md-content-overflow', content.scrollHeight > content.clientHeight);
        }


      });
    }
  };
}

/**
 * @ngdoc service
 * @name $mdDialog
 * @module material.components.dialog
 *
 * @description
 * `$mdDialog` opens a dialog over the app to inform users about critical information or require
 *  them to make decisions. There are two approaches for setup: a simple promise API
 *  and regular object syntax.
 *
 * ## Restrictions
 *
 * - The dialog is always given an isolate scope.
 * - The dialog's template must have an outer `<md-dialog>` element.
 *   Inside, use an `<md-dialog-content>` element for the dialog's content, and use
 *   an `<md-dialog-actions>` element for the dialog's actions.
 * - Dialogs must cover the entire application to keep interactions inside of them.
 * Use the `parent` option to change where dialogs are appended.
 *
 * ## Sizing
 * - Complex dialogs can be sized with `flex="percentage"`, i.e. `flex="66"`.
 * - Default max-width is 80% of the `rootElement` or `parent`.
 *
 * ## CSS
 * - `.md-dialog-content` - class that sets the padding on the content as the spec file
 *
 * @usage
 * <hljs lang="html">
 * <div  ng-app="demoApp" ng-controller="EmployeeController">
 *   <div>
 *     <md-button ng-click="showAlert()" class="md-raised md-warn">
 *       Employee Alert!
 *       </md-button>
 *   </div>
 *   <div>
 *     <md-button ng-click="showDialog($event)" class="md-raised">
 *       Custom Dialog
 *       </md-button>
 *   </div>
 *   <div>
 *     <md-button ng-click="closeAlert()" ng-disabled="!hasAlert()" class="md-raised">
 *       Close Alert
 *     </md-button>
 *   </div>
 *   <div>
 *     <md-button ng-click="showGreeting($event)" class="md-raised md-primary" >
 *       Greet Employee
 *       </md-button>
 *   </div>
 * </div>
 * </hljs>
 *
 * ### JavaScript: object syntax
 * <hljs lang="js">
 * (function(angular, undefined){
 *   "use strict";
 *
 *   angular
 *    .module('demoApp', ['ngMaterial'])
 *    .controller('AppCtrl', AppController);
 *
 *   function AppController($scope, $mdDialog) {
 *     var alert;
 *     $scope.showAlert = showAlert;
 *     $scope.showDialog = showDialog;
 *     $scope.items = [1, 2, 3];
 *
 *     // Internal method
 *     function showAlert() {
 *       alert = $mdDialog.alert({
 *         title: 'Attention',
 *         textContent: 'This is an example of how easy dialogs can be!',
 *         ok: 'Close'
 *       });
 *
 *       $mdDialog
 *         .show( alert )
 *         .finally(function() {
 *           alert = undefined;
 *         });
 *     }
 *
 *     function showDialog($event) {
 *        var parentEl = angular.element(document.body);
 *        $mdDialog.show({
 *          parent: parentEl,
 *          targetEvent: $event,
 *          template:
 *            '<md-dialog aria-label="List dialog">' +
 *            '  <md-dialog-content>'+
 *            '    <md-list>'+
 *            '      <md-list-item ng-repeat="item in items">'+
 *            '       <p>Number {{item}}</p>' +
 *            '      </md-item>'+
 *            '    </md-list>'+
 *            '  </md-dialog-content>' +
 *            '  <md-dialog-actions>' +
 *            '    <md-button ng-click="closeDialog()" class="md-primary">' +
 *            '      Close Dialog' +
 *            '    </md-button>' +
 *            '  </md-dialog-actions>' +
 *            '</md-dialog>',
 *          locals: {
 *            items: $scope.items
 *          },
 *          controller: DialogController
 *       });
 *       function DialogController($scope, $mdDialog, items) {
 *         $scope.items = items;
 *         $scope.closeDialog = function() {
 *           $mdDialog.hide();
 *         }
 *       }
 *     }
 *   }
 * })(angular);
 * </hljs>
 *
 * ### Multiple Dialogs
 * Using the `multiple` option for the `$mdDialog` service allows developers to show multiple dialogs
 * at the same time.
 *
 * <hljs lang="js">
 *   // From plain options
 *   $mdDialog.show({
 *     multiple: true
 *   });
 *
 *   // From a dialog preset
 *   $mdDialog.show(
 *     $mdDialog
 *       .alert()
 *       .multiple(true)
 *   );
 *
 * </hljs>
 *
 * ### Pre-Rendered Dialogs
 * By using the `contentElement` option, it is possible to use an already existing element in the DOM.
 *
 * > Pre-rendered dialogs will be not linked to any scope and will not instantiate any new controller.<br/>
 * > You can manually link the elements to a scope or instantiate a controller from the template (`ng-controller`)
 *
 * <hljs lang="js">
 *   $scope.showPrerenderedDialog = function() {
 *     $mdDialog.show({
 *       contentElement: '#myStaticDialog',
 *       parent: angular.element(document.body)
 *     });
 *   };
 * </hljs>
 *
 * When using a string as value, `$mdDialog` will automatically query the DOM for the specified CSS selector.
 *
 * <hljs lang="html">
 *   <div style="visibility: hidden">
 *     <div class="md-dialog-container" id="myStaticDialog">
 *       <md-dialog>
 *         This is a pre-rendered dialog.
 *       </md-dialog>
 *     </div>
 *   </div>
 * </hljs>
 *
 * **Notice**: It is important, to use the `.md-dialog-container` as the content element, otherwise the dialog
 * will not show up.
 *
 * It also possible to use a DOM element for the `contentElement` option.
 * - `contentElement: document.querySelector('#myStaticDialog')`
 * - `contentElement: angular.element(TEMPLATE)`
 *
 * When using a `template` as content element, it will be not compiled upon open.
 * This allows you to compile the element yourself and use it each time the dialog opens.
 *
 * ### Custom Presets
 * Developers are also able to create their own preset, which can be easily used without repeating
 * their options each time.
 *
 * <hljs lang="js">
 *   $mdDialogProvider.addPreset('testPreset', {
 *     options: function() {
 *       return {
 *         template:
 *           '<md-dialog>' +
 *             'This is a custom preset' +
 *           '</md-dialog>',
 *         controllerAs: 'dialog',
 *         bindToController: true,
 *         clickOutsideToClose: true,
 *         escapeToClose: true
 *       };
 *     }
 *   });
 * </hljs>
 *
 * After you created your preset at config phase, you can easily access it.
 *
 * <hljs lang="js">
 *   $mdDialog.show(
 *     $mdDialog.testPreset()
 *   );
 * </hljs>
 *
 * ### JavaScript: promise API syntax, custom dialog template
 * <hljs lang="js">
 * (function(angular, undefined){
 *   "use strict";
 *
 *   angular
 *     .module('demoApp', ['ngMaterial'])
 *     .controller('EmployeeController', EmployeeEditor)
 *     .controller('GreetingController', GreetingController);
 *
 *   // Fictitious Employee Editor to show how to use simple and complex dialogs.
 *
 *   function EmployeeEditor($scope, $mdDialog) {
 *     var alert;
 *
 *     $scope.showAlert = showAlert;
 *     $scope.closeAlert = closeAlert;
 *     $scope.showGreeting = showCustomGreeting;
 *
 *     $scope.hasAlert = function() { return !!alert };
 *     $scope.userName = $scope.userName || 'Bobby';
 *
 *     // Dialog #1 - Show simple alert dialog and cache
 *     // reference to dialog instance
 *
 *     function showAlert() {
 *       alert = $mdDialog.alert()
 *         .title('Attention, ' + $scope.userName)
 *         .textContent('This is an example of how easy dialogs can be!')
 *         .ok('Close');
 *
 *       $mdDialog
 *           .show( alert )
 *           .finally(function() {
 *             alert = undefined;
 *           });
 *     }
 *
 *     // Close the specified dialog instance and resolve with 'finished' flag
 *     // Normally this is not needed, just use '$mdDialog.hide()' to close
 *     // the most recent dialog popup.
 *
 *     function closeAlert() {
 *       $mdDialog.hide( alert, "finished" );
 *       alert = undefined;
 *     }
 *
 *     // Dialog #2 - Demonstrate more complex dialogs construction and popup.
 *
 *     function showCustomGreeting($event) {
 *         $mdDialog.show({
 *           targetEvent: $event,
 *           template:
 *             '<md-dialog>' +
 *
 *             '  <md-dialog-content>Hello {{ employee }}!</md-dialog-content>' +
 *
 *             '  <md-dialog-actions>' +
 *             '    <md-button ng-click="closeDialog()" class="md-primary">' +
 *             '      Close Greeting' +
 *             '    </md-button>' +
 *             '  </md-dialog-actions>' +
 *             '</md-dialog>',
 *           controller: 'GreetingController',
 *           onComplete: afterShowAnimation,
 *           locals: { employee: $scope.userName }
 *         });
 *
 *         // When the 'enter' animation finishes...
 *
 *         function afterShowAnimation(scope, element, options) {
 *            // post-show code here: DOM element focus, etc.
 *         }
 *     }
 *
 *     // Dialog #3 - Demonstrate use of ControllerAs and passing $scope to dialog
 *     //             Here we used ng-controller="GreetingController as vm" and
 *     //             $scope.vm === <controller instance>
 *
 *     function showCustomGreeting() {
 *
 *        $mdDialog.show({
 *           clickOutsideToClose: true,
 *
 *           scope: $scope,        // use parent scope in template
 *           preserveScope: true,  // do not forget this if use parent scope

 *           // Since GreetingController is instantiated with ControllerAs syntax
 *           // AND we are passing the parent '$scope' to the dialog, we MUST
 *           // use 'vm.<xxx>' in the template markup
 *
 *           template: '<md-dialog>' +
 *                     '  <md-dialog-content>' +
 *                     '     Hi There {{vm.employee}}' +
 *                     '  </md-dialog-content>' +
 *                     '</md-dialog>',
 *
 *           controller: function DialogController($scope, $mdDialog) {
 *             $scope.closeDialog = function() {
 *               $mdDialog.hide();
 *             }
 *           }
 *        });
 *     }
 *
 *   }
 *
 *   // Greeting controller used with the more complex 'showCustomGreeting()' custom dialog
 *
 *   function GreetingController($scope, $mdDialog, employee) {
 *     // Assigned from construction <code>locals</code> options...
 *     $scope.employee = employee;
 *
 *     $scope.closeDialog = function() {
 *       // Easily hides most recent dialog shown...
 *       // no specific instance reference is needed.
 *       $mdDialog.hide();
 *     };
 *   }
 *
 * })(angular);
 * </hljs>
 */

/**
 * @ngdoc method
 * @name $mdDialog#alert
 *
 * @description
 * Builds a preconfigured dialog with the specified message.
 *
 * @returns {obj} an `$mdDialogPreset` with the chainable configuration methods:
 *
 * - $mdDialogPreset#title(string) - Sets the alert title.
 * - $mdDialogPreset#textContent(string) - Sets the alert message.
 * - $mdDialogPreset#htmlContent(string) - Sets the alert message as HTML. Requires ngSanitize
 *     module to be loaded. HTML is not run through Angular's compiler.
 * - $mdDialogPreset#ok(string) - Sets the alert "Okay" button text.
 * - $mdDialogPreset#theme(string) - Sets the theme of the alert dialog.
 * - $mdDialogPreset#targetEvent(DOMClickEvent=) - A click's event object. When passed in as an option,
 *     the location of the click will be used as the starting point for the opening animation
 *     of the the dialog.
 *
 */

/**
 * @ngdoc method
 * @name $mdDialog#confirm
 *
 * @description
 * Builds a preconfigured dialog with the specified message. You can call show and the promise returned
 * will be resolved only if the user clicks the confirm action on the dialog.
 *
 * @returns {obj} an `$mdDialogPreset` with the chainable configuration methods:
 *
 * Additionally, it supports the following methods:
 *
 * - $mdDialogPreset#title(string) - Sets the confirm title.
 * - $mdDialogPreset#textContent(string) - Sets the confirm message.
 * - $mdDialogPreset#htmlContent(string) - Sets the confirm message as HTML. Requires ngSanitize
 *     module to be loaded. HTML is not run through Angular's compiler.
 * - $mdDialogPreset#ok(string) - Sets the confirm "Okay" button text.
 * - $mdDialogPreset#cancel(string) - Sets the confirm "Cancel" button text.
 * - $mdDialogPreset#theme(string) - Sets the theme of the confirm dialog.
 * - $mdDialogPreset#targetEvent(DOMClickEvent=) - A click's event object. When passed in as an option,
 *     the location of the click will be used as the starting point for the opening animation
 *     of the the dialog.
 *
 */

/**
 * @ngdoc method
 * @name $mdDialog#prompt
 *
 * @description
 * Builds a preconfigured dialog with the specified message and input box. You can call show and the promise returned
 * will be resolved only if the user clicks the prompt action on the dialog, passing the input value as the first argument.
 *
 * @returns {obj} an `$mdDialogPreset` with the chainable configuration methods:
 *
 * Additionally, it supports the following methods:
 *
 * - $mdDialogPreset#title(string) - Sets the prompt title.
 * - $mdDialogPreset#textContent(string) - Sets the prompt message.
 * - $mdDialogPreset#htmlContent(string) - Sets the prompt message as HTML. Requires ngSanitize
 *     module to be loaded. HTML is not run through Angular's compiler.
 * - $mdDialogPreset#placeholder(string) - Sets the placeholder text for the input.
 * - $mdDialogPreset#required(boolean) - Sets the input required value.
 * - $mdDialogPreset#initialValue(string) - Sets the initial value for the prompt input.
 * - $mdDialogPreset#ok(string) - Sets the prompt "Okay" button text.
 * - $mdDialogPreset#cancel(string) - Sets the prompt "Cancel" button text.
 * - $mdDialogPreset#theme(string) - Sets the theme of the prompt dialog.
 * - $mdDialogPreset#targetEvent(DOMClickEvent=) - A click's event object. When passed in as an option,
 *     the location of the click will be used as the starting point for the opening animation
 *     of the the dialog.
 *
 */

/**
 * @ngdoc method
 * @name $mdDialog#show
 *
 * @description
 * Show a dialog with the specified options.
 *
 * @param {object} optionsOrPreset Either provide an `$mdDialogPreset` returned from `alert()`, and
 * `confirm()`, or an options object with the following properties:
 *   - `templateUrl` - `{string=}`: The url of a template that will be used as the content
 *   of the dialog.
 *   - `template` - `{string=}`: HTML template to show in the dialog. This **must** be trusted HTML
 *      with respect to Angular's [$sce service](https://docs.angularjs.org/api/ng/service/$sce).
 *      This template should **never** be constructed with any kind of user input or user data.
 *   - `contentElement` - `{string|Element}`: Instead of using a template, which will be compiled each time a
 *     dialog opens, you can also use a DOM element.<br/>
 *     * When specifying an element, which is present on the DOM, `$mdDialog` will temporary fetch the element into
 *       the dialog and restores it at the old DOM position upon close.
 *     * When specifying a string, the string be used as a CSS selector, to lookup for the element in the DOM.
 *   - `autoWrap` - `{boolean=}`: Whether or not to automatically wrap the template with a
 *     `<md-dialog>` tag if one is not provided. Defaults to true. Can be disabled if you provide a
 *     custom dialog directive.
 *   - `targetEvent` - `{DOMClickEvent=}`: A click's event object. When passed in as an option,
 *     the location of the click will be used as the starting point for the opening animation
 *     of the the dialog.
 *   - `openFrom` - `{string|Element|object}`: The query selector, DOM element or the Rect object
 *     that is used to determine the bounds (top, left, height, width) from which the Dialog will
 *     originate.
 *   - `closeTo` - `{string|Element|object}`: The query selector, DOM element or the Rect object
 *     that is used to determine the bounds (top, left, height, width) to which the Dialog will
 *     target.
 *   - `scope` - `{object=}`: the scope to link the template / controller to. If none is specified,
 *     it will create a new isolate scope.
 *     This scope will be destroyed when the dialog is removed unless `preserveScope` is set to true.
 *   - `preserveScope` - `{boolean=}`: whether to preserve the scope when the element is removed. Default is false
 *   - `disableParentScroll` - `{boolean=}`: Whether to disable scrolling while the dialog is open.
 *     Default true.
 *   - `hasBackdrop` - `{boolean=}`: Whether there should be an opaque backdrop behind the dialog.
 *     Default true.
 *   - `clickOutsideToClose` - `{boolean=}`: Whether the user can click outside the dialog to
 *     close it. Default false.
 *   - `escapeToClose` - `{boolean=}`: Whether the user can press escape to close the dialog.
 *     Default true.
 *   - `focusOnOpen` - `{boolean=}`: An option to override focus behavior on open. Only disable if
 *     focusing some other way, as focus management is required for dialogs to be accessible.
 *     Defaults to true.
 *   - `controller` - `{function|string=}`: The controller to associate with the dialog. The controller
 *     will be injected with the local `$mdDialog`, which passes along a scope for the dialog.
 *   - `locals` - `{object=}`: An object containing key/value pairs. The keys will be used as names
 *     of values to inject into the controller. For example, `locals: {three: 3}` would inject
 *     `three` into the controller, with the value 3. If `bindToController` is true, they will be
 *     copied to the controller instead.
 *   - `bindToController` - `bool`: bind the locals to the controller, instead of passing them in.
 *   - `resolve` - `{function=}`: Similar to locals, except it takes as values functions that return promises, and the
 *      dialog will not open until all of the promises resolve.
 *   - `controllerAs` - `{string=}`: An alias to assign the controller to on the scope.
 *   - `parent` - `{element=}`: The element to append the dialog to. Defaults to appending
 *     to the root element of the application.
 *   - `onShowing` - `function(scope, element)`: Callback function used to announce the show() action is
 *     starting.
 *   - `onComplete` - `function(scope, element)`: Callback function used to announce when the show() action is
 *     finished.
 *   - `onRemoving` - `function(element, removePromise)`: Callback function used to announce the
 *      close/hide() action is starting. This allows developers to run custom animations
 *      in parallel with the close animations.
 *   - `fullscreen` `{boolean=}`: An option to toggle whether the dialog should show in fullscreen
 *      or not. Defaults to `false`.
 *   - `multiple` `{boolean=}`: An option to allow this dialog to display over one that's currently open.
 * @returns {promise} A promise that can be resolved with `$mdDialog.hide()` or
 * rejected with `$mdDialog.cancel()`.
 */

/**
 * @ngdoc method
 * @name $mdDialog#hide
 *
 * @description
 * Hide an existing dialog and resolve the promise returned from `$mdDialog.show()`.
 *
 * @param {*=} response An argument for the resolved promise.
 *
 * @returns {promise} A promise that is resolved when the dialog has been closed.
 */

/**
 * @ngdoc method
 * @name $mdDialog#cancel
 *
 * @description
 * Hide an existing dialog and reject the promise returned from `$mdDialog.show()`.
 *
 * @param {*=} response An argument for the rejected promise.
 *
 * @returns {promise} A promise that is resolved when the dialog has been closed.
 */

function MdDialogProvider($$interimElementProvider) {
  // Elements to capture and redirect focus when the user presses tab at the dialog boundary.
  MdDialogController.$inject = ["$mdDialog", "$mdConstant"];
  dialogDefaultOptions.$inject = ["$mdDialog", "$mdAria", "$mdUtil", "$mdConstant", "$animate", "$document", "$window", "$rootElement", "$log", "$injector", "$mdTheming", "$interpolate", "$mdInteraction"];
  var topFocusTrap, bottomFocusTrap;

  return $$interimElementProvider('$mdDialog')
    .setDefaults({
      methods: ['disableParentScroll', 'hasBackdrop', 'clickOutsideToClose', 'escapeToClose',
          'targetEvent', 'closeTo', 'openFrom', 'parent', 'fullscreen', 'multiple'],
      options: dialogDefaultOptions
    })
    .addPreset('alert', {
      methods: ['title', 'htmlContent', 'textContent', 'content', 'ariaLabel', 'ok', 'theme',
          'css'],
      options: advancedDialogOptions
    })
    .addPreset('confirm', {
      methods: ['title', 'htmlContent', 'textContent', 'content', 'ariaLabel', 'ok', 'cancel',
          'theme', 'css'],
      options: advancedDialogOptions
    })
    .addPreset('prompt', {
      methods: ['title', 'htmlContent', 'textContent', 'initialValue', 'content', 'placeholder', 'ariaLabel',
          'ok', 'cancel', 'theme', 'css', 'required'],
      options: advancedDialogOptions
    });

  /* @ngInject */
  function advancedDialogOptions() {
    return {
      template: [
        '<md-dialog md-theme="{{ dialog.theme || dialog.defaultTheme }}" aria-label="{{ dialog.ariaLabel }}" ng-class="dialog.css">',
        '  <md-dialog-content class="md-dialog-content" role="document" tabIndex="-1">',
        '    <h2 class="md-title">{{ dialog.title }}</h2>',
        '    <div ng-if="::dialog.mdHtmlContent" class="md-dialog-content-body" ',
        '        ng-bind-html="::dialog.mdHtmlContent"></div>',
        '    <div ng-if="::!dialog.mdHtmlContent" class="md-dialog-content-body">',
        '      <p>{{::dialog.mdTextContent}}</p>',
        '    </div>',
        '    <md-input-container md-no-float ng-if="::dialog.$type == \'prompt\'" class="md-prompt-input-container">',
        '      <input ng-keypress="dialog.keypress($event)" md-autofocus ng-model="dialog.result" ' +
        '             placeholder="{{::dialog.placeholder}}" ng-required="dialog.required">',
        '    </md-input-container>',
        '  </md-dialog-content>',
        '  <md-dialog-actions>',
        '    <md-button ng-if="dialog.$type === \'confirm\' || dialog.$type === \'prompt\'"' +
        '               ng-click="dialog.abort()" class="md-primary md-cancel-button">',
        '      {{ dialog.cancel }}',
        '    </md-button>',
        '    <md-button ng-click="dialog.hide()" class="md-primary md-confirm-button" md-autofocus="dialog.$type===\'alert\'"' +
        '               ng-disabled="dialog.required && !dialog.result">',
        '      {{ dialog.ok }}',
        '    </md-button>',
        '  </md-dialog-actions>',
        '</md-dialog>'
      ].join('').replace(/\s\s+/g, ''),
      controller: MdDialogController,
      controllerAs: 'dialog',
      bindToController: true,
    };
  }

  /**
   * Controller for the md-dialog interim elements
   * @ngInject
   */
  function MdDialogController($mdDialog, $mdConstant) {
    // For compatibility with AngularJS 1.6+, we should always use the $onInit hook in
    // interimElements. The $mdCompiler simulates the $onInit hook for all versions.
    this.$onInit = function() {
      var isPrompt = this.$type == 'prompt';

      if (isPrompt && this.initialValue) {
        this.result = this.initialValue;
      }

      this.hide = function() {
        $mdDialog.hide(isPrompt ? this.result : true);
      };
      this.abort = function() {
        $mdDialog.cancel();
      };
      this.keypress = function($event) {
        var invalidPrompt = isPrompt && this.required && !angular.isDefined(this.result);

        if ($event.keyCode === $mdConstant.KEY_CODE.ENTER && !invalidPrompt) {
          $mdDialog.hide(this.result);
        }
      };
    };
  }

  /* @ngInject */
  function dialogDefaultOptions($mdDialog, $mdAria, $mdUtil, $mdConstant, $animate, $document, $window, $rootElement,
                                $log, $injector, $mdTheming, $interpolate, $mdInteraction) {

    return {
      hasBackdrop: true,
      isolateScope: true,
      onCompiling: beforeCompile,
      onShow: onShow,
      onShowing: beforeShow,
      onRemove: onRemove,
      clickOutsideToClose: false,
      escapeToClose: true,
      targetEvent: null,
      closeTo: null,
      openFrom: null,
      focusOnOpen: true,
      disableParentScroll: true,
      autoWrap: true,
      fullscreen: false,
      transformTemplate: function(template, options) {
        // Make the dialog container focusable, because otherwise the focus will be always redirected to
        // an element outside of the container, and the focus trap won't work probably..
        // Also the tabindex is needed for the `escapeToClose` functionality, because
        // the keyDown event can't be triggered when the focus is outside of the container.
        var startSymbol = $interpolate.startSymbol();
        var endSymbol = $interpolate.endSymbol();
        var theme = startSymbol + (options.themeWatch ? '' : '::') + 'theme' + endSymbol;
        var themeAttr = (options.hasTheme) ? 'md-theme="'+theme+'"': '';
        return '<div class="md-dialog-container" tabindex="-1" ' + themeAttr + '>' + validatedTemplate(template) + '</div>';

        /**
         * The specified template should contain a <md-dialog> wrapper element....
         */
        function validatedTemplate(template) {
          if (options.autoWrap && !/<\/md-dialog>/g.test(template)) {
            return '<md-dialog>' + (template || '') + '</md-dialog>';
          } else {
            return template || '';
          }
        }
      }
    };

    function beforeCompile(options) {
      // Automatically apply the theme, if the user didn't specify a theme explicitly.
      // Those option changes need to be done, before the compilation has started, because otherwise
      // the option changes will be not available in the $mdCompilers locales.
      options.defaultTheme = $mdTheming.defaultTheme();

      detectTheming(options);
    }

    function beforeShow(scope, element, options, controller) {

      if (controller) {
        var mdHtmlContent = controller.htmlContent || options.htmlContent || '';
        var mdTextContent = controller.textContent || options.textContent ||
            controller.content || options.content || '';

        if (mdHtmlContent && !$injector.has('$sanitize')) {
          throw Error('The ngSanitize module must be loaded in order to use htmlContent.');
        }

        if (mdHtmlContent && mdTextContent) {
          throw Error('md-dialog cannot have both `htmlContent` and `textContent`');
        }

        // Only assign the content if nothing throws, otherwise it'll still be compiled.
        controller.mdHtmlContent = mdHtmlContent;
        controller.mdTextContent = mdTextContent;
      }
    }

    /** Show method for dialogs */
    function onShow(scope, element, options, controller) {
      angular.element($document[0].body).addClass('md-dialog-is-showing');

      var dialogElement = element.find('md-dialog');

      // Once a dialog has `ng-cloak` applied on his template the dialog animation will not work properly.
      // This is a very common problem, so we have to notify the developer about this.
      if (dialogElement.hasClass('ng-cloak')) {
        var message = '$mdDialog: using `<md-dialog ng-cloak>` will affect the dialog opening animations.';
        $log.warn(message, element[0]);
      }

      captureParentAndFromToElements(options);
      configureAria(dialogElement, options);
      showBackdrop(scope, element, options);
      activateListeners(element, options);

      return dialogPopIn(element, options)
        .then(function() {
          lockScreenReader(element, options);
          warnDeprecatedActions();
          focusOnOpen();
        });

      /**
       * Check to see if they used the deprecated .md-actions class and log a warning
       */
      function warnDeprecatedActions() {
        if (element[0].querySelector('.md-actions')) {
          $log.warn('Using a class of md-actions is deprecated, please use <md-dialog-actions>.');
        }
      }

      /**
       * For alerts, focus on content... otherwise focus on
       * the close button (or equivalent)
       */
      function focusOnOpen() {
        if (options.focusOnOpen) {
          var target = $mdUtil.findFocusTarget(element) || findCloseButton() || dialogElement;
          target.focus();
        }

        /**
         * If no element with class dialog-close, try to find the last
         * button child in md-actions and assume it is a close button.
         *
         * If we find no actions at all, log a warning to the console.
         */
        function findCloseButton() {
          return element[0].querySelector('.dialog-close, md-dialog-actions button:last-child');
        }
      }
    }

    /**
     * Remove function for all dialogs
     */
    function onRemove(scope, element, options) {
      options.deactivateListeners();
      options.unlockScreenReader();
      options.hideBackdrop(options.$destroy);

      // Remove the focus traps that we added earlier for keeping focus within the dialog.
      if (topFocusTrap && topFocusTrap.parentNode) {
        topFocusTrap.parentNode.removeChild(topFocusTrap);
      }

      if (bottomFocusTrap && bottomFocusTrap.parentNode) {
        bottomFocusTrap.parentNode.removeChild(bottomFocusTrap);
      }

      // For navigation $destroy events, do a quick, non-animated removal,
      // but for normal closes (from clicks, etc) animate the removal
      return options.$destroy ? detachAndClean() : animateRemoval().then(detachAndClean);

      /**
       * For normal closes, animate the removal.
       * For forced closes (like $destroy events), skip the animations
       */
      function animateRemoval() {
        return dialogPopOut(element, options);
      }

      /**
       * Detach the element
       */
      function detachAndClean() {
        angular.element($document[0].body).removeClass('md-dialog-is-showing');

        // Reverse the container stretch if using a content element.
        if (options.contentElement) {
          options.reverseContainerStretch();
        }

        // Exposed cleanup function from the $mdCompiler.
        options.cleanupElement();

        // Restores the focus to the origin element if the last interaction upon opening was a keyboard.
        if (!options.$destroy && options.originInteraction === 'keyboard') {
          options.origin.focus();
        }
      }
    }

    function detectTheming(options) {
      // Once the user specifies a targetEvent, we will automatically try to find the correct
      // nested theme.
      var targetEl;
      if (options.targetEvent && options.targetEvent.target) {
        targetEl = angular.element(options.targetEvent.target);
      }

      var themeCtrl = targetEl && targetEl.controller('mdTheme');

      options.hasTheme = (!!themeCtrl);

      if (!options.hasTheme) {
        return;
      }

      options.themeWatch = themeCtrl.$shouldWatch;

      var theme = options.theme || themeCtrl.$mdTheme;

      if (theme) {
        options.scope.theme = theme;
      }

      var unwatch = themeCtrl.registerChanges(function (newTheme) {
        options.scope.theme = newTheme;

        if (!options.themeWatch) {
          unwatch();
        }
      });
    }

    /**
     * Capture originator/trigger/from/to element information (if available)
     * and the parent container for the dialog; defaults to the $rootElement
     * unless overridden in the options.parent
     */
    function captureParentAndFromToElements(options) {
          options.origin = angular.extend({
            element: null,
            bounds: null,
            focus: angular.noop
          }, options.origin || {});

          options.parent   = getDomElement(options.parent, $rootElement);
          options.closeTo  = getBoundingClientRect(getDomElement(options.closeTo));
          options.openFrom = getBoundingClientRect(getDomElement(options.openFrom));

          if (options.targetEvent) {
            options.origin = getBoundingClientRect(options.targetEvent.target, options.origin);
            options.originInteraction = $mdInteraction.getLastInteractionType();
          }


          /**
           * Identify the bounding RECT for the target element
           *
           */
          function getBoundingClientRect (element, orig) {
            var source = angular.element((element || {}));
            if (source && source.length) {
              // Compute and save the target element's bounding rect, so that if the
              // element is hidden when the dialog closes, we can shrink the dialog
              // back to the same position it expanded from.
              //
              // Checking if the source is a rect object or a DOM element
              var bounds = {top:0,left:0,height:0,width:0};
              var hasFn = angular.isFunction(source[0].getBoundingClientRect);

              return angular.extend(orig || {}, {
                  element : hasFn ? source : undefined,
                  bounds  : hasFn ? source[0].getBoundingClientRect() : angular.extend({}, bounds, source[0]),
                  focus   : angular.bind(source, source.focus),
              });
            }
          }

          /**
           * If the specifier is a simple string selector, then query for
           * the DOM element.
           */
          function getDomElement(element, defaultElement) {
            if (angular.isString(element)) {
              element = $document[0].querySelector(element);
            }

            // If we have a reference to a raw dom element, always wrap it in jqLite
            return angular.element(element || defaultElement);
          }

        }

    /**
     * Listen for escape keys and outside clicks to auto close
     */
    function activateListeners(element, options) {
      var window = angular.element($window);
      var onWindowResize = $mdUtil.debounce(function() {
        stretchDialogContainerToViewport(element, options);
      }, 60);

      var removeListeners = [];
      var smartClose = function() {
        // Only 'confirm' dialogs have a cancel button... escape/clickOutside will
        // cancel or fallback to hide.
        var closeFn = (options.$type == 'alert') ? $mdDialog.hide : $mdDialog.cancel;
        $mdUtil.nextTick(closeFn, true);
      };

      if (options.escapeToClose) {
        var parentTarget = options.parent;
        var keyHandlerFn = function(ev) {
          if (ev.keyCode === $mdConstant.KEY_CODE.ESCAPE) {
            ev.stopImmediatePropagation();
            ev.preventDefault();

            smartClose();
          }
        };

        // Add keydown listeners
        element.on('keydown', keyHandlerFn);
        parentTarget.on('keydown', keyHandlerFn);

        // Queue remove listeners function
        removeListeners.push(function() {

          element.off('keydown', keyHandlerFn);
          parentTarget.off('keydown', keyHandlerFn);

        });
      }

      // Register listener to update dialog on window resize
      window.on('resize', onWindowResize);

      removeListeners.push(function() {
        window.off('resize', onWindowResize);
      });

      if (options.clickOutsideToClose) {
        var target = element;
        var sourceElem;

        // Keep track of the element on which the mouse originally went down
        // so that we can only close the backdrop when the 'click' started on it.
        // A simple 'click' handler does not work,
        // it sets the target object as the element the mouse went down on.
        var mousedownHandler = function(ev) {
          sourceElem = ev.target;
        };

        // We check if our original element and the target is the backdrop
        // because if the original was the backdrop and the target was inside the dialog
        // we don't want to dialog to close.
        var mouseupHandler = function(ev) {
          if (sourceElem === target[0] && ev.target === target[0]) {
            ev.stopPropagation();
            ev.preventDefault();

            smartClose();
          }
        };

        // Add listeners
        target.on('mousedown', mousedownHandler);
        target.on('mouseup', mouseupHandler);

        // Queue remove listeners function
        removeListeners.push(function() {
          target.off('mousedown', mousedownHandler);
          target.off('mouseup', mouseupHandler);
        });
      }

      // Attach specific `remove` listener handler
      options.deactivateListeners = function() {
        removeListeners.forEach(function(removeFn) {
          removeFn();
        });
        options.deactivateListeners = null;
      };
    }

    /**
     * Show modal backdrop element...
     */
    function showBackdrop(scope, element, options) {

      if (options.disableParentScroll) {
        // !! DO this before creating the backdrop; since disableScrollAround()
        //    configures the scroll offset; which is used by mdBackDrop postLink()
        options.restoreScroll = $mdUtil.disableScrollAround(element, options.parent);
      }

      if (options.hasBackdrop) {
        options.backdrop = $mdUtil.createBackdrop(scope, "md-dialog-backdrop md-opaque");
        $animate.enter(options.backdrop, options.parent);
      }

      /**
       * Hide modal backdrop element...
       */
      options.hideBackdrop = function hideBackdrop($destroy) {
        if (options.backdrop) {
          if ($destroy) options.backdrop.remove();
          else              $animate.leave(options.backdrop);
        }


        if (options.disableParentScroll) {
          options.restoreScroll && options.restoreScroll();
          delete options.restoreScroll;
        }

        options.hideBackdrop = null;
      };
    }

    /**
     * Inject ARIA-specific attributes appropriate for Dialogs
     */
    function configureAria(element, options) {

      var role = (options.$type === 'alert') ? 'alertdialog' : 'dialog';
      var dialogContent = element.find('md-dialog-content');
      var existingDialogId = element.attr('id');
      var dialogContentId = 'dialogContent_' + (existingDialogId || $mdUtil.nextUid());

      element.attr({
        'role': role,
        'tabIndex': '-1'
      });

      if (dialogContent.length === 0) {
        dialogContent = element;
        // If the dialog element already had an ID, don't clobber it.
        if (existingDialogId) {
          dialogContentId = existingDialogId;
        }
      }

      dialogContent.attr('id', dialogContentId);
      element.attr('aria-describedby', dialogContentId);

      if (options.ariaLabel) {
        $mdAria.expect(element, 'aria-label', options.ariaLabel);
      }
      else {
        $mdAria.expectAsync(element, 'aria-label', function() {
          // If dialog title is specified, set aria-label with it
          // See https://github.com/angular/material/issues/10582
          if (options.title) {
            return options.title;
          } else {
            var words = dialogContent.text().split(/\s+/);
            if (words.length > 3) words = words.slice(0, 3).concat('...');
            return words.join(' ');
          }
        });
      }

      // Set up elements before and after the dialog content to capture focus and
      // redirect back into the dialog.
      topFocusTrap = document.createElement('div');
      topFocusTrap.classList.add('md-dialog-focus-trap');
      topFocusTrap.tabIndex = 0;

      bottomFocusTrap = topFocusTrap.cloneNode(false);

      // When focus is about to move out of the dialog, we want to intercept it and redirect it
      // back to the dialog element.
      var focusHandler = function() {
        element.focus();
      };
      topFocusTrap.addEventListener('focus', focusHandler);
      bottomFocusTrap.addEventListener('focus', focusHandler);

      // The top focus trap inserted immeidately before the md-dialog element (as a sibling).
      // The bottom focus trap is inserted at the very end of the md-dialog element (as a child).
      element[0].parentNode.insertBefore(topFocusTrap, element[0]);
      element.after(bottomFocusTrap);
    }

    /**
     * Prevents screen reader interaction behind modal window
     * on swipe interfaces
     */
    function lockScreenReader(element, options) {
      var isHidden = true;

      // get raw DOM node
      walkDOM(element[0]);

      options.unlockScreenReader = function () {
        isHidden = false;
        walkDOM(element[0]);

        options.unlockScreenReader = null;
      };

      /**
       * Get all of an element's parent elements up the DOM tree
       * @return {Array} The parent elements
       */
      function getParents(element) {
        var parents = [];
        while (element.parentNode) {
          if (element === document.body) {
            return parents;
          }
          var children = element.parentNode.children;
          for (var i = 0; i < children.length; i++) {
            // skip over child if it is an ascendant of the dialog
            // a script or style tag, or a live region.
            if (element !== children[i] &&
                !isNodeOneOf(children[i], ['SCRIPT', 'STYLE']) &&
                !children[i].hasAttribute('aria-live')) {
              parents.push(children[i]);
            }
          }
          element = element.parentNode;
        }
        return parents;
      }

      /**
       * Walk DOM to apply or remove aria-hidden on sibling nodes
       * and parent sibling nodes
       */
      function walkDOM(element) {
        var elements = getParents(element);
        for (var i = 0; i < elements.length; i++) {
          elements[i].setAttribute('aria-hidden', isHidden);
        }
      }
    }

    /**
     * Ensure the dialog container fill-stretches to the viewport
     */
    function stretchDialogContainerToViewport(container, options) {
      var isFixed = $window.getComputedStyle($document[0].body).position == 'fixed';
      var backdrop = options.backdrop ? $window.getComputedStyle(options.backdrop[0]) : null;
      var height = backdrop ? Math.min($document[0].body.clientHeight, Math.ceil(Math.abs(parseInt(backdrop.height, 10)))) : 0;

      var previousStyles = {
        top: container.css('top'),
        height: container.css('height')
      };

      // If the body is fixed, determine the distance to the viewport in relative from the parent.
      var parentTop = Math.abs(options.parent[0].getBoundingClientRect().top);

      container.css({
        top: (isFixed ? parentTop : 0) + 'px',
        height: height ? height + 'px' : '100%'
      });

      return function() {
        // Reverts the modified styles back to the previous values.
        // This is needed for contentElements, which should have the same styles after close
        // as before.
        container.css(previousStyles);
      };
    }

    /**
     *  Dialog open and pop-in animation
     */
    function dialogPopIn(container, options) {
      // Add the `md-dialog-container` to the DOM
      options.parent.append(container);
      options.reverseContainerStretch = stretchDialogContainerToViewport(container, options);

      var dialogEl = container.find('md-dialog');
      var animator = $mdUtil.dom.animator;
      var buildTranslateToOrigin = animator.calculateZoomToOrigin;
      var translateOptions = {transitionInClass: 'md-transition-in', transitionOutClass: 'md-transition-out'};
      var from = animator.toTransformCss(buildTranslateToOrigin(dialogEl, options.openFrom || options.origin));
      var to = animator.toTransformCss("");  // defaults to center display (or parent or $rootElement)

      dialogEl.toggleClass('md-dialog-fullscreen', !!options.fullscreen);

      return animator
        .translate3d(dialogEl, from, to, translateOptions)
        .then(function(animateReversal) {

          // Build a reversal translate function synced to this translation...
          options.reverseAnimate = function() {
            delete options.reverseAnimate;

            if (options.closeTo) {
              // Using the opposite classes to create a close animation to the closeTo element
              translateOptions = {transitionInClass: 'md-transition-out', transitionOutClass: 'md-transition-in'};
              from = to;
              to = animator.toTransformCss(buildTranslateToOrigin(dialogEl, options.closeTo));

              return animator
                .translate3d(dialogEl, from, to,translateOptions);
            }

            return animateReversal(
              to = animator.toTransformCss(
                // in case the origin element has moved or is hidden,
                // let's recalculate the translateCSS
                buildTranslateToOrigin(dialogEl, options.origin)
              )
            );

          };

          // Function to revert the generated animation styles on the dialog element.
          // Useful when using a contentElement instead of a template.
          options.clearAnimate = function() {
            delete options.clearAnimate;

            // Remove the transition classes, added from $animateCSS, since those can't be removed
            // by reversely running the animator.
            dialogEl.removeClass([
              translateOptions.transitionOutClass,
              translateOptions.transitionInClass
            ].join(' '));

            // Run the animation reversely to remove the previous added animation styles.
            return animator.translate3d(dialogEl, to, animator.toTransformCss(''), {});
          };

          return true;
        });
    }

    /**
     * Dialog close and pop-out animation
     */
    function dialogPopOut(container, options) {
      return options.reverseAnimate().then(function() {
        if (options.contentElement) {
          // When we use a contentElement, we want the element to be the same as before.
          // That means, that we have to clear all the animation properties, like transform.
          options.clearAnimate();
        }
      });
    }

    /**
     * Utility function to filter out raw DOM nodes
     */
    function isNodeOneOf(elem, nodeTypeArray) {
      if (nodeTypeArray.indexOf(elem.nodeName) !== -1) {
        return true;
      }
    }

  }
}

})();
(function(){
"use strict";

/**
 * @ngdoc module
 * @name material.components.divider
 * @description Divider module!
 */
MdDividerDirective.$inject = ["$mdTheming"];
angular.module('material.components.divider', [
  'material.core'
])
  .directive('mdDivider', MdDividerDirective);

/**
 * @ngdoc directive
 * @name mdDivider
 * @module material.components.divider
 * @restrict E
 *
 * @description
 * Dividers group and separate content within lists and page layouts using strong visual and spatial distinctions. This divider is a thin rule, lightweight enough to not distract the user from content.
 *
 * @param {boolean=} md-inset Add this attribute to activate the inset divider style.
 * @usage
 * <hljs lang="html">
 * <md-divider></md-divider>
 *
 * <md-divider md-inset></md-divider>
 * </hljs>
 *
 */
function MdDividerDirective($mdTheming) {
  return {
    restrict: 'E',
    link: $mdTheming
  };
}

})();
(function(){
"use strict";

(function() {
  'use strict';

  /**
   * @ngdoc module
   * @name material.components.fabActions
   */
  MdFabActionsDirective.$inject = ["$mdUtil"];
  angular
    .module('material.components.fabActions', ['material.core'])
    .directive('mdFabActions', MdFabActionsDirective);

  /**
   * @ngdoc directive
   * @name mdFabActions
   * @module material.components.fabActions
   *
   * @restrict E
   *
   * @description
   * The `<md-fab-actions>` directive is used inside of a `<md-fab-speed-dial>` or
   * `<md-fab-toolbar>` directive to mark an element (or elements) as the actions and setup the
   * proper event listeners.
   *
   * @usage
   * See the `<md-fab-speed-dial>` or `<md-fab-toolbar>` directives for example usage.
   */
  function MdFabActionsDirective($mdUtil) {
    return {
      restrict: 'E',

      require: ['^?mdFabSpeedDial', '^?mdFabToolbar'],

      compile: function(element, attributes) {
        var children = element.children();

        var hasNgRepeat = $mdUtil.prefixer().hasAttribute(children, 'ng-repeat');

        // Support both ng-repeat and static content
        if (hasNgRepeat) {
          children.addClass('md-fab-action-item');
        } else {
          // Wrap every child in a new div and add a class that we can scale/fling independently
          children.wrap('<div class="md-fab-action-item">');
        }
      }
    };
  }

})();

})();
(function(){
"use strict";

(function() {
  'use strict';

  MdFabController.$inject = ["$scope", "$element", "$animate", "$mdUtil", "$mdConstant", "$timeout"];
  angular.module('material.components.fabShared', ['material.core'])
    .controller('MdFabController', MdFabController);

  function MdFabController($scope, $element, $animate, $mdUtil, $mdConstant, $timeout) {
    var vm = this;
    var initialAnimationAttempts = 0;

    // NOTE: We use async eval(s) below to avoid conflicts with any existing digest loops

    vm.open = function() {
      $scope.$evalAsync("vm.isOpen = true");
    };

    vm.close = function() {
      // Async eval to avoid conflicts with existing digest loops
      $scope.$evalAsync("vm.isOpen = false");

      // Focus the trigger when the element closes so users can still tab to the next item
      $element.find('md-fab-trigger')[0].focus();
    };

    // Toggle the open/close state when the trigger is clicked
    vm.toggle = function() {
      $scope.$evalAsync("vm.isOpen = !vm.isOpen");
    };

    /*
     * AngularJS Lifecycle hook for newer AngularJS versions.
     * Bindings are not guaranteed to have been assigned in the controller, but they are in the $onInit hook.
     */
    vm.$onInit = function() {
      setupDefaults();
      setupListeners();
      setupWatchers();

      fireInitialAnimations();
    };

    // For AngularJS 1.4 and older, where there are no lifecycle hooks but bindings are pre-assigned,
    // manually call the $onInit hook.
    if (angular.version.major === 1 && angular.version.minor <= 4) {
      this.$onInit();
    }

    function setupDefaults() {
      // Set the default direction to 'down' if none is specified
      vm.direction = vm.direction || 'down';

      // Set the default to be closed
      vm.isOpen = vm.isOpen || false;

      // Start the keyboard interaction at the first action
      resetActionIndex();

      // Add an animations waiting class so we know not to run
      $element.addClass('md-animations-waiting');
    }

    function setupListeners() {
      var eventTypes = [
        'click', 'focusin', 'focusout'
      ];

      // Add our listeners
      angular.forEach(eventTypes, function(eventType) {
        $element.on(eventType, parseEvents);
      });

      // Remove our listeners when destroyed
      $scope.$on('$destroy', function() {
        angular.forEach(eventTypes, function(eventType) {
          $element.off(eventType, parseEvents);
        });

        // remove any attached keyboard handlers in case element is removed while
        // speed dial is open
        disableKeyboard();
      });
    }

    var closeTimeout;
    function parseEvents(event) {
      // If the event is a click, just handle it
      if (event.type == 'click') {
        handleItemClick(event);
      }

      // If we focusout, set a timeout to close the element
      if (event.type == 'focusout' && !closeTimeout) {
        closeTimeout = $timeout(function() {
          vm.close();
        }, 100, false);
      }

      // If we see a focusin and there is a timeout about to run, cancel it so we stay open
      if (event.type == 'focusin' && closeTimeout) {
        $timeout.cancel(closeTimeout);
        closeTimeout = null;
      }
    }

    function resetActionIndex() {
      vm.currentActionIndex = -1;
    }

    function setupWatchers() {
      // Watch for changes to the direction and update classes/attributes
      $scope.$watch('vm.direction', function(newDir, oldDir) {
        // Add the appropriate classes so we can target the direction in the CSS
        $animate.removeClass($element, 'md-' + oldDir);
        $animate.addClass($element, 'md-' + newDir);

        // Reset the action index since it may have changed
        resetActionIndex();
      });

      var trigger, actions;

      // Watch for changes to md-open
      $scope.$watch('vm.isOpen', function(isOpen) {
        // Reset the action index since it may have changed
        resetActionIndex();

        // We can't get the trigger/actions outside of the watch because the component hasn't been
        // linked yet, so we wait until the first watch fires to cache them.
        if (!trigger || !actions) {
          trigger = getTriggerElement();
          actions = getActionsElement();
        }

        if (isOpen) {
          enableKeyboard();
        } else {
          disableKeyboard();
        }

        var toAdd = isOpen ? 'md-is-open' : '';
        var toRemove = isOpen ? '' : 'md-is-open';

        // Set the proper ARIA attributes
        trigger.attr('aria-haspopup', true);
        trigger.attr('aria-expanded', isOpen);
        actions.attr('aria-hidden', !isOpen);

        // Animate the CSS classes
        $animate.setClass($element, toAdd, toRemove);
      });
    }

    function fireInitialAnimations() {
      // If the element is actually visible on the screen
      if ($element[0].scrollHeight > 0) {
        // Fire our animation
        $animate.addClass($element, '_md-animations-ready').then(function() {
          // Remove the waiting class
          $element.removeClass('md-animations-waiting');
        });
      }

      // Otherwise, try for up to 1 second before giving up
      else if (initialAnimationAttempts < 10) {
        $timeout(fireInitialAnimations, 100);

        // Increment our counter
        initialAnimationAttempts = initialAnimationAttempts + 1;
      }
    }

    function enableKeyboard() {
      $element.on('keydown', keyPressed);

      // On the next tick, setup a check for outside clicks; we do this on the next tick to avoid
      // clicks/touches that result in the isOpen attribute changing (e.g. a bound radio button)
      $mdUtil.nextTick(function() {
        angular.element(document).on('click touchend', checkForOutsideClick);
      });

      // TODO: On desktop, we should be able to reset the indexes so you cannot tab through, but
      // this breaks accessibility, especially on mobile, since you have no arrow keys to press
      // resetActionTabIndexes();
    }

    function disableKeyboard() {
      $element.off('keydown', keyPressed);
      angular.element(document).off('click touchend', checkForOutsideClick);
    }

    function checkForOutsideClick(event) {
      if (event.target) {
        var closestTrigger = $mdUtil.getClosest(event.target, 'md-fab-trigger');
        var closestActions = $mdUtil.getClosest(event.target, 'md-fab-actions');

        if (!closestTrigger && !closestActions) {
          vm.close();
        }
      }
    }

    function keyPressed(event) {
      switch (event.which) {
        case $mdConstant.KEY_CODE.ESCAPE: vm.close(); event.preventDefault(); return false;
        case $mdConstant.KEY_CODE.LEFT_ARROW: doKeyLeft(event); return false;
        case $mdConstant.KEY_CODE.UP_ARROW: doKeyUp(event); return false;
        case $mdConstant.KEY_CODE.RIGHT_ARROW: doKeyRight(event); return false;
        case $mdConstant.KEY_CODE.DOWN_ARROW: doKeyDown(event); return false;
      }
    }

    function doActionPrev(event) {
      focusAction(event, -1);
    }

    function doActionNext(event) {
      focusAction(event, 1);
    }

    function focusAction(event, direction) {
      var actions = resetActionTabIndexes();

      // Increment/decrement the counter with restrictions
      vm.currentActionIndex = vm.currentActionIndex + direction;
      vm.currentActionIndex = Math.min(actions.length - 1, vm.currentActionIndex);
      vm.currentActionIndex = Math.max(0, vm.currentActionIndex);

      // Focus the element
      var focusElement =  angular.element(actions[vm.currentActionIndex]).children()[0];
      angular.element(focusElement).attr('tabindex', 0);
      focusElement.focus();

      // Make sure the event doesn't bubble and cause something else
      event.preventDefault();
      event.stopImmediatePropagation();
    }

    function resetActionTabIndexes() {
      // Grab all of the actions
      var actions = getActionsElement()[0].querySelectorAll('.md-fab-action-item');

      // Disable all other actions for tabbing
      angular.forEach(actions, function(action) {
        angular.element(angular.element(action).children()[0]).attr('tabindex', -1);
      });

      return actions;
    }

    function doKeyLeft(event) {
      if (vm.direction === 'left') {
        doActionNext(event);
      } else {
        doActionPrev(event);
      }
    }

    function doKeyUp(event) {
      if (vm.direction === 'down') {
        doActionPrev(event);
      } else {
        doActionNext(event);
      }
    }

    function doKeyRight(event) {
      if (vm.direction === 'left') {
        doActionPrev(event);
      } else {
        doActionNext(event);
      }
    }

    function doKeyDown(event) {
      if (vm.direction === 'up') {
        doActionPrev(event);
      } else {
        doActionNext(event);
      }
    }

    function isTrigger(element) {
      return $mdUtil.getClosest(element, 'md-fab-trigger');
    }

    function isAction(element) {
      return $mdUtil.getClosest(element, 'md-fab-actions');
    }

    function handleItemClick(event) {
      if (isTrigger(event.target)) {
        vm.toggle();
      }

      if (isAction(event.target)) {
        vm.close();
      }
    }

    function getTriggerElement() {
      return $element.find('md-fab-trigger');
    }

    function getActionsElement() {
      return $element.find('md-fab-actions');
    }
  }
})();

})();
(function(){
"use strict";

(function() {
  'use strict';

  /**
   * The duration of the CSS animation in milliseconds.
   *
   * @type {number}
   */
  MdFabSpeedDialFlingAnimation.$inject = ["$timeout"];
  MdFabSpeedDialScaleAnimation.$inject = ["$timeout"];
  var cssAnimationDuration = 300;

  /**
   * @ngdoc module
   * @name material.components.fabSpeedDial
   */
  angular
    // Declare our module
    .module('material.components.fabSpeedDial', [
      'material.core',
      'material.components.fabShared',
      'material.components.fabActions'
    ])

    // Register our directive
    .directive('mdFabSpeedDial', MdFabSpeedDialDirective)

    // Register our custom animations
    .animation('.md-fling', MdFabSpeedDialFlingAnimation)
    .animation('.md-scale', MdFabSpeedDialScaleAnimation)

    // Register a service for each animation so that we can easily inject them into unit tests
    .service('mdFabSpeedDialFlingAnimation', MdFabSpeedDialFlingAnimation)
    .service('mdFabSpeedDialScaleAnimation', MdFabSpeedDialScaleAnimation);

  /**
   * @ngdoc directive
   * @name mdFabSpeedDial
   * @module material.components.fabSpeedDial
   *
   * @restrict E
   *
   * @description
   * The `<md-fab-speed-dial>` directive is used to present a series of popup elements (usually
   * `<md-button>`s) for quick access to common actions.
   *
   * There are currently two animations available by applying one of the following classes to
   * the component:
   *
   *  - `md-fling` - The speed dial items appear from underneath the trigger and move into their
   *    appropriate positions.
   *  - `md-scale` - The speed dial items appear in their proper places by scaling from 0% to 100%.
   *
   * You may also easily position the trigger by applying one one of the following classes to the
   * `<md-fab-speed-dial>` element:
   *  - `md-fab-top-left`
   *  - `md-fab-top-right`
   *  - `md-fab-bottom-left`
   *  - `md-fab-bottom-right`
   *
   * These CSS classes use `position: absolute`, so you need to ensure that the container element
   * also uses `position: absolute` or `position: relative` in order for them to work.
   *
   * Additionally, you may use the standard `ng-mouseenter` and `ng-mouseleave` directives to
   * open or close the speed dial. However, if you wish to allow users to hover over the empty
   * space where the actions will appear, you must also add the `md-hover-full` class to the speed
   * dial element. Without this, the hover effect will only occur on top of the trigger.
   *
   * See the demos for more information.
   *
   * ## Troubleshooting
   *
   * If your speed dial shows the closing animation upon launch, you may need to use `ng-cloak` on
   * the parent container to ensure that it is only visible once ready. We have plans to remove this
   * necessity in the future.
   *
   * @usage
   * <hljs lang="html">
   * <md-fab-speed-dial md-direction="up" class="md-fling">
   *   <md-fab-trigger>
   *     <md-button aria-label="Add..."><md-icon md-svg-src="/img/icons/plus.svg"></md-icon></md-button>
   *   </md-fab-trigger>
   *
   *   <md-fab-actions>
   *     <md-button aria-label="Add User">
   *       <md-icon md-svg-src="/img/icons/user.svg"></md-icon>
   *     </md-button>
   *
   *     <md-button aria-label="Add Group">
   *       <md-icon md-svg-src="/img/icons/group.svg"></md-icon>
   *     </md-button>
   *   </md-fab-actions>
   * </md-fab-speed-dial>
   * </hljs>
   *
   * @param {string} md-direction From which direction you would like the speed dial to appear
   * relative to the trigger element.
   * @param {expression=} md-open Programmatically control whether or not the speed-dial is visible.
   */
  function MdFabSpeedDialDirective() {
    return {
      restrict: 'E',

      scope: {
        direction: '@?mdDirection',
        isOpen: '=?mdOpen'
      },

      bindToController: true,
      controller: 'MdFabController',
      controllerAs: 'vm',

      link: FabSpeedDialLink
    };

    function FabSpeedDialLink(scope, element) {
      // Prepend an element to hold our CSS variables so we can use them in the animations below
      element.prepend('<div class="_md-css-variables"></div>');
    }
  }

  function MdFabSpeedDialFlingAnimation($timeout) {
    function delayDone(done) { $timeout(done, cssAnimationDuration, false); }

    function runAnimation(element) {
      // Don't run if we are still waiting and we are not ready
      if (element.hasClass('md-animations-waiting') && !element.hasClass('_md-animations-ready')) {
        return;
      }

      var el = element[0];
      var ctrl = element.controller('mdFabSpeedDial');
      var items = el.querySelectorAll('.md-fab-action-item');

      // Grab our trigger element
      var triggerElement = el.querySelector('md-fab-trigger');

      // Grab our element which stores CSS variables
      var variablesElement = el.querySelector('._md-css-variables');

      // Setup JS variables based on our CSS variables
      var startZIndex = parseInt(window.getComputedStyle(variablesElement).zIndex);

      // Always reset the items to their natural position/state
      angular.forEach(items, function(item, index) {
        var styles = item.style;

        styles.transform = styles.webkitTransform = '';
        styles.transitionDelay = '';
        styles.opacity = 1;

        // Make the items closest to the trigger have the highest z-index
        styles.zIndex = (items.length - index) + startZIndex;
      });

      // Set the trigger to be above all of the actions so they disappear behind it.
      triggerElement.style.zIndex = startZIndex + items.length + 1;

      // If the control is closed, hide the items behind the trigger
      if (!ctrl.isOpen) {
        angular.forEach(items, function(item, index) {
          var newPosition, axis;
          var styles = item.style;

          // Make sure to account for differences in the dimensions of the trigger verses the items
          // so that we can properly center everything; this helps hide the item's shadows behind
          // the trigger.
          var triggerItemHeightOffset = (triggerElement.clientHeight - item.clientHeight) / 2;
          var triggerItemWidthOffset = (triggerElement.clientWidth - item.clientWidth) / 2;

          switch (ctrl.direction) {
            case 'up':
              newPosition = (item.scrollHeight * (index + 1) + triggerItemHeightOffset);
              axis = 'Y';
              break;
            case 'down':
              newPosition = -(item.scrollHeight * (index + 1) + triggerItemHeightOffset);
              axis = 'Y';
              break;
            case 'left':
              newPosition = (item.scrollWidth * (index + 1) + triggerItemWidthOffset);
              axis = 'X';
              break;
            case 'right':
              newPosition = -(item.scrollWidth * (index + 1) + triggerItemWidthOffset);
              axis = 'X';
              break;
          }

          var newTranslate = 'translate' + axis + '(' + newPosition + 'px)';

          styles.transform = styles.webkitTransform = newTranslate;
        });
      }
    }

    return {
      addClass: function(element, className, done) {
        if (element.hasClass('md-fling')) {
          runAnimation(element);
          delayDone(done);
        } else {
          done();
        }
      },
      removeClass: function(element, className, done) {
        runAnimation(element);
        delayDone(done);
      }
    };
  }

  function MdFabSpeedDialScaleAnimation($timeout) {
    function delayDone(done) { $timeout(done, cssAnimationDuration, false); }

    var delay = 65;

    function runAnimation(element) {
      var el = element[0];
      var ctrl = element.controller('mdFabSpeedDial');
      var items = el.querySelectorAll('.md-fab-action-item');

      // Grab our element which stores CSS variables
      var variablesElement = el.querySelector('._md-css-variables');

      // Setup JS variables based on our CSS variables
      var startZIndex = parseInt(window.getComputedStyle(variablesElement).zIndex);

      // Always reset the items to their natural position/state
      angular.forEach(items, function(item, index) {
        var styles = item.style,
          offsetDelay = index * delay;

        styles.opacity = ctrl.isOpen ? 1 : 0;
        styles.transform = styles.webkitTransform = ctrl.isOpen ? 'scale(1)' : 'scale(0)';
        styles.transitionDelay = (ctrl.isOpen ? offsetDelay : (items.length - offsetDelay)) + 'ms';

        // Make the items closest to the trigger have the highest z-index
        styles.zIndex = (items.length - index) + startZIndex;
      });
    }

    return {
      addClass: function(element, className, done) {
        runAnimation(element);
        delayDone(done);
      },

      removeClass: function(element, className, done) {
        runAnimation(element);
        delayDone(done);
      }
    };
  }
})();

})();
(function(){
"use strict";

(function() {
  'use strict';

  /**
   * @ngdoc module
   * @name material.components.fabToolbar
   */
  angular
    // Declare our module
    .module('material.components.fabToolbar', [
      'material.core',
      'material.components.fabShared',
      'material.components.fabActions'
    ])

    // Register our directive
    .directive('mdFabToolbar', MdFabToolbarDirective)

    // Register our custom animations
    .animation('.md-fab-toolbar', MdFabToolbarAnimation)

    // Register a service for the animation so that we can easily inject it into unit tests
    .service('mdFabToolbarAnimation', MdFabToolbarAnimation);

  /**
   * @ngdoc directive
   * @name mdFabToolbar
   * @module material.components.fabToolbar
   *
   * @restrict E
   *
   * @description
   *
   * The `<md-fab-toolbar>` directive is used to present a toolbar of elements (usually `<md-button>`s)
   * for quick access to common actions when a floating action button is activated (via click or
   * keyboard navigation).
   *
   * You may also easily position the trigger by applying one one of the following classes to the
   * `<md-fab-toolbar>` element:
   *  - `md-fab-top-left`
   *  - `md-fab-top-right`
   *  - `md-fab-bottom-left`
   *  - `md-fab-bottom-right`
   *
   * These CSS classes use `position: absolute`, so you need to ensure that the container element
   * also uses `position: absolute` or `position: relative` in order for them to work.
   *
   * @usage
   *
   * <hljs lang="html">
   * <md-fab-toolbar md-direction='left'>
   *   <md-fab-trigger>
   *     <md-button aria-label="Add..."><md-icon md-svg-src="/img/icons/plus.svg"></md-icon></md-button>
   *   </md-fab-trigger>
   *
   *   <md-toolbar>
   *    <md-fab-actions>
   *      <md-button aria-label="Add User">
   *        <md-icon md-svg-src="/img/icons/user.svg"></md-icon>
   *      </md-button>
   *
   *      <md-button aria-label="Add Group">
   *        <md-icon md-svg-src="/img/icons/group.svg"></md-icon>
   *      </md-button>
   *    </md-fab-actions>
   *   </md-toolbar>
   * </md-fab-toolbar>
   * </hljs>
   *
   * @param {string} md-direction From which direction you would like the toolbar items to appear
   * relative to the trigger element. Supports `left` and `right` directions.
   * @param {expression=} md-open Programmatically control whether or not the toolbar is visible.
   */
  function MdFabToolbarDirective() {
    return {
      restrict: 'E',
      transclude: true,
      template: '<div class="md-fab-toolbar-wrapper">' +
      '  <div class="md-fab-toolbar-content" ng-transclude></div>' +
      '</div>',

      scope: {
        direction: '@?mdDirection',
        isOpen: '=?mdOpen'
      },

      bindToController: true,
      controller: 'MdFabController',
      controllerAs: 'vm',

      link: link
    };

    function link(scope, element, attributes) {
      // Add the base class for animations
      element.addClass('md-fab-toolbar');

      // Prepend the background element to the trigger's button
      element.find('md-fab-trigger').find('button')
        .prepend('<div class="md-fab-toolbar-background"></div>');
    }
  }

  function MdFabToolbarAnimation() {

    function runAnimation(element, className, done) {
      // If no className was specified, don't do anything
      if (!className) {
        return;
      }

      var el = element[0];
      var ctrl = element.controller('mdFabToolbar');

      // Grab the relevant child elements
      var backgroundElement = el.querySelector('.md-fab-toolbar-background');
      var triggerElement = el.querySelector('md-fab-trigger button');
      var toolbarElement = el.querySelector('md-toolbar');
      var iconElement = el.querySelector('md-fab-trigger button md-icon');
      var actions = element.find('md-fab-actions').children();

      // If we have both elements, use them to position the new background
      if (triggerElement && backgroundElement) {
        // Get our variables
        var color = window.getComputedStyle(triggerElement).getPropertyValue('background-color');
        var width = el.offsetWidth;
        var height = el.offsetHeight;

        // Make it twice as big as it should be since we scale from the center
        var scale = 2 * (width / triggerElement.offsetWidth);

        // Set some basic styles no matter what animation we're doing
        backgroundElement.style.backgroundColor = color;
        backgroundElement.style.borderRadius = width + 'px';

        // If we're open
        if (ctrl.isOpen) {
          // Turn on toolbar pointer events when closed
          toolbarElement.style.pointerEvents = 'inherit';

          backgroundElement.style.width = triggerElement.offsetWidth + 'px';
          backgroundElement.style.height = triggerElement.offsetHeight + 'px';
          backgroundElement.style.transform = 'scale(' + scale + ')';

          // Set the next close animation to have the proper delays
          backgroundElement.style.transitionDelay = '0ms';
          iconElement && (iconElement.style.transitionDelay = '.3s');

          // Apply a transition delay to actions
          angular.forEach(actions, function(action, index) {
            action.style.transitionDelay = (actions.length - index) * 25 + 'ms';
          });
        } else {
          // Turn off toolbar pointer events when closed
          toolbarElement.style.pointerEvents = 'none';

          // Scale it back down to the trigger's size
          backgroundElement.style.transform = 'scale(1)';

          // Reset the position
          backgroundElement.style.top = '0';

          if (element.hasClass('md-right')) {
            backgroundElement.style.left = '0';
            backgroundElement.style.right = null;
          }

          if (element.hasClass('md-left')) {
            backgroundElement.style.right = '0';
            backgroundElement.style.left = null;
          }

          // Set the next open animation to have the proper delays
          backgroundElement.style.transitionDelay = '200ms';
          iconElement && (iconElement.style.transitionDelay = '0ms');

          // Apply a transition delay to actions
          angular.forEach(actions, function(action, index) {
            action.style.transitionDelay = 200 + (index * 25) + 'ms';
          });
        }
      }
    }

    return {
      addClass: function(element, className, done) {
        runAnimation(element, className, done);
        done();
      },

      removeClass: function(element, className, done) {
        runAnimation(element, className, done);
        done();
      }
    };
  }
})();

})();
(function(){
"use strict";

/**
 * @ngdoc module
 * @name material.components.gridList
 */
GridListController.$inject = ["$mdUtil"];
GridLayoutFactory.$inject = ["$mdUtil"];
GridListDirective.$inject = ["$interpolate", "$mdConstant", "$mdGridLayout", "$mdMedia"];
GridTileDirective.$inject = ["$mdMedia"];
angular.module('material.components.gridList', ['material.core'])
       .directive('mdGridList', GridListDirective)
       .directive('mdGridTile', GridTileDirective)
       .directive('mdGridTileFooter', GridTileCaptionDirective)
       .directive('mdGridTileHeader', GridTileCaptionDirective)
       .factory('$mdGridLayout', GridLayoutFactory);

/**
 * @ngdoc directive
 * @name mdGridList
 * @module material.components.gridList
 * @restrict E
 * @description
 * Grid lists are an alternative to standard list views. Grid lists are distinct
 * from grids used for layouts and other visual presentations.
 *
 * A grid list is best suited to presenting a homogenous data type, typically
 * images, and is optimized for visual comprehension and differentiating between
 * like data types.
 *
 * A grid list is a continuous element consisting of tessellated, regular
 * subdivisions called cells that contain tiles (`md-grid-tile`).
 *
 * <img src="//material-design.storage.googleapis.com/publish/v_2/material_ext_publish/0Bx4BSt6jniD7OVlEaXZ5YmU1Xzg/components_grids_usage2.png"
 *    style="width: 300px; height: auto; margin-right: 16px;" alt="Concept of grid explained visually">
 * <img src="//material-design.storage.googleapis.com/publish/v_2/material_ext_publish/0Bx4BSt6jniD7VGhsOE5idWlJWXM/components_grids_usage3.png"
 *    style="width: 300px; height: auto;" alt="Grid concepts legend">
 *
 * Cells are arrayed vertically and horizontally within the grid.
 *
 * Tiles hold content and can span one or more cells vertically or horizontally.
 *
 * ### Responsive Attributes
 *
 * The `md-grid-list` directive supports "responsive" attributes, which allow
 * different `md-cols`, `md-gutter` and `md-row-height` values depending on the
 * currently matching media query.
 *
 * In order to set a responsive attribute, first define the fallback value with
 * the standard attribute name, then add additional attributes with the
 * following convention: `{base-attribute-name}-{media-query-name}="{value}"`
 * (ie. `md-cols-lg="8"`)
 *
 * @param {number} md-cols Number of columns in the grid.
 * @param {string} md-row-height One of
 * <ul>
 *   <li>CSS length - Fixed height rows (eg. `8px` or `1rem`)</li>
 *   <li>`{width}:{height}` - Ratio of width to height (eg.
 *   `md-row-height="16:9"`)</li>
 *   <li>`"fit"` - Height will be determined by subdividing the available
 *   height by the number of rows</li>
 * </ul>
 * @param {string=} md-gutter The amount of space between tiles in CSS units
 *     (default 1px)
 * @param {expression=} md-on-layout Expression to evaluate after layout. Event
 *     object is available as `$event`, and contains performance information.
 *
 * @usage
 * Basic:
 * <hljs lang="html">
 * <md-grid-list md-cols="5" md-gutter="1em" md-row-height="4:3">
 *   <md-grid-tile></md-grid-tile>
 * </md-grid-list>
 * </hljs>
 *
 * Fixed-height rows:
 * <hljs lang="html">
 * <md-grid-list md-cols="4" md-row-height="200px" ...>
 *   <md-grid-tile></md-grid-tile>
 * </md-grid-list>
 * </hljs>
 *
 * Fit rows:
 * <hljs lang="html">
 * <md-grid-list md-cols="4" md-row-height="fit" style="height: 400px;" ...>
 *   <md-grid-tile></md-grid-tile>
 * </md-grid-list>
 * </hljs>
 *
 * Using responsive attributes:
 * <hljs lang="html">
 * <md-grid-list
 *     md-cols-sm="2"
 *     md-cols-md="4"
 *     md-cols-lg="8"
 *     md-cols-gt-lg="12"
 *     ...>
 *   <md-grid-tile></md-grid-tile>
 * </md-grid-list>
 * </hljs>
 */
function GridListDirective($interpolate, $mdConstant, $mdGridLayout, $mdMedia) {
  return {
    restrict: 'E',
    controller: GridListController,
    scope: {
      mdOnLayout: '&'
    },
    link: postLink
  };

  function postLink(scope, element, attrs, ctrl) {
    element.addClass('_md');     // private md component indicator for styling

    // Apply semantics
    element.attr('role', 'list');

    // Provide the controller with a way to trigger layouts.
    ctrl.layoutDelegate = layoutDelegate;

    var invalidateLayout = angular.bind(ctrl, ctrl.invalidateLayout),
        unwatchAttrs = watchMedia();
      scope.$on('$destroy', unwatchMedia);

    /**
     * Watches for changes in media, invalidating layout as necessary.
     */
    function watchMedia() {
      for (var mediaName in $mdConstant.MEDIA) {
        $mdMedia(mediaName); // initialize
        $mdMedia.getQuery($mdConstant.MEDIA[mediaName])
            .addListener(invalidateLayout);
      }
      return $mdMedia.watchResponsiveAttributes(
          ['md-cols', 'md-row-height', 'md-gutter'], attrs, layoutIfMediaMatch);
    }

    function unwatchMedia() {
      ctrl.layoutDelegate = angular.noop;

      unwatchAttrs();
      for (var mediaName in $mdConstant.MEDIA) {
        $mdMedia.getQuery($mdConstant.MEDIA[mediaName])
            .removeListener(invalidateLayout);
      }
    }

    /**
     * Performs grid layout if the provided mediaName matches the currently
     * active media type.
     */
    function layoutIfMediaMatch(mediaName) {
      if (mediaName == null) {
        // TODO(shyndman): It would be nice to only layout if we have
        // instances of attributes using this media type
        ctrl.invalidateLayout();
      } else if ($mdMedia(mediaName)) {
        ctrl.invalidateLayout();
      }
    }

    var lastLayoutProps;

    /**
     * Invokes the layout engine, and uses its results to lay out our
     * tile elements.
     *
     * @param {boolean} tilesInvalidated Whether tiles have been
     *    added/removed/moved since the last layout. This is to avoid situations
     *    where tiles are replaced with properties identical to their removed
     *    counterparts.
     */
    function layoutDelegate(tilesInvalidated) {
      var tiles = getTileElements();
      var props = {
        tileSpans: getTileSpans(tiles),
        colCount: getColumnCount(),
        rowMode: getRowMode(),
        rowHeight: getRowHeight(),
        gutter: getGutter()
      };

      if (!tilesInvalidated && angular.equals(props, lastLayoutProps)) {
        return;
      }

      var performance =
        $mdGridLayout(props.colCount, props.tileSpans, tiles)
          .map(function(tilePositions, rowCount) {
            return {
              grid: {
                element: element,
                style: getGridStyle(props.colCount, rowCount,
                    props.gutter, props.rowMode, props.rowHeight)
              },
              tiles: tilePositions.map(function(ps, i) {
                return {
                  element: angular.element(tiles[i]),
                  style: getTileStyle(ps.position, ps.spans,
                      props.colCount, rowCount,
                      props.gutter, props.rowMode, props.rowHeight)
                };
              })
            };
          })
          .reflow()
          .performance();

      // Report layout
      scope.mdOnLayout({
        $event: {
          performance: performance
        }
      });

      lastLayoutProps = props;
    }

    // Use $interpolate to do some simple string interpolation as a convenience.

    var startSymbol = $interpolate.startSymbol();
    var endSymbol = $interpolate.endSymbol();

    // Returns an expression wrapped in the interpolator's start and end symbols.
    function expr(exprStr) {
      return startSymbol + exprStr + endSymbol;
    }

    // The amount of space a single 1x1 tile would take up (either width or height), used as
    // a basis for other calculations. This consists of taking the base size percent (as would be
    // if evenly dividing the size between cells), and then subtracting the size of one gutter.
    // However, since there are no gutters on the edges, each tile only uses a fration
    // (gutterShare = numGutters / numCells) of the gutter size. (Imagine having one gutter per
    // tile, and then breaking up the extra gutter on the edge evenly among the cells).
    var UNIT = $interpolate(expr('share') + '% - (' + expr('gutter') + ' * ' + expr('gutterShare') + ')');

    // The horizontal or vertical position of a tile, e.g., the 'top' or 'left' property value.
    // The position comes the size of a 1x1 tile plus gutter for each previous tile in the
    // row/column (offset).
    var POSITION  = $interpolate('calc((' + expr('unit') + ' + ' + expr('gutter') + ') * ' + expr('offset') + ')');

    // The actual size of a tile, e.g., width or height, taking rowSpan or colSpan into account.
    // This is computed by multiplying the base unit by the rowSpan/colSpan, and then adding back
    // in the space that the gutter would normally have used (which was already accounted for in
    // the base unit calculation).
    var DIMENSION = $interpolate('calc((' + expr('unit') + ') * ' + expr('span') + ' + (' + expr('span') + ' - 1) * ' + expr('gutter') + ')');

    /**
     * Gets the styles applied to a tile element described by the given parameters.
     * @param {{row: number, col: number}} position The row and column indices of the tile.
     * @param {{row: number, col: number}} spans The rowSpan and colSpan of the tile.
     * @param {number} colCount The number of columns.
     * @param {number} rowCount The number of rows.
     * @param {string} gutter The amount of space between tiles. This will be something like
     *     '5px' or '2em'.
     * @param {string} rowMode The row height mode. Can be one of:
     *     'fixed': all rows have a fixed size, given by rowHeight,
     *     'ratio': row height defined as a ratio to width, or
     *     'fit': fit to the grid-list element height, divinding evenly among rows.
     * @param {string|number} rowHeight The height of a row. This is only used for 'fixed' mode and
     *     for 'ratio' mode. For 'ratio' mode, this is the *ratio* of width-to-height (e.g., 0.75).
     * @returns {Object} Map of CSS properties to be applied to the style element. Will define
     *     values for top, left, width, height, marginTop, and paddingTop.
     */
    function getTileStyle(position, spans, colCount, rowCount, gutter, rowMode, rowHeight) {
      // TODO(shyndman): There are style caching opportunities here.

      // Percent of the available horizontal space that one column takes up.
      var hShare = (1 / colCount) * 100;

      // Fraction of the gutter size that each column takes up.
      var hGutterShare = (colCount - 1) / colCount;

      // Base horizontal size of a column.
      var hUnit = UNIT({share: hShare, gutterShare: hGutterShare, gutter: gutter});

      // The width and horizontal position of each tile is always calculated the same way, but the
      // height and vertical position depends on the rowMode.
      var ltr = document.dir != 'rtl' && document.body.dir != 'rtl';
      var style = ltr ? {
          left: POSITION({ unit: hUnit, offset: position.col, gutter: gutter }),
          width: DIMENSION({ unit: hUnit, span: spans.col, gutter: gutter }),
          // resets
          paddingTop: '',
          marginTop: '',
          top: '',
          height: ''
        } : {
        right: POSITION({ unit: hUnit, offset: position.col, gutter: gutter }),
        width: DIMENSION({ unit: hUnit, span: spans.col, gutter: gutter }),
        // resets
        paddingTop: '',
        marginTop: '',
        top: '',
        height: ''
      };

      switch (rowMode) {
        case 'fixed':
          // In fixed mode, simply use the given rowHeight.
          style.top = POSITION({ unit: rowHeight, offset: position.row, gutter: gutter });
          style.height = DIMENSION({ unit: rowHeight, span: spans.row, gutter: gutter });
          break;

        case 'ratio':
          // Percent of the available vertical space that one row takes up. Here, rowHeight holds
          // the ratio value. For example, if the width:height ratio is 4:3, rowHeight = 1.333.
          var vShare = hShare / rowHeight;

          // Base veritcal size of a row.
          var vUnit = UNIT({ share: vShare, gutterShare: hGutterShare, gutter: gutter });

          // padidngTop and marginTop are used to maintain the given aspect ratio, as
          // a percentage-based value for these properties is applied to the *width* of the
          // containing block. See http://www.w3.org/TR/CSS2/box.html#margin-properties
          style.paddingTop = DIMENSION({ unit: vUnit, span: spans.row, gutter: gutter});
          style.marginTop = POSITION({ unit: vUnit, offset: position.row, gutter: gutter });
          break;

        case 'fit':
          // Fraction of the gutter size that each column takes up.
          var vGutterShare = (rowCount - 1) / rowCount;

          // Percent of the available vertical space that one row takes up.
          vShare = (1 / rowCount) * 100;

          // Base vertical size of a row.
          vUnit = UNIT({share: vShare, gutterShare: vGutterShare, gutter: gutter});

          style.top = POSITION({unit: vUnit, offset: position.row, gutter: gutter});
          style.height = DIMENSION({unit: vUnit, span: spans.row, gutter: gutter});
          break;
      }

      return style;
    }

    function getGridStyle(colCount, rowCount, gutter, rowMode, rowHeight) {
      var style = {};

      switch (rowMode) {
        case 'fixed':
          style.height = DIMENSION({ unit: rowHeight, span: rowCount, gutter: gutter });
          style.paddingBottom = '';
          break;

        case 'ratio':
          // rowHeight is width / height
          var hGutterShare = colCount === 1 ? 0 : (colCount - 1) / colCount,
              hShare = (1 / colCount) * 100,
              vShare = hShare * (1 / rowHeight),
              vUnit = UNIT({ share: vShare, gutterShare: hGutterShare, gutter: gutter });

          style.height = '';
          style.paddingBottom = DIMENSION({ unit: vUnit, span: rowCount, gutter: gutter});
          break;

        case 'fit':
          // noop, as the height is user set
          break;
      }

      return style;
    }

    function getTileElements() {
      return [].filter.call(element.children(), function(ele) {
        return ele.tagName == 'MD-GRID-TILE' && !ele.$$mdDestroyed;
      });
    }

    /**
     * Gets an array of objects containing the rowspan and colspan for each tile.
     * @returns {Array<{row: number, col: number}>}
     */
    function getTileSpans(tileElements) {
      return [].map.call(tileElements, function(ele) {
        var ctrl = angular.element(ele).controller('mdGridTile');
        return {
          row: parseInt(
              $mdMedia.getResponsiveAttribute(ctrl.$attrs, 'md-rowspan'), 10) || 1,
          col: parseInt(
              $mdMedia.getResponsiveAttribute(ctrl.$attrs, 'md-colspan'), 10) || 1
        };
      });
    }

    function getColumnCount() {
      var colCount = parseInt($mdMedia.getResponsiveAttribute(attrs, 'md-cols'), 10);
      if (isNaN(colCount)) {
        throw 'md-grid-list: md-cols attribute was not found, or contained a non-numeric value';
      }
      return colCount;
    }

    function getGutter() {
      return applyDefaultUnit($mdMedia.getResponsiveAttribute(attrs, 'md-gutter') || 1);
    }

    function getRowHeight() {
      var rowHeight = $mdMedia.getResponsiveAttribute(attrs, 'md-row-height');
      if (!rowHeight) {
        throw 'md-grid-list: md-row-height attribute was not found';
      }

      switch (getRowMode()) {
        case 'fixed':
          return applyDefaultUnit(rowHeight);
        case 'ratio':
          var whRatio = rowHeight.split(':');
          return parseFloat(whRatio[0]) / parseFloat(whRatio[1]);
        case 'fit':
          return 0; // N/A
      }
    }

    function getRowMode() {
      var rowHeight = $mdMedia.getResponsiveAttribute(attrs, 'md-row-height');
      if (!rowHeight) {
        throw 'md-grid-list: md-row-height attribute was not found';
      }

      if (rowHeight == 'fit') {
        return 'fit';
      } else if (rowHeight.indexOf(':') !== -1) {
        return 'ratio';
      } else {
        return 'fixed';
      }
    }

    function applyDefaultUnit(val) {
      return /\D$/.test(val) ? val : val + 'px';
    }
  }
}

/* @ngInject */
function GridListController($mdUtil) {
  this.layoutInvalidated = false;
  this.tilesInvalidated = false;
  this.$timeout_ = $mdUtil.nextTick;
  this.layoutDelegate = angular.noop;
}

GridListController.prototype = {
  invalidateTiles: function() {
    this.tilesInvalidated = true;
    this.invalidateLayout();
  },

  invalidateLayout: function() {
    if (this.layoutInvalidated) {
      return;
    }
    this.layoutInvalidated = true;
    this.$timeout_(angular.bind(this, this.layout));
  },

  layout: function() {
    try {
      this.layoutDelegate(this.tilesInvalidated);
    } finally {
      this.layoutInvalidated = false;
      this.tilesInvalidated = false;
    }
  }
};


/* @ngInject */
function GridLayoutFactory($mdUtil) {
  var defaultAnimator = GridTileAnimator;

  /**
   * Set the reflow animator callback
   */
  GridLayout.animateWith = function(customAnimator) {
    defaultAnimator = !angular.isFunction(customAnimator) ? GridTileAnimator : customAnimator;
  };

  return GridLayout;

  /**
   * Publish layout function
   */
  function GridLayout(colCount, tileSpans) {
      var self, layoutInfo, gridStyles, layoutTime, mapTime, reflowTime;

      layoutTime = $mdUtil.time(function() {
        layoutInfo = calculateGridFor(colCount, tileSpans);
      });

      return self = {

        /**
         * An array of objects describing each tile's position in the grid.
         */
        layoutInfo: function() {
          return layoutInfo;
        },

        /**
         * Maps grid positioning to an element and a set of styles using the
         * provided updateFn.
         */
        map: function(updateFn) {
          mapTime = $mdUtil.time(function() {
            var info = self.layoutInfo();
            gridStyles = updateFn(info.positioning, info.rowCount);
          });
          return self;
        },

        /**
         * Default animator simply sets the element.css( <styles> ). An alternate
         * animator can be provided as an argument. The function has the following
         * signature:
         *
         *    function({grid: {element: JQLite, style: Object}, tiles: Array<{element: JQLite, style: Object}>)
         */
        reflow: function(animatorFn) {
          reflowTime = $mdUtil.time(function() {
            var animator = animatorFn || defaultAnimator;
            animator(gridStyles.grid, gridStyles.tiles);
          });
          return self;
        },

        /**
         * Timing for the most recent layout run.
         */
        performance: function() {
          return {
            tileCount: tileSpans.length,
            layoutTime: layoutTime,
            mapTime: mapTime,
            reflowTime: reflowTime,
            totalTime: layoutTime + mapTime + reflowTime
          };
        }
      };
    }

  /**
   * Default Gridlist animator simple sets the css for each element;
   * NOTE: any transitions effects must be manually set in the CSS.
   * e.g.
   *
   *  md-grid-tile {
   *    transition: all 700ms ease-out 50ms;
   *  }
   *
   */
  function GridTileAnimator(grid, tiles) {
    grid.element.css(grid.style);
    tiles.forEach(function(t) {
      t.element.css(t.style);
    });
  }

  /**
   * Calculates the positions of tiles.
   *
   * The algorithm works as follows:
   *    An Array<Number> with length colCount (spaceTracker) keeps track of
   *    available tiling positions, where elements of value 0 represents an
   *    empty position. Space for a tile is reserved by finding a sequence of
   *    0s with length <= than the tile's colspan. When such a space has been
   *    found, the occupied tile positions are incremented by the tile's
   *    rowspan value, as these positions have become unavailable for that
   *    many rows.
   *
   *    If the end of a row has been reached without finding space for the
   *    tile, spaceTracker's elements are each decremented by 1 to a minimum
   *    of 0. Rows are searched in this fashion until space is found.
   */
  function calculateGridFor(colCount, tileSpans) {
    var curCol = 0,
        curRow = 0,
        spaceTracker = newSpaceTracker();

    return {
      positioning: tileSpans.map(function(spans, i) {
        return {
          spans: spans,
          position: reserveSpace(spans, i)
        };
      }),
      rowCount: curRow + Math.max.apply(Math, spaceTracker)
    };

    function reserveSpace(spans, i) {
      if (spans.col > colCount) {
        throw 'md-grid-list: Tile at position ' + i + ' has a colspan ' +
            '(' + spans.col + ') that exceeds the column count ' +
            '(' + colCount + ')';
      }

      var start = 0,
          end = 0;

      // TODO(shyndman): This loop isn't strictly necessary if you can
      // determine the minimum number of rows before a space opens up. To do
      // this, recognize that you've iterated across an entire row looking for
      // space, and if so fast-forward by the minimum rowSpan count. Repeat
      // until the required space opens up.
      while (end - start < spans.col) {
        if (curCol >= colCount) {
          nextRow();
          continue;
        }

        start = spaceTracker.indexOf(0, curCol);
        if (start === -1 || (end = findEnd(start + 1)) === -1) {
          start = end = 0;
          nextRow();
          continue;
        }

        curCol = end + 1;
      }

      adjustRow(start, spans.col, spans.row);
      curCol = start + spans.col;

      return {
        col: start,
        row: curRow
      };
    }

    function nextRow() {
      curCol = 0;
      curRow++;
      adjustRow(0, colCount, -1); // Decrement row spans by one
    }

    function adjustRow(from, cols, by) {
      for (var i = from; i < from + cols; i++) {
        spaceTracker[i] = Math.max(spaceTracker[i] + by, 0);
      }
    }

    function findEnd(start) {
      var i;
      for (i = start; i < spaceTracker.length; i++) {
        if (spaceTracker[i] !== 0) {
          return i;
        }
      }

      if (i === spaceTracker.length) {
        return i;
      }
    }

    function newSpaceTracker() {
      var tracker = [];
      for (var i = 0; i < colCount; i++) {
        tracker.push(0);
      }
      return tracker;
    }
  }
}

/**
 * @ngdoc directive
 * @name mdGridTile
 * @module material.components.gridList
 * @restrict E
 * @description
 * Tiles contain the content of an `md-grid-list`. They span one or more grid
 * cells vertically or horizontally, and use `md-grid-tile-{footer,header}` to
 * display secondary content.
 *
 * ### Responsive Attributes
 *
 * The `md-grid-tile` directive supports "responsive" attributes, which allow
 * different `md-rowspan` and `md-colspan` values depending on the currently
 * matching media query.
 *
 * In order to set a responsive attribute, first define the fallback value with
 * the standard attribute name, then add additional attributes with the
 * following convention: `{base-attribute-name}-{media-query-name}="{value}"`
 * (ie. `md-colspan-sm="4"`)
 *
 * @param {number=} md-colspan The number of columns to span (default 1). Cannot
 *    exceed the number of columns in the grid. Supports interpolation.
 * @param {number=} md-rowspan The number of rows to span (default 1). Supports
 *     interpolation.
 *
 * @usage
 * With header:
 * <hljs lang="html">
 * <md-grid-tile>
 *   <md-grid-tile-header>
 *     <h3>This is a header</h3>
 *   </md-grid-tile-header>
 * </md-grid-tile>
 * </hljs>
 *
 * With footer:
 * <hljs lang="html">
 * <md-grid-tile>
 *   <md-grid-tile-footer>
 *     <h3>This is a footer</h3>
 *   </md-grid-tile-footer>
 * </md-grid-tile>
 * </hljs>
 *
 * Spanning multiple rows/columns:
 * <hljs lang="html">
 * <md-grid-tile md-colspan="2" md-rowspan="3">
 * </md-grid-tile>
 * </hljs>
 *
 * Responsive attributes:
 * <hljs lang="html">
 * <md-grid-tile md-colspan="1" md-colspan-sm="3" md-colspan-md="5">
 * </md-grid-tile>
 * </hljs>
 */
function GridTileDirective($mdMedia) {
  return {
    restrict: 'E',
    require: '^mdGridList',
    template: '<figure ng-transclude></figure>',
    transclude: true,
    scope: {},
    // Simple controller that exposes attributes to the grid directive
    controller: ["$attrs", function($attrs) {
      this.$attrs = $attrs;
    }],
    link: postLink
  };

  function postLink(scope, element, attrs, gridCtrl) {
    // Apply semantics
    element.attr('role', 'listitem');

    // If our colspan or rowspan changes, trigger a layout
    var unwatchAttrs = $mdMedia.watchResponsiveAttributes(['md-colspan', 'md-rowspan'],
        attrs, angular.bind(gridCtrl, gridCtrl.invalidateLayout));

    // Tile registration/deregistration
    gridCtrl.invalidateTiles();
    scope.$on('$destroy', function() {
      // Mark the tile as destroyed so it is no longer considered in layout,
      // even if the DOM element sticks around (like during a leave animation)
      element[0].$$mdDestroyed = true;
      unwatchAttrs();
      gridCtrl.invalidateLayout();
    });

    if (angular.isDefined(scope.$parent.$index)) {
      scope.$watch(function() { return scope.$parent.$index; },
        function indexChanged(newIdx, oldIdx) {
          if (newIdx === oldIdx) {
            return;
          }
          gridCtrl.invalidateTiles();
        });
    }
  }
}


function GridTileCaptionDirective() {
  return {
    template: '<figcaption ng-transclude></figcaption>',
    transclude: true
  };
}

})();
(function(){
"use strict";

/**
 * @ngdoc module
 * @name material.components.icon
 * @description
 * Icon
 */
angular.module('material.components.icon', ['material.core']);

})();
(function(){
"use strict";

angular
  .module('material.components.icon')
  .directive('mdIcon', ['$mdIcon', '$mdTheming', '$mdAria', '$sce', mdIconDirective]);

/**
 * @ngdoc directive
 * @name mdIcon
 * @module material.components.icon
 *
 * @restrict E
 *
 * @description
 * The `md-icon` directive makes it easier to use vector-based icons in your app (as opposed to
 * raster-based icons types like PNG). The directive supports both icon fonts and SVG icons.
 *
 * Icons should be considered view-only elements that should not be used directly as buttons; instead nest a `<md-icon>`
 * inside a `md-button` to add hover and click features.
 *
 * ### Icon fonts
 * Icon fonts are a technique in which you use a font where the glyphs in the font are
 * your icons instead of text. Benefits include a straightforward way to bundle everything into a
 * single HTTP request, simple scaling, easy color changing, and more.
 *
 * `md-icon` lets you consume an icon font by letting you reference specific icons in that font
 * by name rather than character code.
 *
 * When using font-icons, developers must follow three (3) simple steps:
 *
 * <ol>
 * <li>Load the font library. e.g.<br/>
 *    `<link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">`
 * </li>
 * <li>
 *   Use either (a) font-icon class names or (b) a fontset and a font ligature to render the font glyph by
 *   using its textual name _or_ numerical character reference. Note that `material-icons` is the default fontset when
 *   none is specified.
 * </li>
 * <li> Use any of the following templates: <br/>
 *   <ul>
 *     <li>`<md-icon md-font-icon="classname"></md-icon>`</li>
 *     <li>`<md-icon md-font-set="font library classname or alias">textual_name</md-icon>`</li>
 *     <li>`<md-icon> numerical_character_reference </md-icon>`</li>
 *     <li>`<md-icon ng_bind="'textual_name'"></md-icon>`</li>
 *     <li>`<md-icon ng-bind="scopeVariable"></md-icon>`</li>
 *   </ul>
 * </li>
 * </ol>
 *
 * Full details for these steps can be found in the
 * <a href="http://google.github.io/material-design-icons/#icon-font-for-the-web" target="_blank">
 * Material Design Icon font for the web docs</a>.
 *
 * You can browse and search the Material Design icon style <code>.material-icons</code>
 * in the <a href="https://material.io/tools/icons/" target="_blank">Material Design Icons tool</a>.
 *
 * ### SVG
 * For SVGs, the problem with using `<img>` or a CSS `background-image` is that you can't take
 * advantage of some SVG features, such as styling specific parts of the icon with CSS or SVG
 * animation.
 *
 * `md-icon` makes it easier to use SVG icons by *inlining* the SVG into an `<svg>` element in the
 * document. The most straightforward way of referencing an SVG icon is via URL, just like a
 * traditional `<img>`. `$mdIconProvider`, as a convenience, lets you _name_ an icon so you can
 * reference it by name instead of URL throughout your templates.
 *
 * Additionally, you may not want to make separate HTTP requests for every icon, so you can bundle
 * your SVG icons together and pre-load them with `$mdIconProvider` as an icon set. An icon set can
 * also be given a name, which acts as a namespace for individual icons, so you can reference them
 * like `"social:cake"`.
 *
 * When using SVGs, both external SVGs (via URLs) or sets of SVGs (from icon sets) can be
 * easily loaded and used.
 *
 * ### Localization
 *
 * Because an `md-icon` element's text content is not intended to be translated, it is recommended
 * to declare the text content for an `md-icon` element in its start tag. Instead of using the HTML
 * text content, consider using `ng-bind` with a scope variable or literal string.
 *
 * Examples:
 *
 * <ul>
 *   <li>`<md-icon ng-bind="myIconVariable"></md-icon>`</li>
 *   <li>`<md-icon ng-bind="'menu'"></md-icon>`
 * </ul>
 *
 * <h2 id="material_design_icons">Material Design Icons tool</h2>
 * Using the Material Design Icons tool, developers can easily and quickly search for a specific
 * open source Material Design icon. The search is in the top left. Below search, you can select
 * from the new icon themes or filter by icon category.
 *
 * <a href="https://material.io/tools/icons/" target="_blank" style="border-bottom:none;">
 * <img src="https://user-images.githubusercontent.com/3506071/41942584-ef0695d0-796d-11e8-9436-44f25023a111.png"
 *      aria-label="Material Design Icons tool" style="max-width:95%">
 * </a>
 *
 * <div class="md-caption" style="text-align: center; margin-bottom: 24px">
 *  Click on the image above to open the
 *  <a href="https://material.io/tools/icons/" target="_blank">Material Design Icons tool</a>.
 * </div>
 *
 * Click on any icon, then click on the "Selected Icon" chevron to see the slide-up
 * information panel with details regarding a SVG download and information on the font-icon's
 * textual name. This panel also allows you to select a black on transparent or white on transparent
 * icon and to change the icon size. These settings only affect the downloaded icons.
 *
 * @param {string} md-font-icon String name of CSS icon associated with the font-face will be used
 * to render the icon. Requires the fonts and the named CSS styles to be preloaded.
 * @param {string} md-font-set CSS style name associated with the font library; which will be assigned as
 * the class for the font-icon ligature. This value may also be an alias that is used to lookup the classname;
 * internally use `$mdIconProvider.fontSet(<alias>)` to determine the style name.
 * @param {string} md-svg-src String URL (or expression) used to load, cache, and display an
 *     external SVG.
 * @param {string} md-svg-icon md-svg-icon String name used for lookup of the icon from the internal cache;
 *     interpolated strings or expressions may also be used. Specific set names can be used with
 *     the syntax `<set name>:<icon name>`.<br/><br/>
 * To use icon sets, developers are required to pre-register the sets using the `$mdIconProvider` service.
 * @param {string=} aria-label Labels icon for accessibility. If an empty string is provided, icon
 * will be hidden from accessibility layer with `aria-hidden="true"`. If there's no aria-label on the icon
 * nor a label on the parent element, a warning will be logged to the console.
 * @param {string=} alt Labels icon for accessibility. If an empty string is provided, icon
 * will be hidden from accessibility layer with `aria-hidden="true"`. If there's no alt on the icon
 * nor a label on the parent element, a warning will be logged to the console.
 *
 * @usage
 * When using SVGs:
 * <hljs lang="html">
 *
 *<!-- Icon ID; may contain optional icon set prefix.
 *     Icons must be registered using $mdIconProvider. -->
 *<md-icon md-svg-icon="social:android"    aria-label="android " ></md-icon>
 *
 *<!-- Icon urls; may be preloaded in templateCache -->
 *<md-icon md-svg-src="/android.svg"       aria-label="android " ></md-icon>
 *<md-icon md-svg-src="{{ getAndroid() }}" aria-label="android " ></md-icon>
 *
 * </hljs>
 *
 * Use the <code>$mdIconProvider</code> to configure your application with
 * SVG icon sets.
 *
 * <hljs lang="js">
 * angular.module('appSvgIconSets', ['ngMaterial'])
 *   .controller('DemoCtrl', function($scope) {})
 *   .config(function($mdIconProvider) {
 *     $mdIconProvider
 *       .iconSet('social', 'img/icons/sets/social-icons.svg', 24)
 *       .defaultIconSet('img/icons/sets/core-icons.svg', 24);
 *    });
 * </hljs>
 *
 *
 * When using Font Icons with classnames:
 * <hljs lang="html">
 *
 * <md-icon md-font-icon="android" aria-label="android" ></md-icon>
 * <md-icon class="icon_home" aria-label="Home"></md-icon>
 *
 * </hljs>
 *
 * When using Material Font Icons with ligatures:
 * <hljs lang="html">
 *  <!--
 *  For Material Design Icons
 *  The class '.material-icons' is auto-added if a style has NOT been specified
 *  since `material-icons` is the default fontset. So your markup:
 *  -->
 *  <md-icon> face </md-icon>
 *  <!-- becomes this at runtime: -->
 *  <md-icon md-font-set="material-icons"> face </md-icon>
 *  <!-- If the fontset does not support ligature names, then we need to use the ligature unicode.-->
 *  <md-icon> &#xE87C; </md-icon>
 *  <!-- The class '.material-icons' must be manually added if other styles are also specified-->
 *  <md-icon class="material-icons md-light md-48"> face </md-icon>
 * </hljs>
 *
 * When using other Font-Icon libraries:
 *
 * <hljs lang="js">
 *  // Specify a font-icon style alias
 *  angular.config(function($mdIconProvider) {
 *    $mdIconProvider.fontSet('md', 'material-icons');
 *  });
 * </hljs>
 *
 * <hljs lang="html">
 *  <md-icon md-font-set="md">favorite</md-icon>
 * </hljs>
 *
 */
function mdIconDirective($mdIcon, $mdTheming, $mdAria, $sce) {

  return {
    restrict: 'E',
    link : postLink
  };


  /**
   * Directive postLink
   * Supports embedded SVGs, font-icons, & external SVGs
   */
  function postLink(scope, element, attr) {
    $mdTheming(element);
    var lastFontIcon = attr.mdFontIcon;
    var lastFontSet = $mdIcon.fontSet(attr.mdFontSet);

    prepareForFontIcon();

    attr.$observe('mdFontIcon', fontIconChanged);
    attr.$observe('mdFontSet', fontIconChanged);

    // Keep track of the content of the svg src so we can compare against it later to see if the
    // attribute is static (and thus safe).
    var originalSvgSrc = element[0].getAttribute(attr.$attr.mdSvgSrc);

    // If using a font-icon, then the textual name of the icon itself
    // provides the aria-label.

    var attrName = attr.$normalize(attr.$attr.mdSvgIcon || attr.$attr.mdSvgSrc || '');

    /* Provide a default accessibility role of img */
    if (!attr.role) {
      $mdAria.expect(element, 'role', 'img');
      /* manually update attr variable */
      attr.role = 'img';
    }

    /* Don't process ARIA if already valid */
    if (attr.role === "img" && !attr.ariaHidden && !$mdAria.hasAriaLabel(element)) {
      var iconName;
      if (attr.alt) {
        /* Use alt text by default if available */
        $mdAria.expect(element, 'aria-label', attr.alt);
      } else if ($mdAria.parentHasAriaLabel(element, 2)) {
        /* Parent has ARIA so we will assume it will describe the image */
        $mdAria.expect(element, 'aria-hidden', 'true');
      } else if (iconName = (attr.mdFontIcon || attr.mdSvgIcon || element.text())) {
        /* Use icon name as aria-label */
        $mdAria.expect(element, 'aria-label', iconName);
      } else {
        /* No label found */
        $mdAria.expect(element, 'aria-hidden', 'true');
      }
    }

    if (attrName) {
      // Use either pre-configured SVG or URL source, respectively.
      attr.$observe(attrName, function(attrVal) {
        element.empty();
        if (attrVal) {
          $mdIcon(attrVal)
            .then(function(svg) {
            element.empty();
            element.append(svg);
          });
        }
      });
    }

    function prepareForFontIcon() {
      if (!attr.mdSvgIcon && !attr.mdSvgSrc) {
        if (attr.mdFontIcon) {
          element.addClass('md-font ' + attr.mdFontIcon);
        }

        element.addClass(lastFontSet);
      }
    }

    function fontIconChanged() {
      if (!attr.mdSvgIcon && !attr.mdSvgSrc) {
        if (attr.mdFontIcon) {
          element.removeClass(lastFontIcon);
          element.addClass(attr.mdFontIcon);

          lastFontIcon = attr.mdFontIcon;
        }

        var fontSet = $mdIcon.fontSet(attr.mdFontSet);

        if (lastFontSet !== fontSet) {
          element.removeClass(lastFontSet);
          element.addClass(fontSet);

          lastFontSet = fontSet;
        }
      }
    }
  }
}

})();
(function(){
"use strict";

  
MdIconService.$inject = ["config", "$templateRequest", "$q", "$log", "$mdUtil", "$sce"];angular
    .module('material.components.icon')
    .constant('$$mdSvgRegistry', {
        'mdTabsArrow':   'data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHg9IjBweCIgeT0iMHB4IiB2aWV3Qm94PSIwIDAgMjQgMjQiPjxnPjxwb2x5Z29uIHBvaW50cz0iMTUuNCw3LjQgMTQsNiA4LDEyIDE0LDE4IDE1LjQsMTYuNiAxMC44LDEyICIvPjwvZz48L3N2Zz4=',
        'mdClose':       'data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHg9IjBweCIgeT0iMHB4IiB2aWV3Qm94PSIwIDAgMjQgMjQiPjxnPjxwYXRoIGQ9Ik0xOSA2LjQxbC0xLjQxLTEuNDEtNS41OSA1LjU5LTUuNTktNS41OS0xLjQxIDEuNDEgNS41OSA1LjU5LTUuNTkgNS41OSAxLjQxIDEuNDEgNS41OS01LjU5IDUuNTkgNS41OSAxLjQxLTEuNDEtNS41OS01LjU5eiIvPjwvZz48L3N2Zz4=',
        'mdCancel':      'data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHg9IjBweCIgeT0iMHB4IiB2aWV3Qm94PSIwIDAgMjQgMjQiPjxnPjxwYXRoIGQ9Ik0xMiAyYy01LjUzIDAtMTAgNC40Ny0xMCAxMHM0LjQ3IDEwIDEwIDEwIDEwLTQuNDcgMTAtMTAtNC40Ny0xMC0xMC0xMHptNSAxMy41OWwtMS40MSAxLjQxLTMuNTktMy41OS0zLjU5IDMuNTktMS40MS0xLjQxIDMuNTktMy41OS0zLjU5LTMuNTkgMS40MS0xLjQxIDMuNTkgMy41OSAzLjU5LTMuNTkgMS40MSAxLjQxLTMuNTkgMy41OSAzLjU5IDMuNTl6Ii8+PC9nPjwvc3ZnPg==',
        'mdMenu':        'data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHg9IjBweCIgeT0iMHB4IiB2aWV3Qm94PSIwIDAgMjQgMjQiPjxwYXRoIGQ9Ik0zLDZIMjFWOEgzVjZNMywxMUgyMVYxM0gzVjExTTMsMTZIMjFWMThIM1YxNloiIC8+PC9zdmc+',
        'mdToggleArrow': 'data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHg9IjBweCIgeT0iMHB4IiB2aWV3Qm94PSIwIDAgNDggNDgiPjxwYXRoIGQ9Ik0yNCAxNmwtMTIgMTIgMi44MyAyLjgzIDkuMTctOS4xNyA5LjE3IDkuMTcgMi44My0yLjgzeiIvPjxwYXRoIGQ9Ik0wIDBoNDh2NDhoLTQ4eiIgZmlsbD0ibm9uZSIvPjwvc3ZnPg==',
        'mdCalendar':    'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0Ij48cGF0aCBkPSJNMTkgM2gtMVYxaC0ydjJIOFYxSDZ2Mkg1Yy0xLjExIDAtMS45OS45LTEuOTkgMkwzIDE5YzAgMS4xLjg5IDIgMiAyaDE0YzEuMSAwIDItLjkgMi0yVjVjMC0xLjEtLjktMi0yLTJ6bTAgMTZINVY4aDE0djExek03IDEwaDV2NUg3eiIvPjwvc3ZnPg==',
        'mdChecked':     'data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHg9IjBweCIgeT0iMHB4IiB2aWV3Qm94PSIwIDAgMjQgMjQiPjxnPjxwYXRoIGQ9Ik05IDE2LjE3TDQuODMgMTJsLTEuNDIgMS40MUw5IDE5IDIxIDdsLTEuNDEtMS40MXoiLz48L2c+PC9zdmc+'
    })
    .provider('$mdIcon', MdIconProvider);

/**
 * @ngdoc service
 * @name $mdIconProvider
 * @module material.components.icon
 *
 * @description
 * `$mdIconProvider` is used only to register icon IDs with URLs. These configuration features allow
 * icons and icon sets to be pre-registered and associated with source URLs **before** the `<md-icon />`
 * directives are compiled.
 *
 * If using font-icons, the developer is responsible for loading the fonts.
 *
 * If using SVGs, loading of the actual svg files are deferred to on-demand requests and are loaded
 * internally by the `$mdIcon` service using the `$templateRequest` service. When an SVG is
 * requested by name/ID, the `$mdIcon` service searches its registry for the associated source URL;
 * that URL is used to on-demand load and parse the SVG dynamically.
 *
 * The `$templateRequest` service expects the icons source to be loaded over trusted URLs.<br/>
 * This means, when loading icons from an external URL, you have to trust the URL in the `$sceDelegateProvider`.
 *
 * <hljs lang="js">
 *   app.config(function($sceDelegateProvider) {
 *     $sceDelegateProvider.resourceUrlWhitelist([
 *       // Adding 'self' to the whitelist, will allow requests from the current origin.
 *       'self',
 *       // Using double asterisks here, will allow all URLs to load.
 *       // We recommend to only specify the given domain you want to allow.
 *       '**'
 *     ]);
 *   });
 * </hljs>
 *
 * Read more about the [$sceDelegateProvider](https://docs.angularjs.org/api/ng/provider/$sceDelegateProvider).
 *
 * **Notice:** Most font-icons libraries do not support ligatures (for example `fontawesome`).<br/>
 *  In such cases you are not able to use the icon's ligature name - Like so:
 *
 *  <hljs lang="html">
 *    <md-icon md-font-set="fa">fa-bell</md-icon>
 *  </hljs>
 *
 * You should instead use the given unicode, instead of the ligature name.
 *
 * <p ng-hide="true"> ##// Notice we can't use a hljs element here, because the characters will be escaped.</p>
 *  ```html
 *    <md-icon md-font-set="fa">&#xf0f3</md-icon>
 *  ```
 *
 * All unicode ligatures are prefixed with the `&#x` string.
 *
 * @usage
 * <hljs lang="js">
 *   app.config(function($mdIconProvider) {
    *
    *     // Configure URLs for icons specified by [set:]id.
    *
    *     $mdIconProvider
    *          .defaultFontSet( 'fa' )                   // This sets our default fontset className.
    *          .defaultIconSet('my/app/icons.svg')       // Register a default set of SVG icons
    *          .iconSet('social', 'my/app/social.svg')   // Register a named icon set of SVGs
    *          .icon('android', 'my/app/android.svg')    // Register a specific icon (by name)
    *          .icon('work:chair', 'my/app/chair.svg');  // Register icon in a specific set
    *   });
 * </hljs>
 *
 * SVG icons and icon sets can be easily pre-loaded and cached using either (a) a build process or (b) a runtime
 * **startup** process (shown below):
 *
 * <hljs lang="js">
 *   app.config(function($mdIconProvider) {
    *
    *     // Register a default set of SVG icon definitions
    *     $mdIconProvider.defaultIconSet('my/app/icons.svg')
    *
    *   })
 *   .run(function($templateRequest){
    *
    *     // Pre-fetch icons sources by URL and cache in the $templateCache...
    *     // subsequent $templateRequest calls will look there first.
    *
    *     var urls = [ 'imy/app/icons.svg', 'img/icons/android.svg'];
    *
    *     angular.forEach(urls, function(url) {
    *       $templateRequest(url);
    *     });
    *
    *   });
 *
 * </hljs>
 *
 * > <b>Note:</b> The loaded SVG data is subsequently cached internally for future requests.
 *
 */

/**
 * @ngdoc method
 * @name $mdIconProvider#icon
 *
 * @description
 * Register a source URL for a specific icon name; the name may include optional 'icon set' name prefix.
 * These icons  will later be retrieved from the cache using `$mdIcon( <icon name> )`
 *
 * @param {string} id Icon name/id used to register the icon
 * @param {string} url specifies the external location for the data file. Used internally by
 * `$templateRequest` to load the data or as part of the lookup in `$templateCache` if pre-loading
 * was configured.
 * @param {number=} viewBoxSize Sets the width and height the icon's viewBox.
 * It is ignored for icons with an existing viewBox. Default size is 24.
 *
 * @returns {obj} an `$mdIconProvider` reference; used to support method call chains for the API
 *
 * @usage
 * <hljs lang="js">
 *   app.config(function($mdIconProvider) {
    *
    *     // Configure URLs for icons specified by [set:]id.
    *
    *     $mdIconProvider
    *          .icon('android', 'my/app/android.svg')    // Register a specific icon (by name)
    *          .icon('work:chair', 'my/app/chair.svg');  // Register icon in a specific set
    *   });
 * </hljs>
 *
 */
/**
 * @ngdoc method
 * @name $mdIconProvider#iconSet
 *
 * @description
 * Register a source URL for a 'named' set of icons; group of SVG definitions where each definition
 * has an icon id. Individual icons can be subsequently retrieved from this cached set using
 * `$mdIcon(<icon set name>:<icon name>)`
 *
 * @param {string} id Icon name/id used to register the iconset
 * @param {string} url specifies the external location for the data file. Used internally by
 * `$templateRequest` to load the data or as part of the lookup in `$templateCache` if pre-loading
 * was configured.
 * @param {number=} viewBoxSize Sets the width and height of the viewBox of all icons in the set.
 * It is ignored for icons with an existing viewBox. All icons in the icon set should be the same size.
 * Default value is 24.
 *
 * @returns {obj} an `$mdIconProvider` reference; used to support method call chains for the API
 *
 *
 * @usage
 * <hljs lang="js">
 *   app.config(function($mdIconProvider) {
    *
    *     // Configure URLs for icons specified by [set:]id.
    *
    *     $mdIconProvider
    *          .iconSet('social', 'my/app/social.svg')   // Register a named icon set
    *   });
 * </hljs>
 *
 */
/**
 * @ngdoc method
 * @name $mdIconProvider#defaultIconSet
 *
 * @description
 * Register a source URL for the default 'named' set of icons. Unless explicitly registered,
 * subsequent lookups of icons will failover to search this 'default' icon set.
 * Icon can be retrieved from this cached, default set using `$mdIcon(<name>)`
 *
 * @param {string} url specifies the external location for the data file. Used internally by
 * `$templateRequest` to load the data or as part of the lookup in `$templateCache` if pre-loading
 * was configured.
 * @param {number=} viewBoxSize Sets the width and height of the viewBox of all icons in the set.
 * It is ignored for icons with an existing viewBox. All icons in the icon set should be the same size.
 * Default value is 24.
 *
 * @returns {obj} an `$mdIconProvider` reference; used to support method call chains for the API
 *
 * @usage
 * <hljs lang="js">
 *   app.config(function($mdIconProvider) {
    *
    *     // Configure URLs for icons specified by [set:]id.
    *
    *     $mdIconProvider
    *          .defaultIconSet( 'my/app/social.svg' )   // Register a default icon set
    *   });
 * </hljs>
 *
 */
/**
 * @ngdoc method
 * @name $mdIconProvider#defaultFontSet
 *
 * @description
 * When using Font-Icons, AngularJS Material assumes the the Material Design icons will be used and automatically
 * configures the default font-set == 'material-icons'. Note that the font-set references the font-icon library
 * class style that should be applied to the `<md-icon>`.
 *
 * Configuring the default means that the attributes
 * `md-font-set="material-icons"` or `class="material-icons"` do not need to be explicitly declared on the
 * `<md-icon>` markup. For example:
 *
 *  `<md-icon> face </md-icon>`
 *  will render as
 *  `<span class="material-icons"> face </span>`, and
 *
 *  `<md-icon md-font-set="fa"> face </md-icon>`
 *  will render as
 *  `<span class="fa"> face </span>`
 *
 * @param {string} name of the font-library style that should be applied to the md-icon DOM element
 *
 * @usage
 * <hljs lang="js">
 *   app.config(function($mdIconProvider) {
   *     $mdIconProvider.defaultFontSet( 'fa' );
   *   });
 * </hljs>
 *
 */

/**
 * @ngdoc method
 * @name $mdIconProvider#fontSet
 *
 * @description
 * When using a font set for `<md-icon>` you must specify the correct font classname in the `md-font-set`
 * attribute. If the fonset className is really long, your markup may become cluttered... an easy
 * solution is to define an `alias` for your fontset:
 *
 * @param {string} alias of the specified fontset.
 * @param {string} className of the fontset.
 *
 * @usage
 * <hljs lang="js">
 *   app.config(function($mdIconProvider) {
   *     // In this case, we set an alias for the `material-icons` fontset.
   *     $mdIconProvider.fontSet('md', 'material-icons');
   *   });
 * </hljs>
 *
 */

/**
 * @ngdoc method
 * @name $mdIconProvider#defaultViewBoxSize
 *
 * @description
 * While `<md-icon />` markup can also be style with sizing CSS, this method configures
 * the default width **and** height used for all icons; unless overridden by specific CSS.
 * The default sizing is (24px, 24px).
 * @param {number=} viewBoxSize Sets the width and height of the viewBox for an icon or an icon set.
 * All icons in a set should be the same size. The default value is 24.
 *
 * @returns {obj} an `$mdIconProvider` reference; used to support method call chains for the API
 *
 * @usage
 * <hljs lang="js">
 *   app.config(function($mdIconProvider) {
    *
    *     // Configure URLs for icons specified by [set:]id.
    *
    *     $mdIconProvider
    *          .defaultViewBoxSize(36)   // Register a default icon size (width == height)
    *   });
 * </hljs>
 *
 */

var config = {
  defaultViewBoxSize: 24,
  defaultFontSet: 'material-icons',
  fontSets: []
};

function MdIconProvider() {
}

MdIconProvider.prototype = {
  icon: function(id, url, viewBoxSize) {
    if (id.indexOf(':') == -1) id = '$default:' + id;

    config[id] = new ConfigurationItem(url, viewBoxSize);
    return this;
  },

  iconSet: function(id, url, viewBoxSize) {
    config[id] = new ConfigurationItem(url, viewBoxSize);
    return this;
  },

  defaultIconSet: function(url, viewBoxSize) {
    var setName = '$default';

    if (!config[setName]) {
      config[setName] = new ConfigurationItem(url, viewBoxSize);
    }

    config[setName].viewBoxSize = viewBoxSize || config.defaultViewBoxSize;

    return this;
  },

  defaultViewBoxSize: function(viewBoxSize) {
    config.defaultViewBoxSize = viewBoxSize;
    return this;
  },

  /**
   * Register an alias name associated with a font-icon library style ;
   */
  fontSet: function fontSet(alias, className) {
    config.fontSets.push({
      alias: alias,
      fontSet: className || alias
    });
    return this;
  },

  /**
   * Specify a default style name associated with a font-icon library
   * fallback to Material Icons.
   *
   */
  defaultFontSet: function defaultFontSet(className) {
    config.defaultFontSet = !className ? '' : className;
    return this;
  },

  defaultIconSize: function defaultIconSize(iconSize) {
    config.defaultIconSize = iconSize;
    return this;
  },

  $get: ['$templateRequest', '$q', '$log', '$mdUtil', '$sce', function($templateRequest, $q, $log, $mdUtil, $sce) {
    return MdIconService(config, $templateRequest, $q, $log, $mdUtil, $sce);
  }]
};

  /**
   * Configuration item stored in the Icon registry; used for lookups
   * to load if not already cached in the `loaded` cache
   * @param {string} url
   * @param {=number} viewBoxSize
   * @constructor
   */
  function ConfigurationItem(url, viewBoxSize) {
    this.url = url;
    this.viewBoxSize = viewBoxSize || config.defaultViewBoxSize;
  }

/**
 * @ngdoc service
 * @name $mdIcon
 * @module material.components.icon
 *
 * @description
 * The `$mdIcon` service is a function used to lookup SVG icons.
 *
 * @param {string} id Query value for a unique Id or URL. If the argument is a URL, then the service will retrieve the icon element
 * from its internal cache or load the icon and cache it first. If the value is not a URL-type string, then an ID lookup is
 * performed. The Id may be a unique icon ID or may include an iconSet ID prefix.
 *
 * For the **id** query to work properly, this means that all id-to-URL mappings must have been previously configured
 * using the `$mdIconProvider`.
 *
 * @returns {angular.$q.Promise} A promise that gets resolved to a clone of the initial SVG DOM element; which was
 * created from the SVG markup in the SVG data file. If an error occurs (e.g. the icon cannot be found) the promise
 * will get rejected.
 *
 * @usage
 * <hljs lang="js">
 * function SomeDirective($mdIcon) {
  *
  *   // See if the icon has already been loaded, if not
  *   // then lookup the icon from the registry cache, load and cache
  *   // it for future requests.
  *   // NOTE: ID queries require configuration with $mdIconProvider
  *
  *   $mdIcon('android').then(function(iconEl)    { element.append(iconEl); });
  *   $mdIcon('work:chair').then(function(iconEl) { element.append(iconEl); });
  *
  *   // Load and cache the external SVG using a URL
  *
  *   $mdIcon('img/icons/android.svg').then(function(iconEl) {
  *     element.append(iconEl);
  *   });
  * };
 * </hljs>
 *
 * > <b>Note:</b> The `<md-icon>` directive internally uses the `$mdIcon` service to query, load,
 *   and instantiate SVG DOM elements.
 */

/* @ngInject */
function MdIconService(config, $templateRequest, $q, $log, $mdUtil, $sce) {
  var iconCache = {};
  var svgCache = {};
  var urlRegex = /[-\w@:%+.~#?&//=]{2,}\.[a-z]{2,4}\b(\/[-\w@:%+.~#?&//=]*)?/i;
  var dataUrlRegex = /^data:image\/svg\+xml[\s*;\w\-=]*?(base64)?,(.*)$/i;

  Icon.prototype = {clone: cloneSVG, prepare: prepareAndStyle};
  getIcon.fontSet = findRegisteredFontSet;

  // Publish service...
  return getIcon;

  /**
   * Actual $mdIcon service is essentially a lookup function
   * @param {*} id $sce trust wrapper over a URL string, URL, icon registry id, or icon set id
   * @returns {angular.$q.Promise}
   */
  function getIcon(id) {
    id = id || '';

    // If the "id" provided is not a string, the only other valid value is a $sce trust wrapper
    // over a URL string. If the value is not trusted, this will intentionally throw an error
    // because the user is attempted to use an unsafe URL, potentially opening themselves up
    // to an XSS attack.
    if (!angular.isString(id)) {
      id = $sce.getTrustedUrl(id);
    }

    // If already loaded and cached, use a clone of the cached icon.
    // Otherwise either load by URL, or lookup in the registry and then load by URL, and cache.

    if (iconCache[id]) {
      return $q.when(transformClone(iconCache[id]));
    }

    if (urlRegex.test(id) || dataUrlRegex.test(id)) {
      return loadByURL(id).then(cacheIcon(id));
    }

    if (id.indexOf(':') === -1) {
      id = '$default:' + id;
    }

    var load = config[id] ? loadByID : loadFromIconSet;
    return load(id)
      .then(cacheIcon(id));
  }

  /**
   * Lookup a registered fontSet style using its alias.
   * @param {string} alias used to lookup the alias in the array of fontSets
   * @returns {*} matching fontSet or the defaultFontSet if that alias does not match
   */
  function findRegisteredFontSet(alias) {
    var useDefault = angular.isUndefined(alias) || !(alias && alias.length);
    if (useDefault) {
      return config.defaultFontSet;
    }

    var result = alias;
    angular.forEach(config.fontSets, function(fontSet) {
      if (fontSet.alias === alias) {
        result = fontSet.fontSet || result;
      }
    });

    return result;
  }

  /**
   * @param {!Icon} cacheElement cached icon from the iconCache
   * @returns {Icon} cloned Icon element with unique ids
   */
  function transformClone(cacheElement) {
    var clone = cacheElement.clone();
    var newUid = $mdUtil.nextUid();
    var cacheSuffix, svgUrlQuerySelector, i, xlinkHrefValue;
    // These are SVG attributes that can reference element ids.
    var svgUrlAttributes = [
      'clip-path', 'color-profile', 'cursor', 'fill', 'filter', 'href', 'marker-start',
      'marker-mid', 'marker-end', 'mask', 'stroke', 'style', 'vector-effect'
    ];
    var isIeSvg = clone.innerHTML === undefined;

    // Verify that the newUid only contains a number and not some XSS content.
    if (!isFinite(Number(newUid))) {
      throw new Error('Unsafe and unexpected non-number result from $mdUtil.nextUid().');
    }
    cacheSuffix = '_cache' + newUid;

    // For each cached icon, we need to modify the id attributes and references.
    // This is needed because SVG ids are treated as normal DOM ids and should not be duplicated on
    // the page.
    if (clone.id) {
      clone.id += cacheSuffix;
    }

    // Do as much as possible with querySelectorAll as it provides much greater performance
    // than RegEx against serialized DOM.
    angular.forEach(clone.querySelectorAll('[id]'), function(descendantElem) {
      svgUrlQuerySelector = '';
      for (i = 0; i < svgUrlAttributes.length; i++) {
        svgUrlQuerySelector += '[' + svgUrlAttributes[i] + '="url(#' + descendantElem.id + ')"]';
        if (i + 1 < svgUrlAttributes.length) {
          svgUrlQuerySelector += ', ';
        }
      }
      // Append the cacheSuffix to references of the element's id within url(#id) calls.
      angular.forEach(clone.querySelectorAll(svgUrlQuerySelector), function(refItem) {
        updateSvgIdReferences(descendantElem, refItem, isIeSvg, newUid);
      });
      // Handle usages of url(#id) in the SVG's stylesheets
      angular.forEach(clone.querySelectorAll('style'), function(refItem) {
        updateSvgIdReferences(descendantElem, refItem, isIeSvg, newUid);
      });

      // Update ids referenced by the deprecated (in SVG v2) xlink:href XML attribute. The now
      // preferred href attribute is handled above. However, this non-standard XML namespaced
      // attribute cannot be handled in the same way. Explanation of this query selector here:
      // https://stackoverflow.com/q/23034283/633107.
      angular.forEach(clone.querySelectorAll('[*|href]:not([href])'), function(refItem) {
        xlinkHrefValue = refItem.getAttribute('xlink:href');
        if (xlinkHrefValue) {
          xlinkHrefValue = xlinkHrefValue.replace("#" + descendantElem.id, "#" + descendantElem.id + cacheSuffix);
          refItem.setAttribute('xlink:href', xlinkHrefValue);
        }
      });

      descendantElem.id += cacheSuffix;
    });

    return clone;
  }

  /**
   * @param {Element} referencedElement element w/ id that needs to be updated
   * @param {Element} referencingElement element that references the original id
   * @param {boolean} isIeSvg true if we're dealing with an SVG in IE11, false otherwise
   * @param {string} newUid the cache id to add as part of the cache suffix
   */
  function updateSvgIdReferences(referencedElement, referencingElement, isIeSvg, newUid) {
    var svgElement, cacheSuffix;

    // Verify that the newUid only contains a number and not some XSS content.
    if (!isFinite(Number(newUid))) {
      throw new Error('Unsafe and unexpected non-number result for newUid.');
    }
    cacheSuffix = '_cache' + newUid;

    // outerHTML of SVG elements is not supported by IE11
    if (isIeSvg) {
      svgElement = $mdUtil.getOuterHTML(referencingElement);
      svgElement = svgElement.replace("url(#" + referencedElement.id + ")",
        "url(#" + referencedElement.id + cacheSuffix + ")");
      referencingElement.textContent = angular.element(svgElement)[0].innerHTML;
    } else {
      // This use of outerHTML should be safe from XSS attack since we are only injecting the
      // cacheSuffix with content from $mdUtil.nextUid which we verify is a finite number above.
      referencingElement.outerHTML = referencingElement.outerHTML.replace(
        "url(#" + referencedElement.id + ")",
        "url(#" + referencedElement.id + cacheSuffix + ")");
    }
  }

  /**
   * Prepare and cache the loaded icon for the specified `id`.
   * @param {string} id icon cache id
   * @returns {function(*=): *}
   */
  function cacheIcon(id) {

    return function updateCache(icon) {
      iconCache[id] = isIcon(icon) ? icon : new Icon(icon, config[id]);

      return transformClone(iconCache[id]);
    };
  }

  /**
   * Lookup the configuration in the registry, if !registered throw an error
   * otherwise load the icon [on-demand] using the registered URL.
   * @param {string} id icon registry id
   * @returns {angular.$q.Promise}
   */
  function loadByID(id) {
    var iconConfig = config[id];
    return loadByURL(iconConfig.url).then(function(icon) {
      return new Icon(icon, iconConfig);
    });
  }

  /**
   * Loads the file as XML and uses querySelector( <id> ) to find the desired node...
   * @param {string} id icon id in icon set
   * @returns {angular.$q.Promise}
   */
  function loadFromIconSet(id) {
    var setName = id.substring(0, id.lastIndexOf(':')) || '$default';
    var iconSetConfig = config[setName];

    return !iconSetConfig ? announceIdNotFound(id) : loadByURL(iconSetConfig.url).then(extractFromSet);

    function extractFromSet(set) {
      var iconName = id.slice(id.lastIndexOf(':') + 1);
      var icon = set.querySelector('#' + iconName);
      return icon ? new Icon(icon, iconSetConfig) : announceIdNotFound(id);
    }

    function announceIdNotFound(id) {
      var msg = 'icon ' + id + ' not found';
      $log.warn(msg);

      return $q.reject(msg || id);
    }
  }

  /**
   * Load the icon by URL (may use the $templateCache).
   * Extract the data for later conversion to Icon
   * @param {string} url icon URL
   * @returns {angular.$q.Promise}
   */
  function loadByURL(url) {
    /* Load the icon from embedded data URL. */
    function loadByDataUrl(url) {
      var results = dataUrlRegex.exec(url);
      var isBase64 = /base64/i.test(url);
      var data = isBase64 ? window.atob(results[2]) : results[2];

      return $q.when(angular.element(data)[0]);
    }

    /* Load the icon by URL using HTTP. */
    function loadByHttpUrl(url) {
      return $q(function(resolve, reject) {
        // Catch HTTP or generic errors not related to incorrect icon IDs.
        var announceAndReject = function(err) {
            var msg = angular.isString(err) ? err : (err.message || err.data || err.statusText);
            $log.warn(msg);
            reject(err);
          },
          extractSvg = function(response) {
            if (!svgCache[url]) {
              svgCache[url] = angular.element('<div>').append(response)[0].querySelector('svg');
            }
            resolve(svgCache[url]);
          };

        $templateRequest(url, true).then(extractSvg, announceAndReject);
      });
    }

    return dataUrlRegex.test(url)
      ? loadByDataUrl(url)
      : loadByHttpUrl(url);
  }

  /**
   * Check target signature to see if it is an Icon instance.
   * @param {Icon|Element} target
   * @returns {boolean} true if the specified target is an Icon object, false otherwise.
   */
  function isIcon(target) {
    return angular.isDefined(target.element) && angular.isDefined(target.config);
  }

  /**
   * Define the Icon class
   * @param {Element} el
   * @param {=ConfigurationItem} config
   * @constructor
   */
  function Icon(el, config) {
    // If the node is a <symbol>, it won't be rendered so we have to convert it into <svg>.
    if (el && el.tagName.toLowerCase() === 'symbol') {
      var viewbox = el.getAttribute('viewBox');
      // // Check if innerHTML is supported as IE11 does not support innerHTML on SVG elements.
      if (el.innerHTML) {
        el = angular.element('<svg xmlns="http://www.w3.org/2000/svg">')
          .html(el.innerHTML)[0];
      } else {
        el = angular.element('<svg xmlns="http://www.w3.org/2000/svg">')
          .append($mdUtil.getInnerHTML(el))[0];
      }
      if (viewbox) el.setAttribute('viewBox', viewbox);
    }

    if (el && el.tagName.toLowerCase() !== 'svg') {
      el = angular.element(
        '<svg xmlns="http://www.w3.org/2000/svg">').append(el.cloneNode(true))[0];
    }

    // Inject the namespace if not available...
    if (!el.getAttribute('xmlns')) {
      el.setAttribute('xmlns', "http://www.w3.org/2000/svg");
    }

    this.element = el;
    this.config = config;
    this.prepare();
  }

  /**
   *  Prepare the DOM element that will be cached in the
   *  loaded iconCache store.
   */
  function prepareAndStyle() {
    var viewBoxSize = this.config ? this.config.viewBoxSize : config.defaultViewBoxSize;
    angular.forEach({
      'fit': '',
      'height': '100%',
      'width': '100%',
      'preserveAspectRatio': 'xMidYMid meet',
      'viewBox': this.element.getAttribute('viewBox') || ('0 0 ' + viewBoxSize + ' ' + viewBoxSize),
      'focusable': false // Disable IE11s default behavior to make SVGs focusable
    }, function(val, attr) {
      this.element.setAttribute(attr, val);
    }, this);
  }

  /**
   * Clone the Icon DOM element.
   */
  function cloneSVG() {
    // If the element or any of its children have a style attribute, then a CSP policy without
    // 'unsafe-inline' in the style-src directive, will result in a violation.
    return this.element.cloneNode(true);
  }

}

})();
(function(){
"use strict";

/**
 * @ngdoc module
 * @name material.components.input
 */
mdInputContainerDirective.$inject = ["$mdTheming", "$parse", "$$rAF"];
inputTextareaDirective.$inject = ["$mdUtil", "$window", "$mdAria", "$timeout", "$mdGesture"];
mdMaxlengthDirective.$inject = ["$animate", "$mdUtil"];
placeholderDirective.$inject = ["$compile"];
ngMessageDirective.$inject = ["$mdUtil"];
mdSelectOnFocusDirective.$inject = ["$document", "$timeout"];
mdInputInvalidMessagesAnimation.$inject = ["$$AnimateRunner", "$animateCss", "$mdUtil"];
ngMessagesAnimation.$inject = ["$$AnimateRunner", "$animateCss", "$mdUtil"];
ngMessageAnimation.$inject = ["$$AnimateRunner", "$animateCss", "$mdUtil", "$log"];
var inputModule = angular.module('material.components.input', [
    'material.core'
  ])
  .directive('mdInputContainer', mdInputContainerDirective)
  .directive('label', labelDirective)
  .directive('input', inputTextareaDirective)
  .directive('textarea', inputTextareaDirective)
  .directive('mdMaxlength', mdMaxlengthDirective)
  .directive('placeholder', placeholderDirective)
  .directive('ngMessages', ngMessagesDirective)
  .directive('ngMessage', ngMessageDirective)
  .directive('ngMessageExp', ngMessageDirective)
  .directive('mdSelectOnFocus', mdSelectOnFocusDirective)

  .animation('.md-input-invalid', mdInputInvalidMessagesAnimation)
  .animation('.md-input-messages-animation', ngMessagesAnimation)
  .animation('.md-input-message-animation', ngMessageAnimation);

// If we are running inside of tests; expose some extra services so that we can test them
if (window._mdMocksIncluded) {
  inputModule.service('$$mdInput', function() {
    return {
      // special accessor to internals... useful for testing
      messages: {
        getElement  : getMessagesElement
      }
    };
  })

  // Register a service for each animation so that we can easily inject them into unit tests
  .service('mdInputInvalidAnimation', mdInputInvalidMessagesAnimation)
  .service('mdInputMessagesAnimation', ngMessagesAnimation)
  .service('mdInputMessageAnimation', ngMessageAnimation);
}

/**
 * @ngdoc directive
 * @name mdInputContainer
 * @module material.components.input
 *
 * @restrict E
 *
 * @description
 * `<md-input-container>` is the parent of any input or textarea element. It can also optionally
 * wrap `<md-select>` elements so that they will be formatted for use in a form.
 *
 * Input and textarea elements will not behave properly unless the md-input-container parent is
 * provided.
 *
 * A single `<md-input-container>` should contain only one `<input>` or `<md-select>` element,
 * otherwise it will throw an error.
 *
 * <b>Exception:</b> Hidden inputs (`<input type="hidden" />`) are ignored and will not throw an
 * error, so you may combine these with other inputs.
 *
 * <b>Note:</b> When using `ngMessages` with your input element, make sure the message and container
 * elements are *block* elements, otherwise animations applied to the messages will not look as
 * intended. Either use a `div` and apply the `ng-message` and `ng-messages` classes respectively,
 * or use the `md-block` class on your element.
 *
 * @param {expression=} md-is-error When the given expression evaluates to `true`, the input
 *   container will go into the error state. Defaults to erroring if the input has been touched and
 *   is invalid.
 * @param {boolean=} md-no-float When present, `placeholder` attributes on the input will not be
 *   converted to floating labels.
 *
 * @usage
 * <hljs lang="html">
 * <md-input-container>
 *   <label>Username</label>
 *   <input type="text" ng-model="user.name">
 * </md-input-container>
 *
 * <md-input-container>
 *   <label>Description</label>
 *   <textarea ng-model="user.description"></textarea>
 * </md-input-container>
 *
 * <md-input-container>
 *   <md-select ng-model="user.state" placeholder="State of Residence">
 *     <md-option ng-value="state" ng-repeat="state in states">{{ state }}</md-option>
 *   </md-select>
 * </md-input-container>
 * </hljs>
 *
 * <h3>When disabling floating labels</h3>
 * <hljs lang="html">
 *
 * <md-input-container md-no-float>
 *   <input type="text" placeholder="Non-Floating Label">
 * </md-input-container>
 * </hljs>
 */
function mdInputContainerDirective($mdTheming, $parse, $$rAF) {

  ContainerCtrl.$inject = ["$scope", "$element", "$attrs", "$animate"];
  var INPUT_TAGS = ['INPUT', 'TEXTAREA', 'SELECT', 'MD-SELECT'];

  var LEFT_SELECTORS = INPUT_TAGS.reduce(function(selectors, isel) {
    return selectors.concat(['md-icon ~ ' + isel, '.md-icon ~ ' + isel]);
  }, []).join(",");

  var RIGHT_SELECTORS = INPUT_TAGS.reduce(function(selectors, isel) {
    return selectors.concat([isel + ' ~ md-icon', isel + ' ~ .md-icon']);
  }, []).join(",");

  return {
    restrict: 'E',
    compile: compile,
    controller: ContainerCtrl
  };

  function compile(tElement) {
    // Check for both a left & right icon
    var hasLeftIcon = tElement[0].querySelector(LEFT_SELECTORS);
    var hasRightIcon = tElement[0].querySelector(RIGHT_SELECTORS);

    return function postLink(scope, element) {
      $mdTheming(element);

      if (hasLeftIcon || hasRightIcon) {
        // When accessing the element's contents synchronously, they may not be defined yet because
        // of the use of ng-if. If we wait one frame, then the element should be there if the ng-if
        // resolves to true.
        $$rAF(function() {
          // Handle the case where the md-icon element is initially hidden via ng-if from #9529.
          // We don't want to preserve the space for the icon in the case of ng-if, like we do for
          // ng-show.
          // Note that we can't use the same selectors from above because the elements are no longer
          // siblings for textareas at this point due to the insertion of the md-resize-wrapper.
          var iconNotRemoved = element[0].querySelector('md-icon') ||
            element[0].querySelector('.md-icon');
          if (hasLeftIcon && iconNotRemoved) {
            element.addClass('md-icon-left');
          }
          if (hasRightIcon && iconNotRemoved) {
            element.addClass('md-icon-right');
          }
        });
      }
    };
  }

  function ContainerCtrl($scope, $element, $attrs, $animate) {
    var self = this;

    self.isErrorGetter = $attrs.mdIsError && $parse($attrs.mdIsError);

    self.delegateClick = function() {
      self.input.focus();
    };
    self.element = $element;
    self.setFocused = function(isFocused) {
      $element.toggleClass('md-input-focused', !!isFocused);
    };
    self.setHasValue = function(hasValue) {
      $element.toggleClass('md-input-has-value', !!hasValue);
    };
    self.setHasPlaceholder = function(hasPlaceholder) {
      $element.toggleClass('md-input-has-placeholder', !!hasPlaceholder);
    };
    self.setInvalid = function(isInvalid) {
      if (isInvalid) {
        $animate.addClass($element, 'md-input-invalid');
      } else {
        $animate.removeClass($element, 'md-input-invalid');
      }
    };
    $scope.$watch(function() {
      return self.label && self.input;
    }, function(hasLabelAndInput) {
      if (hasLabelAndInput && !self.label.attr('for')) {
        self.label.attr('for', self.input.attr('id'));
      }
    });
  }
}

function labelDirective() {
  return {
    restrict: 'E',
    require: '^?mdInputContainer',
    link: function(scope, element, attr, containerCtrl) {
      if (!containerCtrl || attr.mdNoFloat || element.hasClass('md-container-ignore')) return;

      containerCtrl.label = element;
      scope.$on('$destroy', function() {
        containerCtrl.label = null;
      });
    }
  };
}

/**
 * @ngdoc directive
 * @name mdInput
 * @restrict E
 * @module material.components.input
 *
 * @description
 * You can use any `<input>` or `<textarea>` element as a child of an `<md-input-container>`. This
 * allows you to build complex forms for data entry.
 *
 * When the input is required and uses a floating label, then the label will automatically contain
 * an asterisk (`*`).<br/>
 * This behavior can be disabled by using the `md-no-asterisk` attribute.
 *
 * @param {number=} md-maxlength The maximum number of characters allowed in this input. If this is
 *   specified, a character counter will be shown underneath the input.<br/><br/>
 *   The purpose of **`md-maxlength`** is exactly to show the max length counter text. If you don't
 *   want the counter text and only need "plain" validation, you can use the "simple" `ng-maxlength`
 *   or maxlength attributes.<br/><br/>
 * @param {boolean=} ng-trim If set to false, the input text will be not trimmed automatically.
 *     Defaults to true.
 * @param {string=} aria-label Aria-label is required when no label is present.  A warning message
 *   will be logged in the console if not present.
 * @param {string=} placeholder An alternative approach to using aria-label when the label is not
 *   PRESENT. The placeholder text is copied to the aria-label attribute.
 * @param {boolean=} md-no-autogrow When present, textareas will not grow automatically.
 * @param {boolean=} md-no-asterisk When present, an asterisk will not be appended to the inputs
 *   floating label.
 * @param {boolean=} md-no-resize Disables the textarea resize handle.
 * @param {number=} max-rows The maximum amount of rows for a textarea.
 * @param {boolean=} md-detect-hidden When present, textareas will be sized properly when they are
 *   revealed after being hidden. This is off by default for performance reasons because it
 *   guarantees a reflow every digest cycle.
 *
 * @usage
 * <hljs lang="html">
 * <md-input-container>
 *   <label>Color</label>
 *   <input type="text" ng-model="color" required md-maxlength="10">
 * </md-input-container>
 * </hljs>
 *
 * <h3>With Errors</h3>
 *
 * `md-input-container` also supports errors using the standard `ng-messages` directives and
 * animates the messages when they become visible using from the `ngEnter`/`ngLeave` events or
 * the `ngShow`/`ngHide` events.
 *
 * By default, the messages will be hidden until the input is in an error state. This is based off
 * of the `md-is-error` expression of the `md-input-container`. This gives the user a chance to
 * fill out the form before the errors become visible.
 *
 * <hljs lang="html">
 * <form name="colorForm">
 *   <md-input-container>
 *     <label>Favorite Color</label>
 *     <input name="favoriteColor" ng-model="favoriteColor" required>
 *     <div ng-messages="colorForm.favoriteColor.$error">
 *       <div ng-message="required">This is required!</div>
 *     </div>
 *   </md-input-container>
 * </form>
 * </hljs>
 *
 * We automatically disable this auto-hiding functionality if you provide any of the following
 * visibility directives on the `ng-messages` container:
 *
 *  - `ng-if`
 *  - `ng-show`/`ng-hide`
 *  - `ng-switch-when`/`ng-switch-default`
 *
 * You can also disable this functionality manually by adding the `md-auto-hide="false"` expression
 * to the `ng-messages` container. This may be helpful if you always want to see the error messages
 * or if you are building your own visibility directive.
 *
 * _<b>Note:</b> The `md-auto-hide` attribute is a static string that is  only checked upon
 * initialization of the `ng-messages` directive to see if it equals the string `false`._
 *
 * <hljs lang="html">
 * <form name="userForm">
 *   <md-input-container>
 *     <label>Last Name</label>
 *     <input name="lastName" ng-model="lastName" required md-maxlength="10" minlength="4">
 *     <div ng-messages="userForm.lastName.$error" ng-show="userForm.lastName.$dirty">
 *       <div ng-message="required">This is required!</div>
 *       <div ng-message="md-maxlength">That's too long!</div>
 *       <div ng-message="minlength">That's too short!</div>
 *     </div>
 *   </md-input-container>
 *   <md-input-container>
 *     <label>Biography</label>
 *     <textarea name="bio" ng-model="biography" required md-maxlength="150"></textarea>
 *     <div ng-messages="userForm.bio.$error" ng-show="userForm.bio.$dirty">
 *       <div ng-message="required">This is required!</div>
 *       <div ng-message="md-maxlength">That's too long!</div>
 *     </div>
 *   </md-input-container>
 *   <md-input-container>
 *     <input aria-label='title' ng-model='title'>
 *   </md-input-container>
 *   <md-input-container>
 *     <input placeholder='title' ng-model='title'>
 *   </md-input-container>
 * </form>
 * </hljs>
 *
 * <h3>Notes</h3>
 *
 * - Requires [ngMessages](https://docs.angularjs.org/api/ngMessages).
 * - Behaves like the [AngularJS input directive](https://docs.angularjs.org/api/ng/directive/input).
 *
 * The `md-input` and `md-input-container` directives use very specific positioning to achieve the
 * error animation effects. Therefore, it is *not* advised to use the Layout system inside of the
 * `<md-input-container>` tags. Instead, use relative or absolute positioning.
 *
 *
 * <h3>Textarea directive</h3>
 * The `textarea` element within a `md-input-container` has the following specific behavior:
 * - By default the `textarea` grows as the user types. This can be disabled via the `md-no-autogrow`
 * attribute.
 * - If a `textarea` has the `rows` attribute, it will treat the `rows` as the minimum height and will
 * continue growing as the user types. For example a textarea with `rows="3"` will be 3 lines of text
 * high initially. If no rows are specified, the directive defaults to 1.
 * - The textarea's height gets set on initialization, as well as while the user is typing. In certain situations
 * (e.g. while animating) the directive might have been initialized, before the element got it's final height. In
 * those cases, you can trigger a resize manually by broadcasting a `md-resize-textarea` event on the scope.
 * - If you want a `textarea` to stop growing at a certain point, you can specify the `max-rows` attribute.
 * - The textarea's bottom border acts as a handle which users can drag, in order to resize the element vertically.
 * Once the user has resized a `textarea`, the autogrowing functionality becomes disabled. If you don't want a
 * `textarea` to be resizeable by the user, you can add the `md-no-resize` attribute.
 */

function inputTextareaDirective($mdUtil, $window, $mdAria, $timeout, $mdGesture) {
  return {
    restrict: 'E',
    require: ['^?mdInputContainer', '?ngModel', '?^form'],
    link: postLink
  };

  function postLink(scope, element, attr, ctrls) {

    var containerCtrl = ctrls[0];
    var hasNgModel = !!ctrls[1];
    var ngModelCtrl = ctrls[1] || $mdUtil.fakeNgModel();
    var parentForm = ctrls[2];
    var isReadonly = angular.isDefined(attr.readonly);
    var mdNoAsterisk = $mdUtil.parseAttributeBoolean(attr.mdNoAsterisk);
    var tagName = element[0].tagName.toLowerCase();


    if (!containerCtrl) return;
    if (attr.type === 'hidden') {
      element.attr('aria-hidden', 'true');
      return;
    } else if (containerCtrl.input) {
      if (containerCtrl.input[0].contains(element[0])) {
        return;
      } else {
        throw new Error("<md-input-container> can only have *one* <input>, <textarea> or <md-select> child element!");
      }
    }
    containerCtrl.input = element;

    setupAttributeWatchers();

    // Add an error spacer div after our input to provide space for the char counter and any ng-messages
    var errorsSpacer = angular.element('<div class="md-errors-spacer">');
    element.after(errorsSpacer);

    var placeholderText = angular.isString(attr.placeholder) ? attr.placeholder.trim() : '';
    if (!containerCtrl.label && !placeholderText.length) {
      $mdAria.expect(element, 'aria-label');
    }

    element.addClass('md-input');
    if (!element.attr('id')) {
      element.attr('id', 'input_' + $mdUtil.nextUid());
    }

    // This works around a Webkit issue where number inputs, placed in a flexbox, that have
    // a `min` and `max` will collapse to about 1/3 of their proper width. Please check #7349
    // for more info. Also note that we don't override the `step` if the user has specified it,
    // in order to prevent some unexpected behaviour.
    if (tagName === 'input' && attr.type === 'number' && attr.min && attr.max && !attr.step) {
      element.attr('step', 'any');
    } else if (tagName === 'textarea') {
      setupTextarea();
    }

    // If the input doesn't have an ngModel, it may have a static value. For that case,
    // we have to do one initial check to determine if the container should be in the
    // "has a value" state.
    if (!hasNgModel) {
      inputCheckValue();
    }

    var isErrorGetter = containerCtrl.isErrorGetter || function() {
      return ngModelCtrl.$invalid && (ngModelCtrl.$touched || (parentForm && parentForm.$submitted));
    };

    scope.$watch(isErrorGetter, containerCtrl.setInvalid);

    // When the developer uses the ngValue directive for the input, we have to observe the attribute, because
    // AngularJS's ngValue directive is just setting the `value` attribute.
    if (attr.ngValue) {
      attr.$observe('value', inputCheckValue);
    }

    ngModelCtrl.$parsers.push(ngModelPipelineCheckValue);
    ngModelCtrl.$formatters.push(ngModelPipelineCheckValue);

    element.on('input', inputCheckValue);

    if (!isReadonly) {
      element
        .on('focus', function(ev) {
          $mdUtil.nextTick(function() {
            containerCtrl.setFocused(true);
          });
        })
        .on('blur', function(ev) {
          $mdUtil.nextTick(function() {
            containerCtrl.setFocused(false);
            inputCheckValue();
          });
        });
    }

    scope.$on('$destroy', function() {
      containerCtrl.setFocused(false);
      containerCtrl.setHasValue(false);
      containerCtrl.input = null;
    });

    /** Gets run through ngModel's pipeline and set the `has-value` class on the container. */
    function ngModelPipelineCheckValue(arg) {
      containerCtrl.setHasValue(!ngModelCtrl.$isEmpty(arg));
      return arg;
    }

    function setupAttributeWatchers() {
      if (containerCtrl.label) {
        attr.$observe('required', function (value) {
          // We don't need to parse the required value, it's always a boolean because of angular's
          // required directive.
          containerCtrl.label.toggleClass('md-required', value && !mdNoAsterisk);
        });
      }
    }

    function inputCheckValue() {
      // An input's value counts if its length > 0,
      // or if the input's validity state says it has bad input (eg string in a number input)
      containerCtrl.setHasValue(element.val().length > 0 || (element[0].validity || {}).badInput);
    }

    function setupTextarea() {
      var isAutogrowing = !attr.hasOwnProperty('mdNoAutogrow');

      attachResizeHandle();

      if (!isAutogrowing) return;

      // Can't check if height was or not explicity set,
      // so rows attribute will take precedence if present
      var minRows = attr.hasOwnProperty('rows') ? parseInt(attr.rows) : NaN;
      var maxRows = attr.hasOwnProperty('maxRows') ? parseInt(attr.maxRows) : NaN;
      var scopeResizeListener = scope.$on('md-resize-textarea', growTextarea);
      var lineHeight = null;
      var node = element[0];

      // This timeout is necessary, because the browser needs a little bit
      // of time to calculate the `clientHeight` and `scrollHeight`.
      $timeout(function() {
        $mdUtil.nextTick(growTextarea);
      }, 10, false);

      // We could leverage ngModel's $parsers here, however it
      // isn't reliable, because AngularJS trims the input by default,
      // which means that growTextarea won't fire when newlines and
      // spaces are added.
      element.on('input', growTextarea);

      // We should still use the $formatters, because they fire when
      // the value was changed from outside the textarea.
      if (hasNgModel) {
        ngModelCtrl.$formatters.push(formattersListener);
      }

      if (!minRows) {
        element.attr('rows', 1);
      }

      angular.element($window).on('resize', growTextarea);
      scope.$on('$destroy', disableAutogrow);

      function growTextarea() {
        // temporarily disables element's flex so its height 'runs free'
        element
          .attr('rows', 1)
          .css('height', 'auto')
          .addClass('md-no-flex');

        var height = getHeight();

        if (!lineHeight) {
          // offsetHeight includes padding which can throw off our value
          var originalPadding = element[0].style.padding || '';
          lineHeight = element.css('padding', 0).prop('offsetHeight');
          element[0].style.padding = originalPadding;
        }

        if (minRows && lineHeight) {
          height = Math.max(height, lineHeight * minRows);
        }

        if (maxRows && lineHeight) {
          var maxHeight = lineHeight * maxRows;

          if (maxHeight < height) {
            element.attr('md-no-autogrow', '');
            height = maxHeight;
          } else {
            element.removeAttr('md-no-autogrow');
          }
        }

        if (lineHeight) {
          element.attr('rows', Math.round(height / lineHeight));
        }

        element
          .css('height', height + 'px')
          .removeClass('md-no-flex');
      }

      function getHeight() {
        var offsetHeight = node.offsetHeight;
        var line = node.scrollHeight - offsetHeight;
        return offsetHeight + Math.max(line, 0);
      }

      function formattersListener(value) {
        $mdUtil.nextTick(growTextarea);
        return value;
      }

      function disableAutogrow() {
        if (!isAutogrowing) return;

        isAutogrowing = false;
        angular.element($window).off('resize', growTextarea);
        scopeResizeListener && scopeResizeListener();
        element
          .attr('md-no-autogrow', '')
          .off('input', growTextarea);

        if (hasNgModel) {
          var listenerIndex = ngModelCtrl.$formatters.indexOf(formattersListener);

          if (listenerIndex > -1) {
            ngModelCtrl.$formatters.splice(listenerIndex, 1);
          }
        }
      }

      function attachResizeHandle() {
        if (attr.hasOwnProperty('mdNoResize')) return;

        var handle = angular.element('<div class="md-resize-handle"></div>');
        var isDragging = false;
        var dragStart = null;
        var startHeight = 0;
        var container = containerCtrl.element;
        var dragGestureHandler = $mdGesture.register(handle, 'drag', { horizontal: false });


        element.wrap('<div class="md-resize-wrapper">').after(handle);
        handle.on('mousedown', onMouseDown);

        container
          .on('$md.dragstart', onDragStart)
          .on('$md.drag', onDrag)
          .on('$md.dragend', onDragEnd);

        scope.$on('$destroy', function() {
          handle
            .off('mousedown', onMouseDown)
            .remove();

          container
            .off('$md.dragstart', onDragStart)
            .off('$md.drag', onDrag)
            .off('$md.dragend', onDragEnd);

          dragGestureHandler();
          handle = null;
          container = null;
          dragGestureHandler = null;
        });

        function onMouseDown(ev) {
          ev.preventDefault();
          isDragging = true;
          dragStart = ev.clientY;
          startHeight = parseFloat(element.css('height')) || element.prop('offsetHeight');
        }

        function onDragStart(ev) {
          if (!isDragging) return;
          ev.preventDefault();
          disableAutogrow();
          container.addClass('md-input-resized');
        }

        function onDrag(ev) {
          if (!isDragging) return;

          element.css('height', (startHeight + ev.pointer.distanceY) + 'px');
        }

        function onDragEnd(ev) {
          if (!isDragging) return;
          isDragging = false;
          container.removeClass('md-input-resized');
        }
      }

      // Attach a watcher to detect when the textarea gets shown.
      if (attr.hasOwnProperty('mdDetectHidden')) {

        var handleHiddenChange = function() {
          var wasHidden = false;

          return function() {
            var isHidden = node.offsetHeight === 0;

            if (isHidden === false && wasHidden === true) {
              growTextarea();
            }

            wasHidden = isHidden;
          };
        }();

        // Check every digest cycle whether the visibility of the textarea has changed.
        // Queue up to run after the digest cycle is complete.
        scope.$watch(function() {
          $mdUtil.nextTick(handleHiddenChange, false);
          return true;
        });
      }
    }
  }
}

function mdMaxlengthDirective($animate, $mdUtil) {
  return {
    restrict: 'A',
    require: ['ngModel', '^mdInputContainer'],
    link: postLink
  };

  function postLink(scope, element, attr, ctrls) {
    var maxlength = parseInt(attr.mdMaxlength);
    if (isNaN(maxlength)) maxlength = -1;
    var ngModelCtrl = ctrls[0];
    var containerCtrl = ctrls[1];
    var charCountEl, errorsSpacer;
    var ngTrim = angular.isDefined(attr.ngTrim) ? $mdUtil.parseAttributeBoolean(attr.ngTrim) : true;
    var isPasswordInput = attr.type === 'password';

    scope.$watch(attr.mdMaxlength, function(value) {
      maxlength = value;
    });

    ngModelCtrl.$validators['md-maxlength'] = function(modelValue, viewValue) {
      if (!angular.isNumber(maxlength) || maxlength < 0) {
        return true;
      }

      // We always update the char count, when the modelValue has changed.
      // Using the $validators for triggering the update works very well.
      renderCharCount();

      var elementVal = element.val() || viewValue;
      if (elementVal === undefined || elementVal === null) {
        elementVal = '';
      }
      elementVal = ngTrim && !isPasswordInput && angular.isString(elementVal) ? elementVal.trim() : elementVal;
      // Force the value into a string since it may be a number,
      // which does not have a length property.
      return String(elementVal).length <= maxlength;
    };

    /**
     * Override the default NgModelController $isEmpty check to take ng-trim, password inputs,
     * etc. into account.
     * @param value {*} the input's value
     * @returns {boolean} true if the input's value should be considered empty, false otherwise
     */
    ngModelCtrl.$isEmpty = function(value) {
      return calculateInputValueLength(value) === 0;
    };

    // Wait until the next tick to ensure that the input has setup the errors spacer where we will
    // append our counter
    $mdUtil.nextTick(function() {
      errorsSpacer = angular.element(containerCtrl.element[0].querySelector('.md-errors-spacer'));
      charCountEl = angular.element('<div class="md-char-counter">');

      // Append our character counter inside the errors spacer
      errorsSpacer.append(charCountEl);

      attr.$observe('ngTrim', function (value) {
        ngTrim = angular.isDefined(value) ? $mdUtil.parseAttributeBoolean(value) : true;
      });

      scope.$watch(attr.mdMaxlength, function(value) {
        if (angular.isNumber(value) && value > 0) {
          if (!charCountEl.parent().length) {
            $animate.enter(charCountEl, errorsSpacer);
          }
          renderCharCount();
        } else {
          $animate.leave(charCountEl);
        }
      });
    });

    /**
     * Calculate the input value's length after coercing it to a string
     * and trimming it if appropriate.
     * @param value {*} the input's value
     * @returns {number} calculated length of the input's value
     */
    function calculateInputValueLength(value) {
      value = ngTrim && !isPasswordInput && angular.isString(value) ? value.trim() : value;
      if (value === undefined || value === null) {
        value = '';
      }
      return String(value).length;
    }

    function renderCharCount() {
      // If we have not been initialized or appended to the body yet; do not render.
      if (!charCountEl || !charCountEl.parent()) {
        return;
      }
      // Force the value into a string since it may be a number,
      // which does not have a length property.
      charCountEl.text(calculateInputValueLength(element.val()) + ' / ' + maxlength);
    }
  }
}

function placeholderDirective($compile) {
  return {
    restrict: 'A',
    require: '^^?mdInputContainer',
    priority: 200,
    link: {
      // Note that we need to do this in the pre-link, as opposed to the post link, if we want to
      // support data bindings in the placeholder. This is necessary, because we have a case where
      // we transfer the placeholder value to the `<label>` and we remove it from the original `<input>`.
      // If we did this in the post-link, AngularJS would have set up the observers already and would be
      // re-adding the attribute, even though we removed it from the element.
      pre: preLink
    }
  };

  function preLink(scope, element, attr, inputContainer) {
    // If there is no input container, just return
    if (!inputContainer) return;

    var label = inputContainer.element.find('label');
    var noFloat = inputContainer.element.attr('md-no-float');

    // If we have a label, or they specify the md-no-float attribute, just return
    if ((label && label.length) || noFloat === '' || scope.$eval(noFloat)) {
      // Add a placeholder class so we can target it in the CSS
      inputContainer.setHasPlaceholder(true);
      return;
    }

    // md-select handles placeholders on it's own
    if (element[0].nodeName !== 'MD-SELECT') {
      // Move the placeholder expression to the label
      var newLabel = angular.element(
        '<label ng-click="delegateClick()" tabindex="-1" aria-hidden="true">' + attr.placeholder +
        '</label>');

      // Note that we unset it via `attr`, in order to get AngularJS
      // to remove any observers that it might have set up. Otherwise
      // the attribute will be added on the next digest.
      attr.$set('placeholder', null);

      // We need to compile the label manually in case it has any bindings.
      // A gotcha here is that we first add the element to the DOM and we compile
      // it later. This is necessary, because if we compile the element beforehand,
      // it won't be able to find the `mdInputContainer` controller.
      inputContainer.element
        .addClass('md-icon-float')
        .prepend(newLabel);

      $compile(newLabel)(scope);
    }
  }
}

/**
 * @ngdoc directive
 * @name mdSelectOnFocus
 * @module material.components.input
 *
 * @restrict A
 *
 * @description
 * The `md-select-on-focus` directive allows you to automatically select the element's input text on focus.
 *
 * <h3>Notes</h3>
 * - The use of `md-select-on-focus` is restricted to `<input>` and `<textarea>` elements.
 *
 * @usage
 * <h3>Using with an Input</h3>
 * <hljs lang="html">
 *
 * <md-input-container>
 *   <label>Auto Select</label>
 *   <input type="text" md-select-on-focus>
 * </md-input-container>
 * </hljs>
 *
 * <h3>Using with a Textarea</h3>
 * <hljs lang="html">
 *
 * <md-input-container>
 *   <label>Auto Select</label>
 *   <textarea md-select-on-focus>This text will be selected on focus.</textarea>
 * </md-input-container>
 *
 * </hljs>
 */
function mdSelectOnFocusDirective($document, $timeout) {

  return {
    restrict: 'A',
    link: postLink
  };

  function postLink(scope, element, attr) {
    if (element[0].nodeName !== 'INPUT' && element[0].nodeName !== "TEXTAREA") return;

    var preventMouseUp = false;

    element
      .on('focus', onFocus)
      .on('mouseup', onMouseUp);

    scope.$on('$destroy', function() {
      element
        .off('focus', onFocus)
        .off('mouseup', onMouseUp);
    });

    function onFocus() {
      preventMouseUp = true;

      $timeout(function() {

        // Use HTMLInputElement#select to fix firefox select issues.
        // The debounce is here for Edge's sake, otherwise the selection doesn't work.
        // Since focus may already have been lost on the input (and because `select()`
        // will re-focus), make sure the element is still active before applying.
        if ($document[0].activeElement === element[0]) {
          element[0].select();
        }

        // This should be reset from inside the `focus`, because the event might
        // have originated from something different than a click, e.g. a keyboard event.
        preventMouseUp = false;
      }, 1, false);
    }

    // Prevents the default action of the first `mouseup` after a focus.
    // This is necessary, because browsers fire a `mouseup` right after the element
    // has been focused. In some browsers (Firefox in particular) this can clear the
    // selection. There are examples of the problem in issue #7487.
    function onMouseUp(event) {
      if (preventMouseUp) {
        event.preventDefault();
      }
    }
  }
}

var visibilityDirectives = ['ngIf', 'ngShow', 'ngHide', 'ngSwitchWhen', 'ngSwitchDefault'];
function ngMessagesDirective() {
  return {
    restrict: 'EA',
    link: postLink,

    // This is optional because we don't want target *all* ngMessage instances, just those inside of
    // mdInputContainer.
    require: '^^?mdInputContainer'
  };

  function postLink(scope, element, attrs, inputContainer) {
    // If we are not a child of an input container, don't do anything
    if (!inputContainer) return;

    // Add our animation class
    element.toggleClass('md-input-messages-animation', true);

    // Add our md-auto-hide class to automatically hide/show messages when container is invalid
    element.toggleClass('md-auto-hide', true);

    // If we see some known visibility directives, remove the md-auto-hide class
    if (attrs.mdAutoHide == 'false' || hasVisibiltyDirective(attrs)) {
      element.toggleClass('md-auto-hide', false);
    }
  }

  function hasVisibiltyDirective(attrs) {
    return visibilityDirectives.some(function(attr) {
      return attrs[attr];
    });
  }
}

function ngMessageDirective($mdUtil) {
  return {
    restrict: 'EA',
    compile: compile,
    priority: 100
  };

  function compile(tElement) {
    if (!isInsideInputContainer(tElement)) {

      // When the current element is inside of a document fragment, then we need to check for an input-container
      // in the postLink, because the element will be later added to the DOM and is currently just in a temporary
      // fragment, which causes the input-container check to fail.
      if (isInsideFragment()) {
        return function (scope, element) {
          if (isInsideInputContainer(element)) {
            // Inside of the postLink function, a ngMessage directive will be a comment element, because it's
            // currently hidden. To access the shown element, we need to use the element from the compile function.
            initMessageElement(tElement);
          }
        };
      }
    } else {
      initMessageElement(tElement);
    }

    function isInsideFragment() {
      var nextNode = tElement[0];
      while (nextNode = nextNode.parentNode) {
        if (nextNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
          return true;
        }
      }
      return false;
    }

    function isInsideInputContainer(element) {
      return !!$mdUtil.getClosest(element, "md-input-container");
    }

    function initMessageElement(element) {
      // Add our animation class
      element.toggleClass('md-input-message-animation', true);
    }
  }
}

var $$AnimateRunner, $animateCss, $mdUtil;

function mdInputInvalidMessagesAnimation($$AnimateRunner, $animateCss, $mdUtil) {
  saveSharedServices($$AnimateRunner, $animateCss, $mdUtil);

  return {
    addClass: function(element, className, done) {
      showInputMessages(element, done);
    }

    // NOTE: We do not need the removeClass method, because the message ng-leave animation will fire
  };
}

function ngMessagesAnimation($$AnimateRunner, $animateCss, $mdUtil) {
  saveSharedServices($$AnimateRunner, $animateCss, $mdUtil);

  return {
    enter: function(element, done) {
      showInputMessages(element, done);
    },

    leave: function(element, done) {
      hideInputMessages(element, done);
    },

    addClass: function(element, className, done) {
      if (className == "ng-hide") {
        hideInputMessages(element, done);
      } else {
        done();
      }
    },

    removeClass: function(element, className, done) {
      if (className == "ng-hide") {
        showInputMessages(element, done);
      } else {
        done();
      }
    }
  };
}

function ngMessageAnimation($$AnimateRunner, $animateCss, $mdUtil, $log) {
  saveSharedServices($$AnimateRunner, $animateCss, $mdUtil, $log);

  return {
    enter: function(element, done) {
      var animator = showMessage(element);

      animator.start().done(done);
    },

    leave: function(element, done) {
      var animator = hideMessage(element);

      animator.start().done(done);
    }
  };
}

function showInputMessages(element, done) {
  var animators = [], animator;
  var messages = getMessagesElement(element);
  var children = messages.children();

  if (messages.length == 0 || children.length == 0) {
    done();
    return;
  }

  angular.forEach(children, function(child) {
    animator = showMessage(angular.element(child));

    animators.push(animator.start());
  });

  $$AnimateRunner.all(animators, done);
}

function hideInputMessages(element, done) {
  var animators = [], animator;
  var messages = getMessagesElement(element);
  var children = messages.children();

  if (messages.length == 0 || children.length == 0) {
    done();
    return;
  }

  angular.forEach(children, function(child) {
    animator = hideMessage(angular.element(child));

    animators.push(animator.start());
  });

  $$AnimateRunner.all(animators, done);
}

function showMessage(element) {
  var height = parseInt(window.getComputedStyle(element[0]).height);
  var topMargin = parseInt(window.getComputedStyle(element[0]).marginTop);

  var messages = getMessagesElement(element);
  var container = getInputElement(element);

  // Check to see if the message is already visible so we can skip
  var alreadyVisible = (topMargin > -height);

  // If we have the md-auto-hide class, the md-input-invalid animation will fire, so we can skip
  if (alreadyVisible || (messages.hasClass('md-auto-hide') && !container.hasClass('md-input-invalid'))) {
    return $animateCss(element, {});
  }

  return $animateCss(element, {
    event: 'enter',
    structural: true,
    from: {"opacity": 0, "margin-top": -height + "px"},
    to: {"opacity": 1, "margin-top": "0"},
    duration: 0.3
  });
}

function hideMessage(element) {
  var height = element[0].offsetHeight;
  var styles = window.getComputedStyle(element[0]);

  // If we are already hidden, just return an empty animation
  if (parseInt(styles.opacity) === 0) {
    return $animateCss(element, {});
  }

  // Otherwise, animate
  return $animateCss(element, {
    event: 'leave',
    structural: true,
    from: {"opacity": 1, "margin-top": 0},
    to: {"opacity": 0, "margin-top": -height + "px"},
    duration: 0.3
  });
}

function getInputElement(element) {
  var inputContainer = element.controller('mdInputContainer');

  return inputContainer.element;
}

function getMessagesElement(element) {
  // If we ARE the messages element, just return ourself
  if (element.hasClass('md-input-messages-animation')) {
    return element;
  }

  // If we are a ng-message element, we need to traverse up the DOM tree
  if (element.hasClass('md-input-message-animation')) {
    return angular.element($mdUtil.getClosest(element, function(node) {
      return node.classList.contains('md-input-messages-animation');
    }));
  }

  // Otherwise, we can traverse down
  return angular.element(element[0].querySelector('.md-input-messages-animation'));
}

function saveSharedServices(_$$AnimateRunner_, _$animateCss_, _$mdUtil_) {
  $$AnimateRunner = _$$AnimateRunner_;
  $animateCss = _$animateCss_;
  $mdUtil = _$mdUtil_;
}

})();
(function(){
"use strict";

/**
 * @ngdoc module
 * @name material.components.list
 * @description
 * List module
 */
MdListController.$inject = ["$scope", "$element", "$mdListInkRipple"];
mdListDirective.$inject = ["$mdTheming"];
mdListItemDirective.$inject = ["$mdAria", "$mdConstant", "$mdUtil", "$timeout"];
angular.module('material.components.list', [
  'material.core'
])
  .controller('MdListController', MdListController)
  .directive('mdList', mdListDirective)
  .directive('mdListItem', mdListItemDirective);

/**
 * @ngdoc directive
 * @name mdList
 * @module material.components.list
 *
 * @restrict E
 *
 * @description
 * The `<md-list>` directive is a list container for 1..n `<md-list-item>` tags.
 *
 * @usage
 * <hljs lang="html">
 * <md-list>
 *   <md-list-item class="md-2-line" ng-repeat="item in todos">
 *     <md-checkbox ng-model="item.done"></md-checkbox>
 *     <div class="md-list-item-text">
 *       <h3>{{item.title}}</h3>
 *       <p>{{item.description}}</p>
 *     </div>
 *   </md-list-item>
 * </md-list>
 * </hljs>
 */

function mdListDirective($mdTheming) {
  return {
    restrict: 'E',
    compile: function(tEl) {
      tEl[0].setAttribute('role', 'list');
      return $mdTheming;
    }
  };
}
/**
 * @ngdoc directive
 * @name mdListItem
 * @module material.components.list
 *
 * @restrict E
 *
 * @description
 * A `md-list-item` element can be used to represent some information in a row.<br/>
 *
 * @usage
 * ### Single Row Item
 * <hljs lang="html">
 *   <md-list-item>
 *     <span>Single Row Item</span>
 *   </md-list-item>
 * </hljs>
 *
 * ### Multiple Lines
 * By using the following markup, you will be able to have two lines inside of one `md-list-item`.
 *
 * <hljs lang="html">
 *   <md-list-item class="md-2-line">
 *     <div class="md-list-item-text" layout="column">
 *       <p>First Line</p>
 *       <p>Second Line</p>
 *     </div>
 *   </md-list-item>
 * </hljs>
 *
 * It is also possible to have three lines inside of one list item.
 *
 * <hljs lang="html">
 *   <md-list-item class="md-3-line">
 *     <div class="md-list-item-text" layout="column">
 *       <p>First Line</p>
 *       <p>Second Line</p>
 *       <p>Third Line</p>
 *     </div>
 *   </md-list-item>
 * </hljs>
 *
 * ### Secondary Items
 * Secondary items are elements which will be aligned at the end of the `md-list-item`.
 *
 * <hljs lang="html">
 *   <md-list-item>
 *     <span>Single Row Item</span>
 *     <md-button class="md-secondary">
 *       Secondary Button
 *     </md-button>
 *   </md-list-item>
 * </hljs>
 *
 * It also possible to have multiple secondary items inside of one `md-list-item`.
 *
 * <hljs lang="html">
 *   <md-list-item>
 *     <span>Single Row Item</span>
 *     <md-button class="md-secondary">First Button</md-button>
 *     <md-button class="md-secondary">Second Button</md-button>
 *   </md-list-item>
 * </hljs>
 *
 * ### Proxy Item
 * Proxies are elements, which will execute their specific action on click<br/>
 * Currently supported proxy items are
 * - `md-checkbox` (Toggle)
 * - `md-switch` (Toggle)
 * - `md-menu` (Open)
 *
 * This means, when using a supported proxy item inside of `md-list-item`, the list item will
 * automatically become clickable and executes the associated action of the proxy element on click.
 *
 * It is possible to disable this behavior by applying the `md-no-proxy` class to the list item.
 *
 * <hljs lang="html">
 *   <md-list-item class="md-no-proxy">
 *     <span>No Proxy List</span>
 *     <md-checkbox class="md-secondary"></md-checkbox>
 *   </md-list-item>
 * </hljs>
 *
 * Here are a few examples of proxy elements inside of a list item.
 *
 * <hljs lang="html">
 *   <md-list-item>
 *     <span>First Line</span>
 *     <md-checkbox class="md-secondary"></md-checkbox>
 *   </md-list-item>
 * </hljs>
 *
 * The `md-checkbox` element will be automatically detected as a proxy element and will toggle on click.
 *
 * <hljs lang="html">
 *   <md-list-item>
 *     <span>First Line</span>
 *     <md-switch class="md-secondary"></md-switch>
 *   </md-list-item>
 * </hljs>
 *
 * The recognized `md-switch` will toggle its state, when the user clicks on the `md-list-item`.
 *
 * It is also possible to have a `md-menu` inside of a `md-list-item`.
 * <hljs lang="html">
 *   <md-list-item>
 *     <p>Click anywhere to fire the secondary action</p>
 *     <md-menu class="md-secondary">
 *       <md-button class="md-icon-button">
 *         <md-icon md-svg-icon="communication:message"></md-icon>
 *       </md-button>
 *       <md-menu-content width="4">
 *         <md-menu-item>
 *           <md-button>
 *             Redial
 *           </md-button>
 *         </md-menu-item>
 *         <md-menu-item>
 *           <md-button>
 *             Check voicemail
 *           </md-button>
 *         </md-menu-item>
 *         <md-menu-divider></md-menu-divider>
 *         <md-menu-item>
 *           <md-button>
 *             Notifications
 *           </md-button>
 *         </md-menu-item>
 *       </md-menu-content>
 *     </md-menu>
 *   </md-list-item>
 * </hljs>
 *
 * The menu will automatically open, when the users clicks on the `md-list-item`.<br/>
 *
 * If the developer didn't specify any position mode on the menu, the `md-list-item` will automatically detect the
 * position mode and applies it to the `md-menu`.
 *
 * ### Avatars
 * Sometimes you may want to have some avatars inside of the `md-list-item `.<br/>
 * You are able to create a optimized icon for the list item, by applying the `.md-avatar` class on the `<img>` element.
 *
 * <hljs lang="html">
 *   <md-list-item>
 *     <img src="my-avatar.png" class="md-avatar">
 *     <span>Alan Turing</span>
 * </hljs>
 *
 * When using `<md-icon>` for an avatar, you have to use the `.md-avatar-icon` class.
 * <hljs lang="html">
 *   <md-list-item>
 *     <md-icon class="md-avatar-icon" md-svg-icon="social:person"></md-icon>
 *     <span>Timothy Kopra</span>
 *   </md-list-item>
 * </hljs>
 *
 * In cases, you have a `md-list-item`, which doesn't have any avatar,
 * but you want to align it with the other avatar items, you have to use the `.md-offset` class.
 *
 * <hljs lang="html">
 *   <md-list-item class="md-offset">
 *     <span>Jon Doe</span>
 *   </md-list-item>
 * </hljs>
 *
 * ### DOM modification
 * The `md-list-item` component automatically detects if the list item should be clickable.
 *
 * ---
 * If the `md-list-item` is clickable, we wrap all content inside of a `<div>` and create
 * an overlaying button, which will will execute the given actions (like `ng-href`, `ng-click`)
 *
 * We create an overlaying button, instead of wrapping all content inside of the button,
 * because otherwise some elements may not be clickable inside of the button.
 *
 * ---
 * When using a secondary item inside of your list item, the `md-list-item` component will automatically create
 * a secondary container at the end of the `md-list-item`, which contains all secondary items.
 *
 * The secondary item container is not static, because otherwise the overflow will not work properly on the
 * list item.
 *
 */
function mdListItemDirective($mdAria, $mdConstant, $mdUtil, $timeout) {
  var proxiedTypes = ['md-checkbox', 'md-switch', 'md-menu'];
  return {
    restrict: 'E',
    controller: 'MdListController',
    compile: function(tEl, tAttrs) {

      // Check for proxy controls (no ng-click on parent, and a control inside)
      var secondaryItems = tEl[0].querySelectorAll('.md-secondary');
      var hasProxiedElement;
      var proxyElement;
      var itemContainer = tEl;

      tEl[0].setAttribute('role', 'listitem');

      if (tAttrs.ngClick || tAttrs.ngDblclick ||  tAttrs.ngHref || tAttrs.href || tAttrs.uiSref || tAttrs.ngAttrUiSref) {
        wrapIn('button');
      } else if (!tEl.hasClass('md-no-proxy')) {

        for (var i = 0, type; type = proxiedTypes[i]; ++i) {
          if (proxyElement = tEl[0].querySelector(type)) {
            hasProxiedElement = true;
            break;
          }
        }

        if (hasProxiedElement) {
          wrapIn('div');
        } else {
          tEl.addClass('md-no-proxy');
        }

      }

      wrapSecondaryItems();
      setupToggleAria();

      if (hasProxiedElement && proxyElement.nodeName === "MD-MENU") {
        setupProxiedMenu();
      }

      function setupToggleAria() {
        var toggleTypes = ['md-switch', 'md-checkbox'];
        var toggle;

        for (var i = 0, toggleType; toggleType = toggleTypes[i]; ++i) {
          if (toggle = tEl.find(toggleType)[0]) {
            if (!toggle.hasAttribute('aria-label')) {
              var p = tEl.find('p')[0];
              if (!p) return;
              toggle.setAttribute('aria-label', 'Toggle ' + p.textContent);
            }
          }
        }
      }

      function setupProxiedMenu() {
        var menuEl = angular.element(proxyElement);

        var isEndAligned = menuEl.parent().hasClass('md-secondary-container') ||
                           proxyElement.parentNode.firstElementChild !== proxyElement;

        var xAxisPosition = 'left';

        if (isEndAligned) {
          // When the proxy item is aligned at the end of the list, we have to set the origin to the end.
          xAxisPosition = 'right';
        }

        // Set the position mode / origin of the proxied menu.
        if (!menuEl.attr('md-position-mode')) {
          menuEl.attr('md-position-mode', xAxisPosition + ' target');
        }

        // Apply menu open binding to menu button
        var menuOpenButton = menuEl.children().eq(0);
        if (!hasClickEvent(menuOpenButton[0])) {
          menuOpenButton.attr('ng-click', '$mdMenu.open($event)');
        }

        if (!menuOpenButton.attr('aria-label')) {
          menuOpenButton.attr('aria-label', 'Open List Menu');
        }
      }

      function wrapIn(type) {
        if (type == 'div') {
          itemContainer = angular.element('<div class="md-no-style md-list-item-inner">');
          itemContainer.append(tEl.contents());
          tEl.addClass('md-proxy-focus');
        } else {
          // Element which holds the default list-item content.
          itemContainer = angular.element(
            '<div class="md-button md-no-style">'+
            '   <div class="md-list-item-inner"></div>'+
            '</div>'
          );

          // Button which shows ripple and executes primary action.
          var buttonWrap = angular.element(
            '<md-button class="md-no-style"></md-button>'
          );

          copyAttributes(tEl[0], buttonWrap[0]);

          // If there is no aria-label set on the button (previously copied over if present)
          // we determine the label from the content and copy it to the button.
          if (!buttonWrap.attr('aria-label')) {
            buttonWrap.attr('aria-label', $mdAria.getText(tEl));
          }

          // We allow developers to specify the `md-no-focus` class, to disable the focus style
          // on the button executor. Once more classes should be forwarded, we should probably make the
          // class forward more generic.
          if (tEl.hasClass('md-no-focus')) {
            buttonWrap.addClass('md-no-focus');
          }

          // Append the button wrap before our list-item content, because it will overlay in relative.
          itemContainer.prepend(buttonWrap);
          itemContainer.children().eq(1).append(tEl.contents());

          tEl.addClass('_md-button-wrap');
        }

        tEl[0].setAttribute('tabindex', '-1');
        tEl.append(itemContainer);
      }

      function wrapSecondaryItems() {
        var secondaryItemsWrapper = angular.element('<div class="md-secondary-container">');

        angular.forEach(secondaryItems, function(secondaryItem) {
          wrapSecondaryItem(secondaryItem, secondaryItemsWrapper);
        });

        itemContainer.append(secondaryItemsWrapper);
      }

      function wrapSecondaryItem(secondaryItem, container) {
        // If the current secondary item is not a button, but contains a ng-click attribute,
        // the secondary item will be automatically wrapped inside of a button.
        if (secondaryItem && !isButton(secondaryItem) && secondaryItem.hasAttribute('ng-click')) {

          $mdAria.expect(secondaryItem, 'aria-label');
          var buttonWrapper = angular.element('<md-button class="md-secondary md-icon-button">');

          // Copy the attributes from the secondary item to the generated button.
          // We also support some additional attributes from the secondary item,
          // because some developers may use a ngIf, ngHide, ngShow on their item.
          copyAttributes(secondaryItem, buttonWrapper[0], ['ng-if', 'ng-hide', 'ng-show']);

          secondaryItem.setAttribute('tabindex', '-1');
          buttonWrapper.append(secondaryItem);

          secondaryItem = buttonWrapper[0];
        }

        if (secondaryItem && (!hasClickEvent(secondaryItem) || (!tAttrs.ngClick && isProxiedElement(secondaryItem)))) {
          // In this case we remove the secondary class, so we can identify it later, when we searching for the
          // proxy items.
          angular.element(secondaryItem).removeClass('md-secondary');
        }

        tEl.addClass('md-with-secondary');
        container.append(secondaryItem);
      }

      /**
       * Copies attributes from a source element to the destination element
       * By default the function will copy the most necessary attributes, supported
       * by the button executor for clickable list items.
       * @param source Element with the specified attributes
       * @param destination Element which will retrieve the attributes
       * @param extraAttrs Additional attributes, which will be copied over.
       */
      function copyAttributes(source, destination, extraAttrs) {
        var copiedAttrs = $mdUtil.prefixer([
          'ng-if', 'ng-click', 'ng-dblclick', 'aria-label', 'ng-disabled', 'ui-sref',
          'href', 'ng-href', 'rel', 'target', 'ng-attr-ui-sref', 'ui-sref-opts', 'download'
        ]);

        if (extraAttrs) {
          copiedAttrs = copiedAttrs.concat($mdUtil.prefixer(extraAttrs));
        }

        angular.forEach(copiedAttrs, function(attr) {
          if (source.hasAttribute(attr)) {
            destination.setAttribute(attr, source.getAttribute(attr));
            source.removeAttribute(attr);
          }
        });
      }

      function isProxiedElement(el) {
        return proxiedTypes.indexOf(el.nodeName.toLowerCase()) != -1;
      }

      function isButton(el) {
        var nodeName = el.nodeName.toUpperCase();

        return nodeName == "MD-BUTTON" || nodeName == "BUTTON";
      }

      function hasClickEvent (element) {
        var attr = element.attributes;
        for (var i = 0; i < attr.length; i++) {
          if (tAttrs.$normalize(attr[i].name) === 'ngClick') return true;
        }
        return false;
      }

      return postLink;

      function postLink($scope, $element, $attr, ctrl) {
        $element.addClass('_md');     // private md component indicator for styling

        var proxies       = [],
            firstElement  = $element[0].firstElementChild,
            isButtonWrap  = $element.hasClass('_md-button-wrap'),
            clickChild    = isButtonWrap ? firstElement.firstElementChild : firstElement,
            hasClick      = clickChild && hasClickEvent(clickChild),
            noProxies     = $element.hasClass('md-no-proxy');

        computeProxies();
        computeClickable();

        if (proxies.length) {
          angular.forEach(proxies, function(proxy) {
            proxy = angular.element(proxy);

            $scope.mouseActive = false;
            proxy.on('mousedown', function() {
              $scope.mouseActive = true;
              $timeout(function(){
                $scope.mouseActive = false;
              }, 100);
            })
            .on('focus', function() {
              if ($scope.mouseActive === false) { $element.addClass('md-focused'); }
              proxy.on('blur', function proxyOnBlur() {
                $element.removeClass('md-focused');
                proxy.off('blur', proxyOnBlur);
              });
            });
          });
        }


        function computeProxies() {

          if (firstElement && firstElement.children && !hasClick && !noProxies) {

            angular.forEach(proxiedTypes, function(type) {

              // All elements which are not capable for being used a proxy have the .md-secondary class
              // applied. These items had been sorted out in the secondary wrap function.
              angular.forEach(firstElement.querySelectorAll(type + ':not(.md-secondary)'), function(child) {
                proxies.push(child);
              });
            });

          }
        }

        function computeClickable() {
          if (proxies.length == 1 || hasClick) {
            $element.addClass('md-clickable');

            if (!hasClick) {
              ctrl.attachRipple($scope, angular.element($element[0].querySelector('.md-no-style')));
            }
          }
        }

        function isEventFromControl(event) {
          var forbiddenControls = ['md-slider'];

          // If there is no path property in the event, then we can assume that the event was not bubbled.
          if (!event.path) {
            return forbiddenControls.indexOf(event.target.tagName.toLowerCase()) !== -1;
          }

          // We iterate the event path up and check for a possible component.
          // Our maximum index to search, is the list item root.
          var maxPath = event.path.indexOf($element.children()[0]);

          for (var i = 0; i < maxPath; i++) {
            if (forbiddenControls.indexOf(event.path[i].tagName.toLowerCase()) !== -1) {
              return true;
            }
          }
        }

        var clickChildKeypressListener = function(e) {
          if (e.target.nodeName != 'INPUT' && e.target.nodeName != 'TEXTAREA' && !e.target.isContentEditable) {
            var keyCode = e.which || e.keyCode;
            if (keyCode == $mdConstant.KEY_CODE.SPACE) {
              if (clickChild) {
                clickChild.click();
                e.preventDefault();
                e.stopPropagation();
              }
            }
          }
        };

        if (!hasClick && !proxies.length) {
          clickChild && clickChild.addEventListener('keypress', clickChildKeypressListener);
        }

        $element.off('click');
        $element.off('keypress');

        if (proxies.length == 1 && clickChild) {
          $element.children().eq(0).on('click', function(e) {
            // When the event is coming from an control and it should not trigger the proxied element
            // then we are skipping.
            if (isEventFromControl(e)) return;

            var parentButton = $mdUtil.getClosest(e.target, 'BUTTON');
            if (!parentButton && clickChild.contains(e.target)) {
              angular.forEach(proxies, function(proxy) {
                if (e.target !== proxy && !proxy.contains(e.target)) {
                  if (proxy.nodeName === 'MD-MENU') {
                    proxy = proxy.children[0];
                  }
                  angular.element(proxy).triggerHandler('click');
                }
              });
            }
          });
        }

        $scope.$on('$destroy', function () {
          clickChild && clickChild.removeEventListener('keypress', clickChildKeypressListener);
        });
      }
    }
  };
}

/*
 * @private
 * @ngdoc controller
 * @name MdListController
 * @module material.components.list
 *
 */
function MdListController($scope, $element, $mdListInkRipple) {
  var ctrl = this;
  ctrl.attachRipple = attachRipple;

  function attachRipple (scope, element) {
    var options = {};
    $mdListInkRipple.attach(scope, element, options);
  }
}

})();
(function(){
"use strict";

/**
 * @ngdoc module
 * @name material.components.menu
 */

angular.module('material.components.menu', [
  'material.core',
  'material.components.backdrop'
]);

})();
(function(){
"use strict";



MenuController.$inject = ["$mdMenu", "$attrs", "$element", "$scope", "$mdUtil", "$timeout", "$rootScope", "$q", "$log"];
angular
    .module('material.components.menu')
    .controller('mdMenuCtrl', MenuController);

/**
 * @ngInject
 */
function MenuController($mdMenu, $attrs, $element, $scope, $mdUtil, $timeout, $rootScope, $q, $log) {

  var prefixer = $mdUtil.prefixer();
  var menuContainer;
  var self = this;
  var triggerElement;

  this.nestLevel = parseInt($attrs.mdNestLevel, 10) || 0;

  /**
   * Called by our linking fn to provide access to the menu-content
   * element removed during link
   */
  this.init = function init(setMenuContainer, opts) {
    opts = opts || {};
    menuContainer = setMenuContainer;

    // Default element for ARIA attributes has the ngClick or ngMouseenter expression
    triggerElement = $element[0].querySelector(prefixer.buildSelector(['ng-click', 'ng-mouseenter']));
    triggerElement.setAttribute('aria-expanded', 'false');

    this.isInMenuBar = opts.isInMenuBar;
    this.nestedMenus = $mdUtil.nodesToArray(menuContainer[0].querySelectorAll('.md-nested-menu'));

    menuContainer.on('$mdInterimElementRemove', function() {
      self.isOpen = false;
      $mdUtil.nextTick(function(){ self.onIsOpenChanged(self.isOpen);});
    });
    $mdUtil.nextTick(function(){ self.onIsOpenChanged(self.isOpen);});

    var menuContainerId = 'menu_container_' + $mdUtil.nextUid();
    menuContainer.attr('id', menuContainerId);
    angular.element(triggerElement).attr({
      'aria-owns': menuContainerId,
      'aria-haspopup': 'true'
    });

    $scope.$on('$destroy', angular.bind(this, function() {
      this.disableHoverListener();
      $mdMenu.destroy();
    }));

    menuContainer.on('$destroy', function() {
      $mdMenu.destroy();
    });
  };

  var openMenuTimeout, menuItems, deregisterScopeListeners = [];
  this.enableHoverListener = function() {
    deregisterScopeListeners.push($rootScope.$on('$mdMenuOpen', function(event, el) {
      if (menuContainer[0].contains(el[0])) {
        self.currentlyOpenMenu = el.controller('mdMenu');
        self.isAlreadyOpening = false;
        self.currentlyOpenMenu.registerContainerProxy(self.triggerContainerProxy.bind(self));
      }
    }));
    deregisterScopeListeners.push($rootScope.$on('$mdMenuClose', function(event, el) {
      if (menuContainer[0].contains(el[0])) {
        self.currentlyOpenMenu = undefined;
      }
    }));
    menuItems = angular.element($mdUtil.nodesToArray(menuContainer[0].children[0].children));
    menuItems.on('mouseenter', self.handleMenuItemHover);
    menuItems.on('mouseleave', self.handleMenuItemMouseLeave);
  };

  this.disableHoverListener = function() {
    while (deregisterScopeListeners.length) {
      deregisterScopeListeners.shift()();
    }
    menuItems && menuItems.off('mouseenter', self.handleMenuItemHover);
    menuItems && menuItems.off('mouseleave', self.handleMenuItemMouseLeave);
  };

  this.handleMenuItemHover = function(event) {
    if (self.isAlreadyOpening) return;
    var nestedMenu = (
      event.target.querySelector('md-menu')
        || $mdUtil.getClosest(event.target, 'MD-MENU')
    );
    openMenuTimeout = $timeout(function() {
      if (nestedMenu) {
        nestedMenu = angular.element(nestedMenu).controller('mdMenu');
      }

      if (self.currentlyOpenMenu && self.currentlyOpenMenu != nestedMenu) {
        var closeTo = self.nestLevel + 1;
        self.currentlyOpenMenu.close(true, { closeTo: closeTo });
        self.isAlreadyOpening = !!nestedMenu;
        nestedMenu && nestedMenu.open();
      } else if (nestedMenu && !nestedMenu.isOpen && nestedMenu.open) {
        self.isAlreadyOpening = !!nestedMenu;
        nestedMenu && nestedMenu.open();
      }
    }, nestedMenu ? 100 : 250);
    var focusableTarget = event.currentTarget.querySelector('.md-button:not([disabled])');
    focusableTarget && focusableTarget.focus();
  };

  this.handleMenuItemMouseLeave = function() {
    if (openMenuTimeout) {
      $timeout.cancel(openMenuTimeout);
      openMenuTimeout = undefined;
    }
  };


  /**
   * Uses the $mdMenu interim element service to open the menu contents
   */
  this.open = function openMenu(ev) {
    ev && ev.stopPropagation();
    ev && ev.preventDefault();
    if (self.isOpen) return;
    self.enableHoverListener();
    self.isOpen = true;
    $mdUtil.nextTick(function(){ self.onIsOpenChanged(self.isOpen);});
    triggerElement = triggerElement || (ev ? ev.target : $element[0]);
    triggerElement.setAttribute('aria-expanded', 'true');
    $scope.$emit('$mdMenuOpen', $element);
    $mdMenu.show({
      scope: $scope,
      mdMenuCtrl: self,
      nestLevel: self.nestLevel,
      element: menuContainer,
      target: triggerElement,
      preserveElement: true,
      parent: 'body'
    }).finally(function() {
      triggerElement.setAttribute('aria-expanded', 'false');
      self.disableHoverListener();
    });
  };

  this.onIsOpenChanged = function(isOpen) {
    if (isOpen) {
      menuContainer.attr('aria-hidden', 'false');
      $element[0].classList.add('md-open');
      angular.forEach(self.nestedMenus, function(el) {
        el.classList.remove('md-open');
      });
    } else {
      menuContainer.attr('aria-hidden', 'true');
      $element[0].classList.remove('md-open');
    }
    $scope.$mdMenuIsOpen = self.isOpen;
  };

  this.focusMenuContainer = function focusMenuContainer() {
    var focusTarget = menuContainer[0]
      .querySelector(prefixer.buildSelector(['md-menu-focus-target', 'md-autofocus']));

    if (!focusTarget) focusTarget = menuContainer[0].querySelector('.md-button:not([disabled])');
    focusTarget.focus();
  };

  this.registerContainerProxy = function registerContainerProxy(handler) {
    this.containerProxy = handler;
  };

  this.triggerContainerProxy = function triggerContainerProxy(ev) {
    this.containerProxy && this.containerProxy(ev);
  };

  this.destroy = function() {
    return self.isOpen ? $mdMenu.destroy() : $q.when(false);
  };

  // Use the $mdMenu interim element service to close the menu contents
  this.close = function closeMenu(skipFocus, closeOpts) {
    if (!self.isOpen) return;
    self.isOpen = false;
    $mdUtil.nextTick(function(){ self.onIsOpenChanged(self.isOpen);});

    var eventDetails = angular.extend({}, closeOpts, { skipFocus: skipFocus });
    $scope.$emit('$mdMenuClose', $element, eventDetails);
    $mdMenu.hide(null, closeOpts);

    if (!skipFocus) {
      var el = self.restoreFocusTo || $element.find('button')[0];
      if (el instanceof angular.element) el = el[0];
      if (el) el.focus();
    }
  };

  /**
   * Build a nice object out of our string attribute which specifies the
   * target mode for left and top positioning
   */
  this.positionMode = function positionMode() {
    var attachment = ($attrs.mdPositionMode || 'target').split(' ');

    // If attachment is a single item, duplicate it for our second value.
    // ie. 'target' -> 'target target'
    if (attachment.length === 1) {
      attachment.push(attachment[0]);
    }

    return {
      left: attachment[0],
      top: attachment[1]
    };
  };

  /**
   * Build a nice object out of our string attribute which specifies
   * the offset of top and left in pixels.
   */
  this.offsets = function offsets() {
    var position = ($attrs.mdOffset || '0 0').split(' ').map(parseFloat);
    if (position.length === 2) {
      return {
        left: position[0],
        top: position[1]
      };
    } else if (position.length === 1) {
      return {
        top: position[0],
        left: position[0]
      };
    } else {
      throw Error('Invalid offsets specified. Please follow format <x, y> or <n>');
    }
  };

  // Functionality that is exposed in the view.
  $scope.$mdMenu = {
    open: this.open,
    close: this.close
  };

  // Deprecated APIs
  $scope.$mdOpenMenu = angular.bind(this, function() {
    $log.warn('mdMenu: The $mdOpenMenu method is deprecated. Please use `$mdMenu.open`.');
    return this.open.apply(this, arguments);
  });
}

})();
(function(){
"use strict";

/**
 * @ngdoc directive
 * @name mdMenu
 * @module material.components.menu
 * @restrict E
 * @description
 *
 * Menus are elements that open when clicked. They are useful for displaying
 * additional options within the context of an action.
 *
 * Every `md-menu` must specify exactly two child elements. The first element is what is
 * left in the DOM and is used to open the menu. This element is called the trigger element.
 * The trigger element's scope has access to `$mdMenu.open($event)`
 * which it may call to open the menu. By passing $event as argument, the
 * corresponding event is stopped from propagating up the DOM-tree. Similarly, `$mdMenu.close()`
 * can be used to close the menu.
 *
 * The second element is the `md-menu-content` element which represents the
 * contents of the menu when it is open. Typically this will contain `md-menu-item`s,
 * but you can do custom content as well.
 *
 * <hljs lang="html">
 * <md-menu>
 *  <!-- Trigger element is a md-button with an icon -->
 *  <md-button ng-click="$mdMenu.open($event)" class="md-icon-button" aria-label="Open sample menu">
 *    <md-icon md-svg-icon="call:phone"></md-icon>
 *  </md-button>
 *  <md-menu-content>
 *    <md-menu-item><md-button ng-click="doSomething()">Do Something</md-button></md-menu-item>
 *  </md-menu-content>
 * </md-menu>
 * </hljs>

 * ## Sizing Menus
 *
 * The width of the menu when it is open may be specified by specifying a `width`
 * attribute on the `md-menu-content` element.
 * See the [Material Design Spec](https://material.io/archive/guidelines/components/menus.html#menus-simple-menus)
 * for more information.
 *
 * ## Menu Density
 *
 * You can use dense menus by adding the `md-dense` class to the `md-menu-content` element.
 * This reduces the height of menu items, their top and bottom padding, and default font size.
 * Without the `md-dense` class, we use the "mobile" height of `48px`. With the `md-dense` class,
 * we use the "desktop" height of `32px`. We do not support the "dense desktop" option in the spec,
 * which uses a height of `24px`, at this time.
 * See the [Menu Specs](https://material.io/archive/guidelines/components/menus.html#menus-specs)
 * section of the Material Design Spec for more information.
 *
 * ## Aligning Menus
 *
 * When a menu opens, it is important that the content aligns with the trigger element.
 * Failure to align menus can result in jarring experiences for users as content
 * suddenly shifts. To help with this, `md-menu` provides several APIs to help
 * with alignment.
 *
 * ### Target Mode
 *
 * By default, `md-menu` will attempt to align the `md-menu-content` by aligning
 * designated child elements in both the trigger and the menu content.
 *
 * To specify the alignment element in the `trigger` you can use the `md-menu-origin`
 * attribute on a child element. If no `md-menu-origin` is specified, the `md-menu`
 * will be used as the origin element.
 *
 * Similarly, the `md-menu-content` may specify a `md-menu-align-target` for a
 * `md-menu-item` to specify the node that it should try and align with.
 *
 * In this example code, we specify an icon to be our origin element, and an
 * icon in our menu content to be our alignment target. This ensures that both
 * icons are aligned when the menu opens.
 *
 * <hljs lang="html">
 * <md-menu>
 *  <md-button ng-click="$mdMenu.open($event)" class="md-icon-button" aria-label="Open some menu">
 *    <md-icon md-menu-origin md-svg-icon="call:phone"></md-icon>
 *  </md-button>
 *  <md-menu-content>
 *    <md-menu-item>
 *      <md-button ng-click="doSomething()" aria-label="Do something">
 *        <md-icon md-menu-align-target md-svg-icon="call:phone"></md-icon>
 *        Do Something
 *      </md-button>
 *    </md-menu-item>
 *  </md-menu-content>
 * </md-menu>
 * </hljs>
 *
 * ### Position Mode
 *
 * We can specify the origin of the menu by using the `md-position-mode` attribute.
 * This attribute allows specifying the positioning by the `x` and `y` axes.
 *
 * The default mode is `target target`. This mode uses the left and top edges of the origin element
 * to position the menu in LTR layouts. The `x` axis modes will adjust when in RTL layouts.
 *
 * Sometimes you want to specify alignment from the right side of a origin element. For example,
 * if we have a menu on the right side a toolbar, we may want to right align our menu content.
 * We can use `target-right target` to specify a right-oriented alignment target.
 * There is a working example of this in the Menu Position Modes demo.
 *
 * #### Horizontal Positioning Options
 * - `target`
 * - `target-left`
 * - `target-right`
 * - `cascade`
 * - `right`
 * - `left`
 *
 * #### Vertical Positioning Options
 * - `target`
 * - `cascade`
 * - `bottom`
 *
 * ### Menu Offsets
 *
 * It is sometimes unavoidable to need to have a deeper level of control for
 * the positioning of a menu to ensure perfect alignment. `md-menu` provides
 * the `md-offset` attribute to allow pixel-level specificity when adjusting
 * menu positioning.
 *
 * This offset is provided in the format of `x y` or `n` where `n` will be used
 * in both the `x` and `y` axis.
 * For example, to move a menu by `2px` down from the top, we can use:
 *
 * <hljs lang="html">
 * <md-menu md-offset="0 2">
 *   <!-- menu-content -->
 * </md-menu>
 * </hljs>
 *
 * Specifying `md-offset="2 2"` would shift the menu two pixels down and two pixels to the right.
 *
 * ### Auto Focus
 * By default, when a menu opens, `md-menu` focuses the first button in the menu content.
 *
 * Sometimes you would like to focus another menu item instead of the first.<br/>
 * This can be done by applying the `md-autofocus` directive on the given element.
 *
 * <hljs lang="html">
 * <md-menu-item>
 *   <md-button md-autofocus ng-click="doSomething()">
 *     Auto Focus
 *   </md-button>
 * </md-menu-item>
 * </hljs>
 *
 *
 * ### Preventing close
 *
 * Sometimes you would like to be able to click on a menu item without having the menu
 * close. To do this, AngularJS Material exposes the `md-prevent-menu-close` attribute which
 * can be added to a button inside a menu to stop the menu from automatically closing.
 * You can then close the menu either by using `$mdMenu.close()` in the template,
 * or programmatically by injecting `$mdMenu` and calling `$mdMenu.hide()`.
 *
 * <hljs lang="html">
 * <md-menu-content ng-mouseleave="$mdMenu.close()">
 *   <md-menu-item>
 *     <md-button ng-click="doSomething()" aria-label="Do something" md-prevent-menu-close="md-prevent-menu-close">
 *       <md-icon md-menu-align-target md-svg-icon="call:phone"></md-icon>
 *       Do Something
 *     </md-button>
 *   </md-menu-item>
 * </md-menu-content>
 * </hljs>
 *
 * @usage
 * <hljs lang="html">
 * <md-menu>
 *  <md-button ng-click="$mdMenu.open($event)" class="md-icon-button">
 *    <md-icon md-svg-icon="call:phone"></md-icon>
 *  </md-button>
 *  <md-menu-content>
 *    <md-menu-item><md-button ng-click="doSomething()">Do Something</md-button></md-menu-item>
 *  </md-menu-content>
 * </md-menu>
 * </hljs>
 *
 * @param {string=} md-position-mode Specify pre-defined position modes for the `x` and `y` axes.
 *  The default modes are `target target`. This positions the origin of the menu using the left and top edges
 *  of the origin element in LTR layouts.<br>
 *  #### Valid modes for horizontal positioning
 * - `target`
 * - `target-left`
 * - `target-right`
 * - `cascade`
 * - `right`
 * - `left`<br>
 *  #### Valid modes for vertical positioning
 * - `target`
 * - `cascade`
 * - `bottom`
 * @param {string=} md-offset An offset to apply to the dropdown on opening, after positioning.
 *  Defined as `x` and `y` pixel offset values in the form of `x y`.<br>
 *  The default value is `0 0`.
 */
MenuDirective.$inject = ["$mdUtil"];
angular
    .module('material.components.menu')
    .directive('mdMenu', MenuDirective);

/**
 * @ngInject
 */
function MenuDirective($mdUtil) {
  var INVALID_PREFIX = 'Invalid HTML for md-menu: ';
  return {
    restrict: 'E',
    require: ['mdMenu', '?^mdMenuBar'],
    controller: 'mdMenuCtrl', // empty function to be built by link
    scope: true,
    compile: compile
  };

  function compile(templateElement) {
    templateElement.addClass('md-menu');

    var triggerEl = templateElement.children()[0];
    var prefixer = $mdUtil.prefixer();

    if (!prefixer.hasAttribute(triggerEl, 'ng-click')) {
      triggerEl = triggerEl
          .querySelector(prefixer.buildSelector(['ng-click', 'ng-mouseenter'])) || triggerEl;
    }

    var isButtonTrigger = triggerEl.nodeName === 'MD-BUTTON' || triggerEl.nodeName === 'BUTTON';

    if (triggerEl && isButtonTrigger && !triggerEl.hasAttribute('type')) {
      triggerEl.setAttribute('type', 'button');
    }

    if (!triggerEl) {
      throw Error(INVALID_PREFIX + 'Expected the menu to have a trigger element.');
    }

    if (templateElement.children().length !== 2) {
      throw Error(INVALID_PREFIX + 'Expected two children elements. The second element must have a `md-menu-content` element.');
    }

    // Default element for ARIA attributes has the ngClick or ngMouseenter expression
    triggerEl && triggerEl.setAttribute('aria-haspopup', 'true');

    var nestedMenus = templateElement[0].querySelectorAll('md-menu');
    var nestingDepth = parseInt(templateElement[0].getAttribute('md-nest-level'), 10) || 0;
    if (nestedMenus) {
      angular.forEach($mdUtil.nodesToArray(nestedMenus), function(menuEl) {
        if (!menuEl.hasAttribute('md-position-mode')) {
          menuEl.setAttribute('md-position-mode', 'cascade');
        }
        menuEl.classList.add('_md-nested-menu');
        menuEl.setAttribute('md-nest-level', nestingDepth + 1);
      });
    }
    return link;
  }

  function link(scope, element, attr, ctrls) {
    var mdMenuCtrl = ctrls[0];
    var isInMenuBar = !!ctrls[1];
    // Move everything into a md-menu-container and pass it to the controller
    var menuContainer = angular.element('<div class="_md md-open-menu-container md-whiteframe-z2"></div>');
    var menuContents = element.children()[1];

    element.addClass('_md');     // private md component indicator for styling

    if (!menuContents.hasAttribute('role')) {
      menuContents.setAttribute('role', 'menu');
    }
    menuContainer.append(menuContents);

    element.on('$destroy', function() {
      menuContainer.remove();
    });

    element.append(menuContainer);
    menuContainer[0].style.display = 'none';
    mdMenuCtrl.init(menuContainer, { isInMenuBar: isInMenuBar });

  }
}

})();
(function(){
"use strict";


MenuProvider.$inject = ["$$interimElementProvider"];angular
  .module('material.components.menu')
  .provider('$mdMenu', MenuProvider);

/**
 * Interim element provider for the menu.
 * Handles behavior for a menu while it is open, including:
 *    - handling animating the menu opening/closing
 *    - handling key/mouse events on the menu element
 *    - handling enabling/disabling scroll while the menu is open
 *    - handling redrawing during resizes and orientation changes
 *
 */

function MenuProvider($$interimElementProvider) {
  menuDefaultOptions.$inject = ["$mdUtil", "$mdTheming", "$mdConstant", "$document", "$window", "$q", "$$rAF", "$animateCss", "$animate", "$log"];
  var MENU_EDGE_MARGIN = 8;

  return $$interimElementProvider('$mdMenu')
    .setDefaults({
      methods: ['target'],
      options: menuDefaultOptions
    });

  /* @ngInject */
  function menuDefaultOptions($mdUtil, $mdTheming, $mdConstant, $document, $window, $q, $$rAF,
                              $animateCss, $animate, $log) {

    var prefixer = $mdUtil.prefixer();
    var animator = $mdUtil.dom.animator;

    return {
      parent: 'body',
      onShow: onShow,
      onRemove: onRemove,
      hasBackdrop: true,
      disableParentScroll: true,
      skipCompile: true,
      preserveScope: true,
      multiple: true,
      themable: true
    };

    /**
     * Show modal backdrop element...
     * @returns {function(): void} A function that removes this backdrop
     */
    function showBackdrop(scope, element, options) {
      if (options.nestLevel) return angular.noop;

      // If we are not within a dialog...
      if (options.disableParentScroll && !$mdUtil.getClosest(options.target, 'MD-DIALOG')) {
        // !! DO this before creating the backdrop; since disableScrollAround()
        //    configures the scroll offset; which is used by mdBackDrop postLink()
        options.restoreScroll = $mdUtil.disableScrollAround(options.element, options.parent);
      } else {
        options.disableParentScroll = false;
      }

      if (options.hasBackdrop) {
        options.backdrop = $mdUtil.createBackdrop(scope, "md-menu-backdrop md-click-catcher");

        $animate.enter(options.backdrop, $document[0].body);
      }

      /**
       * Hide and destroys the backdrop created by showBackdrop()
       */
      return function hideBackdrop() {
        if (options.backdrop) options.backdrop.remove();
        if (options.disableParentScroll) options.restoreScroll();
      };
    }

    /**
     * Removing the menu element from the DOM and remove all associated event listeners
     * and backdrop
     */
    function onRemove(scope, element, opts) {
      opts.cleanupInteraction();
      opts.cleanupBackdrop();
      opts.cleanupResizing();
      opts.hideBackdrop();

      // Before the menu is closing remove the clickable class.
      element.removeClass('md-clickable');

      // For navigation $destroy events, do a quick, non-animated removal,
      // but for normal closes (from clicks, etc) animate the removal

      return (opts.$destroy === true) ? detachAndClean() : animateRemoval().then(detachAndClean);

      /**
       * For normal closes, animate the removal.
       * For forced closes (like $destroy events), skip the animations
       */
      function animateRemoval() {
        return $animateCss(element, {addClass: 'md-leave'}).start();
      }

      /**
       * Detach the element
       */
      function detachAndClean() {
        element.removeClass('md-active');
        detachElement(element, opts);
        opts.alreadyOpen = false;
      }

    }

    /**
     * Inserts and configures the staged Menu element into the DOM, positioning it,
     * and wiring up various interaction events
     */
    function onShow(scope, element, opts) {
      sanitizeAndConfigure(opts);

      if (opts.menuContentEl[0]) {
        // Inherit the theme from the target element.
        $mdTheming.inherit(opts.menuContentEl, opts.target);
      } else {
        $log.warn(
          '$mdMenu: Menu elements should always contain a `md-menu-content` element,' +
          'otherwise interactivity features will not work properly.',
          element
        );
      }

      // Register various listeners to move menu on resize/orientation change
      opts.cleanupResizing = startRepositioningOnResize();
      opts.hideBackdrop = showBackdrop(scope, element, opts);

      // Return the promise for when our menu is done animating in
      return showMenu()
        .then(function(response) {
          opts.alreadyOpen = true;
          opts.cleanupInteraction = activateInteraction();
          opts.cleanupBackdrop = setupBackdrop();

          // Since the menu finished its animation, mark the menu as clickable.
          element.addClass('md-clickable');

          return response;
        });

      /**
       * Place the menu into the DOM and call positioning related functions
       */
      function showMenu() {
        opts.parent.append(element);
        element[0].style.display = '';

        return $q(function(resolve) {
          var position = calculateMenuPosition(element, opts);

          element.removeClass('md-leave');

          // Animate the menu scaling, and opacity [from its position origin (default == top-left)]
          // to normal scale.
          $animateCss(element, {
            addClass: 'md-active',
            from: animator.toCss(position),
            to: animator.toCss({transform: ''})
          })
          .start()
          .then(resolve);

        });
      }

      /**
       * Check for valid opts and set some sane defaults
       */
      function sanitizeAndConfigure() {
        if (!opts.target) {
          throw Error(
            '$mdMenu.show() expected a target to animate from in options.target'
          );
        }
        angular.extend(opts, {
          alreadyOpen: false,
          isRemoved: false,
          target: angular.element(opts.target), // make sure it's not a naked DOM node
          parent: angular.element(opts.parent),
          menuContentEl: angular.element(element[0].querySelector('md-menu-content'))
        });
      }

      /**
       * Configure various resize listeners for screen changes
       */
      function startRepositioningOnResize() {

        var repositionMenu = (function(target, options) {
          return $$rAF.throttle(function() {
            if (opts.isRemoved) return;
            var position = calculateMenuPosition(target, options);

            target.css(animator.toCss(position));
          });
        })(element, opts);

        $window.addEventListener('resize', repositionMenu);
        $window.addEventListener('orientationchange', repositionMenu);

        return function stopRepositioningOnResize() {

          // Disable resizing handlers
          $window.removeEventListener('resize', repositionMenu);
          $window.removeEventListener('orientationchange', repositionMenu);

        };
      }

      /**
       * Sets up the backdrop and listens for click elements.
       * Once the backdrop will be clicked, the menu will automatically close.
       * @returns {!Function} Function to remove the backdrop.
       */
      function setupBackdrop() {
        if (!opts.backdrop) return angular.noop;

        opts.backdrop.on('click', onBackdropClick);

        return function() {
          opts.backdrop.off('click', onBackdropClick);
        };
      }

      /**
       * Function to be called whenever the backdrop is clicked.
       * @param {!MouseEvent} event
       */
      function onBackdropClick(event) {
        event.preventDefault();
        event.stopPropagation();

        scope.$apply(function() {
          opts.mdMenuCtrl.close(true, { closeAll: true });
        });
      }

      /**
       * Activate interaction on the menu. Resolves the focus target and closes the menu on
       * escape or option click.
       * @returns {!Function} Function to deactivate the interaction listeners.
       */
      function activateInteraction() {
        if (!opts.menuContentEl[0]) return angular.noop;

        // Wire up keyboard listeners.
        // - Close on escape,
        // - focus next item on down arrow,
        // - focus prev item on up
        opts.menuContentEl.on('keydown', onMenuKeyDown);
        opts.menuContentEl[0].addEventListener('click', captureClickListener, true);

        // kick off initial focus in the menu on the first enabled element
        var focusTarget = opts.menuContentEl[0]
          .querySelector(prefixer.buildSelector(['md-menu-focus-target', 'md-autofocus']));

        if (!focusTarget) {
          var childrenLen = opts.menuContentEl[0].children.length;
          for (var childIndex = 0; childIndex < childrenLen; childIndex++) {
            var child = opts.menuContentEl[0].children[childIndex];
            focusTarget = child.querySelector('.md-button:not([disabled])');
            if (focusTarget) {
              break;
            }
            if (child.firstElementChild && !child.firstElementChild.disabled) {
              focusTarget = child.firstElementChild;
              break;
            }
          }
        }

        focusTarget && focusTarget.focus();

        return function cleanupInteraction() {
          opts.menuContentEl.off('keydown', onMenuKeyDown);
          opts.menuContentEl[0].removeEventListener('click', captureClickListener, true);
        };

        // ************************************
        // internal functions
        // ************************************

        function onMenuKeyDown(ev) {
          var handled;
          switch (ev.keyCode) {
            case $mdConstant.KEY_CODE.ESCAPE:
              opts.mdMenuCtrl.close(false, { closeAll: true });
              handled = true;
              break;
            case $mdConstant.KEY_CODE.TAB:
              opts.mdMenuCtrl.close(false, { closeAll: true });
              // Don't prevent default or stop propagation on this event as we want tab
              // to move the focus to the next focusable element on the page.
              handled = false;
              break;
            case $mdConstant.KEY_CODE.UP_ARROW:
              if (!focusMenuItem(ev, opts.menuContentEl, opts, -1) && !opts.nestLevel) {
                opts.mdMenuCtrl.triggerContainerProxy(ev);
              }
              handled = true;
              break;
            case $mdConstant.KEY_CODE.DOWN_ARROW:
              if (!focusMenuItem(ev, opts.menuContentEl, opts, 1) && !opts.nestLevel) {
                opts.mdMenuCtrl.triggerContainerProxy(ev);
              }
              handled = true;
              break;
            case $mdConstant.KEY_CODE.LEFT_ARROW:
              if (opts.nestLevel) {
                opts.mdMenuCtrl.close();
              } else {
                opts.mdMenuCtrl.triggerContainerProxy(ev);
              }
              handled = true;
              break;
            case $mdConstant.KEY_CODE.RIGHT_ARROW:
              var parentMenu = $mdUtil.getClosest(ev.target, 'MD-MENU');
              if (parentMenu && parentMenu != opts.parent[0]) {
                ev.target.click();
              } else {
                opts.mdMenuCtrl.triggerContainerProxy(ev);
              }
              handled = true;
              break;
          }
          if (handled) {
            ev.preventDefault();
            ev.stopImmediatePropagation();
          }
        }

        function onBackdropClick(e) {
          e.preventDefault();
          e.stopPropagation();
          scope.$apply(function() {
            opts.mdMenuCtrl.close(true, { closeAll: true });
          });
        }

        // Close menu on menu item click, if said menu-item is not disabled
        function captureClickListener(e) {
          var target = e.target;
          // Traverse up the event until we get to the menuContentEl to see if
          // there is an ng-click and that the ng-click is not disabled
          do {
            if (target == opts.menuContentEl[0]) return;
            if ((hasAnyAttribute(target, ['ng-click', 'ng-href', 'ui-sref']) ||
                target.nodeName == 'BUTTON' || target.nodeName == 'MD-BUTTON') && !hasAnyAttribute(target, ['md-prevent-menu-close'])) {
              var closestMenu = $mdUtil.getClosest(target, 'MD-MENU');
              if (!target.hasAttribute('disabled') && (!closestMenu || closestMenu == opts.parent[0])) {
                close();
              }
              break;
            }
          } while (target = target.parentNode);

          function close() {
            scope.$apply(function() {
              opts.mdMenuCtrl.close(true, { closeAll: true });
            });
          }

          function hasAnyAttribute(target, attrs) {
            if (!target) return false;

            for (var i = 0, attr; attr = attrs[i]; ++i) {
              if (prefixer.hasAttribute(target, attr)) {
                return true;
              }
            }

            return false;
          }
        }

      }
    }

    /**
     * Takes a keypress event and focuses the next/previous menu
     * item from the emitting element
     * @param {event} e - The origin keypress event
     * @param {angular.element} menuEl - The menu element
     * @param {object} opts - The interim element options for the mdMenu
     * @param {number} direction - The direction to move in (+1 = next, -1 = prev)
     */
    function focusMenuItem(e, menuEl, opts, direction) {
      var currentItem = $mdUtil.getClosest(e.target, 'MD-MENU-ITEM');

      var items = $mdUtil.nodesToArray(menuEl[0].children);
      var currentIndex = items.indexOf(currentItem);

      // Traverse through our elements in the specified direction (+/-1) and try to
      // focus them until we find one that accepts focus
      var didFocus;
      for (var i = currentIndex + direction; i >= 0 && i < items.length; i = i + direction) {
        var focusTarget = items[i].querySelector('.md-button');
        didFocus = attemptFocus(focusTarget);
        if (didFocus) {
          break;
        }
      }
      return didFocus;
    }

    /**
     * Attempts to focus an element. Checks whether that element is the currently
     * focused element after attempting.
     * @param {HTMLElement} el - the element to attempt focus on
     * @returns {boolean} - whether the element was successfully focused
     */
    function attemptFocus(el) {
      if (el && el.getAttribute('tabindex') != -1) {
        el.focus();
        return ($document[0].activeElement == el);
      }
    }

    /**
     * Use browser to remove this element without triggering a $destroy event
     */
    function detachElement(element, opts) {
      if (!opts.preserveElement) {
        if (toNode(element).parentNode === toNode(opts.parent)) {
          toNode(opts.parent).removeChild(toNode(element));
        }
      } else {
        toNode(element).style.display = 'none';
      }
    }

    /**
     * Computes menu position and sets the style on the menu container
     * @param {HTMLElement} el - the menu container element
     * @param {object} opts - the interim element options object
     */
    function calculateMenuPosition(el, opts) {

      var containerNode = el[0],
        openMenuNode = el[0].firstElementChild,
        openMenuNodeRect = openMenuNode.getBoundingClientRect(),
        boundryNode = $document[0].body,
        boundryNodeRect = boundryNode.getBoundingClientRect();

      var menuStyle = $window.getComputedStyle(openMenuNode);

      var originNode = opts.target[0].querySelector(prefixer.buildSelector('md-menu-origin')) || opts.target[0],
        originNodeRect = originNode.getBoundingClientRect();

      var bounds = {
        left: boundryNodeRect.left + MENU_EDGE_MARGIN,
        top: Math.max(boundryNodeRect.top, 0) + MENU_EDGE_MARGIN,
        bottom: Math.max(boundryNodeRect.bottom, Math.max(boundryNodeRect.top, 0) + boundryNodeRect.height) - MENU_EDGE_MARGIN,
        right: boundryNodeRect.right - MENU_EDGE_MARGIN
      };

      var alignTarget, alignTargetRect = { top:0, left : 0, right:0, bottom:0 }, existingOffsets  = { top:0, left : 0, right:0, bottom:0  };
      var positionMode = opts.mdMenuCtrl.positionMode();

      if (positionMode.top === 'target' || positionMode.left === 'target' || positionMode.left === 'target-right') {
        alignTarget = firstVisibleChild();
        if (alignTarget) {
          // TODO: Allow centering on an arbitrary node, for now center on first menu-item's child
          alignTarget = alignTarget.firstElementChild || alignTarget;
          alignTarget = alignTarget.querySelector(prefixer.buildSelector('md-menu-align-target')) || alignTarget;
          alignTargetRect = alignTarget.getBoundingClientRect();

          existingOffsets = {
            top: parseFloat(containerNode.style.top || 0),
            left: parseFloat(containerNode.style.left || 0)
          };
        }
      }

      var position = {};
      var transformOrigin = 'top ';

      switch (positionMode.top) {
        case 'target':
          position.top = existingOffsets.top + originNodeRect.top - alignTargetRect.top;
          break;
        case 'cascade':
          position.top = originNodeRect.top - parseFloat(menuStyle.paddingTop) - originNode.style.top;
          break;
        case 'bottom':
          position.top = originNodeRect.top + originNodeRect.height;
          break;
        default:
          throw new Error('Invalid target mode "' + positionMode.top + '" specified for md-menu on Y axis.');
      }

      var rtl = ($mdUtil.bidi() === 'rtl');

      switch (positionMode.left) {
        case 'target':
          position.left = existingOffsets.left + originNodeRect.left - alignTargetRect.left;
          transformOrigin += rtl ? 'right'  : 'left';
          break;
        case 'target-left':
          position.left = originNodeRect.left;
          transformOrigin += 'left';
          break;
        case 'target-right':
          position.left = originNodeRect.right - openMenuNodeRect.width + (openMenuNodeRect.right - alignTargetRect.right);
          transformOrigin += 'right';
          break;
        case 'cascade':
          var willFitRight = rtl ? (originNodeRect.left - openMenuNodeRect.width) < bounds.left : (originNodeRect.right + openMenuNodeRect.width) < bounds.right;
          position.left = willFitRight ? originNodeRect.right - originNode.style.left : originNodeRect.left - originNode.style.left - openMenuNodeRect.width;
          transformOrigin += willFitRight ? 'left' : 'right';
          break;
        case 'right':
          if (rtl) {
            position.left = originNodeRect.right - originNodeRect.width;
            transformOrigin += 'left';
          } else {
            position.left = originNodeRect.right - openMenuNodeRect.width;
            transformOrigin += 'right';
          }
          break;
        case 'left':
          if (rtl) {
            position.left = originNodeRect.right - openMenuNodeRect.width;
            transformOrigin += 'right';
          } else {
            position.left = originNodeRect.left;
            transformOrigin += 'left';
          }
          break;
        default:
          throw new Error('Invalid target mode "' + positionMode.left + '" specified for md-menu on X axis.');
      }

      var offsets = opts.mdMenuCtrl.offsets();
      position.top += offsets.top;
      position.left += offsets.left;

      clamp(position);

      var scaleX = Math.round(100 * Math.min(originNodeRect.width / containerNode.offsetWidth, 1.0)) / 100;
      var scaleY = Math.round(100 * Math.min(originNodeRect.height / containerNode.offsetHeight, 1.0)) / 100;

      return {
        top: Math.round(position.top),
        left: Math.round(position.left),
        // Animate a scale out if we aren't just repositioning
        transform: !opts.alreadyOpen ? $mdUtil.supplant('scale({0},{1})', [scaleX, scaleY]) : undefined,
        transformOrigin: transformOrigin
      };

      /**
       * Clamps the repositioning of the menu within the confines of
       * bounding element (often the screen/body)
       */
      function clamp(pos) {
        pos.top = Math.max(Math.min(pos.top, bounds.bottom - containerNode.offsetHeight), bounds.top);
        pos.left = Math.max(Math.min(pos.left, bounds.right - containerNode.offsetWidth), bounds.left);
      }

      /**
       * Gets the first visible child in the openMenuNode
       * Necessary incase menu nodes are being dynamically hidden
       */
      function firstVisibleChild() {
        for (var i = 0; i < openMenuNode.children.length; ++i) {
          if ($window.getComputedStyle(openMenuNode.children[i]).display != 'none') {
            return openMenuNode.children[i];
          }
        }
      }
    }
  }
  function toNode(el) {
    if (el instanceof angular.element) {
      el = el[0];
    }
    return el;
  }
}

})();
(function(){
"use strict";

/**
 * @ngdoc module
 * @name material.components.menuBar
 */

angular.module('material.components.menuBar', [
  'material.core',
  'material.components.icon',
  'material.components.menu'
]);

})();
(function(){
"use strict";


MenuBarController.$inject = ["$scope", "$rootScope", "$element", "$attrs", "$mdConstant", "$document", "$mdUtil", "$timeout"];
angular
  .module('material.components.menuBar')
  .controller('MenuBarController', MenuBarController);

var BOUND_MENU_METHODS = ['handleKeyDown', 'handleMenuHover', 'scheduleOpenHoveredMenu', 'cancelScheduledOpen'];

/**
 * @ngInject
 */
function MenuBarController($scope, $rootScope, $element, $attrs, $mdConstant, $document, $mdUtil, $timeout) {
  this.$element = $element;
  this.$attrs = $attrs;
  this.$mdConstant = $mdConstant;
  this.$mdUtil = $mdUtil;
  this.$document = $document;
  this.$scope = $scope;
  this.$rootScope = $rootScope;
  this.$timeout = $timeout;

  var self = this;
  angular.forEach(BOUND_MENU_METHODS, function(methodName) {
    self[methodName] = angular.bind(self, self[methodName]);
  });
}

MenuBarController.prototype.init = function() {
  var $element = this.$element;
  var $mdUtil = this.$mdUtil;
  var $scope = this.$scope;

  var self = this;
  var deregisterFns = [];
  $element.on('keydown', this.handleKeyDown);
  this.parentToolbar = $mdUtil.getClosest($element, 'MD-TOOLBAR');

  deregisterFns.push(this.$rootScope.$on('$mdMenuOpen', function(event, el) {
    if (self.getMenus().indexOf(el[0]) != -1) {
      $element[0].classList.add('md-open');
      el[0].classList.add('md-open');
      self.currentlyOpenMenu = el.controller('mdMenu');
      self.currentlyOpenMenu.registerContainerProxy(self.handleKeyDown);
      self.enableOpenOnHover();
    }
  }));

  deregisterFns.push(this.$rootScope.$on('$mdMenuClose', function(event, el, opts) {
    var rootMenus = self.getMenus();
    if (rootMenus.indexOf(el[0]) != -1) {
      $element[0].classList.remove('md-open');
      el[0].classList.remove('md-open');
    }

    if ($element[0].contains(el[0])) {
      var parentMenu = el[0];
      while (parentMenu && rootMenus.indexOf(parentMenu) == -1) {
        parentMenu = $mdUtil.getClosest(parentMenu, 'MD-MENU', true);
      }
      if (parentMenu) {
        if (!opts.skipFocus) parentMenu.querySelector('button:not([disabled])').focus();
        self.currentlyOpenMenu = undefined;
        self.disableOpenOnHover();
        self.setKeyboardMode(true);
      }
    }
  }));

  $scope.$on('$destroy', function() {
    self.disableOpenOnHover();
    while (deregisterFns.length) {
      deregisterFns.shift()();
    }
  });


  this.setKeyboardMode(true);
};

MenuBarController.prototype.setKeyboardMode = function(enabled) {
  if (enabled) this.$element[0].classList.add('md-keyboard-mode');
  else this.$element[0].classList.remove('md-keyboard-mode');
};

MenuBarController.prototype.enableOpenOnHover = function() {
  if (this.openOnHoverEnabled) return;

  var self = this;

  self.openOnHoverEnabled = true;

  if (self.parentToolbar) {
    self.parentToolbar.classList.add('md-has-open-menu');

    // Needs to be on the next tick so it doesn't close immediately.
    self.$mdUtil.nextTick(function() {
      angular.element(self.parentToolbar).on('click', self.handleParentClick);
    }, false);
  }

  angular
    .element(self.getMenus())
    .on('mouseenter', self.handleMenuHover);
};

MenuBarController.prototype.handleMenuHover = function(e) {
  this.setKeyboardMode(false);
  if (this.openOnHoverEnabled) {
    this.scheduleOpenHoveredMenu(e);
  }
};

MenuBarController.prototype.disableOpenOnHover = function() {
  if (!this.openOnHoverEnabled) return;

  this.openOnHoverEnabled = false;

  if (this.parentToolbar) {
    this.parentToolbar.classList.remove('md-has-open-menu');
    angular.element(this.parentToolbar).off('click', this.handleParentClick);
  }

  angular
    .element(this.getMenus())
    .off('mouseenter', this.handleMenuHover);
};

MenuBarController.prototype.scheduleOpenHoveredMenu = function(e) {
  var menuEl = angular.element(e.currentTarget);
  var menuCtrl = menuEl.controller('mdMenu');
  this.setKeyboardMode(false);
  this.scheduleOpenMenu(menuCtrl);
};

MenuBarController.prototype.scheduleOpenMenu = function(menuCtrl) {
  var self = this;
  var $timeout = this.$timeout;
  if (menuCtrl != self.currentlyOpenMenu) {
    $timeout.cancel(self.pendingMenuOpen);
    self.pendingMenuOpen = $timeout(function() {
      self.pendingMenuOpen = undefined;
      if (self.currentlyOpenMenu) {
        self.currentlyOpenMenu.close(true, { closeAll: true });
      }
      menuCtrl.open();
    }, 200, false);
  }
};

MenuBarController.prototype.handleKeyDown = function(e) {
  var keyCodes = this.$mdConstant.KEY_CODE;
  var currentMenu = this.currentlyOpenMenu;
  var wasOpen = currentMenu && currentMenu.isOpen;
  this.setKeyboardMode(true);
  var handled, newMenu, newMenuCtrl;
  switch (e.keyCode) {
    case keyCodes.DOWN_ARROW:
      if (currentMenu) {
        currentMenu.focusMenuContainer();
      } else {
        this.openFocusedMenu();
      }
      handled = true;
      break;
    case keyCodes.UP_ARROW:
      currentMenu && currentMenu.close();
      handled = true;
      break;
    case keyCodes.LEFT_ARROW:
      newMenu = this.focusMenu(-1);
      if (wasOpen) {
        newMenuCtrl = angular.element(newMenu).controller('mdMenu');
        this.scheduleOpenMenu(newMenuCtrl);
      }
      handled = true;
      break;
    case keyCodes.RIGHT_ARROW:
      newMenu = this.focusMenu(+1);
      if (wasOpen) {
        newMenuCtrl = angular.element(newMenu).controller('mdMenu');
        this.scheduleOpenMenu(newMenuCtrl);
      }
      handled = true;
      break;
  }
  if (handled) {
    e && e.preventDefault && e.preventDefault();
    e && e.stopImmediatePropagation && e.stopImmediatePropagation();
  }
};

MenuBarController.prototype.focusMenu = function(direction) {
  var menus = this.getMenus();
  var focusedIndex = this.getFocusedMenuIndex();

  if (focusedIndex == -1) { focusedIndex = this.getOpenMenuIndex(); }

  var changed = false;

  if (focusedIndex == -1) { focusedIndex = 0; changed = true; }
  else if (
    direction < 0 && focusedIndex > 0 ||
    direction > 0 && focusedIndex < menus.length - direction
  ) {
    focusedIndex += direction;
    changed = true;
  }
  if (changed) {
    menus[focusedIndex].querySelector('button').focus();
    return menus[focusedIndex];
  }
};

MenuBarController.prototype.openFocusedMenu = function() {
  var menu = this.getFocusedMenu();
  menu && angular.element(menu).controller('mdMenu').open();
};

MenuBarController.prototype.getMenus = function() {
  var $element = this.$element;
  return this.$mdUtil.nodesToArray($element[0].children)
    .filter(function(el) { return el.nodeName == 'MD-MENU'; });
};

MenuBarController.prototype.getFocusedMenu = function() {
  return this.getMenus()[this.getFocusedMenuIndex()];
};

MenuBarController.prototype.getFocusedMenuIndex = function() {
  var $mdUtil = this.$mdUtil;
  var focusedEl = $mdUtil.getClosest(
    this.$document[0].activeElement,
    'MD-MENU'
  );
  if (!focusedEl) return -1;

  var focusedIndex = this.getMenus().indexOf(focusedEl);
  return focusedIndex;
};

MenuBarController.prototype.getOpenMenuIndex = function() {
  var menus = this.getMenus();
  for (var i = 0; i < menus.length; ++i) {
    if (menus[i].classList.contains('md-open')) return i;
  }
  return -1;
};

MenuBarController.prototype.handleParentClick = function(event) {
  var openMenu = this.querySelector('md-menu.md-open');

  if (openMenu && !openMenu.contains(event.target)) {
    angular.element(openMenu).controller('mdMenu').close(true, {
      closeAll: true
    });
  }
};

})();
(function(){
"use strict";

/**
 * @ngdoc directive
 * @name mdMenuBar
 * @module material.components.menuBar
 * @restrict E
 * @description
 *
 * Menu bars are containers that hold multiple menus. They change the behavior and appearance
 * of the `md-menu` directive to behave similar to an operating system provided menu.
 *
 * @usage
 * <hljs lang="html">
 * <md-menu-bar>
 *   <md-menu>
 *     <button ng-click="$mdMenu.open()">
 *       File
 *     </button>
 *     <md-menu-content>
 *       <md-menu-item>
 *         <md-button ng-click="ctrl.sampleAction('share', $event)">
 *           Share...
 *         </md-button>
 *       </md-menu-item>
 *       <md-menu-divider></md-menu-divider>
 *       <md-menu-item>
 *       <md-menu-item>
 *         <md-menu>
 *           <md-button ng-click="$mdMenu.open()">New</md-button>
 *           <md-menu-content>
 *             <md-menu-item><md-button ng-click="ctrl.sampleAction('New Document', $event)">Document</md-button></md-menu-item>
 *             <md-menu-item><md-button ng-click="ctrl.sampleAction('New Spreadsheet', $event)">Spreadsheet</md-button></md-menu-item>
 *             <md-menu-item><md-button ng-click="ctrl.sampleAction('New Presentation', $event)">Presentation</md-button></md-menu-item>
 *             <md-menu-item><md-button ng-click="ctrl.sampleAction('New Form', $event)">Form</md-button></md-menu-item>
 *             <md-menu-item><md-button ng-click="ctrl.sampleAction('New Drawing', $event)">Drawing</md-button></md-menu-item>
 *           </md-menu-content>
 *         </md-menu>
 *       </md-menu-item>
 *     </md-menu-content>
 *   </md-menu>
 * </md-menu-bar>
 * </hljs>
 *
 * ## Menu Bar Controls
 *
 * You may place `md-menu-item`s that function as controls within menu bars.
 * There are two modes that are exposed via the `type` attribute of the `md-menu-item`.
 * `type="checkbox"` will function as a boolean control for the `ng-model` attribute of the
 * `md-menu-item`. `type="radio"` will function like a radio button, setting the `ngModel`
 * to the `string` value of the `value` attribute. If you need non-string values, you can use
 * `ng-value` to provide an expression (this is similar to how angular's native `input[type=radio]`
 * works.
 *
 * If you want either to disable closing the opened menu when clicked, you can add the
 * `md-prevent-menu-close` attribute to the `md-menu-item`. The attribute will be forwarded to the
 * `button` element that is generated.
 *
 * <hljs lang="html">
 * <md-menu-bar>
 *  <md-menu>
 *    <button ng-click="$mdMenu.open()">
 *      Sample Menu
 *    </button>
 *    <md-menu-content>
 *      <md-menu-item type="checkbox" ng-model="settings.allowChanges" md-prevent-menu-close>
 *        Allow changes
 *      </md-menu-item>
 *      <md-menu-divider></md-menu-divider>
 *      <md-menu-item type="radio" ng-model="settings.mode" ng-value="1">Mode 1</md-menu-item>
 *      <md-menu-item type="radio" ng-model="settings.mode" ng-value="2">Mode 2</md-menu-item>
 *      <md-menu-item type="radio" ng-model="settings.mode" ng-value="3">Mode 3</md-menu-item>
 *    </md-menu-content>
 *  </md-menu>
 * </md-menu-bar>
 * </hljs>
 *
 *
 * ### Nesting Menus
 *
 * Menus may be nested within menu bars. This is commonly called cascading menus.
 * To nest a menu place the nested menu inside the content of the `md-menu-item`.
 * <hljs lang="html">
 * <md-menu-item>
 *   <md-menu>
 *     <button ng-click="$mdMenu.open()">New</md-button>
 *     <md-menu-content>
 *       <md-menu-item><md-button ng-click="ctrl.sampleAction('New Document', $event)">Document</md-button></md-menu-item>
 *       <md-menu-item><md-button ng-click="ctrl.sampleAction('New Spreadsheet', $event)">Spreadsheet</md-button></md-menu-item>
 *       <md-menu-item><md-button ng-click="ctrl.sampleAction('New Presentation', $event)">Presentation</md-button></md-menu-item>
 *       <md-menu-item><md-button ng-click="ctrl.sampleAction('New Form', $event)">Form</md-button></md-menu-item>
 *       <md-menu-item><md-button ng-click="ctrl.sampleAction('New Drawing', $event)">Drawing</md-button></md-menu-item>
 *     </md-menu-content>
 *   </md-menu>
 * </md-menu-item>
 * </hljs>
 *
 */

MenuBarDirective.$inject = ["$mdUtil", "$mdTheming"];
angular
  .module('material.components.menuBar')
  .directive('mdMenuBar', MenuBarDirective);

/* @ngInject */
function MenuBarDirective($mdUtil, $mdTheming) {
  return {
    restrict: 'E',
    require: 'mdMenuBar',
    controller: 'MenuBarController',

    compile: function compile(templateEl, templateAttrs) {
      if (!templateAttrs.ariaRole) {
        templateEl[0].setAttribute('role', 'menubar');
      }
      angular.forEach(templateEl[0].children, function(menuEl) {
        if (menuEl.nodeName == 'MD-MENU') {
          if (!menuEl.hasAttribute('md-position-mode')) {
            menuEl.setAttribute('md-position-mode', 'left bottom');

            // Since we're in the compile function and actual `md-buttons` are not compiled yet,
            // we need to query for possible `md-buttons` as well.
            menuEl.querySelector('button, a, md-button').setAttribute('role', 'menuitem');
          }
          var contentEls = $mdUtil.nodesToArray(menuEl.querySelectorAll('md-menu-content'));
          angular.forEach(contentEls, function(contentEl) {
            contentEl.classList.add('md-menu-bar-menu');
            contentEl.classList.add('md-dense');
            if (!contentEl.hasAttribute('width')) {
              contentEl.setAttribute('width', 5);
            }
          });
        }
      });

      // Mark the child menu items that they're inside a menu bar. This is necessary,
      // because mnMenuItem has special behaviour during compilation, depending on
      // whether it is inside a mdMenuBar. We can usually figure this out via the DOM,
      // however if a directive that uses documentFragment is applied to the child (e.g. ngRepeat),
      // the element won't have a parent and won't compile properly.
      templateEl.find('md-menu-item').addClass('md-in-menu-bar');

      return function postLink(scope, el, attr, ctrl) {
        el.addClass('_md');     // private md component indicator for styling
        $mdTheming(scope, el);
        ctrl.init();
      };
    }
  };

}

})();
(function(){
"use strict";


angular
  .module('material.components.menuBar')
  .directive('mdMenuDivider', MenuDividerDirective);


function MenuDividerDirective() {
  return {
    restrict: 'E',
    compile: function(templateEl, templateAttrs) {
      if (!templateAttrs.role) {
        templateEl[0].setAttribute('role', 'separator');
      }
    }
  };
}

})();
(function(){
"use strict";


MenuItemController.$inject = ["$scope", "$element", "$attrs"];
angular
  .module('material.components.menuBar')
  .controller('MenuItemController', MenuItemController);


/**
 * @ngInject
 */
function MenuItemController($scope, $element, $attrs) {
  this.$element = $element;
  this.$attrs = $attrs;
  this.$scope = $scope;
}

MenuItemController.prototype.init = function(ngModel) {
  var $element = this.$element;
  var $attrs = this.$attrs;

  this.ngModel = ngModel;
  if ($attrs.type == 'checkbox' || $attrs.type == 'radio') {
    this.mode  = $attrs.type;
    this.iconEl = $element[0].children[0];
    this.buttonEl = $element[0].children[1];
    if (ngModel) {
      // Clear ngAria set attributes
      this.initClickListeners();
    }
  }
};

// ngAria auto sets attributes on a menu-item with a ngModel.
// We don't want this because our content (buttons) get the focus
// and set their own aria attributes appropritately. Having both
// breaks NVDA / JAWS. This undeoes ngAria's attrs.
MenuItemController.prototype.clearNgAria = function() {
  var el = this.$element[0];
  var clearAttrs = ['role', 'tabindex', 'aria-invalid', 'aria-checked'];
  angular.forEach(clearAttrs, function(attr) {
    el.removeAttribute(attr);
  });
};

MenuItemController.prototype.initClickListeners = function() {
  var self = this;
  var ngModel = this.ngModel;
  var $scope = this.$scope;
  var $attrs = this.$attrs;
  var $element = this.$element;
  var mode = this.mode;

  this.handleClick = angular.bind(this, this.handleClick);

  var icon = this.iconEl;
  var button = angular.element(this.buttonEl);
  var handleClick = this.handleClick;

  $attrs.$observe('disabled', setDisabled);
  setDisabled($attrs.disabled);

  ngModel.$render = function render() {
    self.clearNgAria();
    if (isSelected()) {
      icon.style.display = '';
      button.attr('aria-checked', 'true');
    } else {
      icon.style.display = 'none';
      button.attr('aria-checked', 'false');
    }
  };

  $scope.$$postDigest(ngModel.$render);

  function isSelected() {
    if (mode == 'radio') {
      var val = $attrs.ngValue ? $scope.$eval($attrs.ngValue) : $attrs.value;
      return ngModel.$modelValue == val;
    } else {
      return ngModel.$modelValue;
    }
  }

  function setDisabled(disabled) {
    if (disabled) {
      button.off('click', handleClick);
    } else {
      button.on('click', handleClick);
    }
  }
};

MenuItemController.prototype.handleClick = function(e) {
  var mode = this.mode;
  var ngModel = this.ngModel;
  var $attrs = this.$attrs;
  var newVal;
  if (mode == 'checkbox') {
    newVal = !ngModel.$modelValue;
  } else if (mode == 'radio') {
    newVal = $attrs.ngValue ? this.$scope.$eval($attrs.ngValue) : $attrs.value;
  }
  ngModel.$setViewValue(newVal);
  ngModel.$render();
};

})();
(function(){
"use strict";


MenuItemDirective.$inject = ["$mdUtil", "$mdConstant", "$$mdSvgRegistry"];
angular
  .module('material.components.menuBar')
  .directive('mdMenuItem', MenuItemDirective);

 /* @ngInject */
function MenuItemDirective($mdUtil, $mdConstant, $$mdSvgRegistry) {
  return {
    controller: 'MenuItemController',
    require: ['mdMenuItem', '?ngModel'],
    priority: $mdConstant.BEFORE_NG_ARIA,
    compile: function(templateEl, templateAttrs) {
      var type = templateAttrs.type;
      var inMenuBarClass = 'md-in-menu-bar';

      // Note: This allows us to show the `check` icon for the md-menu-bar items.
      // The `md-in-menu-bar` class is set by the mdMenuBar directive.
      if ((type === 'checkbox' || type === 'radio') && templateEl.hasClass(inMenuBarClass)) {
        var text = templateEl[0].textContent;
        var buttonEl = angular.element('<md-button type="button"></md-button>');
        var iconTemplate = '<md-icon md-svg-src="' + $$mdSvgRegistry.mdChecked + '"></md-icon>';

        buttonEl.html(text);
        buttonEl.attr('tabindex', '0');

        if (angular.isDefined(templateAttrs.mdPreventMenuClose)) {
          buttonEl.attr('md-prevent-menu-close', templateAttrs.mdPreventMenuClose);
        }

        templateEl.html('');
        templateEl.append(angular.element(iconTemplate));
        templateEl.append(buttonEl);
        templateEl.addClass('md-indent').removeClass(inMenuBarClass);

        setDefault('role', type === 'checkbox' ? 'menuitemcheckbox' : 'menuitemradio', buttonEl);
        moveAttrToButton('ng-disabled');

      } else {
        setDefault('role', 'menuitem', templateEl[0].querySelector('md-button, button, a'));
      }


      return function(scope, el, attrs, ctrls) {
        var ctrl = ctrls[0];
        var ngModel = ctrls[1];
        ctrl.init(ngModel);
      };

      function setDefault(attr, val, el) {
        el = el || templateEl;
        if (el instanceof angular.element) {
          el = el[0];
        }
        if (!el.hasAttribute(attr)) {
          el.setAttribute(attr, val);
        }
      }

      function moveAttrToButton(attribute) {
        var attributes = $mdUtil.prefixer(attribute);

        angular.forEach(attributes, function(attr) {
          if (templateEl[0].hasAttribute(attr)) {
            var val = templateEl[0].getAttribute(attr);
            buttonEl[0].setAttribute(attr, val);
            templateEl[0].removeAttribute(attr);
          }
        });
      }
    }
  };
}

})();
(function(){
"use strict";

/**
 * @ngdoc module
 * @name material.components.navBar
 */


MdNavBar.$inject = ["$mdAria", "$mdTheming"];
MdNavBarController.$inject = ["$element", "$scope", "$timeout", "$mdConstant"];
MdNavItem.$inject = ["$mdAria", "$$rAF", "$mdUtil", "$window"];
MdNavItemController.$inject = ["$element"];
angular.module('material.components.navBar', ['material.core'])
    .controller('MdNavBarController', MdNavBarController)
    .directive('mdNavBar', MdNavBar)
    .controller('MdNavItemController', MdNavItemController)
    .directive('mdNavItem', MdNavItem);

/**
 * @ngdoc directive
 * @name mdNavBar
 * @module material.components.navBar
 *
 * @restrict E
 *
 * @description
 * The `<md-nav-bar>` directive renders a list of material tabs that can be used
 * for top-level page navigation. Unlike `<md-tabs>`, it has no concept of a tab
 * body and no bar pagination.
 *
 * Because it deals with page navigation, certain routing concepts are built-in.
 * Route changes via `ng-href`, `ui-sref`, or `ng-click` events are supported.
 * Alternatively, the user could simply watch the value of `md-selected-nav-item`
 * (`currentNavItem` in the below example) for changes.
 *
 * Accessibility functionality is implemented as a
 * <a href="https://www.w3.org/TR/wai-aria-1.0/complete#tablist">
 *   tablist</a> with
 * <a href="https://www.w3.org/TR/wai-aria-1.0/complete#tab">tabs</a>.
 * We've kept the `role="navigation"` on the `<nav>`, for backwards compatibility, even though
 *  it is not required in the
 * <a href="https://www.w3.org/TR/wai-aria-practices/#aria_lh_navigation">
 *   latest Working Group Note from December 2017</a>.
 *
 * <h3>Keyboard Navigation</h3>
 * - `Tab`/`Shift+Tab` moves the focus to the next/previous interactive element on the page
 * - `Enter`/`Space` selects the focused nav item and navigates to display the item's contents
 * - `Right`/`Down` moves focus to the next nav item, wrapping at the end
 * - `Left`/`Up` moves focus to the previous nav item, wrapping at the end
 * - `Home`/`End` moves the focus to the first/last nav item
 *
 * @param {string=} md-selected-nav-item The name of the current tab; this must
 *     match the `name` attribute of `<md-nav-item>`.
 * @param {boolean=} md-no-ink-bar If set to true, the ink bar will be hidden.
 * @param {string=} nav-bar-aria-label An `aria-label` applied to the `md-nav-bar`'s tablist
 * for accessibility.
 *
 * @usage
 * <hljs lang="html">
 *  <md-nav-bar md-selected-nav-item="currentNavItem">
 *    <md-nav-item md-nav-click="goto('page1')" name="page1">
 *      Page One
 *    </md-nav-item>
 *    <md-nav-item md-nav-href="#page2" name="page3">Page Two</md-nav-item>
 *    <md-nav-item md-nav-sref="page3" name="page2">Page Three</md-nav-item>
 *    <md-nav-item
 *      md-nav-sref="app.page4"
 *      sref-opts="{reload: true, notify: true}"
 *      name="page4">
 *      Page Four
 *    </md-nav-item>
 *  </md-nav-bar>
 *</hljs>
 * <hljs lang="js">
 * (function() {
 *   'use strict';
 *
 *    $rootScope.$on('$routeChangeSuccess', function(event, current) {
 *      $scope.currentLink = getCurrentLinkFromRoute(current);
 *    });
 * });
 * </hljs>
 */
/**
 * @param $mdAria
 * @param $mdTheming
 * @constructor
 * @ngInject
 */
function MdNavBar($mdAria, $mdTheming) {
  return {
    restrict: 'E',
    transclude: true,
    controller: MdNavBarController,
    controllerAs: 'ctrl',
    bindToController: true,
    scope: {
      'mdSelectedNavItem': '=?',
      'mdNoInkBar': '=?',
      'navBarAriaLabel': '@?',
    },
    template:
      '<div class="md-nav-bar">' +
        '<nav role="navigation">' +
          '<ul class="_md-nav-bar-list" ng-transclude role="tablist" ' +
            'ng-focus="ctrl.onFocus()" ' + // Deprecated but kept for now in order to not break tests
            'aria-label="{{ctrl.navBarAriaLabel}}">' +
          '</ul>' +
        '</nav>' +
        '<md-nav-ink-bar ng-hide="ctrl.mdNoInkBar"></md-nav-ink-bar>' +
      '</div>',
    link: function(scope, element, attrs, ctrl) {
      $mdTheming(element);
      if (!ctrl.navBarAriaLabel) {
        $mdAria.expectAsync(element, 'aria-label', angular.noop);
      }
    },
  };
}

/**
 * Controller for the nav-bar component.
 * Accessibility functionality is implemented as a tablist
 * (https://www.w3.org/TR/wai-aria-1.0/complete#tablist) and
 * tabs (https://www.w3.org/TR/wai-aria-1.0/complete#tab).
 *
 * @param {!angular.JQLite} $element
 * @param {!angular.Scope} $scope
 * @param {!angular.Timeout} $timeout
 * @param {!Object} $mdConstant
 * @constructor
 * @final
 * @ngInject
 */
function MdNavBarController($element, $scope, $timeout, $mdConstant) {
  // Injected variables
  /** @private @const {!angular.Timeout} */
  this._$timeout = $timeout;

  /** @private @const {!angular.Scope} */
  this._$scope = $scope;

  /** @private @const {!Object} */
  this._$mdConstant = $mdConstant;

  // Data-bound variables.
  /** @type {string} */
  this.mdSelectedNavItem;

  /** @type {string} */
  this.navBarAriaLabel;

  // State variables.

  /** @type {?angular.JQLite} */
  this._navBarEl = $element[0];

  /** @type {?angular.JQLite} */
  this._inkbar;

  var self = this;
  // need to wait for transcluded content to be available
  var deregisterTabWatch = this._$scope.$watch(function() {
    return self._navBarEl.querySelectorAll('._md-nav-button').length;
  },
  function(newLength) {
    if (newLength > 0) {
      self._initTabs();
      deregisterTabWatch();
    }
  });
}

/**
 * Initializes the tab components once they exist.
 * @private
 */
MdNavBarController.prototype._initTabs = function() {
  this._inkbar = angular.element(this._navBarEl.querySelector('md-nav-ink-bar'));

  var self = this;
  this._$timeout(function() {
    self._updateTabs(self.mdSelectedNavItem, undefined);
  });

  this._$scope.$watch('ctrl.mdSelectedNavItem', function(newValue, oldValue) {
    // Wait a digest before update tabs for products doing
    // anything dynamic in the template.
    self._$timeout(function() {
      self._updateTabs(newValue, oldValue);
    });
  });
};

/**
 * Set the current tab to be selected.
 * @param {string|undefined} newValue New current tab name.
 * @param {string|undefined} oldValue Previous tab name.
 * @private
 */
MdNavBarController.prototype._updateTabs = function(newValue, oldValue) {
  var self = this;
  var tabs = this._getTabs();
  var sameTab = newValue === oldValue;

  // this._getTabs can return null if nav-bar has not yet been initialized
  if (!tabs) return;

  var oldIndex = -1;
  var newIndex = -1;
  var newTab = this._getTabByName(newValue);
  var oldTab = this._getTabByName(oldValue);

  if (oldTab) {
    oldTab.setSelected(false);
    oldIndex = tabs.indexOf(oldTab);
  }

  if (newTab) {
    newTab.setSelected(true);
    newIndex = tabs.indexOf(newTab);
  }

  this._$timeout(function() {
    self._updateInkBarStyles(newTab, newIndex, oldIndex);
    // Don't change focus when there is no newTab, the new and old tabs are the same, or when
    // called from MdNavBarController._initTabs() which would have no oldTab defined.
    if (newTab && oldTab && !sameTab) {
      self._moveFocus(oldTab, newTab);
    }
  });
};

/**
 * Repositions the ink bar to the selected tab.
 * @private
 */
MdNavBarController.prototype._updateInkBarStyles = function(tab, newIndex, oldIndex) {
  this._inkbar.toggleClass('_md-left', newIndex < oldIndex)
      .toggleClass('_md-right', newIndex > oldIndex);

  this._inkbar.css({display: newIndex < 0 ? 'none' : ''});

  if (tab) {
    var tabEl = tab.getButtonEl();
    var left = tabEl.offsetLeft;

    this._inkbar.css({left: left + 'px', width: tabEl.offsetWidth + 'px'});
  }
};

/**
 * Returns an array of the current tabs.
 * @return {Array<!MdNavItemController>}
 * @private
 */
MdNavBarController.prototype._getTabs = function() {
  var controllers = Array.prototype.slice.call(
    this._navBarEl.querySelectorAll('.md-nav-item'))
    .map(function(el) {
      return angular.element(el).controller('mdNavItem');
    });
  return controllers.indexOf(undefined) ? controllers : null;
};

/**
 * Returns the tab with the specified name.
 * @param {string} name The name of the tab, found in its name attribute.
 * @return {MdNavItemController}
 * @private
 */
MdNavBarController.prototype._getTabByName = function(name) {
  return this._findTab(function(tab) {
    return tab.getName() === name;
  });
};

/**
 * Returns the selected tab.
 * @return {MdNavItemController}
 * @private
 */
MdNavBarController.prototype._getSelectedTab = function() {
  return this._findTab(function(tab) {
    return tab.isSelected();
  });
};

/**
 * Returns the focused tab.
 * @return {MdNavItemController}
 */
MdNavBarController.prototype.getFocusedTab = function() {
  return this._findTab(function(tab) {
    return tab.hasFocus();
  });
};

/**
 * Find a tab that matches the specified function, starting from the first tab.
 * @param {Function} fn
 * @param {number=} startIndex index to start at. Defaults to 0.
 * @returns {MdNavItemController}
 * @private
 */
MdNavBarController.prototype._findTab = function(fn, startIndex) {
  var tabs = this._getTabs();
  if (startIndex === undefined || startIndex === null) {
    startIndex = 0;
  }
  for (var i = startIndex; i < tabs.length; i++) {
    if (fn(tabs[i])) {
      return tabs[i];
    }
  }
  return null;
};

/**
 * Find a tab that matches the specified function, going backwards from the end of the list.
 * @param {Function} fn
 * @param {number=} startIndex index to start at. Defaults to tabs.length - 1.
 * @returns {MdNavItemController}
 * @private
 */
MdNavBarController.prototype._findTabReverse = function(fn, startIndex) {
  var tabs = this._getTabs();
  if (startIndex === undefined || startIndex === null) {
    startIndex = tabs.length - 1;
  }
  for (var i = startIndex; i >= 0 ; i--) {
    if (fn(tabs[i])) {
      return tabs[i];
    }
  }
  return null;
};

/**
 * Direct focus to the selected tab when focus enters the nav bar.
 */
MdNavBarController.prototype.onFocus = function() {
  var tab = this._getSelectedTab();
  if (tab) {
    tab.setFocused(true);
  }
};

/**
 * Move focus from oldTab to newTab.
 * @param {!MdNavItemController} oldTab
 * @param {!MdNavItemController} newTab
 * @private
 */
MdNavBarController.prototype._moveFocus = function(oldTab, newTab) {
  oldTab.setFocused(false);
  newTab.setFocused(true);
};

/**
 * Focus the first tab.
 * @private
 */
MdNavBarController.prototype._focusFirstTab = function() {
  var tabs = this._getTabs();
  if (!tabs) return;
  var tabToFocus = this._findTab(function(tab) {
    return tab._isEnabled();
  });
  if (tabToFocus) {
    this._moveFocus(this.getFocusedTab(), tabToFocus);
  }
};

/**
 * Focus the last tab.
 * @private
 */
MdNavBarController.prototype._focusLastTab = function() {
  var tabs = this._getTabs();
  if (!tabs) return;
  var tabToFocus = this._findTabReverse(function(tab) {
    return tab._isEnabled();
  });
  if (tabToFocus) {
    this._moveFocus(this.getFocusedTab(), tabToFocus);
  }
};

/**
 * Focus the next non-disabled tab.
 * @param {number} focusedTabIndex the index of the currently focused tab
 * @private
 */
MdNavBarController.prototype._focusNextTab = function(focusedTabIndex) {
  var tabs = this._getTabs();
  if (!tabs) return;
  var tabToFocus = this._findTab(function(tab) {
    return tab._isEnabled();
  }, focusedTabIndex + 1);
  if (tabToFocus) {
    this._moveFocus(this.getFocusedTab(), tabToFocus);
  } else {
    this._focusFirstTab();
  }
};

/**
 * Focus the previous non-disabled tab.
 * @param {number} focusedTabIndex the index of the currently focused tab
 * @private
 */
MdNavBarController.prototype._focusPreviousTab = function(focusedTabIndex) {
  var tabs = this._getTabs();
  if (!tabs) return;
  var tabToFocus = this._findTabReverse(function(tab) {
    return tab._isEnabled();
  }, focusedTabIndex - 1);
  if (tabToFocus) {
    this._moveFocus(this.getFocusedTab(), tabToFocus);
  } else {
    this._focusLastTab();
  }
};

/**
 * Responds to keydown events.
 * Calls to preventDefault() stop the page from scrolling when changing focus in the nav-bar.
 * @param {!KeyboardEvent} e
 */
MdNavBarController.prototype.onKeydown = function(e) {
  var keyCodes = this._$mdConstant.KEY_CODE;
  var tabs = this._getTabs();
  var focusedTab = this.getFocusedTab();
  if (!focusedTab || !tabs) return;

  var focusedTabIndex = tabs.indexOf(focusedTab);

  // use arrow keys to navigate between tabs
  switch (e.keyCode) {
    case keyCodes.UP_ARROW:
    case keyCodes.LEFT_ARROW:
      e.preventDefault();
      this._focusPreviousTab(focusedTabIndex);
      break;
    case keyCodes.DOWN_ARROW:
    case keyCodes.RIGHT_ARROW:
      e.preventDefault();
      this._focusNextTab(focusedTabIndex);
      break;
    case keyCodes.SPACE:
    case keyCodes.ENTER:
      // timeout to avoid a "digest already in progress" console error
      this._$timeout(function() {
        focusedTab.getButtonEl().click();
      });
      break;
    case keyCodes.HOME:
      e.preventDefault();
      this._focusFirstTab();
      break;
    case keyCodes.END:
      e.preventDefault();
      this._focusLastTab();
      break;
  }
};

/**
 * @ngdoc directive
 * @name mdNavItem
 * @module material.components.navBar
 *
 * @restrict E
 *
 * @description
 * `<md-nav-item>` describes a page navigation link within the `<md-nav-bar>` component.
 * It renders an `<md-button>` as the actual link.
 *
 * Exactly one of the `md-nav-click`, `md-nav-href`, or `md-nav-sref` attributes are required
 * to be specified.
 *
 * @param {string=} nav-item-aria-label Allows setting or overriding the label that is announced by
 *     a screen reader for the nav item's button. If this is not set, the nav item's transcluded
 *     content will be announced. Make sure to set this if the nav item's transcluded content does
 *     not include descriptive text, for example only an icon.
 * @param {expression=} md-nav-click Expression which will be evaluated when the
 *     link is clicked to change the page. Renders as an `ng-click`.
 * @param {string=} md-nav-href url to transition to when this link is clicked.
 *     Renders as an `ng-href`.
 * @param {string=} md-nav-sref UI-Router state to transition to when this link is
 *     clicked. Renders as a `ui-sref`.
 * @param {string} name The name of this link. Used by the nav bar to know
 *     which link is currently selected.
 * @param {!object=} sref-opts UI-Router options that are passed to the `$state.go()` function. See
 *     the <a ng-href="https://ui-router.github.io/docs/latest/interfaces/transition.transitionoptions.html"
 *     target="_blank">UI-Router documentation for details</a>.
 *
 * @usage
 * See <a ng-href="api/directive/mdNavBar">md-nav-bar</a> for usage.
 */
/**
 * @param $mdAria
 * @param $$rAF
 * @param $mdUtil
 * @param $window
 * @constructor
 * @ngInject
 */
function MdNavItem($mdAria, $$rAF, $mdUtil, $window) {
  return {
    restrict: 'E',
    require: ['mdNavItem', '^mdNavBar'],
    controller: MdNavItemController,
    bindToController: true,
    controllerAs: 'ctrl',
    replace: true,
    transclude: true,
    template: function(tElement, tAttrs) {
      var hasNavClick = tAttrs.mdNavClick;
      var hasNavHref = tAttrs.mdNavHref;
      var hasNavSref = tAttrs.mdNavSref;
      var hasSrefOpts = tAttrs.srefOpts;
      var navigationAttribute;
      var navigationOptions;
      var buttonTemplate;

      // Cannot specify more than one nav attribute
      if ((hasNavClick ? 1 : 0) + (hasNavHref ? 1 : 0) + (hasNavSref ? 1 : 0) > 1) {
        throw Error(
          'Please do not specify more than one of the md-nav-click, md-nav-href, ' +
          'or md-nav-sref attributes per nav-item directive.'
        );
      }

      if (hasNavClick !== undefined && hasNavClick !== null) {
        navigationAttribute = 'ng-click="ctrl.mdNavClick()"';
      } else if (hasNavHref !== undefined && hasNavHref !== null) {
        navigationAttribute = 'ng-href="{{ctrl.mdNavHref}}"';
      } else if (hasNavSref !== undefined && hasNavSref !== null) {
        navigationAttribute = 'ui-sref="{{ctrl.mdNavSref}}"';
      } else {
        throw Error(
          'Please specify at least one of the md-nav-click, md-nav-href, or md-nav-sref ' +
          'attributes per nav-item directive.');
      }

      navigationOptions = hasSrefOpts ? 'ui-sref-opts="{{ctrl.srefOpts}}" ' : '';

      if (navigationAttribute) {
        buttonTemplate = '' +
          '<md-button class="_md-nav-button md-accent" ' +
            'ng-class="ctrl.getNgClassMap()" ' +
            'ng-blur="ctrl.setFocused(false)" ' +
            'ng-disabled="ctrl.disabled" ' +
            'tabindex="-1" ' +
            'role="tab" ' +
            'ng-attr-aria-label="{{ctrl.navItemAriaLabel ? ctrl.navItemAriaLabel : undefined}}" ' +
            'aria-selected="{{ctrl.isSelected()}}" ' +
            navigationOptions +
            navigationAttribute + '>' +
            '<span ng-transclude class="_md-nav-button-text"></span>' +
          '</md-button>';
      }

      return '' +
        '<li class="md-nav-item" ' +
          'role="presentation">' +
          (buttonTemplate || '') +
        '</li>';
    },
    scope: {
      'mdNavClick': '&?',
      'mdNavHref': '@?',
      'mdNavSref': '@?',
      'srefOpts': '=?',
      'name': '@',
      'navItemAriaLabel': '@?',
    },
    link: function(scope, element, attrs, controllers) {
      var disconnect;
      var mdNavItem;
      var mdNavBar;
      var navButton;

      // When accessing the element's contents synchronously, they
      // may not be defined yet because of transclusion. There is a higher
      // chance that it will be accessible if we wait one frame.
      $$rAF(function() {
        mdNavItem = controllers[0];
        mdNavBar = controllers[1];
        navButton = angular.element(element[0].querySelector('._md-nav-button'));

        if (!mdNavItem.name) {
          mdNavItem.name = angular.element(element[0]
              .querySelector('._md-nav-button-text')).text().trim();
        }

        navButton.on('keydown', function($event) {
          mdNavBar.onKeydown($event);
        });

        navButton.on('focus', function() {
          if (!mdNavBar.getFocusedTab()) {
            mdNavBar.onFocus();
          }
        });

        navButton.on('click', function() {
          // This triggers a watcher on mdNavBar.mdSelectedNavItem which calls
          // MdNavBarController._updateTabs() after a $timeout. That function calls
          // MdNavItemController.setSelected() for the old tab with false and the new tab with true.
          mdNavBar.mdSelectedNavItem = mdNavItem.name;
          scope.$apply();
        });

        // Get the disabled attribute value first, then setup observing of value changes
        mdNavItem.disabled = $mdUtil.parseAttributeBoolean(attrs['disabled'], false);
        if ('MutationObserver' in $window) {
          var config = {attributes: true, attributeFilter: ['disabled']};
          var targetNode = element[0];
          var mutationCallback = function(mutationList) {
            $mdUtil.nextTick(function() {
              mdNavItem.disabled = $mdUtil.parseAttributeBoolean(attrs[mutationList[0].attributeName], false);
            });
          };
          var observer = new MutationObserver(mutationCallback);
          observer.observe(targetNode, config);
          disconnect = observer.disconnect.bind(observer);
        } else {
          attrs.$observe('disabled', function (value) {
            mdNavItem.disabled = $mdUtil.parseAttributeBoolean(value, false);
          });
        }

        if (!mdNavItem.navItemAriaLabel) {
          $mdAria.expectWithText(navButton, 'aria-label');
        }
      });

      scope.$on('destroy', function() {
        navButton.off('keydown');
        navButton.off('focus');
        navButton.off('click');
        disconnect();
      });
    }
  };
}

/**
 * Controller for the nav-item component.
 * @param {!angular.JQLite} $element
 * @constructor
 * @final
 * @ngInject
 */
function MdNavItemController($element) {

  /** @private @const {!angular.JQLite} */
  this._$element = $element;

  // Data-bound variables

  /** @const {?Function} */
  this.mdNavClick;

  /** @const {?string} */
  this.mdNavHref;

  /** @const {?string} */
  this.mdNavSref;
  /** @const {?Object} */
  this.srefOpts;
  /** @const {?string} */
  this.name;

  /** @type {string} */
  this.navItemAriaLabel;

  // State variables
  /** @private {boolean} */
  this._selected = false;

  /** @private {boolean} */
  this._focused = false;
}

/**
 * Returns a map of class names and values for use by ng-class.
 * @return {!Object<string,boolean>}
 */
MdNavItemController.prototype.getNgClassMap = function() {
  return {
    'md-active': this._selected,
    'md-primary': this._selected,
    'md-unselected': !this._selected,
    'md-focused': this._focused,
  };
};

/**
 * Get the name attribute of the tab.
 * @return {string}
 */
MdNavItemController.prototype.getName = function() {
  return this.name;
};

/**
 * Get the button element associated with the tab.
 * @return {!Element}
 */
MdNavItemController.prototype.getButtonEl = function() {
  return this._$element[0].querySelector('._md-nav-button');
};

/**
 * Set the selected state of the tab and updates the tabindex.
 * This function is called for the oldTab and newTab when selection changes.
 * @param {boolean} isSelected true to select the tab, false to deselect the tab
 */
MdNavItemController.prototype.setSelected = function(isSelected) {
  this._selected = isSelected;
  if (isSelected) {
    // https://www.w3.org/TR/wai-aria-practices/examples/tabs/tabs-2/tabs.html suggests that we call
    // removeAttribute('tabindex') here, but that causes our unit tests to fail due to
    // document.activeElement staying set to the body instead of the focused nav button.
    this.getButtonEl().setAttribute('tabindex', '0');
  } else {
    this.getButtonEl().setAttribute('tabindex', '-1');
  }
};

/**
 * @return {boolean}
 */
MdNavItemController.prototype.isSelected = function() {
  return this._selected;
};

/**
 * Set the focused state of the tab.
 * @param {boolean} isFocused
 */
MdNavItemController.prototype.setFocused = function(isFocused) {
  this._focused = isFocused;

  if (isFocused) {
    this.getButtonEl().focus();
  }
};

/**
 * @return {boolean} true if the tab has focus, false if not.
 */
MdNavItemController.prototype.hasFocus = function() {
  return this._focused;
};

/**
 * @return {boolean} true if the tab is enabled, false if disabled.
 * @private
 */
MdNavItemController.prototype._isEnabled = function() {
  return !this._$element.attr('disabled');
};

})();
(function(){
"use strict";

/**
 * @ngdoc module
 * @name material.components.panel
 */
MdPanelService.$inject = ["presets", "$rootElement", "$rootScope", "$injector", "$window"];
angular
  .module('material.components.panel', [
    'material.core',
    'material.components.backdrop'
  ])
  .provider('$mdPanel', MdPanelProvider);


/*****************************************************************************
 *                            PUBLIC DOCUMENTATION                           *
 *****************************************************************************/


/**
 * @ngdoc service
 * @name $mdPanelProvider
 * @module material.components.panel
 *
 * @description
 * `$mdPanelProvider` allows users to create configuration presets that will be
 * stored within a cached presets object. When the configuration is needed, the
 * user can request the preset by passing it as the first parameter in the
 * `$mdPanel.create` or `$mdPanel.open` methods.
 *
 * @usage
 * <hljs lang="js">
 * (function(angular, undefined) {
 *   'use strict';
 *
 *   angular
 *       .module('demoApp', ['ngMaterial'])
 *       .config(DemoConfig)
 *       .controller('DemoCtrl', DemoCtrl)
 *       .controller('DemoMenuCtrl', DemoMenuCtrl);
 *
 *   function DemoConfig($mdPanelProvider) {
 *     $mdPanelProvider.definePreset('demoPreset', {
 *       attachTo: angular.element(document.body),
 *       controller: DemoMenuCtrl,
 *       controllerAs: 'ctrl',
 *       template: '' +
 *           '<div class="menu-panel" md-whiteframe="4">' +
 *           '  <div class="menu-content">' +
 *           '    <div class="menu-item" ng-repeat="item in ctrl.items">' +
 *           '      <button class="md-button">' +
 *           '        <span>{{item}}</span>' +
 *           '      </button>' +
 *           '    </div>' +
 *           '    <md-divider></md-divider>' +
 *           '    <div class="menu-item">' +
 *           '      <button class="md-button" ng-click="ctrl.closeMenu()">' +
 *           '        <span>Close Menu</span>' +
 *           '      </button>' +
 *           '    </div>' +
 *           '  </div>' +
 *           '</div>',
 *       panelClass: 'menu-panel-container',
 *       focusOnOpen: false,
 *       zIndex: 100,
 *       propagateContainerEvents: true,
 *       groupName: 'menus'
 *     });
 *   }
 *
 *   function PanelProviderCtrl($mdPanel) {
 *     this.navigation = {
 *       name: 'navigation',
 *       items: [
 *         'Home',
 *         'About',
 *         'Contact'
 *       ]
 *     };
 *     this.favorites = {
 *       name: 'favorites',
 *       items: [
 *         'Add to Favorites'
 *       ]
 *     };
 *     this.more = {
 *       name: 'more',
 *       items: [
 *         'Account',
 *         'Sign Out'
 *       ]
 *     };
 *
 *     $mdPanel.newPanelGroup('menus', {
 *       maxOpen: 2
 *     });
 *
 *     this.showMenu = function($event, menu) {
 *       $mdPanel.open('demoPreset', {
 *         id: 'menu_' + menu.name,
 *         position: $mdPanel.newPanelPosition()
 *             .relativeTo($event.target)
 *             .addPanelPosition(
 *               $mdPanel.xPosition.ALIGN_START,
 *               $mdPanel.yPosition.BELOW
 *             ),
 *         locals: {
 *           items: menu.items
 *         },
 *         openFrom: $event
 *       });
 *     };
 *   }
 *
 *   function PanelMenuCtrl(mdPanelRef) {
 *     // 'mdPanelRef' is injected in the controller.
 *     this.closeMenu = function() {
 *       if (mdPanelRef) {
 *         mdPanelRef.close();
 *       }
 *     };
 *   }
 * })(angular);
 * </hljs>
 */

/**
 * @ngdoc method
 * @name $mdPanelProvider#definePreset
 * @description
 * Takes the passed in preset name and preset configuration object and adds it
 * to the `_presets` object of the provider. This `_presets` object is then
 * passed along to the `$mdPanel` service.
 *
 * @param {string} name Preset name.
 * @param {!Object} preset Specific configuration object that can contain any
 *     and all of the parameters avaialble within the `$mdPanel.create` method.
 *     However, parameters that pertain to id, position, animation, and user
 *     interaction are not allowed and will be removed from the preset
 *     configuration.
 */


/*****************************************************************************
 *                               MdPanel Service                             *
 *****************************************************************************/


/**
 * @ngdoc service
 * @name $mdPanel
 * @module material.components.panel
 *
 * @description
 * `$mdPanel` is a robust, low-level service for creating floating panels on
 * the screen. It can be used to implement tooltips, dialogs, pop-ups, etc.
 *
 * The following types, referenced below, have separate documentation:
 * - <a href="api/type/MdPanelAnimation">MdPanelAnimation</a> from `$mdPanel.newPanelAnimation()`
 * - <a href="api/type/MdPanelPosition">MdPanelPosition</a> from `$mdPanel.newPanelPosition()`
 * - <a href="api/type/MdPanelRef">MdPanelRef</a> from the `$mdPanel.open()` Promise or
 * injected in the panel's controller
 *
 * @usage
 * <hljs lang="js">
 * (function(angular, undefined) {
 *   'use strict';
 *
 *   angular
 *       .module('demoApp', ['ngMaterial'])
 *       .controller('DemoDialogController', DialogController)
 *       .controller('DemoCtrl', function($mdPanel) {
 *
 *     var panelRef;
 *
 *     function showPanel($event) {
 *       var panelPosition = $mdPanel.newPanelPosition()
 *           .absolute()
 *           .top('50%')
 *           .left('50%');
 *
 *       var panelAnimation = $mdPanel.newPanelAnimation()
 *           .openFrom($event)
 *           .duration(200)
 *           .closeTo('.show-button')
 *           .withAnimation($mdPanel.animation.SCALE);
 *
 *       var config = {
 *         attachTo: angular.element(document.body),
 *         controller: DialogController,
 *         controllerAs: 'ctrl',
 *         position: panelPosition,
 *         animation: panelAnimation,
 *         targetEvent: $event,
 *         templateUrl: 'dialog-template.html',
 *         clickOutsideToClose: true,
 *         escapeToClose: true,
 *         focusOnOpen: true
 *       };
 *
 *       $mdPanel.open(config)
 *           .then(function(result) {
 *             panelRef = result;
 *           });
 *     }
 *   }
 *
 *   function DialogController(MdPanelRef) {
 *     function closeDialog() {
 *       if (MdPanelRef) MdPanelRef.close();
 *     }
 *   }
 * })(angular);
 * </hljs>
 */

/**
 * @ngdoc method
 * @name $mdPanel#create
 * @description
 * Creates a panel with the specified options.
 *
 * @param config {!Object=} Specific configuration object that may contain the
 *     following properties:
 *
 *   - `id` - `{string=}`: An ID to track the panel by. When an ID is provided,
 *     the created panel is added to a tracked panels object. Any subsequent
 *     requests made to create a panel with that ID are ignored. This is useful
 *     in having the panel service not open multiple panels from the same user
 *     interaction when there is no backdrop and events are propagated. Defaults
 *     to an arbitrary string that is not tracked.
 *   - `template` - `{string=}`: HTML template to show in the panel. This
 *     **must** be trusted HTML with respect to AngularJS’s
 *     [$sce service](https://docs.angularjs.org/api/ng/service/$sce).
 *   - `templateUrl` - `{string=}`: The URL that will be used as the content of
 *     the panel.
 *   - `contentElement` - `{(string|!angular.JQLite|!Element)=}`: Pre-compiled
 *     element to be used as the panel's content.
 *   - `controller` - `{(function|string)=}`: The controller to associate with
 *     the panel. The controller can inject a reference to the returned
 *     panelRef, which allows the panel to be closed, hidden, and shown. Any
 *     fields passed in through locals or resolve will be bound to the
 *     controller.
 *   - `controllerAs` - `{string=}`: An alias to assign the controller to on
 *     the scope.
 *   - `bindToController` - `{boolean=}`: Binds locals to the controller
 *     instead of passing them in. Defaults to true, as this is a best
 *     practice.
 *   - `locals` - `{Object=}`: An object containing key/value pairs. The keys
 *     will be used as names of values to inject into the controller. For
 *     example, `locals: {three: 3}` would inject `three` into the controller,
 *     with the value 3. 'mdPanelRef' is a reserved key, and will always
 *     be set to the created MdPanelRef instance.
 *   - `resolve` - `{Object=}`: Similar to locals, except it takes promises as
 *     values. The panel will not open until all of the promises resolve.
 *   - `attachTo` - `{(string|!angular.JQLite|!Element)=}`: The element to
 *     attach the panel to. Defaults to appending to the root element of the
 *     application.
 *   - `propagateContainerEvents` - `{boolean=}`: Whether pointer or touch
 *     events should be allowed to propagate 'go through' the container, aka the
 *     wrapper, of the panel. Defaults to false.
 *   - `panelClass` - `{string=}`: A css class to apply to the panel element.
 *     This class should define any borders, box-shadow, etc. for the panel.
 *   - `zIndex` - `{number=}`: The z-index to place the panel at.
 *     Defaults to 80.
 *   - `position` - `{MdPanelPosition=}`: An MdPanelPosition object that
 *     specifies the alignment of the panel. For more information, see
 *     `MdPanelPosition`.
 *   - `clickOutsideToClose` - `{boolean=}`: Whether the user can click
 *     outside the panel to close it. Defaults to false.
 *   - `escapeToClose` - `{boolean=}`: Whether the user can press escape to
 *     close the panel. Defaults to false.
 *   - `onCloseSuccess` - `{function(!panelRef, string)=}`: Function that is
 *     called after the close successfully finishes. The first parameter passed
 *     into this function is the current panelRef and the 2nd is an optional
 *     string explaining the close reason. The currently supported closeReasons
 *     can be found in the MdPanelRef.closeReasons enum. These are by default
 *     passed along by the panel.
 *   - `trapFocus` - `{boolean=}`: Whether focus should be trapped within the
 *     panel. If `trapFocus` is true, the user will not be able to interact
 *     with the rest of the page until the panel is dismissed. Defaults to
 *     false.
 *   - `focusOnOpen` - `{boolean=}`: An option to override focus behavior on
 *     open. Only disable if focusing some other way, as focus management is
 *     required for panels to be accessible. Defaults to true.
 *   - `fullscreen` - `{boolean=}`: Whether the panel should be full screen.
 *     Applies the class `._md-panel-fullscreen` to the panel on open. Defaults
 *     to false.
 *   - `animation` - `{MdPanelAnimation=}`: An MdPanelAnimation object that
 *     specifies the animation of the panel. For more information, see
 *     `MdPanelAnimation`.
 *   - `hasBackdrop` - `{boolean=}`: Whether there should be an opaque backdrop
 *     behind the panel. Defaults to false.
 *   - `disableParentScroll` - `{boolean=}`: Whether the user can scroll the
 *     page behind the panel. Defaults to false.
 *   - `onDomAdded` - `{function=}`: Callback function used to announce when
 *     the panel is added to the DOM.
 *   - `onOpenComplete` - `{function=}`: Callback function used to announce
 *     when the open() action is finished.
 *   - `onRemoving` - `{function=}`: Callback function used to announce the
 *     close/hide() action is starting.
 *   - `onDomRemoved` - `{function=}`: Callback function used to announce when
 *     the panel is removed from the DOM.
 *   - `origin` - `{(string|!angular.JQLite|!Element)=}`: The element to focus
 *     on when the panel closes. This is commonly the element which triggered
 *     the opening of the panel. If you do not use `origin`, you need to control
 *     the focus manually.
 *   - `groupName` - `{(string|!Array<string>)=}`: A group name or an array of
 *     group names. The group name is used for creating a group of panels. The
 *     group is used for configuring the number of open panels and identifying
 *     specific behaviors for groups. For instance, all tooltips could be
 *     identified using the same groupName.
 *
 * @returns {!MdPanelRef} panelRef
 */

/**
 * @ngdoc method
 * @name $mdPanel#open
 * @description
 * Calls the create method above, then opens the panel. This is a shortcut for
 * creating and then calling open manually. If custom methods need to be
 * called when the panel is added to the DOM or opened, do not use this method.
 * Instead create the panel, chain promises on the domAdded and openComplete
 * methods, and call open from the returned panelRef.
 *
 * @param {!Object=} config Specific configuration object that may contain
 *     the properties defined in `$mdPanel.create`.
 * @returns {!angular.$q.Promise<!MdPanelRef>} panelRef A promise that resolves
 *     to an instance of the panel.
 */

/**
 * @ngdoc method
 * @name $mdPanel#newPanelPosition
 * @description
 * Returns a new instance of the MdPanelPosition object. Use this to create
 * the position config object.
 *
 * @returns {!MdPanelPosition} panelPosition
 */

/**
 * @ngdoc method
 * @name $mdPanel#newPanelAnimation
 * @description
 * Returns a new instance of the MdPanelAnimation object. Use this to create
 * the animation config object.
 *
 * @returns {!MdPanelAnimation} panelAnimation
 */

/**
 * @ngdoc method
 * @name $mdPanel#newPanelGroup
 * @description
 * Creates a panel group and adds it to a tracked list of panel groups.
 *
 * @param {string} groupName Name of the group to create.
 * @param {!Object=} config Specific configuration object that may contain the
 *     following properties:
 *
 *   - `maxOpen` - `{number=}`: The maximum number of panels that are allowed to
 *     be open within a defined panel group.
 *
 * @returns {!Object<string,
 *     {panels: !Array<!MdPanelRef>,
 *     openPanels: !Array<!MdPanelRef>,
 *     maxOpen: number}>} panelGroup
 */

/**
 * @ngdoc method
 * @name $mdPanel#setGroupMaxOpen
 * @description
 * Sets the maximum number of panels in a group that can be opened at a given
 * time.
 *
 * @param {string} groupName The name of the group to configure.
 * @param {number} maxOpen The maximum number of panels that can be
 *     opened. Infinity can be passed in to remove the maxOpen limit.
 */


/*****************************************************************************
 *                                 MdPanelRef                                *
 *****************************************************************************/


/**
 * @ngdoc type
 * @name MdPanelRef
 * @module material.components.panel
 * @description
 * A reference to a created panel. This reference contains a unique id for the
 * panel, along with the following properties:
 *
 *   - `id` - `{string}`: The unique id for the panel. This id is used to track
 *     when a panel was interacted with.
 *   - `config` - `{!Object=}`: The entire config object that was used in
 *     create.
 *   - `isAttached` - `{boolean}`: Whether the panel is attached to the DOM.
 *     Visibility to the user does not factor into isAttached.
 *   - `panelContainer` - `{angular.JQLite}`: The wrapper element containing the
 *     panel. This property is added in order to have access to the `addClass`,
 *     `removeClass`, `toggleClass`, etc methods.
 *   - `panelEl` - `{angular.JQLite}`: The panel element. This property is added
 *     in order to have access to the `addClass`, `removeClass`, `toggleClass`,
 *     etc methods.
 */

/**
 * @ngdoc method
 * @name MdPanelRef#open
 * @description
 * Attaches and shows the panel.
 *
 * @returns {!angular.$q.Promise} A promise that is resolved when the panel is
 *     opened.
 */

/**
 * @ngdoc method
 * @name MdPanelRef#close
 * @description
 * Hides and detaches the panel. Note that this will **not** destroy the panel.
 * If you don't intend on using the panel again, call the {@link #destroy
 * destroy} method afterwards.
 *
 * @returns {!angular.$q.Promise} A promise that is resolved when the panel is
 *     closed.
 */

/**
 * @ngdoc method
 * @name MdPanelRef#attach
 * @description
 * Create the panel elements and attach them to the DOM. The panel will be
 * hidden by default.
 *
 * @returns {!angular.$q.Promise} A promise that is resolved when the panel is
 *     attached.
 */

/**
 * @ngdoc method
 * @name MdPanelRef#detach
 * @description
 * Removes the panel from the DOM. This will NOT hide the panel before removing
 * it.
 *
 * @returns {!angular.$q.Promise} A promise that is resolved when the panel is
 *     detached.
 */

/**
 * @ngdoc method
 * @name MdPanelRef#show
 * @description
 * Shows the panel.
 *
 * @returns {!angular.$q.Promise} A promise that is resolved when the panel has
 *     shown and animations are completed.
 */

/**
 * @ngdoc method
 * @name MdPanelRef#hide
 * @description
 * Hides the panel.
 *
 * @returns {!angular.$q.Promise} A promise that is resolved when the panel has
 *     hidden and animations are completed.
 */

/**
 * @ngdoc method
 * @name MdPanelRef#destroy
 * @description
 * Destroys the panel. The panel cannot be opened again after this is called.
 */

/**
 * @ngdoc method
 * @name MdPanelRef#addClass
 * @deprecated
 * This method is in the process of being deprecated in favor of using the panel
 * and container JQLite elements that are referenced in the MdPanelRef object.
 * Full deprecation is scheduled for material 1.2.
 * @description
 * Adds a class to the panel. DO NOT use this hide/show the panel.
 *
 * @param {string} newClass class to be added.
 * @param {boolean} toElement Whether or not to add the class to the panel
 *     element instead of the container.
 */

/**
 * @ngdoc method
 * @name MdPanelRef#removeClass
 * @deprecated
 * This method is in the process of being deprecated in favor of using the panel
 * and container JQLite elements that are referenced in the MdPanelRef object.
 * Full deprecation is scheduled for material 1.2.
 * @description
 * Removes a class from the panel. DO NOT use this to hide/show the panel.
 *
 * @param {string} oldClass Class to be removed.
 * @param {boolean} fromElement Whether or not to remove the class from the
 *     panel element instead of the container.
 */

/**
 * @ngdoc method
 * @name MdPanelRef#toggleClass
 * @deprecated
 * This method is in the process of being deprecated in favor of using the panel
 * and container JQLite elements that are referenced in the MdPanelRef object.
 * Full deprecation is scheduled for material 1.2.
 * @description
 * Toggles a class on the panel. DO NOT use this to hide/show the panel.
 *
 * @param {string} toggleClass Class to be toggled.
 * @param {boolean} onElement Whether or not to remove the class from the panel
 *     element instead of the container.
 */

/**
 * @ngdoc method
 * @name MdPanelRef#updatePosition
 * @description
 * Updates the position configuration of a panel. Use this to update the
 * position of a panel that is open, without having to close and re-open the
 * panel.
 *
 * @param {!MdPanelPosition} position
 */

/**
 * @ngdoc method
 * @name MdPanelRef#addToGroup
 * @description
 * Adds a panel to a group if the panel does not exist within the group already.
 * A panel can only exist within a single group.
 *
 * @param {string} groupName The name of the group to add the panel to.
 */

/**
 * @ngdoc method
 * @name MdPanelRef#removeFromGroup
 * @description
 * Removes a panel from a group if the panel exists within that group. The group
 * must be created ahead of time.
 *
 * @param {string} groupName The name of the group.
 */

/**
 * @ngdoc method
 * @name MdPanelRef#registerInterceptor
 * @description
 * Registers an interceptor with the panel. The callback should return a promise,
 * which will allow the action to continue when it gets resolved, or will
 * prevent an action if it is rejected. The interceptors are called sequentially
 * and it reverse order. `type` must be one of the following
 * values available on `$mdPanel.interceptorTypes`:
 * * `CLOSE` - Gets called before the panel begins closing.
 *
 * @param {string} type Type of interceptor.
 * @param {!angular.$q.Promise<any>} callback Callback to be registered.
 * @returns {!MdPanelRef}
 */

/**
 * @ngdoc method
 * @name MdPanelRef#removeInterceptor
 * @description
 * Removes a registered interceptor.
 *
 * @param {string} type Type of interceptor to be removed.
 * @param {function(): !angular.$q.Promise<any>} callback Interceptor to be removed.
 * @returns {!MdPanelRef}
 */

/**
 * @ngdoc method
 * @name MdPanelRef#removeAllInterceptors
 * @description
 * Removes all interceptors. If a type is supplied, only the
 * interceptors of that type will be cleared.
 *
 * @param {string=} type Type of interceptors to be removed.
 * @returns {!MdPanelRef}
 */

/**
 * @ngdoc method
 * @name MdPanelRef#updateAnimation
 * @description
 * Updates the animation configuration for a panel. You can use this to change
 * the panel's animation without having to re-create it.
 *
 * @param {!MdPanelAnimation} animation
 */


/*****************************************************************************
 *                               MdPanelPosition                            *
 *****************************************************************************/


/**
 * @ngdoc type
 * @name MdPanelPosition
 * @module material.components.panel
 * @description
 *
 * Object for configuring the position of the panel.
 *
 * @usage
 *
 * #### Centering the panel
 *
 * <hljs lang="js">
 * new MdPanelPosition().absolute().center();
 * </hljs>
 *
 * #### Overlapping the panel with an element
 *
 * <hljs lang="js">
 * new MdPanelPosition()
 *     .relativeTo(someElement)
 *     .addPanelPosition(
 *       $mdPanel.xPosition.ALIGN_START,
 *       $mdPanel.yPosition.ALIGN_TOPS
 *     );
 * </hljs>
 *
 * #### Aligning the panel with the bottom of an element
 *
 * <hljs lang="js">
 * new MdPanelPosition()
 *     .relativeTo(someElement)
 *     .addPanelPosition($mdPanel.xPosition.CENTER, $mdPanel.yPosition.BELOW);
 * </hljs>
 */

/**
 * @ngdoc method
 * @name MdPanelPosition#absolute
 * @description
 * Positions the panel absolutely relative to the parent element. If the parent
 * is document.body, this is equivalent to positioning the panel absolutely
 * within the viewport.
 *
 * @returns {!MdPanelPosition}
 */

/**
 * @ngdoc method
 * @name MdPanelPosition#relativeTo
 * @description
 * Positions the panel relative to a specific element.
 *
 * @param {string|!Element|!angular.JQLite} element Query selector, DOM element,
 *     or angular element to position the panel with respect to.
 * @returns {!MdPanelPosition}
 */

/**
 * @ngdoc method
 * @name MdPanelPosition#top
 * @description
 * Sets the value of `top` for the panel. Clears any previously set vertical
 * position.
 *
 * @param {string=} top Value of `top`. Defaults to '0'.
 * @returns {!MdPanelPosition}
 */

/**
 * @ngdoc method
 * @name MdPanelPosition#bottom
 * @description
 * Sets the value of `bottom` for the panel. Clears any previously set vertical
 * position.
 *
 * @param {string=} bottom Value of `bottom`. Defaults to '0'.
 * @returns {!MdPanelPosition}
 */

/**
 * @ngdoc method
 * @name MdPanelPosition#start
 * @description
 * Sets the panel to the start of the page - `left` if `ltr` or `right` for
 * `rtl`. Clears any previously set horizontal position.
 *
 * @param {string=} start Value of position. Defaults to '0'.
 * @returns {!MdPanelPosition}
 */

/**
 * @ngdoc method
 * @name MdPanelPosition#end
 * @description
 * Sets the panel to the end of the page - `right` if `ltr` or `left` for `rtl`.
 * Clears any previously set horizontal position.
 *
 * @param {string=} end Value of position. Defaults to '0'.
 * @returns {!MdPanelPosition}
 */

/**
 * @ngdoc method
 * @name MdPanelPosition#left
 * @description
 * Sets the value of `left` for the panel. Clears any previously set
 * horizontal position.
 *
 * @param {string=} left Value of `left`. Defaults to '0'.
 * @returns {!MdPanelPosition}
 */

/**
 * @ngdoc method
 * @name MdPanelPosition#right
 * @description
 * Sets the value of `right` for the panel. Clears any previously set
 * horizontal position.
 *
 * @param {string=} right Value of `right`. Defaults to '0'.
 * @returns {!MdPanelPosition}
 */

/**
 * @ngdoc method
 * @name MdPanelPosition#centerHorizontally
 * @description
 * Centers the panel horizontally in the viewport. Clears any previously set
 * horizontal position.
 *
 * @returns {!MdPanelPosition}
 */

/**
 * @ngdoc method
 * @name MdPanelPosition#centerVertically
 * @description
 * Centers the panel vertically in the viewport. Clears any previously set
 * vertical position.
 *
 * @returns {!MdPanelPosition}
 */

/**
 * @ngdoc method
 * @name MdPanelPosition#center
 * @description
 * Centers the panel horizontally and vertically in the viewport. This is
 * equivalent to calling both `centerHorizontally` and `centerVertically`.
 * Clears any previously set horizontal and vertical positions.
 *
 * @returns {!MdPanelPosition}
 */

/**
 * @ngdoc method
 * @name MdPanelPosition#addPanelPosition
 * @description
 * Sets the x and y position for the panel relative to another element. Can be
 * called multiple times to specify an ordered list of panel positions. The
 * first position which allows the panel to be completely on-screen will be
 * chosen; the last position will be chose whether it is on-screen or not.
 *
 * xPosition must be one of the following values available on
 * $mdPanel.xPosition:
 *
 *
 * CENTER | ALIGN_START | ALIGN_END | OFFSET_START | OFFSET_END
 *
 * <pre>
 *    *************
 *    *           *
 *    *   PANEL   *
 *    *           *
 *    *************
 *   A B    C    D E
 *
 * A: OFFSET_START (for LTR displays)
 * B: ALIGN_START (for LTR displays)
 * C: CENTER
 * D: ALIGN_END (for LTR displays)
 * E: OFFSET_END (for LTR displays)
 * </pre>
 *
 * yPosition must be one of the following values available on
 * $mdPanel.yPosition:
 *
 * CENTER | ALIGN_TOPS | ALIGN_BOTTOMS | ABOVE | BELOW
 *
 * <pre>
 *   F
 *   G *************
 *     *           *
 *   H *   PANEL   *
 *     *           *
 *   I *************
 *   J
 *
 * F: BELOW
 * G: ALIGN_TOPS
 * H: CENTER
 * I: ALIGN_BOTTOMS
 * J: ABOVE
 * </pre>
 *
 * @param {string} xPosition
 * @param {string} yPosition
 * @returns {!MdPanelPosition}
 */

/**
 * @ngdoc method
 * @name MdPanelPosition#withOffsetX
 * @description
 * Sets the value of the offset in the x-direction.
 *
 * @param {string|number} offsetX
 * @returns {!MdPanelPosition}
 */

/**
 * @ngdoc method
 * @name MdPanelPosition#withOffsetY
 * @description
 * Sets the value of the offset in the y-direction.
 *
 * @param {string|number} offsetY
 * @returns {!MdPanelPosition}
 */


/*****************************************************************************
 *                               MdPanelAnimation                            *
 *****************************************************************************/


/**
 * @ngdoc type
 * @name MdPanelAnimation
 * @module material.components.panel
 * @description
 * Animation configuration object. To use, create an MdPanelAnimation with the
 * desired properties, then pass the object as part of $mdPanel creation.
 *
 * @usage
 *
 * <hljs lang="js">
 * var panelAnimation = new MdPanelAnimation()
 *     .openFrom(myButtonEl)
 *     .duration(1337)
 *     .closeTo('.my-button')
 *     .withAnimation($mdPanel.animation.SCALE);
 *
 * $mdPanel.create({
 *   animation: panelAnimation
 * });
 * </hljs>
 */

/**
 * @ngdoc method
 * @name MdPanelAnimation#openFrom
 * @description
 * Specifies where to start the open animation. `openFrom` accepts a
 * click event object, query selector, DOM element, or a Rect object that
 * is used to determine the bounds. When passed a click event, the location
 * of the click will be used as the position to start the animation.
 *
 * @param {string|!Element|!Event|{top: number, left: number}}
 * @returns {!MdPanelAnimation}
 */

/**
 * @ngdoc method
 * @name MdPanelAnimation#closeTo
 * @description
 * Specifies where to animate the panel close. `closeTo` accepts a
 * query selector, DOM element, or a Rect object that is used to determine
 * the bounds.
 *
 * @param {string|!Element|{top: number, left: number}}
 * @returns {!MdPanelAnimation}
 */

/**
 * @ngdoc method
 * @name MdPanelAnimation#withAnimation
 * @description
 * Specifies the animation class.
 *
 * There are several default animations that can be used: `$mdPanel.animation.`
 *  - `SLIDE`: The panel slides in and out from the specified
 *       elements. It will not fade in or out.
 *  - `SCALE`: The panel scales in and out. Slide and fade are
 *       included in this animation.
 *  - `FADE`: The panel fades in and out.
 *
 * Custom classes will by default fade in and out unless
 * `transition: opacity 1ms` is added to the to custom class.
 *
 * @param {string|{open: string, close: string}} cssClass
 * @returns {!MdPanelAnimation}
 */

/**
 * @ngdoc method
 * @name MdPanelAnimation#duration
 * @description
 * Specifies the duration of the animation in milliseconds. The `duration`
 * method accepts either a number or an object with separate open and close
 * durations.
 *
 * @param {number|{open: number, close: number}} duration
 * @returns {!MdPanelAnimation}
 */


/*****************************************************************************
 *                            PUBLIC DOCUMENTATION                           *
 *****************************************************************************/


var MD_PANEL_Z_INDEX = 80;
var MD_PANEL_HIDDEN = '_md-panel-hidden';
var FOCUS_TRAP_TEMPLATE = angular.element(
    '<div class="_md-panel-focus-trap" tabindex="0"></div>');

var _presets = {};


/**
 * A provider that is used for creating presets for the panel API.
 * @final @constructor @ngInject
 */
function MdPanelProvider() {
  return {
    'definePreset': definePreset,
    'getAllPresets': getAllPresets,
    'clearPresets': clearPresets,
    '$get': $getProvider()
  };
}


/**
 * Takes the passed in panel configuration object and adds it to the `_presets`
 * object at the specified name.
 * @param {string} name Name of the preset to set.
 * @param {!Object} preset Specific configuration object that can contain any
 *     and all of the parameters available within the `$mdPanel.create` method.
 *     However, parameters that pertain to id, position, animation, and user
 *     interaction are not allowed and will be removed from the preset
 *     configuration.
 */
function definePreset(name, preset) {
  if (!name || !preset) {
    throw new Error('mdPanelProvider: The panel preset definition is ' +
        'malformed. The name and preset object are required.');
  } else if (_presets.hasOwnProperty(name)) {
    throw new Error('mdPanelProvider: The panel preset you have requested ' +
        'has already been defined.');
  }

  // Delete any property on the preset that is not allowed.
  delete preset.id;
  delete preset.position;
  delete preset.animation;

  _presets[name] = preset;
}


/**
 * Gets a clone of the `_presets`.
 * @return {!Object}
 */
function getAllPresets() {
  return angular.copy(_presets);
}


/**
 * Clears all of the stored presets.
 */
function clearPresets() {
  _presets = {};
}


/**
 * Represents the `$get` method of the AngularJS provider. From here, a new
 * reference to the MdPanelService is returned where the needed arguments are
 * passed in including the MdPanelProvider `_presets`.
 * @param {!Object} _presets
 * @param {!angular.JQLite} $rootElement
 * @param {!angular.Scope} $rootScope
 * @param {!angular.$injector} $injector
 * @param {!angular.$window} $window
 */
function $getProvider() {
  return [
    '$rootElement', '$rootScope', '$injector', '$window',
    function($rootElement, $rootScope, $injector, $window) {
      return new MdPanelService(_presets, $rootElement, $rootScope,
          $injector, $window);
    }
  ];
}


/*****************************************************************************
 *                               MdPanel Service                             *
 *****************************************************************************/


/**
 * A service that is used for controlling/displaying panels on the screen.
 * @param {!Object} presets
 * @param {!angular.JQLite} $rootElement
 * @param {!angular.Scope} $rootScope
 * @param {!angular.$injector} $injector
 * @param {!angular.$window} $window
 * @final @constructor @ngInject
 */
function MdPanelService(presets, $rootElement, $rootScope, $injector, $window) {
  /**
   * Default config options for the panel.
   * Anything angular related needs to be done later. Therefore
   *     scope: $rootScope.$new(true),
   *     attachTo: $rootElement,
   * are added later.
   * @private {!Object}
   */
  this._defaultConfigOptions = {
    bindToController: true,
    clickOutsideToClose: false,
    disableParentScroll: false,
    escapeToClose: false,
    focusOnOpen: true,
    fullscreen: false,
    hasBackdrop: false,
    propagateContainerEvents: false,
    transformTemplate: angular.bind(this, this._wrapTemplate),
    trapFocus: false,
    zIndex: MD_PANEL_Z_INDEX
  };

  /** @private {!Object} */
  this._config = {};

  /** @private {!Object} */
  this._presets = presets;

  /** @private @const */
  this._$rootElement = $rootElement;

  /** @private @const */
  this._$rootScope = $rootScope;

  /** @private @const */
  this._$injector = $injector;

  /** @private @const */
  this._$window = $window;

  /** @private @const */
  this._$mdUtil = this._$injector.get('$mdUtil');

  /** @private {!Object<string, !MdPanelRef>} */
  this._trackedPanels = {};

  /**
   * @private {!Object<string,
   *     {panels: !Array<!MdPanelRef>,
   *     openPanels: !Array<!MdPanelRef>,
   *     maxOpen: number}>}
   */
  this._groups = Object.create(null);

  /**
   * Default animations that can be used within the panel.
   * @type {enum}
   */
  this.animation = MdPanelAnimation.animation;

  /**
   * Possible values of xPosition for positioning the panel relative to
   * another element.
   * @type {enum}
   */
  this.xPosition = MdPanelPosition.xPosition;

  /**
   * Possible values of yPosition for positioning the panel relative to
   * another element.
   * @type {enum}
   */
  this.yPosition = MdPanelPosition.yPosition;

  /**
   * Possible values for the interceptors that can be registered on a panel.
   * @type {enum}
   */
  this.interceptorTypes = MdPanelRef.interceptorTypes;

  /**
   * Possible values for closing of a panel.
   * @type {enum}
   */
  this.closeReasons = MdPanelRef.closeReasons;

  /**
   * Possible values of absolute position.
   * @type {enum}
   */
  this.absPosition = MdPanelPosition.absPosition;
}


/**
 * Creates a panel with the specified options.
 * @param {string=} preset Name of a preset configuration that can be used to
 *     extend the panel configuration.
 * @param {!Object=} config Configuration object for the panel.
 * @returns {!MdPanelRef}
 */
MdPanelService.prototype.create = function(preset, config) {
  if (typeof preset === 'string') {
    preset = this._getPresetByName(preset);
  } else if (typeof preset === 'object' &&
      (angular.isUndefined(config) || !config)) {
    config = preset;
    preset = {};
  }

  preset = preset || {};
  config = config || {};

  // If the passed-in config contains an ID and the ID is within _trackedPanels,
  // return the tracked panel after updating its config with the passed-in
  // config.
  if (angular.isDefined(config.id) && this._trackedPanels[config.id]) {
    var trackedPanel = this._trackedPanels[config.id];
    angular.extend(trackedPanel.config, config);
    return trackedPanel;
  }

  // Combine the passed-in config, the _defaultConfigOptions, and the preset
  // configuration into the `_config`.
  this._config = angular.extend({
    // If no ID is set within the passed-in config, then create an arbitrary ID.
    id: config.id || 'panel_' + this._$mdUtil.nextUid(),
    scope: this._$rootScope.$new(true),
    attachTo: this._$rootElement
  }, this._defaultConfigOptions, config, preset);

  // Create the panelRef and add it to the `_trackedPanels` object.
  var panelRef = new MdPanelRef(this._config, this._$injector);
  this._trackedPanels[this._config.id] = panelRef;

  // Add the panel to each of its requested groups.
  if (this._config.groupName) {
    if (angular.isString(this._config.groupName)) {
      this._config.groupName = [this._config.groupName];
    }
    angular.forEach(this._config.groupName, function(group) {
      panelRef.addToGroup(group);
    });
  }

  this._config.scope.$on('$destroy', angular.bind(panelRef, panelRef.detach));

  return panelRef;
};


/**
 * Creates and opens a panel with the specified options.
 * @param {string=} preset Name of a preset configuration that can be used to
 *     extend the panel configuration.
 * @param {!Object=} config Configuration object for the panel.
 * @returns {!angular.$q.Promise<!MdPanelRef>} The panel created from create.
 */
MdPanelService.prototype.open = function(preset, config) {
  var panelRef = this.create(preset, config);
  return panelRef.open().then(function() {
    return panelRef;
  });
};


/**
 * Gets a specific preset configuration object saved within `_presets`.
 * @param {string} preset Name of the preset to search for.
 * @returns {!Object} The preset configuration object.
 */
MdPanelService.prototype._getPresetByName = function(preset) {
  if (!this._presets[preset]) {
    throw new Error('mdPanel: The panel preset configuration that you ' +
        'requested does not exist. Use the $mdPanelProvider to create a ' +
        'preset before requesting one.');
  }
  return this._presets[preset];
};


/**
 * Returns a new instance of the MdPanelPosition. Use this to create the
 * positioning object.
 * @returns {!MdPanelPosition}
 */
MdPanelService.prototype.newPanelPosition = function() {
  return new MdPanelPosition(this._$injector);
};


/**
 * Returns a new instance of the MdPanelAnimation. Use this to create the
 * animation object.
 * @returns {!MdPanelAnimation}
 */
MdPanelService.prototype.newPanelAnimation = function() {
  return new MdPanelAnimation(this._$injector);
};


/**
 * Creates a panel group and adds it to a tracked list of panel groups.
 * @param groupName {string} Name of the group to create.
 * @param config {!Object=} Specific configuration object that may contain the
 *     following properties:
 *
 *   - `maxOpen` - `{number=}`: The maximum number of panels that are allowed
 *     open within a defined panel group.
 *
 * @returns {!Object<string,
 *     {panels: !Array<!MdPanelRef>,
 *     openPanels: !Array<!MdPanelRef>,
 *     maxOpen: number}>} panelGroup
 */
MdPanelService.prototype.newPanelGroup = function(groupName, config) {
  if (!this._groups[groupName]) {
    config = config || {};
    var group = {
      panels: [],
      openPanels: [],
      maxOpen: config.maxOpen > 0 ? config.maxOpen : Infinity
    };
    this._groups[groupName] = group;
  }
  return this._groups[groupName];
};


/**
 * Sets the maximum number of panels in a group that can be opened at a given
 * time.
 * @param {string} groupName The name of the group to configure.
 * @param {number} maxOpen The maximum number of panels that can be
 *     opened. Infinity can be passed in to remove the maxOpen limit.
 */
MdPanelService.prototype.setGroupMaxOpen = function(groupName, maxOpen) {
  if (this._groups[groupName]) {
    this._groups[groupName].maxOpen = maxOpen;
  } else {
    throw new Error('mdPanel: Group does not exist yet. Call newPanelGroup().');
  }
};


/**
 * Determines if the current number of open panels within a group exceeds the
 * limit of allowed open panels.
 * @param {string} groupName The name of the group to check.
 * @returns {boolean} true if open count does exceed maxOpen and false if not.
 * @private
 */
MdPanelService.prototype._openCountExceedsMaxOpen = function(groupName) {
  if (this._groups[groupName]) {
    var group = this._groups[groupName];
    return group.maxOpen > 0 && group.openPanels.length > group.maxOpen;
  }
  return false;
};


/**
 * Closes the first open panel within a specific group.
 * @param {string} groupName The name of the group.
 * @private
 */
MdPanelService.prototype._closeFirstOpenedPanel = function(groupName) {
  this._groups[groupName].openPanels[0].close();
};


/**
 * Wraps the users template in two elements, md-panel-outer-wrapper, which
 * covers the entire attachTo element, and md-panel, which contains only the
 * template. This allows the panel control over positioning, animations,
 * and similar properties.
 * @param {string} origTemplate The original template.
 * @returns {string} The wrapped template.
 * @private
 */
MdPanelService.prototype._wrapTemplate = function(origTemplate) {
  var template = origTemplate || '';

  // The panel should be initially rendered offscreen so we can calculate
  // height and width for positioning.
  return '' +
      '<div class="md-panel-outer-wrapper">' +
      '  <div class="md-panel _md-panel-offscreen">' + template + '</div>' +
      '</div>';
};


/**
 * Wraps a content element in a md-panel-outer wrapper and
 * positions it off-screen. Allows for proper control over positoning
 * and animations.
 * @param {!angular.JQLite} contentElement Element to be wrapped.
 * @return {!angular.JQLite} Wrapper element.
 * @private
 */
MdPanelService.prototype._wrapContentElement = function(contentElement) {
  var wrapper = angular.element('<div class="md-panel-outer-wrapper">');

  contentElement.addClass('md-panel _md-panel-offscreen');
  wrapper.append(contentElement);

  return wrapper;
};


/*****************************************************************************
 *                                 MdPanelRef                                *
 *****************************************************************************/


/**
 * A reference to a created panel. This reference contains a unique id for the
 * panel, along with properties/functions used to control the panel.
 * @param {!Object} config
 * @param {!angular.$injector} $injector
 * @final @constructor
 */
function MdPanelRef(config, $injector) {
  // Injected variables.
  /** @private @const {!angular.$q} */
  this._$q = $injector.get('$q');

  /** @private @const {!angular.$mdCompiler} */
  this._$mdCompiler = $injector.get('$mdCompiler');

  /** @private @const {!angular.$mdConstant} */
  this._$mdConstant = $injector.get('$mdConstant');

  /** @private @const {!angular.$mdUtil} */
  this._$mdUtil = $injector.get('$mdUtil');

  /** @private @const {!angular.$mdTheming} */
  this._$mdTheming = $injector.get('$mdTheming');

  /** @private @const {!angular.Scope} */
  this._$rootScope = $injector.get('$rootScope');

  /** @private @const {!angular.$animate} */
  this._$animate = $injector.get('$animate');

  /** @private @const {!MdPanelRef} */
  this._$mdPanel = $injector.get('$mdPanel');

  /** @private @const {!angular.$log} */
  this._$log = $injector.get('$log');

  /** @private @const {!angular.$window} */
  this._$window = $injector.get('$window');

  /** @private @const {!Function} */
  this._$$rAF = $injector.get('$$rAF');

  // Public variables.
  /**
   * Unique id for the panelRef.
   * @type {string}
   */
  this.id = config.id;

  /** @type {!Object} */
  this.config = config;

  /** @type {!angular.JQLite|undefined} */
  this.panelContainer;

  /** @type {!angular.JQLite|undefined} */
  this.panelEl;

  /**
   * Whether the panel is attached. This is synchronous. When attach is called,
   * isAttached is set to true. When detach is called, isAttached is set to
   * false.
   * @type {boolean}
   */
  this.isAttached = false;

  // Private variables.
  /** @private {Array<function()>} */
  this._removeListeners = [];

  /** @private {!angular.JQLite|undefined} */
  this._topFocusTrap;

  /** @private {!angular.JQLite|undefined} */
  this._bottomFocusTrap;

  /** @private {!$mdPanel|undefined} */
  this._backdropRef;

  /** @private {Function?} */
  this._restoreScroll = null;

  /**
   * Keeps track of all the panel interceptors.
   * @private {!Object}
   */
  this._interceptors = Object.create(null);

  /**
   * Cleanup function, provided by `$mdCompiler` and assigned after the element
   * has been compiled. When `contentElement` is used, the function is used to
   * restore the element to it's proper place in the DOM.
   * @private {!Function}
   */
  this._compilerCleanup = null;

  /**
   * Cache for saving and restoring element inline styles, CSS classes etc.
   * @type {{styles: string, classes: string}}
   */
  this._restoreCache = {
    styles: '',
    classes: ''
  };
}


MdPanelRef.interceptorTypes = {
  CLOSE: 'onClose'
};


/**
 * Opens an already created and configured panel. If the panel is already
 * visible, does nothing.
 * @returns {!angular.$q.Promise<!MdPanelRef>} A promise that is resolved when
 *     the panel is opened and animations finish.
 */
MdPanelRef.prototype.open = function() {
  var self = this;
  return this._$q(function(resolve, reject) {
    var done = self._done(resolve, self);
    var show = self._simpleBind(self.show, self);
    var checkGroupMaxOpen = function() {
      if (self.config.groupName) {
        angular.forEach(self.config.groupName, function(group) {
          if (self._$mdPanel._openCountExceedsMaxOpen(group)) {
            self._$mdPanel._closeFirstOpenedPanel(group);
          }
        });
      }
    };

    self.attach()
        .then(show)
        .then(checkGroupMaxOpen)
        .then(done)
        .catch(reject);
  });
};


/**
 * Closes the panel.
 * @param {string} closeReason The event type that triggered the close.
 * @returns {!angular.$q.Promise<!MdPanelRef>} A promise that is resolved when
 *     the panel is closed and animations finish.
 */
MdPanelRef.prototype.close = function(closeReason) {
  var self = this;

  return this._$q(function(resolve, reject) {
    self._callInterceptors(MdPanelRef.interceptorTypes.CLOSE).then(function() {
      var done = self._done(resolve, self);
      var detach = self._simpleBind(self.detach, self);
      var onCloseSuccess = self.config['onCloseSuccess'] || angular.noop;
      onCloseSuccess = angular.bind(self, onCloseSuccess, self, closeReason);

      self.hide()
          .then(detach)
          .then(done)
          .then(onCloseSuccess)
          .catch(reject);
    }, reject);
  });
};


/**
 * Attaches the panel. The panel will be hidden afterwards.
 * @returns {!angular.$q.Promise<!MdPanelRef>} A promise that is resolved when
 *     the panel is attached.
 */
MdPanelRef.prototype.attach = function() {
  if (this.isAttached && this.panelEl) {
    return this._$q.when(this);
  }

  var self = this;
  return this._$q(function(resolve, reject) {
    var done = self._done(resolve, self);
    var onDomAdded = self.config['onDomAdded'] || angular.noop;
    var addListeners = function(response) {
      self.isAttached = true;
      self._addEventListeners();
      return response;
    };

    self._$q.all([
        self._createBackdrop(),
        self._createPanel()
            .then(addListeners)
            .catch(reject)
    ]).then(onDomAdded)
      .then(done)
      .catch(reject);
  });
};


/**
 * Only detaches the panel. Will NOT hide the panel first.
 * @returns {!angular.$q.Promise<!MdPanelRef>} A promise that is resolved when
 *     the panel is detached.
 */
MdPanelRef.prototype.detach = function() {
  if (!this.isAttached) {
    return this._$q.when(this);
  }

  var self = this;
  var onDomRemoved = self.config['onDomRemoved'] || angular.noop;

  var detachFn = function() {
    self._removeEventListeners();

    // Remove the focus traps that we added earlier for keeping focus within
    // the panel.
    if (self._topFocusTrap && self._topFocusTrap.parentNode) {
      self._topFocusTrap.parentNode.removeChild(self._topFocusTrap);
    }

    if (self._bottomFocusTrap && self._bottomFocusTrap.parentNode) {
      self._bottomFocusTrap.parentNode.removeChild(self._bottomFocusTrap);
    }

    if (self._restoreCache.classes) {
      self.panelEl[0].className = self._restoreCache.classes;
    }

    // Either restore the saved styles or clear the ones set by mdPanel.
    self.panelEl[0].style.cssText = self._restoreCache.styles || '';

    self._compilerCleanup();
    self.panelContainer.remove();
    self.isAttached = false;
    return self._$q.when(self);
  };

  if (this._restoreScroll) {
    this._restoreScroll();
    this._restoreScroll = null;
  }

  return this._$q(function(resolve, reject) {
    var done = self._done(resolve, self);

    self._$q.all([
      detachFn(),
      self._backdropRef ? self._backdropRef.detach() : true
    ]).then(onDomRemoved)
      .then(done)
      .catch(reject);
  });
};


/**
 * Destroys the panel. The Panel cannot be opened again after this.
 */
MdPanelRef.prototype.destroy = function() {
  var self = this;
  if (this.config.groupName) {
    angular.forEach(this.config.groupName, function(group) {
      self.removeFromGroup(group);
    });
  }
  this.config.scope.$destroy();
  this.config.locals = null;
  this.config.onDomAdded = null;
  this.config.onDomRemoved = null;
  this.config.onRemoving = null;
  this.config.onOpenComplete = null;
  this._interceptors = null;
};


/**
 * Shows the panel.
 * @returns {!angular.$q.Promise<!MdPanelRef>} A promise that is resolved when
 *     the panel has shown and animations finish.
 */
MdPanelRef.prototype.show = function() {
  if (!this.panelContainer) {
    return this._$q(function(resolve, reject) {
      reject('mdPanel: Panel does not exist yet. Call open() or attach().');
    });
  }

  if (!this.panelContainer.hasClass(MD_PANEL_HIDDEN)) {
    return this._$q.when(this);
  }

  var self = this;
  var animatePromise = function() {
    self.panelContainer.removeClass(MD_PANEL_HIDDEN);
    return self._animateOpen();
  };

  return this._$q(function(resolve, reject) {
    var done = self._done(resolve, self);
    var onOpenComplete = self.config['onOpenComplete'] || angular.noop;
    var addToGroupOpen = function() {
      if (self.config.groupName) {
        angular.forEach(self.config.groupName, function(group) {
          self._$mdPanel._groups[group].openPanels.push(self);
        });
      }
    };

    self._$q.all([
      self._backdropRef ? self._backdropRef.show() : self,
      animatePromise().then(function() { self._focusOnOpen(); }, reject)
    ]).then(onOpenComplete)
      .then(addToGroupOpen)
      .then(done)
      .catch(reject);
  });
};


/**
 * Hides the panel.
 * @returns {!angular.$q.Promise<!MdPanelRef>} A promise that is resolved when
 *     the panel has hidden and animations finish.
 */
MdPanelRef.prototype.hide = function() {
  if (!this.panelContainer) {
    return this._$q(function(resolve, reject) {
      reject('mdPanel: Panel does not exist yet. Call open() or attach().');
    });
  }

  if (this.panelContainer.hasClass(MD_PANEL_HIDDEN)) {
    return this._$q.when(this);
  }

  var self = this;

  return this._$q(function(resolve, reject) {
    var done = self._done(resolve, self);
    var onRemoving = self.config['onRemoving'] || angular.noop;
    var hidePanel = function() {
      self.panelContainer.addClass(MD_PANEL_HIDDEN);
    };
    var removeFromGroupOpen = function() {
      if (self.config.groupName) {
        var group, index;
        angular.forEach(self.config.groupName, function(group) {
          group = self._$mdPanel._groups[group];
          index = group.openPanels.indexOf(self);
          if (index > -1) {
            group.openPanels.splice(index, 1);
          }
        });
      }
    };
    var focusOnOrigin = function() {
      var origin = self.config['origin'];
      if (origin) {
        getElement(origin).focus();
      }
    };

    self._$q.all([
      self._backdropRef ? self._backdropRef.hide() : self,
      self._animateClose()
          .then(onRemoving)
          .then(hidePanel)
          .then(removeFromGroupOpen)
          .then(focusOnOrigin)
          .catch(reject)
    ]).then(done, reject);
  });
};


/**
 * Add a class to the panel. DO NOT use this to hide/show the panel.
 * @deprecated
 * This method is in the process of being deprecated in favor of using the panel
 * and container JQLite elements that are referenced in the MdPanelRef object.
 * Full deprecation is scheduled for material 1.2.
 *
 * @param {string} newClass Class to be added.
 * @param {boolean} toElement Whether or not to add the class to the panel
 *     element instead of the container.
 */
MdPanelRef.prototype.addClass = function(newClass, toElement) {
  this._$log.warn(
      'mdPanel: The addClass method is in the process of being deprecated. ' +
      'Full deprecation is scheduled for the AngularJS Material 1.2 release. ' +
      'To achieve the same results, use the panelContainer or panelEl ' +
      'JQLite elements that are referenced in MdPanelRef.');

  if (!this.panelContainer) {
    throw new Error(
        'mdPanel: Panel does not exist yet. Call open() or attach().');
  }

  if (!toElement && !this.panelContainer.hasClass(newClass)) {
    this.panelContainer.addClass(newClass);
  } else if (toElement && !this.panelEl.hasClass(newClass)) {
    this.panelEl.addClass(newClass);
  }
};


/**
 * Remove a class from the panel. DO NOT use this to hide/show the panel.
 * @deprecated
 * This method is in the process of being deprecated in favor of using the panel
 * and container JQLite elements that are referenced in the MdPanelRef object.
 * Full deprecation is scheduled for material 1.2.
 *
 * @param {string} oldClass Class to be removed.
 * @param {boolean} fromElement Whether or not to remove the class from the
 *     panel element instead of the container.
 */
MdPanelRef.prototype.removeClass = function(oldClass, fromElement) {
  this._$log.warn(
      'mdPanel: The removeClass method is in the process of being deprecated. ' +
      'Full deprecation is scheduled for the AngularJS Material 1.2 release. ' +
      'To achieve the same results, use the panelContainer or panelEl ' +
      'JQLite elements that are referenced in MdPanelRef.');

  if (!this.panelContainer) {
    throw new Error(
        'mdPanel: Panel does not exist yet. Call open() or attach().');
  }

  if (!fromElement && this.panelContainer.hasClass(oldClass)) {
    this.panelContainer.removeClass(oldClass);
  } else if (fromElement && this.panelEl.hasClass(oldClass)) {
    this.panelEl.removeClass(oldClass);
  }
};


/**
 * Toggle a class on the panel. DO NOT use this to hide/show the panel.
 * @deprecated
 * This method is in the process of being deprecated in favor of using the panel
 * and container JQLite elements that are referenced in the MdPanelRef object.
 * Full deprecation is scheduled for material 1.2.
 *
 * @param {string} toggleClass The class to toggle.
 * @param {boolean} onElement Whether or not to toggle the class on the panel
 *     element instead of the container.
 */
MdPanelRef.prototype.toggleClass = function(toggleClass, onElement) {
  this._$log.warn(
      'mdPanel: The toggleClass method is in the process of being deprecated. ' +
      'Full deprecation is scheduled for the AngularJS Material 1.2 release. ' +
      'To achieve the same results, use the panelContainer or panelEl ' +
      'JQLite elements that are referenced in MdPanelRef.');

  if (!this.panelContainer) {
    throw new Error(
        'mdPanel: Panel does not exist yet. Call open() or attach().');
  }

  if (!onElement) {
    this.panelContainer.toggleClass(toggleClass);
  } else {
    this.panelEl.toggleClass(toggleClass);
  }
};


/**
 * Compiles the panel, according to the passed in config and appends it to
 * the DOM. Helps normalize differences in the compilation process between
 * using a string template and a content element.
 * @returns {!angular.$q.Promise<!MdPanelRef>} Promise that is resolved when
 *     the element has been compiled and added to the DOM.
 * @private
 */
MdPanelRef.prototype._compile = function() {
  var self = this;

  // Compile the element via $mdCompiler. Note that when using a
  // contentElement, the element isn't actually being compiled, rather the
  // compiler saves it's place in the DOM and provides a way of restoring it.
  return self._$mdCompiler.compile(self.config).then(function(compileData) {
    var config = self.config;

    if (config.contentElement) {
      var panelEl = compileData.element;

      // Since mdPanel modifies the inline styles and CSS classes, we need
      // to save them in order to be able to restore on close.
      self._restoreCache.styles = panelEl[0].style.cssText;
      self._restoreCache.classes = panelEl[0].className;

      self.panelContainer = self._$mdPanel._wrapContentElement(panelEl);
      self.panelEl = panelEl;
    } else {
      self.panelContainer = compileData.link(config['scope']);
      self.panelEl = angular.element(
        self.panelContainer[0].querySelector('.md-panel')
      );
    }

    // Save a reference to the cleanup function from the compiler.
    self._compilerCleanup = compileData.cleanup;

    // Attach the panel to the proper place in the DOM.
    getElement(self.config['attachTo']).append(self.panelContainer);

    return self;
  });
};


/**
 * Creates a panel and adds it to the dom.
 * @returns {!angular.$q.Promise} A promise that is resolved when the panel is
 *     created.
 * @private
 */
MdPanelRef.prototype._createPanel = function() {
  var self = this;

  return this._$q(function(resolve, reject) {
    if (!self.config.locals) {
      self.config.locals = {};
    }

    self.config.locals.mdPanelRef = self;

    self._compile().then(function() {
      if (self.config['disableParentScroll']) {
        self._restoreScroll = self._$mdUtil.disableScrollAround(
          null,
          self.panelContainer,
          { disableScrollMask: true }
        );
      }

      // Add a custom CSS class to the panel element.
      if (self.config['panelClass']) {
        self.panelEl.addClass(self.config['panelClass']);
      }

      // Handle click and touch events for the panel container.
      if (self.config['propagateContainerEvents']) {
        self.panelContainer.css('pointer-events', 'none');
        self.panelEl.css('pointer-events', 'all');
      }

      // Panel may be outside the $rootElement, tell ngAnimate to animate
      // regardless.
      if (self._$animate.pin) {
        self._$animate.pin(
          self.panelContainer,
          getElement(self.config['attachTo'])
        );
      }

      self._configureTrapFocus();
      self._addStyles().then(function() {
        resolve(self);
      }, reject);
    }, reject);

  });
};


/**
 * Adds the styles for the panel, such as positioning and z-index. Also,
 * themes the panel element and panel container using `$mdTheming`.
 * @returns {!angular.$q.Promise<!MdPanelRef>}
 * @private
 */
MdPanelRef.prototype._addStyles = function() {
  var self = this;
  return this._$q(function(resolve) {
    self.panelContainer.css('z-index', self.config['zIndex']);
    self.panelEl.css('z-index', self.config['zIndex'] + 1);

    var hideAndResolve = function() {
      // Theme the element and container.
      self._setTheming();

      // Remove offscreen class and add hidden class.
      self.panelEl.removeClass('_md-panel-offscreen');
      self.panelContainer.addClass(MD_PANEL_HIDDEN);

      resolve(self);
    };

    if (self.config['fullscreen']) {
      self.panelEl.addClass('_md-panel-fullscreen');
      hideAndResolve();
      return; // Don't setup positioning.
    }

    var positionConfig = self.config['position'];
    if (!positionConfig) {
      hideAndResolve();
      return; // Don't setup positioning.
    }

    // Wait for angular to finish processing the template
    self._$rootScope['$$postDigest'](function() {
      // Position it correctly. This is necessary so that the panel will have a
      // defined height and width.
      self._updatePosition(true);

      // Theme the element and container.
      self._setTheming();

      resolve(self);
    });
  });
};


/**
 * Sets the `$mdTheming` classes on the `panelContainer` and `panelEl`.
 * @private
 */
MdPanelRef.prototype._setTheming = function() {
  this._$mdTheming(this.panelEl);
  this._$mdTheming(this.panelContainer);
};


/**
 * Updates the position configuration of a panel
 * @param {!MdPanelPosition} position
 */
MdPanelRef.prototype.updatePosition = function(position) {
  if (!this.panelContainer) {
    throw new Error(
        'mdPanel: Panel does not exist yet. Call open() or attach().');
  }

  this.config['position'] = position;
  this._updatePosition();
};


/**
 * Calculates and updates the position of the panel.
 * @param {boolean=} init
 * @private
 */
MdPanelRef.prototype._updatePosition = function(init) {
  var positionConfig = this.config['position'];

  if (positionConfig) {
    positionConfig._setPanelPosition(this.panelEl);

    // Hide the panel now that position is known.
    if (init) {
      this.panelEl.removeClass('_md-panel-offscreen');
      this.panelContainer.addClass(MD_PANEL_HIDDEN);
    }

    this.panelEl.css(
      MdPanelPosition.absPosition.TOP,
      positionConfig.getTop()
    );
    this.panelEl.css(
      MdPanelPosition.absPosition.BOTTOM,
      positionConfig.getBottom()
    );
    this.panelEl.css(
      MdPanelPosition.absPosition.LEFT,
      positionConfig.getLeft()
    );
    this.panelEl.css(
      MdPanelPosition.absPosition.RIGHT,
      positionConfig.getRight()
    );
  }
};


/**
 * Focuses on the panel or the first focus target.
 * @private
 */
MdPanelRef.prototype._focusOnOpen = function() {
  if (this.config['focusOnOpen']) {
    // Wait for the template to finish rendering to guarantee md-autofocus has
    // finished adding the class md-autofocus, otherwise the focusable element
    // isn't available to focus.
    var self = this;
    this._$rootScope['$$postDigest'](function() {
      var target = self._$mdUtil.findFocusTarget(self.panelEl) ||
          self.panelEl;
      target.focus();
    });
  }
};


/**
 * Shows the backdrop.
 * @returns {!angular.$q.Promise} A promise that is resolved when the backdrop
 *     is created and attached.
 * @private
 */
MdPanelRef.prototype._createBackdrop = function() {
  if (this.config.hasBackdrop) {
    if (!this._backdropRef) {
      var backdropAnimation = this._$mdPanel.newPanelAnimation()
          .openFrom(this.config.attachTo)
          .withAnimation({
            open: '_md-opaque-enter',
            close: '_md-opaque-leave'
          });

      if (this.config.animation) {
        backdropAnimation.duration(this.config.animation._rawDuration);
      }

      var backdropConfig = {
        animation: backdropAnimation,
        attachTo: this.config.attachTo,
        focusOnOpen: false,
        panelClass: '_md-panel-backdrop',
        zIndex: this.config.zIndex - 1
      };

      this._backdropRef = this._$mdPanel.create(backdropConfig);
    }
    if (!this._backdropRef.isAttached) {
      return this._backdropRef.attach();
    }
  }
};


/**
 * Listen for escape keys and outside clicks to auto close.
 * @private
 */
MdPanelRef.prototype._addEventListeners = function() {
  this._configureEscapeToClose();
  this._configureClickOutsideToClose();
  this._configureScrollListener();
};


/**
 * Remove event listeners added in _addEventListeners.
 * @private
 */
MdPanelRef.prototype._removeEventListeners = function() {
  this._removeListeners && this._removeListeners.forEach(function(removeFn) {
    removeFn();
  });
  this._removeListeners = [];
};


/**
 * Setup the escapeToClose event listeners.
 * @private
 */
MdPanelRef.prototype._configureEscapeToClose = function() {
  if (this.config['escapeToClose']) {
    var parentTarget = getElement(this.config['attachTo']);
    var self = this;

    var keyHandlerFn = function(ev) {
      if (ev.keyCode === self._$mdConstant.KEY_CODE.ESCAPE) {
        ev.stopPropagation();
        ev.preventDefault();

        self.close(MdPanelRef.closeReasons.ESCAPE);
      }
    };

    // Add keydown listeners
    this.panelContainer.on('keydown', keyHandlerFn);
    parentTarget.on('keydown', keyHandlerFn);

    // Queue remove listeners function
    this._removeListeners.push(function() {
      self.panelContainer.off('keydown', keyHandlerFn);
      parentTarget.off('keydown', keyHandlerFn);
    });
  }
};


/**
 * Setup the clickOutsideToClose event listeners.
 * @private
 */
MdPanelRef.prototype._configureClickOutsideToClose = function() {
  if (this.config['clickOutsideToClose']) {
    var target = this.config['propagateContainerEvents'] ?
        angular.element(document.body) :
        this.panelContainer;
    var sourceEl;

    // Keep track of the element on which the mouse originally went down
    // so that we can only close the backdrop when the 'click' started on it.
    // A simple 'click' handler does not work, it sets the target object as the
    // element the mouse went down on.
    var mousedownHandler = function(ev) {
      sourceEl = ev.target;
    };

    // We check if our original element and the target is the backdrop
    // because if the original was the backdrop and the target was inside the
    // panel we don't want to panel to close.
    var self = this;
    var mouseupHandler = function(ev) {
      if (self.config['propagateContainerEvents']) {

        // We check if the sourceEl of the event is the panel element or one
        // of it's children. If it is not, then close the panel.
        if (sourceEl !== self.panelEl[0] && !self.panelEl[0].contains(sourceEl)) {
          self.close();
        }

      } else if (sourceEl === target[0] && ev.target === target[0]) {
        ev.stopPropagation();
        ev.preventDefault();

        self.close(MdPanelRef.closeReasons.CLICK_OUTSIDE);
      }
    };

    // Add listeners
    target.on('mousedown', mousedownHandler);
    target.on('mouseup', mouseupHandler);

    // Queue remove listeners function
    this._removeListeners.push(function() {
      target.off('mousedown', mousedownHandler);
      target.off('mouseup', mouseupHandler);
    });
  }
};


/**
 * Configures the listeners for updating the panel position on scroll.
 * @private
*/
MdPanelRef.prototype._configureScrollListener = function() {
  // No need to bind the event if scrolling is disabled.
  if (!this.config['disableParentScroll']) {
    var updatePosition = angular.bind(this, this._updatePosition);
    var debouncedUpdatePosition = this._$$rAF.throttle(updatePosition);
    var self = this;

    var onScroll = function() {
      debouncedUpdatePosition();
    };

    // Add listeners.
    this._$window.addEventListener('scroll', onScroll, true);

    // Queue remove listeners function.
    this._removeListeners.push(function() {
      self._$window.removeEventListener('scroll', onScroll, true);
    });
  }
};


/**
 * Setup the focus traps. These traps will wrap focus when tabbing past the
 * panel. When shift-tabbing, the focus will stick in place.
 * @private
 */
MdPanelRef.prototype._configureTrapFocus = function() {
  // Focus doesn't remain inside of the panel without this.
  this.panelEl.attr('tabIndex', '-1');
  if (this.config['trapFocus']) {
    var element = this.panelEl;
    // Set up elements before and after the panel to capture focus and
    // redirect back into the panel.
    this._topFocusTrap = FOCUS_TRAP_TEMPLATE.clone()[0];
    this._bottomFocusTrap = FOCUS_TRAP_TEMPLATE.clone()[0];

    // When focus is about to move out of the panel, we want to intercept it
    // and redirect it back to the panel element.
    var focusHandler = function() {
      element.focus();
    };
    this._topFocusTrap.addEventListener('focus', focusHandler);
    this._bottomFocusTrap.addEventListener('focus', focusHandler);

    // Queue remove listeners function
    this._removeListeners.push(this._simpleBind(function() {
      this._topFocusTrap.removeEventListener('focus', focusHandler);
      this._bottomFocusTrap.removeEventListener('focus', focusHandler);
    }, this));

    // The top focus trap inserted immediately before the md-panel element (as
    // a sibling). The bottom focus trap inserted immediately after the
    // md-panel element (as a sibling).
    element[0].parentNode.insertBefore(this._topFocusTrap, element[0]);
    element.after(this._bottomFocusTrap);
  }
};


/**
 * Updates the animation of a panel.
 * @param {!MdPanelAnimation} animation
 */
MdPanelRef.prototype.updateAnimation = function(animation) {
  this.config['animation'] = animation;

  if (this._backdropRef) {
    this._backdropRef.config.animation.duration(animation._rawDuration);
  }
};


/**
 * Animate the panel opening.
 * @returns {!angular.$q.Promise} A promise that is resolved when the panel has
 *     animated open.
 * @private
 */
MdPanelRef.prototype._animateOpen = function() {
  this.panelContainer.addClass('md-panel-is-showing');
  var animationConfig = this.config['animation'];
  if (!animationConfig) {
    // Promise is in progress, return it.
    this.panelContainer.addClass('_md-panel-shown');
    return this._$q.when(this);
  }

  var self = this;
  return this._$q(function(resolve) {
    var done = self._done(resolve, self);
    var warnAndOpen = function() {
      self._$log.warn(
          'mdPanel: MdPanel Animations failed. ' +
          'Showing panel without animating.');
      done();
    };

    animationConfig.animateOpen(self.panelEl)
        .then(done, warnAndOpen);
  });
};


/**
 * Animate the panel closing.
 * @returns {!angular.$q.Promise} A promise that is resolved when the panel has
 *     animated closed.
 * @private
 */
MdPanelRef.prototype._animateClose = function() {
  var animationConfig = this.config['animation'];
  if (!animationConfig) {
    this.panelContainer.removeClass('md-panel-is-showing');
    this.panelContainer.removeClass('_md-panel-shown');
    return this._$q.when(this);
  }

  var self = this;
  return this._$q(function(resolve) {
    var done = function() {
      self.panelContainer.removeClass('md-panel-is-showing');
      resolve(self);
    };
    var warnAndClose = function() {
      self._$log.warn(
          'mdPanel: MdPanel Animations failed. ' +
          'Hiding panel without animating.');
      done();
    };

    animationConfig.animateClose(self.panelEl)
        .then(done, warnAndClose);
  });
};


/**
 * Registers a interceptor with the panel. The callback should return a promise,
 * which will allow the action to continue when it gets resolved, or will
 * prevent an action if it is rejected.
 * @param {string} type Type of interceptor.
 * @param {!angular.$q.Promise<!any>} callback Callback to be registered.
 * @returns {!MdPanelRef}
 */
MdPanelRef.prototype.registerInterceptor = function(type, callback) {
  var error = null;

  if (!angular.isString(type)) {
    error = 'Interceptor type must be a string, instead got ' + typeof type;
  } else if (!angular.isFunction(callback)) {
    error = 'Interceptor callback must be a function, instead got ' + typeof callback;
  }

  if (error) {
    throw new Error('MdPanel: ' + error);
  }

  var interceptors = this._interceptors[type] = this._interceptors[type] || [];

  if (interceptors.indexOf(callback) === -1) {
    interceptors.push(callback);
  }

  return this;
};


/**
 * Removes a registered interceptor.
 * @param {string} type Type of interceptor to be removed.
 * @param {Function} callback Interceptor to be removed.
 * @returns {!MdPanelRef}
 */
MdPanelRef.prototype.removeInterceptor = function(type, callback) {
  var index = this._interceptors[type] ?
    this._interceptors[type].indexOf(callback) : -1;

  if (index > -1) {
    this._interceptors[type].splice(index, 1);
  }

  return this;
};


/**
 * Removes all interceptors.
 * @param {string=} type Type of interceptors to be removed.
 *     If ommited, all interceptors types will be removed.
 * @returns {!MdPanelRef}
 */
MdPanelRef.prototype.removeAllInterceptors = function(type) {
  if (type) {
    this._interceptors[type] = [];
  } else {
    this._interceptors = Object.create(null);
  }

  return this;
};


/**
 * Invokes all the interceptors of a certain type sequantially in
 *     reverse order. Works in a similar way to `$q.all`, except it
 *     respects the order of the functions.
 * @param {string} type Type of interceptors to be invoked.
 * @returns {!angular.$q.Promise<!MdPanelRef>}
 * @private
 */
MdPanelRef.prototype._callInterceptors = function(type) {
  var self = this;
  var $q = self._$q;
  var interceptors = self._interceptors && self._interceptors[type] || [];

  return interceptors.reduceRight(function(promise, interceptor) {
    var isPromiseLike = interceptor && angular.isFunction(interceptor.then);
    var response = isPromiseLike ? interceptor : null;

    /**
    * For interceptors to reject/cancel subsequent portions of the chain, simply
    * return a `$q.reject(<value>)`
    */
    return promise.then(function() {
      if (!response) {
        try {
          response = interceptor(self);
        } catch (e) {
          response = $q.reject(e);
        }
      }

     return response;
    });
  }, $q.resolve(self));
};


/**
 * Faster, more basic than angular.bind
 * http://jsperf.com/angular-bind-vs-custom-vs-native
 * @param {function} callback
 * @param {!Object} self
 * @return {function} Callback function with a bound self.
 */
MdPanelRef.prototype._simpleBind = function(callback, self) {
  return function(value) {
    return callback.apply(self, value);
  };
};


/**
 * @param {function} callback
 * @param {!Object} self
 * @return {function} Callback function with a self param.
 */
MdPanelRef.prototype._done = function(callback, self) {
  return function() {
    callback(self);
  };
};


/**
 * Adds a panel to a group if the panel does not exist within the group already.
 * A panel can only exist within a single group.
 * @param {string} groupName The name of the group.
 */
MdPanelRef.prototype.addToGroup = function(groupName) {
  if (!this._$mdPanel._groups[groupName]) {
    this._$mdPanel.newPanelGroup(groupName);
  }

  var group = this._$mdPanel._groups[groupName];
  var index = group.panels.indexOf(this);

  if (index < 0) {
    group.panels.push(this);
  }
};


/**
 * Removes a panel from a group if the panel exists within that group. The group
 * must be created ahead of time.
 * @param {string} groupName The name of the group.
 */
MdPanelRef.prototype.removeFromGroup = function(groupName) {
  if (!this._$mdPanel._groups[groupName]) {
    throw new Error('mdPanel: The group ' + groupName + ' does not exist.');
  }

  var group = this._$mdPanel._groups[groupName];
  var index = group.panels.indexOf(this);

  if (index > -1) {
    group.panels.splice(index, 1);
  }
};


/**
 * Possible default closeReasons for the close function.
 * @enum {string}
 */
MdPanelRef.closeReasons = {
  CLICK_OUTSIDE: 'clickOutsideToClose',
  ESCAPE: 'escapeToClose',
};


/*****************************************************************************
 *                               MdPanelPosition                             *
 *****************************************************************************/


/**
 * Position configuration object. To use, create an MdPanelPosition with the
 * desired properties, then pass the object as part of $mdPanel creation.
 *
 * Example:
 *
 * var panelPosition = new MdPanelPosition()
 *     .relativeTo(myButtonEl)
 *     .addPanelPosition(
 *       $mdPanel.xPosition.CENTER,
 *       $mdPanel.yPosition.ALIGN_TOPS
 *     );
 *
 * $mdPanel.create({
 *   position: panelPosition
 * });
 *
 * @param {!angular.$injector} $injector
 * @final @constructor
 */
function MdPanelPosition($injector) {
  /** @private @const {!angular.$window} */
  this._$window = $injector.get('$window');

  /** @private {boolean} */
  this._isRTL = $injector.get('$mdUtil').bidi() === 'rtl';

  /** @private @const {!angular.$mdConstant} */
  this._$mdConstant = $injector.get('$mdConstant');

  /** @private {boolean} */
  this._absolute = false;

  /** @private {!angular.JQLite} */
  this._relativeToEl;

  /** @private {string} */
  this._top = '';

  /** @private {string} */
  this._bottom = '';

  /** @private {string} */
  this._left = '';

  /** @private {string} */
  this._right = '';

  /** @private {!Array<string>} */
  this._translateX = [];

  /** @private {!Array<string>} */
  this._translateY = [];

  /** @private {!Array<{x:string, y:string}>} */
  this._positions = [];

  /** @private {?{x:string, y:string}} */
  this._actualPosition;
}


/**
 * Possible values of xPosition.
 * @enum {string}
 */
MdPanelPosition.xPosition = {
  CENTER: 'center',
  ALIGN_START: 'align-start',
  ALIGN_END: 'align-end',
  OFFSET_START: 'offset-start',
  OFFSET_END: 'offset-end'
};


/**
 * Possible values of yPosition.
 * @enum {string}
 */
MdPanelPosition.yPosition = {
  CENTER: 'center',
  ALIGN_TOPS: 'align-tops',
  ALIGN_BOTTOMS: 'align-bottoms',
  ABOVE: 'above',
  BELOW: 'below'
};


/**
 * Possible values of absolute position.
 * @enum {string}
 */
MdPanelPosition.absPosition = {
  TOP: 'top',
  RIGHT: 'right',
  BOTTOM: 'bottom',
  LEFT: 'left'
};

/**
 * Margin between the edges of a panel and the viewport.
 * @const {number}
 */
MdPanelPosition.viewportMargin = 8;


/**
 * Sets absolute positioning for the panel.
 * @return {!MdPanelPosition}
 */
MdPanelPosition.prototype.absolute = function() {
  this._absolute = true;
  return this;
};


/**
 * Sets the value of a position for the panel. Clears any previously set
 * position.
 * @param {string} position Position to set
 * @param {string=} value Value of the position. Defaults to '0'.
 * @returns {!MdPanelPosition}
 * @private
 */
MdPanelPosition.prototype._setPosition = function(position, value) {
  if (position === MdPanelPosition.absPosition.RIGHT ||
      position === MdPanelPosition.absPosition.LEFT) {
    this._left = this._right = '';
  } else if (
      position === MdPanelPosition.absPosition.BOTTOM ||
      position === MdPanelPosition.absPosition.TOP) {
    this._top = this._bottom = '';
  } else {
    var positions = Object.keys(MdPanelPosition.absPosition).join()
        .toLowerCase();

    throw new Error('mdPanel: Position must be one of ' + positions + '.');
  }

  this['_' +  position] = angular.isString(value) ? value : '0';

  return this;
};


/**
 * Sets the value of `top` for the panel. Clears any previously set vertical
 * position.
 * @param {string=} top Value of `top`. Defaults to '0'.
 * @returns {!MdPanelPosition}
 */
MdPanelPosition.prototype.top = function(top) {
  return this._setPosition(MdPanelPosition.absPosition.TOP, top);
};


/**
 * Sets the value of `bottom` for the panel. Clears any previously set vertical
 * position.
 * @param {string=} bottom Value of `bottom`. Defaults to '0'.
 * @returns {!MdPanelPosition}
 */
MdPanelPosition.prototype.bottom = function(bottom) {
  return this._setPosition(MdPanelPosition.absPosition.BOTTOM, bottom);
};


/**
 * Sets the panel to the start of the page - `left` if `ltr` or `right` for
 * `rtl`. Clears any previously set horizontal position.
 * @param {string=} start Value of position. Defaults to '0'.
 * @returns {!MdPanelPosition}
 */
MdPanelPosition.prototype.start = function(start) {
  var position = this._isRTL ? MdPanelPosition.absPosition.RIGHT : MdPanelPosition.absPosition.LEFT;
  return this._setPosition(position, start);
};


/**
 * Sets the panel to the end of the page - `right` if `ltr` or `left` for `rtl`.
 * Clears any previously set horizontal position.
 * @param {string=} end Value of position. Defaults to '0'.
 * @returns {!MdPanelPosition}
 */
MdPanelPosition.prototype.end = function(end) {
  var position = this._isRTL ? MdPanelPosition.absPosition.LEFT : MdPanelPosition.absPosition.RIGHT;
  return this._setPosition(position, end);
};


/**
 * Sets the value of `left` for the panel. Clears any previously set
 * horizontal position.
 * @param {string=} left Value of `left`. Defaults to '0'.
 * @returns {!MdPanelPosition}
 */
MdPanelPosition.prototype.left = function(left) {
  return this._setPosition(MdPanelPosition.absPosition.LEFT, left);
};


/**
 * Sets the value of `right` for the panel. Clears any previously set
 * horizontal position.
 * @param {string=} right Value of `right`. Defaults to '0'.
 * @returns {!MdPanelPosition}
*/
MdPanelPosition.prototype.right = function(right) {
  return this._setPosition(MdPanelPosition.absPosition.RIGHT, right);
};


/**
 * Centers the panel horizontally in the viewport. Clears any previously set
 * horizontal position.
 * @returns {!MdPanelPosition}
 */
MdPanelPosition.prototype.centerHorizontally = function() {
  this._left = '50%';
  this._right = '';
  this._translateX = ['-50%'];
  return this;
};


/**
 * Centers the panel vertically in the viewport. Clears any previously set
 * vertical position.
 * @returns {!MdPanelPosition}
 */
MdPanelPosition.prototype.centerVertically = function() {
  this._top = '50%';
  this._bottom = '';
  this._translateY = ['-50%'];
  return this;
};


/**
 * Centers the panel horizontally and vertically in the viewport. This is
 * equivalent to calling both `centerHorizontally` and `centerVertically`.
 * Clears any previously set horizontal and vertical positions.
 * @returns {!MdPanelPosition}
 */
MdPanelPosition.prototype.center = function() {
  return this.centerHorizontally().centerVertically();
};


/**
 * Sets element for relative positioning.
 * @param {string|!Element|!angular.JQLite} element Query selector, DOM element,
 *     or angular element to set the panel relative to.
 * @returns {!MdPanelPosition}
 */
MdPanelPosition.prototype.relativeTo = function(element) {
  this._absolute = false;
  this._relativeToEl = getElement(element);
  return this;
};


/**
 * Sets the x and y positions for the panel relative to another element.
 * @param {string} xPosition must be one of the MdPanelPosition.xPosition
 *     values.
 * @param {string} yPosition must be one of the MdPanelPosition.yPosition
 *     values.
 * @returns {!MdPanelPosition}
 */
MdPanelPosition.prototype.addPanelPosition = function(xPosition, yPosition) {
  if (!this._relativeToEl) {
    throw new Error('mdPanel: addPanelPosition can only be used with ' +
        'relative positioning. Set relativeTo first.');
  }

  this._validateXPosition(xPosition);
  this._validateYPosition(yPosition);

  this._positions.push({
      x: xPosition,
      y: yPosition,
  });
  return this;
};


/**
 * Ensures that yPosition is a valid position name. Throw an exception if not.
 * @param {string} yPosition
 */
MdPanelPosition.prototype._validateYPosition = function(yPosition) {
  // empty is ok
  if (yPosition == null) {
      return;
  }

  var positionKeys = Object.keys(MdPanelPosition.yPosition);
  var positionValues = [];
  for (var key, i = 0; key = positionKeys[i]; i++) {
    var position = MdPanelPosition.yPosition[key];
    positionValues.push(position);

    if (position === yPosition) {
      return;
    }
  }

  throw new Error('mdPanel: Panel y position only accepts the following ' +
      'values:\n' + positionValues.join(' | '));
};


/**
 * Ensures that xPosition is a valid position name. Throw an exception if not.
 * @param {string} xPosition
 */
MdPanelPosition.prototype._validateXPosition = function(xPosition) {
  // empty is ok
  if (xPosition == null) {
      return;
  }

  var positionKeys = Object.keys(MdPanelPosition.xPosition);
  var positionValues = [];
  for (var key, i = 0; key = positionKeys[i]; i++) {
    var position = MdPanelPosition.xPosition[key];
    positionValues.push(position);
    if (position === xPosition) {
      return;
    }
  }

  throw new Error('mdPanel: Panel x Position only accepts the following ' +
      'values:\n' + positionValues.join(' | '));
};


/**
 * Sets the value of the offset in the x-direction. This will add to any
 * previously set offsets.
 * @param {string|number|function(MdPanelPosition): string} offsetX
 * @returns {!MdPanelPosition}
 */
MdPanelPosition.prototype.withOffsetX = function(offsetX) {
  this._translateX.push(addUnits(offsetX));
  return this;
};


/**
 * Sets the value of the offset in the y-direction. This will add to any
 * previously set offsets.
 * @param {string|number|function(MdPanelPosition): string} offsetY
 * @returns {!MdPanelPosition}
 */
MdPanelPosition.prototype.withOffsetY = function(offsetY) {
  this._translateY.push(addUnits(offsetY));
  return this;
};


/**
 * Gets the value of `top` for the panel.
 * @returns {string}
 */
MdPanelPosition.prototype.getTop = function() {
  return this._top;
};


/**
 * Gets the value of `bottom` for the panel.
 * @returns {string}
 */
MdPanelPosition.prototype.getBottom = function() {
  return this._bottom;
};


/**
 * Gets the value of `left` for the panel.
 * @returns {string}
 */
MdPanelPosition.prototype.getLeft = function() {
  return this._left;
};


/**
 * Gets the value of `right` for the panel.
 * @returns {string}
 */
MdPanelPosition.prototype.getRight = function() {
  return this._right;
};


/**
 * Gets the value of `transform` for the panel.
 * @returns {string}
 */
MdPanelPosition.prototype.getTransform = function() {
  var translateX = this._reduceTranslateValues('translateX', this._translateX);
  var translateY = this._reduceTranslateValues('translateY', this._translateY);

  // It's important to trim the result, because the browser will ignore the set
  // operation if the string contains only whitespace.
  return (translateX + ' ' + translateY).trim();
};


/**
 * Sets the `transform` value for a panel element.
 * @param {!angular.JQLite} panelEl
 * @returns {!angular.JQLite}
 * @private
 */
MdPanelPosition.prototype._setTransform = function(panelEl) {
  return panelEl.css(this._$mdConstant.CSS.TRANSFORM, this.getTransform());
};


/**
 * True if the panel is completely on-screen with this positioning; false
 * otherwise.
 * @param {!angular.JQLite} panelEl
 * @return {boolean}
 * @private
 */
MdPanelPosition.prototype._isOnscreen = function(panelEl) {
  // this works because we always use fixed positioning for the panel,
  // which is relative to the viewport.
  var left = parseInt(this.getLeft());
  var top = parseInt(this.getTop());

  if (this._translateX.length || this._translateY.length) {
    var prefixedTransform = this._$mdConstant.CSS.TRANSFORM;
    var offsets = getComputedTranslations(panelEl, prefixedTransform);
    left += offsets.x;
    top += offsets.y;
  }

  var right = left + panelEl[0].offsetWidth;
  var bottom = top + panelEl[0].offsetHeight;

  return (left >= 0) &&
    (top >= 0) &&
    (bottom <= this._$window.innerHeight) &&
    (right <= this._$window.innerWidth);
};


/**
 * Gets the first x/y position that can fit on-screen.
 * @returns {{x: string, y: string}}
 */
MdPanelPosition.prototype.getActualPosition = function() {
  return this._actualPosition;
};


/**
 * Reduces a list of translate values to a string that can be used within
 * transform.
 * @param {string} translateFn
 * @param {!Array<string>} values
 * @returns {string}
 * @private
 */
MdPanelPosition.prototype._reduceTranslateValues =
    function(translateFn, values) {
      return values.map(function(translation) {
        var translationValue = angular.isFunction(translation) ?
            addUnits(translation(this)) : translation;
        return translateFn + '(' + translationValue + ')';
      }, this).join(' ');
    };


/**
 * Sets the panel position based on the created panel element and best x/y
 * positioning.
 * @param {!angular.JQLite} panelEl
 * @private
 */
MdPanelPosition.prototype._setPanelPosition = function(panelEl) {
  // Remove the "position adjusted" class in case it has been added before.
  panelEl.removeClass('_md-panel-position-adjusted');

  // Only calculate the position if necessary.
  if (this._absolute) {
    this._setTransform(panelEl);
    return;
  }

  if (this._actualPosition) {
    this._calculatePanelPosition(panelEl, this._actualPosition);
    this._setTransform(panelEl);
    this._constrainToViewport(panelEl);
    return;
  }

  for (var i = 0; i < this._positions.length; i++) {
    this._actualPosition = this._positions[i];
    this._calculatePanelPosition(panelEl, this._actualPosition);
    this._setTransform(panelEl);

    if (this._isOnscreen(panelEl)) {
      return;
    }
  }

  this._constrainToViewport(panelEl);
};


/**
 * Constrains a panel's position to the viewport.
 * @param {!angular.JQLite} panelEl
 * @private
 */
MdPanelPosition.prototype._constrainToViewport = function(panelEl) {
  var margin = MdPanelPosition.viewportMargin;
  var initialTop = this._top;
  var initialLeft = this._left;

  if (this.getTop()) {
    var top = parseInt(this.getTop());
    var bottom = panelEl[0].offsetHeight + top;
    var viewportHeight = this._$window.innerHeight;

    if (top < margin) {
      this._top = margin + 'px';
    } else if (bottom > viewportHeight) {
      this._top = top - (bottom - viewportHeight + margin) + 'px';
    }
  }

  if (this.getLeft()) {
    var left = parseInt(this.getLeft());
    var right = panelEl[0].offsetWidth + left;
    var viewportWidth = this._$window.innerWidth;

    if (left < margin) {
      this._left = margin + 'px';
    } else if (right > viewportWidth) {
      this._left = left - (right - viewportWidth + margin) + 'px';
    }
  }

  // Class that can be used to re-style the panel if it was repositioned.
  panelEl.toggleClass(
    '_md-panel-position-adjusted',
    this._top !== initialTop || this._left !== initialLeft
  );
};


/**
 * Switches between 'start' and 'end'.
 * @param {string} position Horizontal position of the panel
 * @returns {string} Reversed position
 * @private
 */
MdPanelPosition.prototype._reverseXPosition = function(position) {
  if (position === MdPanelPosition.xPosition.CENTER) {
    return position;
  }

  var start = 'start';
  var end = 'end';

  return position.indexOf(start) > -1 ? position.replace(start, end) : position.replace(end, start);
};


/**
 * Handles horizontal positioning in rtl or ltr environments.
 * @param {string} position Horizontal position of the panel
 * @returns {string} The correct position according the page direction
 * @private
 */
MdPanelPosition.prototype._bidi = function(position) {
  return this._isRTL ? this._reverseXPosition(position) : position;
};


/**
 * Calculates the panel position based on the created panel element and the
 * provided positioning.
 * @param {!angular.JQLite} panelEl
 * @param {!{x:string, y:string}} position
 * @private
 */
MdPanelPosition.prototype._calculatePanelPosition = function(panelEl, position) {

  var panelBounds = panelEl[0].getBoundingClientRect();
  var panelWidth = Math.max(panelBounds.width, panelEl[0].clientWidth);
  var panelHeight = Math.max(panelBounds.height, panelEl[0].clientHeight);

  var targetBounds = this._relativeToEl[0].getBoundingClientRect();

  var targetLeft = targetBounds.left;
  var targetRight = targetBounds.right;
  var targetWidth = targetBounds.width;

  switch (this._bidi(position.x)) {
    case MdPanelPosition.xPosition.OFFSET_START:
      this._left = targetLeft - panelWidth + 'px';
      break;
    case MdPanelPosition.xPosition.ALIGN_END:
      this._left = targetRight - panelWidth + 'px';
      break;
    case MdPanelPosition.xPosition.CENTER:
      var left = targetLeft + (0.5 * targetWidth) - (0.5 * panelWidth);
      this._left = left + 'px';
      break;
    case MdPanelPosition.xPosition.ALIGN_START:
      this._left = targetLeft + 'px';
      break;
    case MdPanelPosition.xPosition.OFFSET_END:
      this._left = targetRight + 'px';
      break;
  }

  var targetTop = targetBounds.top;
  var targetBottom = targetBounds.bottom;
  var targetHeight = targetBounds.height;

  switch (position.y) {
    case MdPanelPosition.yPosition.ABOVE:
      this._top = targetTop - panelHeight + 'px';
      break;
    case MdPanelPosition.yPosition.ALIGN_BOTTOMS:
      this._top = targetBottom - panelHeight + 'px';
      break;
    case MdPanelPosition.yPosition.CENTER:
      var top = targetTop + (0.5 * targetHeight) - (0.5 * panelHeight);
      this._top = top + 'px';
      break;
    case MdPanelPosition.yPosition.ALIGN_TOPS:
      this._top = targetTop + 'px';
      break;
    case MdPanelPosition.yPosition.BELOW:
      this._top = targetBottom + 'px';
      break;
  }
};


/*****************************************************************************
 *                               MdPanelAnimation                            *
 *****************************************************************************/


/**
 * Animation configuration object. To use, create an MdPanelAnimation with the
 * desired properties, then pass the object as part of $mdPanel creation.
 *
 * Example:
 *
 * var panelAnimation = new MdPanelAnimation()
 *     .openFrom(myButtonEl)
 *     .closeTo('.my-button')
 *     .withAnimation($mdPanel.animation.SCALE);
 *
 * $mdPanel.create({
 *   animation: panelAnimation
 * });
 *
 * @param {!angular.$injector} $injector
 * @final @constructor
 */
function MdPanelAnimation($injector) {
  /** @private @const {!angular.$mdUtil} */
  this._$mdUtil = $injector.get('$mdUtil');

  /**
   * @private {{element: !angular.JQLite|undefined, bounds: !DOMRect}|
   *     undefined}
   */
  this._openFrom;

  /**
   * @private {{element: !angular.JQLite|undefined, bounds: !DOMRect}|
   *     undefined}
   */
  this._closeTo;

  /** @private {string|{open: string, close: string}} */
  this._animationClass = '';

  /** @private {number} */
  this._openDuration;

  /** @private {number} */
  this._closeDuration;

  /** @private {number|{open: number, close: number}} */
  this._rawDuration;
}


/**
 * Possible default animations.
 * @enum {string}
 */
MdPanelAnimation.animation = {
  SLIDE: 'md-panel-animate-slide',
  SCALE: 'md-panel-animate-scale',
  FADE: 'md-panel-animate-fade'
};


/**
 * Specifies where to start the open animation. `openFrom` accepts a
 * click event object, query selector, DOM element, or a Rect object that
 * is used to determine the bounds. When passed a click event, the location
 * of the click will be used as the position to start the animation.
 * @param {string|!Element|!Event|{top: number, left: number}} openFrom
 * @returns {!MdPanelAnimation}
 */
MdPanelAnimation.prototype.openFrom = function(openFrom) {
  // Check if 'openFrom' is an Event.
  openFrom = openFrom.target ? openFrom.target : openFrom;

  this._openFrom = this._getPanelAnimationTarget(openFrom);

  if (!this._closeTo) {
    this._closeTo = this._openFrom;
  }
  return this;
};


/**
 * Specifies where to animate the panel close. `closeTo` accepts a
 * query selector, DOM element, or a Rect object that is used to determine
 * the bounds.
 * @param {string|!Element|{top: number, left: number}} closeTo
 * @returns {!MdPanelAnimation}
 */
MdPanelAnimation.prototype.closeTo = function(closeTo) {
  this._closeTo = this._getPanelAnimationTarget(closeTo);
  return this;
};


/**
 * Specifies the duration of the animation in milliseconds.
 * @param {number|{open: number, close: number}} duration
 * @returns {!MdPanelAnimation}
 */
MdPanelAnimation.prototype.duration = function(duration) {
  if (duration) {
    if (angular.isNumber(duration)) {
      this._openDuration = this._closeDuration = toSeconds(duration);
    } else if (angular.isObject(duration)) {
      this._openDuration = toSeconds(duration.open);
      this._closeDuration = toSeconds(duration.close);
    }
  }

  // Save the original value so it can be passed to the backdrop.
  this._rawDuration = duration;

  return this;

  function toSeconds(value) {
    if (angular.isNumber(value)) return value / 1000;
  }
};


/**
 * Returns the element and bounds for the animation target.
 * @param {string|!Element|{top: number, left: number}} location
 * @returns {{element: !angular.JQLite|undefined, bounds: !DOMRect}}
 * @private
 */
MdPanelAnimation.prototype._getPanelAnimationTarget = function(location) {
  if (angular.isDefined(location.top) || angular.isDefined(location.left)) {
    return {
      element: undefined,
      bounds: {
        top: location.top || 0,
        left: location.left || 0
      }
    };
  } else {
    return this._getBoundingClientRect(getElement(location));
  }
};


/**
 * Specifies the animation class.
 *
 * There are several default animations that can be used:
 * (MdPanelAnimation.animation)
 *   SLIDE: The panel slides in and out from the specified
 *        elements.
 *   SCALE: The panel scales in and out.
 *   FADE: The panel fades in and out.
 *
 * @param {string|{open: string, close: string}} cssClass
 * @returns {!MdPanelAnimation}
 */
MdPanelAnimation.prototype.withAnimation = function(cssClass) {
  this._animationClass = cssClass;
  return this;
};


/**
 * Animate the panel open.
 * @param {!angular.JQLite} panelEl
 * @returns {!angular.$q.Promise} A promise that is resolved when the open
 *     animation is complete.
 */
MdPanelAnimation.prototype.animateOpen = function(panelEl) {
  var animator = this._$mdUtil.dom.animator;

  this._fixBounds(panelEl);
  var animationOptions = {};

  // Include the panel transformations when calculating the animations.
  var panelTransform = panelEl[0].style.transform || '';

  var openFrom = animator.toTransformCss(panelTransform);
  var openTo = animator.toTransformCss(panelTransform);

  switch (this._animationClass) {
    case MdPanelAnimation.animation.SLIDE:
      // Slide should start with opacity: 1.
      panelEl.css('opacity', '1');

      animationOptions = {
        transitionInClass: '_md-panel-animate-enter'
      };

      var openSlide = animator.calculateSlideToOrigin(
              panelEl, this._openFrom) || '';
      openFrom = animator.toTransformCss(openSlide + ' ' + panelTransform);
      break;

    case MdPanelAnimation.animation.SCALE:
      animationOptions = {
        transitionInClass: '_md-panel-animate-enter'
      };

      var openScale = animator.calculateZoomToOrigin(
              panelEl, this._openFrom) || '';
      openFrom = animator.toTransformCss(openScale + ' ' + panelTransform);
      break;

    case MdPanelAnimation.animation.FADE:
      animationOptions = {
        transitionInClass: '_md-panel-animate-enter'
      };
      break;

    default:
      if (angular.isString(this._animationClass)) {
        animationOptions = {
          transitionInClass: this._animationClass
        };
      } else {
        animationOptions = {
          transitionInClass: this._animationClass['open'],
          transitionOutClass: this._animationClass['close'],
        };
      }
  }

  animationOptions.duration = this._openDuration;

  return animator
      .translate3d(panelEl, openFrom, openTo, animationOptions);
};


/**
 * Animate the panel close.
 * @param {!angular.JQLite} panelEl
 * @returns {!angular.$q.Promise} A promise that resolves when the close
 *     animation is complete.
 */
MdPanelAnimation.prototype.animateClose = function(panelEl) {
  var animator = this._$mdUtil.dom.animator;
  var reverseAnimationOptions = {};

  // Include the panel transformations when calculating the animations.
  var panelTransform = panelEl[0].style.transform || '';

  var closeFrom = animator.toTransformCss(panelTransform);
  var closeTo = animator.toTransformCss(panelTransform);

  switch (this._animationClass) {
    case MdPanelAnimation.animation.SLIDE:
      // Slide should start with opacity: 1.
      panelEl.css('opacity', '1');
      reverseAnimationOptions = {
        transitionInClass: '_md-panel-animate-leave'
      };

      var closeSlide = animator.calculateSlideToOrigin(
              panelEl, this._closeTo) || '';
      closeTo = animator.toTransformCss(closeSlide + ' ' + panelTransform);
      break;

    case MdPanelAnimation.animation.SCALE:
      reverseAnimationOptions = {
        transitionInClass: '_md-panel-animate-scale-out _md-panel-animate-leave'
      };

      var closeScale = animator.calculateZoomToOrigin(
              panelEl, this._closeTo) || '';
      closeTo = animator.toTransformCss(closeScale + ' ' + panelTransform);
      break;

    case MdPanelAnimation.animation.FADE:
      reverseAnimationOptions = {
        transitionInClass: '_md-panel-animate-fade-out _md-panel-animate-leave'
      };
      break;

    default:
      if (angular.isString(this._animationClass)) {
        reverseAnimationOptions = {
          transitionOutClass: this._animationClass
        };
      } else {
        reverseAnimationOptions = {
          transitionInClass: this._animationClass['close'],
          transitionOutClass: this._animationClass['open']
        };
      }
  }

  reverseAnimationOptions.duration = this._closeDuration;

  return animator
      .translate3d(panelEl, closeFrom, closeTo, reverseAnimationOptions);
};


/**
 * Set the height and width to match the panel if not provided.
 * @param {!angular.JQLite} panelEl
 * @private
 */
MdPanelAnimation.prototype._fixBounds = function(panelEl) {
  var panelWidth = panelEl[0].offsetWidth;
  var panelHeight = panelEl[0].offsetHeight;

  if (this._openFrom && this._openFrom.bounds.height == null) {
    this._openFrom.bounds.height = panelHeight;
  }
  if (this._openFrom && this._openFrom.bounds.width == null) {
    this._openFrom.bounds.width = panelWidth;
  }
  if (this._closeTo && this._closeTo.bounds.height == null) {
    this._closeTo.bounds.height = panelHeight;
  }
  if (this._closeTo && this._closeTo.bounds.width == null) {
    this._closeTo.bounds.width = panelWidth;
  }
};


/**
 * Identify the bounding RECT for the target element.
 * @param {!angular.JQLite} element
 * @returns {{element: !angular.JQLite|undefined, bounds: !DOMRect}}
 * @private
 */
MdPanelAnimation.prototype._getBoundingClientRect = function(element) {
  if (element instanceof angular.element) {
    return {
      element: element,
      bounds: element[0].getBoundingClientRect()
    };
  }
};


/*****************************************************************************
 *                                Util Methods                               *
 *****************************************************************************/


/**
 * Returns the angular element associated with a css selector or element.
 * @param el {string|!angular.JQLite|!Element}
 * @returns {!angular.JQLite}
 */
function getElement(el) {
  var queryResult = angular.isString(el) ?
      document.querySelector(el) : el;
  return angular.element(queryResult);
}

/**
 * Gets the computed values for an element's translateX and translateY in px.
 * @param {!angular.JQLite|!Element} el
 * @param {string} property
 * @return {{x: number, y: number}}
 */
function getComputedTranslations(el, property) {
  // The transform being returned by `getComputedStyle` is in the format:
  // `matrix(a, b, c, d, translateX, translateY)` if defined and `none`
  // if the element doesn't have a transform.
  var transform = getComputedStyle(el[0] || el)[property];
  var openIndex = transform.indexOf('(');
  var closeIndex = transform.lastIndexOf(')');
  var output = { x: 0, y: 0 };

  if (openIndex > -1 && closeIndex > -1) {
    var parsedValues = transform
      .substring(openIndex + 1, closeIndex)
      .split(', ')
      .slice(-2);

    output.x = parseInt(parsedValues[0]);
    output.y = parseInt(parsedValues[1]);
  }

  return output;
}

/**
 * Adds units to a number value.
 * @param {string|number} value
 * @return {string}
 */
function addUnits(value) {
  return angular.isNumber(value) ? value + 'px' : value;
}

})();
(function(){
"use strict";

/**
 * @ngdoc module
 * @name material.components.progressCircular
 * @description Module for a circular progressbar
 */

angular.module('material.components.progressCircular', ['material.core']);

})();
(function(){
"use strict";

/**
 * @ngdoc directive
 * @name mdProgressCircular
 * @module material.components.progressCircular
 * @restrict E
 *
 * @description
 * The circular progress directive is used to make loading content in your app as delightful and
 * painless as possible by minimizing the amount of visual change a user sees before they can view
 * and interact with content.
 *
 * For operations where the percentage of the operation completed can be determined, use a
 * determinate indicator. They give users a quick sense of how long an operation will take.
 *
 * For operations where the user is asked to wait a moment while something finishes up, and it’s
 * not necessary to expose what's happening behind the scenes and how long it will take, use an
 * indeterminate indicator.
 *
 * @param {string} md-mode Select from one of two modes: **'determinate'** and **'indeterminate'**.
 *
 * Note: if the `md-mode` value is set as undefined or specified as not 1 of the two (2) valid modes, then **'indeterminate'**
 * will be auto-applied as the mode.
 *
 * Note: if not configured, the `md-mode="indeterminate"` will be auto injected as an attribute.
 * If `value=""` is also specified, however, then `md-mode="determinate"` would be auto-injected instead.
 * @param {number=} value In determinate mode, this number represents the percentage of the
 *     circular progress. Default: 0
 * @param {number=} md-diameter This specifies the diameter of the circular progress. The value
 * should be a pixel-size value (eg '100'). If this attribute is
 * not present then a default value of '50px' is assumed.
 *
 * @param {boolean=} ng-disabled Determines whether to disable the progress element.
 *
 * @usage
 * <hljs lang="html">
 * <md-progress-circular md-mode="determinate" value="..."></md-progress-circular>
 *
 * <md-progress-circular md-mode="determinate" ng-value="..."></md-progress-circular>
 *
 * <md-progress-circular md-mode="determinate" value="..." md-diameter="100"></md-progress-circular>
 *
 * <md-progress-circular md-mode="indeterminate"></md-progress-circular>
 * </hljs>
 */

MdProgressCircularDirective.$inject = ["$window", "$mdProgressCircular", "$mdTheming", "$mdUtil", "$interval", "$log"];
angular
  .module('material.components.progressCircular')
  .directive('mdProgressCircular', MdProgressCircularDirective);

/* @ngInject */
function MdProgressCircularDirective($window, $mdProgressCircular, $mdTheming,
                                     $mdUtil, $interval, $log) {

  // Note that this shouldn't use use $$rAF, because it can cause an infinite loop
  // in any tests that call $animate.flush.
  var rAF = $window.requestAnimationFrame ||
            $window.webkitRequestAnimationFrame ||
            angular.noop;

  var cAF = $window.cancelAnimationFrame ||
            $window.webkitCancelAnimationFrame ||
            $window.webkitCancelRequestAnimationFrame ||
            angular.noop;

  var MODE_DETERMINATE = 'determinate';
  var MODE_INDETERMINATE = 'indeterminate';
  var DISABLED_CLASS = '_md-progress-circular-disabled';
  var INDETERMINATE_CLASS = 'md-mode-indeterminate';

  return {
    restrict: 'E',
    scope: {
      value: '@',
      mdDiameter: '@',
      mdMode: '@'
    },
    template:
      '<svg xmlns="http://www.w3.org/2000/svg">' +
        '<path fill="none"/>' +
      '</svg>',
    compile: function(element, attrs) {
      element.attr({
        'aria-valuemin': 0,
        'aria-valuemax': 100,
        'role': 'progressbar'
      });

      if (angular.isUndefined(attrs.mdMode)) {
        var mode = attrs.hasOwnProperty('value') ? MODE_DETERMINATE : MODE_INDETERMINATE;
        attrs.$set('mdMode', mode);
      } else {
        attrs.$set('mdMode', attrs.mdMode.trim());
      }

      return MdProgressCircularLink;
    }
  };

  function MdProgressCircularLink(scope, element, attrs) {
    var node = element[0];
    var svg = angular.element(node.querySelector('svg'));
    var path = angular.element(node.querySelector('path'));
    var startIndeterminate = $mdProgressCircular.startIndeterminate;
    var endIndeterminate = $mdProgressCircular.endIndeterminate;
    var iterationCount = 0;
    var lastAnimationId = 0;
    var lastDrawFrame;
    var interval;

    $mdTheming(element);
    element.toggleClass(DISABLED_CLASS, attrs.hasOwnProperty('disabled'));

    // If the mode is indeterminate, it doesn't need to
    // wait for the next digest. It can start right away.
    if (scope.mdMode === MODE_INDETERMINATE){
      startIndeterminateAnimation();
    }

    scope.$on('$destroy', function(){
      cleanupIndeterminateAnimation();

      if (lastDrawFrame) {
        cAF(lastDrawFrame);
      }
    });

    scope.$watchGroup(['value', 'mdMode', function() {
      var isDisabled = node.disabled;

      // Sometimes the browser doesn't return a boolean, in
      // which case we should check whether the attribute is
      // present.
      if (isDisabled === true || isDisabled === false){
        return isDisabled;
      }

      return angular.isDefined(element.attr('disabled'));
    }], function(newValues, oldValues) {
      var mode = newValues[1];
      var isDisabled = newValues[2];
      var wasDisabled = oldValues[2];
      var diameter = 0;
      var strokeWidth = 0;

      if (isDisabled !== wasDisabled) {
        element.toggleClass(DISABLED_CLASS, !!isDisabled);
      }

      if (isDisabled) {
        cleanupIndeterminateAnimation();
      } else {
        if (mode !== MODE_DETERMINATE && mode !== MODE_INDETERMINATE) {
          mode = MODE_INDETERMINATE;
          attrs.$set('mdMode', mode);
        }

        if (mode === MODE_INDETERMINATE) {
          if (oldValues[1] === MODE_DETERMINATE) {
            diameter = getSize(scope.mdDiameter);
            strokeWidth = getStroke(diameter);
            path.attr('d', getSvgArc(diameter, strokeWidth, true));
            path.attr('stroke-dasharray', (diameter - strokeWidth) * $window.Math.PI * 0.75);
          }
          startIndeterminateAnimation();
        } else {
          var newValue = clamp(newValues[0]);
          var oldValue = clamp(oldValues[0]);

          cleanupIndeterminateAnimation();

          if (oldValues[1] === MODE_INDETERMINATE) {
            diameter = getSize(scope.mdDiameter);
            strokeWidth = getStroke(diameter);
            path.attr('d', getSvgArc(diameter, strokeWidth, false));
            path.attr('stroke-dasharray', (diameter - strokeWidth) * $window.Math.PI);
          }

          element.attr('aria-valuenow', newValue);
          renderCircle(oldValue, newValue);
        }
      }

    });

    // This is in a separate watch in order to avoid layout, unless
    // the value has actually changed.
    scope.$watch('mdDiameter', function(newValue) {
      var diameter = getSize(newValue);
      var strokeWidth = getStroke(diameter);
      var value = clamp(scope.value);
      var transformOrigin = (diameter / 2) + 'px';
      var dimensions = {
        width: diameter + 'px',
        height: diameter + 'px'
      };

      // The viewBox has to be applied via setAttribute, because it is
      // case-sensitive. If jQuery is included in the page, `.attr` lowercases
      // all attribute names.
      svg[0].setAttribute('viewBox', '0 0 ' + diameter + ' ' + diameter);

      // Usually viewBox sets the dimensions for the SVG, however that doesn't
      // seem to be the case on IE10.
      // Important! The transform origin has to be set from here and it has to
      // be in the format of "Ypx Ypx Ypx", otherwise the rotation wobbles in
      // IE and Edge, because they don't account for the stroke width when
      // rotating. Also "center" doesn't help in this case, it has to be a
      // precise value.
      svg
        .css(dimensions)
        .css('transform-origin', transformOrigin + ' ' + transformOrigin + ' ' + transformOrigin);

      element.css(dimensions);

      path.attr('stroke-width', strokeWidth);
      path.attr('stroke-linecap', 'square');
      if (scope.mdMode == MODE_INDETERMINATE) {
        path.attr('d', getSvgArc(diameter, strokeWidth, true));
        path.attr('stroke-dasharray', (diameter - strokeWidth) * $window.Math.PI * 0.75);
        path.attr('stroke-dashoffset', getDashLength(diameter, strokeWidth, 1, 75));
      } else {
        path.attr('d', getSvgArc(diameter, strokeWidth, false));
        path.attr('stroke-dasharray', (diameter - strokeWidth) * $window.Math.PI);
        path.attr('stroke-dashoffset', getDashLength(diameter, strokeWidth, 0, 100));
        renderCircle(value, value);
      }

    });

    function renderCircle(animateFrom, animateTo, easing, duration, iterationCount, maxValue) {
      var id = ++lastAnimationId;
      var startTime = $mdUtil.now();
      var changeInValue = animateTo - animateFrom;
      var diameter = getSize(scope.mdDiameter);
      var strokeWidth = getStroke(diameter);
      var ease = easing || $mdProgressCircular.easeFn;
      var animationDuration = duration || $mdProgressCircular.duration;
      var rotation = -90 * (iterationCount || 0);
      var dashLimit = maxValue || 100;

      // No need to animate it if the values are the same
      if (animateTo === animateFrom) {
        renderFrame(animateTo);
      } else {
        lastDrawFrame = rAF(function animation() {
          var currentTime = $window.Math.max(0, $window.Math.min($mdUtil.now() - startTime, animationDuration));

          renderFrame(ease(currentTime, animateFrom, changeInValue, animationDuration));

          // Do not allow overlapping animations
          if (id === lastAnimationId && currentTime < animationDuration) {
            lastDrawFrame = rAF(animation);
          }
        });
      }

      function renderFrame(value) {
        path.attr('stroke-dashoffset', getDashLength(diameter, strokeWidth, value, dashLimit));
        path.attr('transform','rotate(' + (rotation) + ' ' + diameter/2 + ' ' + diameter/2 + ')');
      }
    }

    function animateIndeterminate() {
      renderCircle(
        startIndeterminate,
        endIndeterminate,
        $mdProgressCircular.easeFnIndeterminate,
        $mdProgressCircular.durationIndeterminate,
        iterationCount,
        75
      );

      // The %4 technically isn't necessary, but it keeps the rotation
      // under 360, instead of becoming a crazy large number.
      iterationCount = ++iterationCount % 4;

    }

    function startIndeterminateAnimation() {
      if (!interval) {
        // Note that this interval isn't supposed to trigger a digest.
        interval = $interval(
          animateIndeterminate,
          $mdProgressCircular.durationIndeterminate,
          0,
          false
        );

        animateIndeterminate();

        element
          .addClass(INDETERMINATE_CLASS)
          .removeAttr('aria-valuenow');
      }
    }

    function cleanupIndeterminateAnimation() {
      if (interval) {
        $interval.cancel(interval);
        interval = null;
        element.removeClass(INDETERMINATE_CLASS);
      }
    }
  }

  /**
   * Returns SVG path data for progress circle
   * Syntax spec: https://www.w3.org/TR/SVG/paths.html#PathDataEllipticalArcCommands
   *
   * @param {number} diameter Diameter of the container.
   * @param {number} strokeWidth Stroke width to be used when drawing circle
   * @param {boolean} indeterminate Use if progress circle will be used for indeterminate
   *
   * @returns {string} String representation of an SVG arc.
   */
  function getSvgArc(diameter, strokeWidth, indeterminate) {
    var radius = diameter / 2;
    var offset = strokeWidth / 2;
    var start = radius + ',' + offset; // ie: (25, 2.5) or 12 o'clock
    var end = offset + ',' + radius;   // ie: (2.5, 25) or  9 o'clock
    var arcRadius = radius - offset;
    return 'M' + start
         + 'A' + arcRadius + ',' + arcRadius + ' 0 1 1 ' + end // 75% circle
         + (indeterminate ? '' : 'A' + arcRadius + ',' + arcRadius + ' 0 0 1 ' + start); // loop to start
  }

  /**
   * Return stroke length for progress circle
   *
   * @param {number} diameter Diameter of the container.
   * @param {number} strokeWidth Stroke width to be used when drawing circle
   * @param {number} value Percentage of circle (between 0 and 100)
   * @param {number} limit Max percentage for circle
   *
   * @returns {number} Stroke length for progres circle
   */
  function getDashLength(diameter, strokeWidth, value, limit) {
    return (diameter - strokeWidth) * $window.Math.PI * ((3 * (limit || 100) / 100) - (value/100));
  }

  /**
   * Limits a value between 0 and 100.
   */
  function clamp(value) {
    return $window.Math.max(0, $window.Math.min(value || 0, 100));
  }

  /**
   * Determines the size of a progress circle, based on the provided
   * value in the following formats: `X`, `Ypx`, `Z%`.
   */
  function getSize(value) {
    var defaultValue = $mdProgressCircular.progressSize;

    if (value) {
      var parsed = parseFloat(value);

      if (value.lastIndexOf('%') === value.length - 1) {
        parsed = (parsed / 100) * defaultValue;
      }

      return parsed;
    }

    return defaultValue;
  }

  /**
   * Determines the circle's stroke width, based on
   * the provided diameter.
   */
  function getStroke(diameter) {
    return $mdProgressCircular.strokeWidth / 100 * diameter;
  }

}

})();
(function(){
"use strict";

/**
 * @ngdoc service
 * @name $mdProgressCircular
 * @module material.components.progressCircular
 *
 * @description
 * Allows the user to specify the default options for the `progressCircular` directive.
 *
 * @property {number} progressSize Diameter of the progress circle in pixels.
 * @property {number} strokeWidth Width of the circle's stroke as a percentage of the circle's size.
 * @property {number} duration Length of the circle animation in milliseconds.
 * @property {function} easeFn Default easing animation function.
 * @property {object} easingPresets Collection of pre-defined easing functions.
 *
 * @property {number} durationIndeterminate Duration of the indeterminate animation.
 * @property {number} startIndeterminate Indeterminate animation start point.
 * @property {number} endIndeterminate Indeterminate animation end point.
 * @property {function} easeFnIndeterminate Easing function to be used when animating
 * between the indeterminate values.
 *
 * @property {(function(object): object)} configure Used to modify the default options.
 *
 * @usage
 * <hljs lang="js">
 *   myAppModule.config(function($mdProgressCircularProvider) {
 *
 *     // Example of changing the default progress options.
 *     $mdProgressCircularProvider.configure({
 *       progressSize: 100,
 *       strokeWidth: 20,
 *       duration: 800
 *     });
 * });
 * </hljs>
 *
 */

angular
  .module('material.components.progressCircular')
  .provider("$mdProgressCircular", MdProgressCircularProvider);

function MdProgressCircularProvider() {
  var progressConfig = {
    progressSize: 50,
    strokeWidth: 10,
    duration: 100,
    easeFn: linearEase,

    durationIndeterminate: 1333,
    startIndeterminate: 1,
    endIndeterminate: 149,
    easeFnIndeterminate: materialEase,

    easingPresets: {
      linearEase: linearEase,
      materialEase: materialEase
    }
  };

  return {
    configure: function(options) {
      progressConfig = angular.extend(progressConfig, options || {});
      return progressConfig;
    },
    $get: function() { return progressConfig; }
  };

  function linearEase(t, b, c, d) {
    return c * t / d + b;
  }

  function materialEase(t, b, c, d) {
    // via http://www.timotheegroleau.com/Flash/experiments/easing_function_generator.htm
    // with settings of [0, 0, 1, 1]
    var ts = (t /= d) * t;
    var tc = ts * t;
    return b + c * (6 * tc * ts + -15 * ts * ts + 10 * tc);
  }
}

})();
(function(){
"use strict";

/**
 * @ngdoc module
 * @name material.components.progressLinear
 * @description Linear Progress module!
 */
MdProgressLinearDirective.$inject = ["$mdTheming", "$mdUtil", "$log"];
angular.module('material.components.progressLinear', [
  'material.core'
])
  .directive('mdProgressLinear', MdProgressLinearDirective);

/**
 * @ngdoc directive
 * @name mdProgressLinear
 * @module material.components.progressLinear
 * @restrict E
 *
 * @description
 * The linear progress directive is used to make loading content
 * in your app as delightful and painless as possible by minimizing
 * the amount of visual change a user sees before they can view
 * and interact with content.
 *
 * Each operation should only be represented by one activity indicator
 * For example: one refresh operation should not display both a
 * refresh bar and an activity circle.
 *
 * For operations where the percentage of the operation completed
 * can be determined, use a determinate indicator. They give users
 * a quick sense of how long an operation will take.
 *
 * For operations where the user is asked to wait a moment while
 * something finishes up, and it’s not necessary to expose what's
 * happening behind the scenes and how long it will take, use an
 * indeterminate indicator.
 *
 * @param {string} md-mode Select from one of four modes: determinate, indeterminate, buffer or query.
 *
 * Note: if the `md-mode` value is set as undefined or specified as 1 of the four (4) valid modes, then `indeterminate`
 * will be auto-applied as the mode.
 *
 * Note: if not configured, the `md-mode="indeterminate"` will be auto injected as an attribute. If `value=""` is also specified, however,
 * then `md-mode="determinate"` would be auto-injected instead.
 * @param {number=} value In determinate and buffer modes, this number represents the percentage of the primary progress bar. Default: 0
 * @param {number=} md-buffer-value In the buffer mode, this number represents the percentage of the secondary progress bar. Default: 0
 * @param {boolean=} ng-disabled Determines whether to disable the progress element.
 *
 * @usage
 * <hljs lang="html">
 * <md-progress-linear md-mode="determinate" value="..."></md-progress-linear>
 *
 * <md-progress-linear md-mode="determinate" ng-value="..."></md-progress-linear>
 *
 * <md-progress-linear md-mode="indeterminate"></md-progress-linear>
 *
 * <md-progress-linear md-mode="buffer" value="..." md-buffer-value="..."></md-progress-linear>
 *
 * <md-progress-linear md-mode="query"></md-progress-linear>
 * </hljs>
 */
function MdProgressLinearDirective($mdTheming, $mdUtil, $log) {
  var MODE_DETERMINATE = "determinate";
  var MODE_INDETERMINATE = "indeterminate";
  var MODE_BUFFER = "buffer";
  var MODE_QUERY = "query";
  var DISABLED_CLASS = "_md-progress-linear-disabled";

  return {
    restrict: 'E',
    template: '<div class="md-container">' +
      '<div class="md-dashed"></div>' +
      '<div class="md-bar md-bar1"></div>' +
      '<div class="md-bar md-bar2"></div>' +
      '</div>',
    compile: compile
  };

  function compile(tElement, tAttrs, transclude) {
    tElement.attr('aria-valuemin', 0);
    tElement.attr('aria-valuemax', 100);
    tElement.attr('role', 'progressbar');

    return postLink;
  }
  function postLink(scope, element, attr) {
    $mdTheming(element);

    var lastMode;
    var isDisabled = attr.hasOwnProperty('disabled');
    var toVendorCSS = $mdUtil.dom.animator.toCss;
    var bar1 = angular.element(element[0].querySelector('.md-bar1'));
    var bar2 = angular.element(element[0].querySelector('.md-bar2'));
    var container = angular.element(element[0].querySelector('.md-container'));

    element
      .attr('md-mode', mode())
      .toggleClass(DISABLED_CLASS, isDisabled);

    validateMode();
    watchAttributes();

    /**
     * Watch the value, md-buffer-value, and md-mode attributes
     */
    function watchAttributes() {
      attr.$observe('value', function(value) {
        var percentValue = clamp(value);
        element.attr('aria-valuenow', percentValue);

        if (mode() != MODE_QUERY) animateIndicator(bar2, percentValue);
      });

      attr.$observe('mdBufferValue', function(value) {
        animateIndicator(bar1, clamp(value));
      });

      attr.$observe('disabled', function(value) {
        if (value === true || value === false) {
          isDisabled = !!value;
        } else {
          isDisabled = angular.isDefined(value);
        }

        element.toggleClass(DISABLED_CLASS, isDisabled);
        container.toggleClass(lastMode, !isDisabled);
      });

      attr.$observe('mdMode', function(mode) {
        if (lastMode) container.removeClass(lastMode);

        switch (mode) {
          case MODE_QUERY:
          case MODE_BUFFER:
          case MODE_DETERMINATE:
          case MODE_INDETERMINATE:
            container.addClass(lastMode = "md-mode-" + mode);
            break;
          default:
            container.addClass(lastMode = "md-mode-" + MODE_INDETERMINATE);
            break;
        }
      });
    }

    /**
     * Auto-defaults the mode to either `determinate` or `indeterminate` mode; if not specified
     */
    function validateMode() {
      if (angular.isUndefined(attr.mdMode)) {
        var hasValue = angular.isDefined(attr.value);
        var mode = hasValue ? MODE_DETERMINATE : MODE_INDETERMINATE;
        var info = "Auto-adding the missing md-mode='{0}' to the ProgressLinear element";
        element.attr("md-mode", mode);
        attr.mdMode = mode;
      }
    }

    /**
     * Is the md-mode a valid option?
     */
    function mode() {
      var value = (attr.mdMode || "").trim();
      if (value) {
        switch (value) {
          case MODE_DETERMINATE:
          case MODE_INDETERMINATE:
          case MODE_BUFFER:
          case MODE_QUERY:
            break;
          default:
            value = MODE_INDETERMINATE;
            break;
        }
      }
      return value;
    }

    /**
     * Manually set CSS to animate the Determinate indicator based on the specified
     * percentage value (0-100).
     */
    function animateIndicator(target, value) {
      if (isDisabled || !mode()) return;

      var to = $mdUtil.supplant("translateX({0}%) scale({1},1)", [(value-100)/2, value/100]);
      var styles = toVendorCSS({ transform : to });
      angular.element(target).css(styles);
    }
  }

  /**
   * Clamps the value to be between 0 and 100.
   * @param {number} value The value to clamp.
   * @returns {number}
   */
  function clamp(value) {
    return Math.max(0, Math.min(value || 0, 100));
  }
}


})();
(function(){
"use strict";

/**
 * @ngdoc module
 * @name material.components.radioButton
 * @description radioButton module!
 */
mdRadioGroupDirective.$inject = ["$mdUtil", "$mdConstant", "$mdTheming", "$timeout"];
mdRadioButtonDirective.$inject = ["$mdAria", "$mdUtil", "$mdTheming"];
angular.module('material.components.radioButton', [
  'material.core'
])
  .directive('mdRadioGroup', mdRadioGroupDirective)
  .directive('mdRadioButton', mdRadioButtonDirective);

/**
 * @ngdoc directive
 * @module material.components.radioButton
 * @name mdRadioGroup
 *
 * @restrict E
 *
 * @description
 * The `<md-radio-group>` directive identifies a grouping
 * container for the 1..n grouped radio buttons; specified using nested
 * `<md-radio-button>` elements.
 *
 * The radio button uses the accent color by default. The primary color palette may be used with
 * the `md-primary` class.
 *
 * Note: `<md-radio-group>` and `<md-radio-button>` handle `tabindex` differently
 * than the native `<input type="radio">` controls. Whereas the native controls
 * force the user to tab through all the radio buttons, `<md-radio-group>`
 * is focusable and by default the `<md-radio-button>`s are not.
 *
 * @param {string} ng-model Assignable angular expression to data-bind to.
 * @param {string=} ng-change AngularJS expression to be executed when input changes due to user
 *    interaction.
 * @param {boolean=} md-no-ink If present, disables ink ripple effects.
 *
 * @usage
 * <hljs lang="html">
 * <md-radio-group ng-model="selected">
 *   <md-radio-button ng-repeat="item in items"
 *                    ng-value="item.value" aria-label="{{item.label}}">
 *     {{ item.label }}
 *   </md-radio-button>
 * </md-radio-group>
 * </hljs>
 */
function mdRadioGroupDirective($mdUtil, $mdConstant, $mdTheming, $timeout) {
  RadioGroupController.prototype = createRadioGroupControllerProto();

  return {
    restrict: 'E',
    controller: ['$element', RadioGroupController],
    require: ['mdRadioGroup', '?ngModel'],
    link: { pre: linkRadioGroup }
  };

  function linkRadioGroup(scope, element, attr, ctrls) {
    element.addClass('_md');     // private md component indicator for styling
    $mdTheming(element);

    var rgCtrl = ctrls[0];
    var ngModelCtrl = ctrls[1] || $mdUtil.fakeNgModel();

    rgCtrl.init(ngModelCtrl);

    scope.mouseActive = false;

    element
      .attr({
        'role': 'radiogroup',
        'tabIndex': element.attr('tabindex') || '0'
      })
      .on('keydown', keydownListener)
      .on('mousedown', function(event) {
        scope.mouseActive = true;
        $timeout(function() {
          scope.mouseActive = false;
        }, 100);
      })
      .on('focus', function() {
        if (scope.mouseActive === false) {
          rgCtrl.$element.addClass('md-focused');
        }
      })
      .on('blur', function() {
        rgCtrl.$element.removeClass('md-focused');
      });

    /**
     *
     */
    function setFocus() {
      if (!element.hasClass('md-focused')) { element.addClass('md-focused'); }
    }

    /**
     *
     */
    function keydownListener(ev) {
      var keyCode = ev.which || ev.keyCode;

      // Only listen to events that we originated ourselves
      // so that we don't trigger on things like arrow keys in
      // inputs.

      if (keyCode != $mdConstant.KEY_CODE.ENTER &&
          ev.currentTarget != ev.target) {
        return;
      }

      switch (keyCode) {
        case $mdConstant.KEY_CODE.LEFT_ARROW:
        case $mdConstant.KEY_CODE.UP_ARROW:
          ev.preventDefault();
          rgCtrl.selectPrevious();
          setFocus();
          break;

        case $mdConstant.KEY_CODE.RIGHT_ARROW:
        case $mdConstant.KEY_CODE.DOWN_ARROW:
          ev.preventDefault();
          rgCtrl.selectNext();
          setFocus();
          break;

        case $mdConstant.KEY_CODE.ENTER:
          var form = angular.element($mdUtil.getClosest(element[0], 'form'));
          if (form.length > 0) {
            form.triggerHandler('submit');
          }
          break;
      }

    }
  }

  function RadioGroupController($element) {
    this._radioButtonRenderFns = [];
    this.$element = $element;
  }

  function createRadioGroupControllerProto() {
    return {
      init: function(ngModelCtrl) {
        this._ngModelCtrl = ngModelCtrl;
        this._ngModelCtrl.$render = angular.bind(this, this.render);
      },
      add: function(rbRender) {
        this._radioButtonRenderFns.push(rbRender);
      },
      remove: function(rbRender) {
        var index = this._radioButtonRenderFns.indexOf(rbRender);
        if (index !== -1) {
          this._radioButtonRenderFns.splice(index, 1);
        }
      },
      render: function() {
        this._radioButtonRenderFns.forEach(function(rbRender) {
          rbRender();
        });
      },
      setViewValue: function(value, eventType) {
        this._ngModelCtrl.$setViewValue(value, eventType);
        // update the other radio buttons as well
        this.render();
      },
      getViewValue: function() {
        return this._ngModelCtrl.$viewValue;
      },
      selectNext: function() {
        return changeSelectedButton(this.$element, 1);
      },
      selectPrevious: function() {
        return changeSelectedButton(this.$element, -1);
      },
      setActiveDescendant: function (radioId) {
        this.$element.attr('aria-activedescendant', radioId);
      },
      isDisabled: function() {
        return this.$element[0].hasAttribute('disabled');
      }
    };
  }
  /**
   * Change the radio group's selected button by a given increment.
   * If no button is selected, select the first button.
   */
  function changeSelectedButton(parent, increment) {
    // Coerce all child radio buttons into an array, then wrap then in an iterator
    var buttons = $mdUtil.iterator(parent[0].querySelectorAll('md-radio-button'), true);

    if (buttons.count()) {
      var validate = function (button) {
        // If disabled, then NOT valid
        return !angular.element(button).attr("disabled");
      };

      var selected = parent[0].querySelector('md-radio-button.md-checked');
      var target = buttons[increment < 0 ? 'previous' : 'next'](selected, validate) || buttons.first();

      // Activate radioButton's click listener (triggerHandler won't create a real click event)
      angular.element(target).triggerHandler('click');
    }
  }

}

/**
 * @ngdoc directive
 * @module material.components.radioButton
 * @name mdRadioButton
 *
 * @restrict E
 *
 * @description
 * The `<md-radio-button>`directive is the child directive required to be used within `<md-radio-group>` elements.
 *
 * While similar to the `<input type="radio" ng-model="" value="">` directive,
 * the `<md-radio-button>` directive provides ink effects, ARIA support, and
 * supports use within named radio groups.
 *
 * One of `value` or `ng-value` must be set so that the `md-radio-group`'s model is set properly when the
 * `md-radio-button` is selected.
 *
 * @param {string} value The value to which the model should be set when selected.
 * @param {string} ng-value AngularJS expression which sets the value to which the model should
 *    be set when selected.
 * @param {string=} name Property name of the form under which the control is published.
 * @param {string=} aria-label Adds label to radio button for accessibility.
 *    Defaults to radio button's text. If no text content is available, a warning will be logged.
 *
 * @usage
 * <hljs lang="html">
 *
 * <md-radio-button value="1" aria-label="Label 1">
 *   Label 1
 * </md-radio-button>
 *
 * <md-radio-button ng-value="specialValue" aria-label="Green">
 *   Green
 * </md-radio-button>
 *
 * </hljs>
 *
 */
function mdRadioButtonDirective($mdAria, $mdUtil, $mdTheming) {

  var CHECKED_CSS = 'md-checked';

  return {
    restrict: 'E',
    require: '^mdRadioGroup',
    transclude: true,
    template: '<div class="md-container" md-ink-ripple md-ink-ripple-checkbox>' +
                '<div class="md-off"></div>' +
                '<div class="md-on"></div>' +
              '</div>' +
              '<div ng-transclude class="md-label"></div>',
    link: link
  };

  function link(scope, element, attr, rgCtrl) {
    var lastChecked;

    $mdTheming(element);
    configureAria(element, scope);

    // ngAria overwrites the aria-checked inside a $watch for ngValue.
    // We should defer the initialization until all the watches have fired.
    // This can also be fixed by removing the `lastChecked` check, but that'll
    // cause more DOM manipulation on each digest.
    if (attr.ngValue) {
      $mdUtil.nextTick(initialize, false);
    } else {
      initialize();
    }

    /**
     * Initializes the component.
     */
    function initialize() {
      if (!rgCtrl) {
        throw 'RadioButton: No RadioGroupController could be found.';
      }

      rgCtrl.add(render);
      attr.$observe('value', render);

      element
        .on('click', listener)
        .on('$destroy', function() {
          rgCtrl.remove(render);
        });
    }

    /**
     * On click functionality.
     */
    function listener(ev) {
      if (element[0].hasAttribute('disabled') || rgCtrl.isDisabled()) return;

      scope.$apply(function() {
        rgCtrl.setViewValue(attr.value, ev && ev.type);
      });
    }

    /**
     *  Add or remove the `.md-checked` class from the RadioButton (and conditionally its parent).
     *  Update the `aria-activedescendant` attribute.
     */
    function render() {
      var checked = rgCtrl.getViewValue() == attr.value;

      if (checked === lastChecked) return;

      if (element[0].parentNode.nodeName.toLowerCase() !== 'md-radio-group') {
        // If the radioButton is inside a div, then add class so highlighting will work
        element.parent().toggleClass(CHECKED_CSS, checked);
      }

      if (checked) {
        rgCtrl.setActiveDescendant(element.attr('id'));
      }

      lastChecked = checked;

      element
        .attr('aria-checked', checked)
        .toggleClass(CHECKED_CSS, checked);
    }

    /**
     * Inject ARIA-specific attributes appropriate for each radio button
     */
    function configureAria(element, scope){
      element.attr({
        id: attr.id || 'radio_' + $mdUtil.nextUid(),
        role: 'radio',
        'aria-checked': 'false'
      });

      $mdAria.expectWithText(element, 'aria-label');
    }
  }
}

})();
(function(){
"use strict";

/**
 * @ngdoc module
 * @name material.components.select
 */

/***************************************************

 ### TODO ###
 - [ ] Abstract placement logic in $mdSelect service to $mdMenu service

 ***************************************************/

SelectDirective.$inject = ["$mdSelect", "$mdUtil", "$mdConstant", "$mdTheming", "$mdAria", "$parse", "$sce", "$injector"];
SelectMenuDirective.$inject = ["$parse", "$mdUtil", "$mdConstant", "$mdTheming"];
OptionDirective.$inject = ["$mdButtonInkRipple", "$mdUtil", "$mdTheming"];
SelectProvider.$inject = ["$$interimElementProvider"];
var SELECT_EDGE_MARGIN = 8;
var selectNextId = 0;
var CHECKBOX_SELECTION_INDICATOR =
  angular.element('<div class="md-container"><div class="md-icon"></div></div>');

angular.module('material.components.select', [
    'material.core',
    'material.components.backdrop'
  ])
  .directive('mdSelect', SelectDirective)
  .directive('mdSelectMenu', SelectMenuDirective)
  .directive('mdOption', OptionDirective)
  .directive('mdOptgroup', OptgroupDirective)
  .directive('mdSelectHeader', SelectHeaderDirective)
  .provider('$mdSelect', SelectProvider);

/**
 * @ngdoc directive
 * @name mdSelect
 * @restrict E
 * @module material.components.select
 *
 * @description Displays a select box, bound to an `ng-model`. Selectable options are defined using
 * the <a ng-href="/api/directive/mdOption">md-option</a> element directive. Options can be grouped
 * using the <a ng-href="/api/directive/mdOptgroup">md-optgroup</a> element directive.
 *
 * When the select is required and uses a floating label, then the label will automatically contain
 * an asterisk (`*`). This behavior can be disabled by using the `md-no-asterisk` attribute.
 *
 * By default, the select will display with an underline to match other form elements. This can be
 * disabled by applying the `md-no-underline` CSS class.
 *
 * @param {expression} ng-model Assignable angular expression to data-bind to.
 * @param {expression=} ng-change Expression to be executed when the model value changes.
 * @param {boolean=} multiple When present, allows for more than one option to be selected.
 *  The model is an array with the selected choices. **Note:** This attribute is only evaluated
 *  once; it is not watched.
 * @param {expression=} md-on-close Expression to be evaluated when the select is closed.
 * @param {expression=} md-on-open Expression to be evaluated when opening the select.
 * Will hide the select options and show a spinner until the evaluated promise resolves.
 * @param {expression=} md-selected-text Expression to be evaluated that will return a string
 * to be displayed as a placeholder in the select input box when it is closed. The value
 * will be treated as *text* (not html).
 * @param {expression=} md-selected-html Expression to be evaluated that will return a string
 * to be displayed as a placeholder in the select input box when it is closed. The value
 * will be treated as *html*. The value must either be explicitly marked as trustedHtml or
 * the ngSanitize module must be loaded.
 * @param {string=} placeholder Placeholder hint text.
 * @param {boolean=} md-no-asterisk When set to true, an asterisk will not be appended to the
 * floating label. **Note:** This attribute is only evaluated once; it is not watched.
 * @param {string=} aria-label Optional label for accessibility. Only necessary if no placeholder or
 * explicit label is present.
 * @param {string=} md-container-class Class list to get applied to the `.md-select-menu-container`
 * element (for custom styling).
 *
 * @usage
 * With a placeholder (label and aria-label are added dynamically)
 * <hljs lang="html">
 *   <md-input-container>
 *     <md-select
 *       ng-model="someModel"
 *       placeholder="Select a state">
 *       <md-option ng-value="opt" ng-repeat="opt in neighborhoods2">{{ opt }}</md-option>
 *     </md-select>
 *   </md-input-container>
 * </hljs>
 *
 * With an explicit label
 * <hljs lang="html">
 *   <md-input-container>
 *     <label>State</label>
 *     <md-select
 *       ng-model="someModel">
 *       <md-option ng-value="opt" ng-repeat="opt in neighborhoods2">{{ opt }}</md-option>
 *     </md-select>
 *   </md-input-container>
 * </hljs>
 *
 * Using the `md-select-header` element directive
 *
 * When a developer needs to put more than just a text label in the `md-select-menu`, they should
 * use one or more `md-select-header`s. These elements can contain custom HTML which can be styled
 * as desired. Use cases for this element include a sticky search bar and custom option group
 * labels.
 *
 * <hljs lang="html">
 *   <md-input-container>
 *     <md-select ng-model="someModel">
 *       <md-select-header>
 *         <span> Neighborhoods - </span>
 *       </md-select-header>
 *       <md-option ng-value="opt" ng-repeat="opt in neighborhoods2">{{ opt }}</md-option>
 *     </md-select>
 *   </md-input-container>
 * </hljs>
 *
 * ## Selects and object equality
 * When using a `md-select` to pick from a list of objects, it is important to realize how javascript handles
 * equality. Consider the following example:
 * <hljs lang="js">
 * angular.controller('MyCtrl', function($scope) {
 *   $scope.users = [
 *     { id: 1, name: 'Bob' },
 *     { id: 2, name: 'Alice' },
 *     { id: 3, name: 'Steve' }
 *   ];
 *   $scope.selectedUser = { id: 1, name: 'Bob' };
 * });
 * </hljs>
 * <hljs lang="html">
 * <div ng-controller="MyCtrl">
 *   <md-select ng-model="selectedUser">
 *     <md-option ng-value="user" ng-repeat="user in users">{{ user.name }}</md-option>
 *   </md-select>
 * </div>
 * </hljs>
 *
 * At first one might expect that the select should be populated with "Bob" as the selected user.
 * However, this is not true. To determine whether something is selected,
 * `ngModelController` is looking at whether `$scope.selectedUser == (any user in $scope.users);`;
 *
 * Javascript's `==` operator does not check for deep equality (ie. that all properties
 * on the object are the same), but instead whether the objects are *the same object in memory*.
 * In this case, we have two instances of identical objects, but they exist in memory as unique
 * entities. Because of this, the select will have no value populated for a selected user.
 *
 * To get around this, `ngModelController` provides a `track by` option that allows us to specify a
 * different expression which will be used for the equality operator. As such, we can update our
 * `html` to make use of this by specifying the `ng-model-options="{trackBy: '$value.id'}"` on the
 * `md-select` element. This converts our equality expression to be
 * `$scope.selectedUser.id == (any id in $scope.users.map(function(u) { return u.id; }));`
 * which results in Bob being selected as desired.
 *
 * **Note:** We do not support AngularJS's `track by` syntax. For instance
 *  `ng-options="user in users track by user.id"` will not work with `md-select`.
 *
 * Working HTML:
 * <hljs lang="html">
 * <div ng-controller="MyCtrl">
 *   <md-select ng-model="selectedUser" ng-model-options="{trackBy: '$value.id'}">
 *     <md-option ng-value="user" ng-repeat="user in users">{{ user.name }}</md-option>
 *   </md-select>
 * </div>
 * </hljs>
 */
function SelectDirective($mdSelect, $mdUtil, $mdConstant, $mdTheming, $mdAria, $parse, $sce,
    $injector) {
  var keyCodes = $mdConstant.KEY_CODE;
  var NAVIGATION_KEYS = [keyCodes.SPACE, keyCodes.ENTER, keyCodes.UP_ARROW, keyCodes.DOWN_ARROW];

  return {
    restrict: 'E',
    require: ['^?mdInputContainer', 'mdSelect', 'ngModel', '?^form'],
    compile: compile,
    controller: function() {
    } // empty placeholder controller to be initialized in link
  };

  function compile(element, attr) {
    // add the select value that will hold our placeholder or selected option value
    var valueEl = angular.element('<md-select-value><span></span></md-select-value>');
    valueEl.append('<span class="md-select-icon" aria-hidden="true"></span>');
    valueEl.addClass('md-select-value');
    if (!valueEl[0].hasAttribute('id')) {
      valueEl.attr('id', 'select_value_label_' + $mdUtil.nextUid());
    }

    // There's got to be an md-content inside. If there's not one, let's add it.
    var mdContentEl = element.find('md-content');
    if (!mdContentEl.length) {
      element.append(angular.element('<md-content>').append(element.contents()));
    }
    mdContentEl.attr('role', 'presentation');


    // Add progress spinner for md-options-loading
    if (attr.mdOnOpen) {

      // Show progress indicator while loading async
      // Use ng-hide for `display:none` so the indicator does not interfere with the options list
      element
        .find('md-content')
        .prepend(angular.element(
          '<div>' +
          ' <md-progress-circular md-mode="indeterminate" ng-if="$$loadingAsyncDone === false" md-diameter="25px"></md-progress-circular>' +
          '</div>'
        ));

      // Hide list [of item options] while loading async
      element
        .find('md-option')
        .attr('ng-show', '$$loadingAsyncDone');
    }

    if (attr.name) {
      var autofillClone = angular.element('<select class="md-visually-hidden"></select>');
      autofillClone.attr({
        'name': attr.name,
        'aria-hidden': 'true',
        'tabindex': '-1'
      });
      var opts = element.find('md-option');
      angular.forEach(opts, function(el) {
        var newEl = angular.element('<option>' + el.innerHTML + '</option>');
        if (el.hasAttribute('ng-value')) newEl.attr('ng-value', el.getAttribute('ng-value'));
        else if (el.hasAttribute('value')) newEl.attr('value', el.getAttribute('value'));
        autofillClone.append(newEl);
      });

      // Adds an extra option that will hold the selected value for the
      // cases where the select is a part of a non-angular form. This can be done with a ng-model,
      // however if the `md-option` is being `ng-repeat`-ed, AngularJS seems to insert a similar
      // `option` node, but with a value of `? string: <value> ?` which would then get submitted.
      // This also goes around having to prepend a dot to the name attribute.
      autofillClone.append(
        '<option ng-value="' + attr.ngModel + '" selected></option>'
      );

      element.parent().append(autofillClone);
    }

    var isMultiple = $mdUtil.parseAttributeBoolean(attr.multiple);

    // Use everything that's left inside element.contents() as the contents of the menu
    var multipleContent = isMultiple ? 'multiple' : '';
    var selectTemplate = '' +
      '<div class="md-select-menu-container" aria-hidden="true" role="presentation">' +
      '<md-select-menu role="presentation" {0}>{1}</md-select-menu>' +
      '</div>';

    selectTemplate = $mdUtil.supplant(selectTemplate, [multipleContent, element.html()]);
    element.empty().append(valueEl);
    element.append(selectTemplate);

    if (!attr.tabindex){
      attr.$set('tabindex', 0);
    }

    return function postLink(scope, element, attr, ctrls) {
      var untouched = true;
      var isDisabled, ariaLabelBase;

      var containerCtrl = ctrls[0];
      var mdSelectCtrl = ctrls[1];
      var ngModelCtrl = ctrls[2];
      var formCtrl = ctrls[3];
      // grab a reference to the select menu value label
      var valueEl = element.find('md-select-value');
      var isReadonly = angular.isDefined(attr.readonly);
      var disableAsterisk = $mdUtil.parseAttributeBoolean(attr.mdNoAsterisk);

      if (disableAsterisk) {
        element.addClass('md-no-asterisk');
      }

      if (containerCtrl) {
        var isErrorGetter = containerCtrl.isErrorGetter || function() {
          return ngModelCtrl.$invalid && (ngModelCtrl.$touched || (formCtrl && formCtrl.$submitted));
        };

        if (containerCtrl.input) {
          // We ignore inputs that are in the md-select-header (one
          // case where this might be useful would be adding as searchbox)
          if (element.find('md-select-header').find('input')[0] !== containerCtrl.input[0]) {
            throw new Error("<md-input-container> can only have *one* child <input>, <textarea> or <select> element!");
          }
        }

        containerCtrl.input = element;
        if (!containerCtrl.label) {
          $mdAria.expect(element, 'aria-label', element.attr('placeholder'));
        }

        scope.$watch(isErrorGetter, containerCtrl.setInvalid);
      }

      var selectContainer, selectScope, selectMenuCtrl;

      findSelectContainer();
      $mdTheming(element);

      var originalRender = ngModelCtrl.$render;
      ngModelCtrl.$render = function() {
        originalRender();
        syncLabelText();
        syncAriaLabel();
        inputCheckValue();
      };

      attr.$observe('placeholder', ngModelCtrl.$render);

      if (containerCtrl && containerCtrl.label) {
        attr.$observe('required', function (value) {
          // Toggle the md-required class on the input containers label, because the input container is automatically
          // applying the asterisk indicator on the label.
          containerCtrl.label.toggleClass('md-required', value && !disableAsterisk);
        });
      }

      mdSelectCtrl.setLabelText = function(text) {
        mdSelectCtrl.setIsPlaceholder(!text);

        // Whether the select label has been given via user content rather than the internal
        // template of <md-option>
        var isSelectLabelFromUser = false;

        if (attr.mdSelectedText && attr.mdSelectedHtml) {
          throw Error('md-select cannot have both `md-selected-text` and `md-selected-html`');
        }

        if (attr.mdSelectedText || attr.mdSelectedHtml) {
          text = $parse(attr.mdSelectedText || attr.mdSelectedHtml)(scope);
          isSelectLabelFromUser = true;
        } else if (!text) {
          // Use placeholder attribute, otherwise fallback to the md-input-container label
          var tmpPlaceholder = attr.placeholder ||
              (containerCtrl && containerCtrl.label ? containerCtrl.label.text() : '');

          text = tmpPlaceholder || '';
          isSelectLabelFromUser = true;
        }

        var target = valueEl.children().eq(0);

        if (attr.mdSelectedHtml) {
            // Using getTrustedHtml will run the content through $sanitize if it is not already
            // explicitly trusted. If the ngSanitize module is not loaded, this will
            // *correctly* throw an sce error.
            target.html($sce.getTrustedHtml(text));
        } else if (isSelectLabelFromUser) {
          target.text(text);
        } else {
          // If we've reached this point, the text is not user-provided.
          target.html(text);
        }
      };

      mdSelectCtrl.setIsPlaceholder = function(isPlaceholder) {
        if (isPlaceholder) {
          valueEl.addClass('md-select-placeholder');
          if (containerCtrl && containerCtrl.label) {
            containerCtrl.label.addClass('md-placeholder');
          }
        } else {
          valueEl.removeClass('md-select-placeholder');
          if (containerCtrl && containerCtrl.label) {
            containerCtrl.label.removeClass('md-placeholder');
          }
        }
      };

      if (!isReadonly) {
        element
          .on('focus', function(ev) {
            // Always focus the container (if we have one) so floating labels and other styles are
            // applied properly
            containerCtrl && containerCtrl.setFocused(true);
          });

        // Attach before ngModel's blur listener to stop propagation of blur event
        // to prevent from setting $touched.
        element.on('blur', function(event) {
          if (untouched) {
            untouched = false;
            if (selectScope._mdSelectIsOpen) {
              event.stopImmediatePropagation();
            }
          }

          if (selectScope._mdSelectIsOpen) return;
          containerCtrl && containerCtrl.setFocused(false);
          inputCheckValue();
        });
      }

      mdSelectCtrl.triggerClose = function() {
        $parse(attr.mdOnClose)(scope);
      };

      scope.$$postDigest(function() {
        initAriaLabel();
        syncLabelText();
        syncAriaLabel();
      });

      function initAriaLabel() {
        var labelText = element.attr('aria-label') || element.attr('placeholder');
        if (!labelText && containerCtrl && containerCtrl.label) {
          labelText = containerCtrl.label.text();
        }
        ariaLabelBase = labelText;
        $mdAria.expect(element, 'aria-label', labelText);
      }

      scope.$watch(function() {
        return selectMenuCtrl.selectedLabels();
      }, syncLabelText);

      function syncLabelText() {
        if (selectContainer) {
          selectMenuCtrl = selectMenuCtrl || selectContainer.find('md-select-menu').controller('mdSelectMenu');
          mdSelectCtrl.setLabelText(selectMenuCtrl.selectedLabels());
        }
      }

      function syncAriaLabel() {
        if (!ariaLabelBase) return;
        var ariaLabels = selectMenuCtrl.selectedLabels({mode: 'aria'});
        element.attr('aria-label', ariaLabels.length ? ariaLabelBase + ': ' + ariaLabels : ariaLabelBase);
      }

      var deregisterWatcher;
      attr.$observe('ngMultiple', function(val) {
        if (deregisterWatcher) deregisterWatcher();
        var parser = $parse(val);
        deregisterWatcher = scope.$watch(function() {
          return parser(scope);
        }, function(multiple, prevVal) {
          if (multiple === undefined && prevVal === undefined) return; // assume compiler did a good job
          if (multiple) {
            element.attr('multiple', 'multiple');
          } else {
            element.removeAttr('multiple');
          }
          element.attr('aria-multiselectable', multiple ? 'true' : 'false');
          if (selectContainer) {
            selectMenuCtrl.setMultiple(multiple);
            originalRender = ngModelCtrl.$render;
            ngModelCtrl.$render = function() {
              originalRender();
              syncLabelText();
              syncAriaLabel();
              inputCheckValue();
            };
            ngModelCtrl.$render();
          }
        });
      });

      attr.$observe('disabled', function(disabled) {
        if (angular.isString(disabled)) {
          disabled = true;
        }
        // Prevent click event being registered twice
        if (isDisabled !== undefined && isDisabled === disabled) {
          return;
        }
        isDisabled = disabled;
        if (disabled) {
          element
            .attr({'aria-disabled': 'true'})
            .removeAttr('tabindex')
            .off('click', openSelect)
            .off('keydown', handleKeypress);
        } else {
          element
            .attr({'tabindex': attr.tabindex, 'aria-disabled': 'false'})
            .on('click', openSelect)
            .on('keydown', handleKeypress);
        }
      });

      if (!attr.hasOwnProperty('disabled') && !attr.hasOwnProperty('ngDisabled')) {
        element.attr({'aria-disabled': 'false'});
        element.on('click', openSelect);
        element.on('keydown', handleKeypress);
      }

      var ariaAttrs = {
        role: 'listbox',
        'aria-expanded': 'false',
        'aria-multiselectable': isMultiple && !attr.ngMultiple ? 'true' : 'false'
      };

      if (!element[0].hasAttribute('id')) {
        ariaAttrs.id = 'select_' + $mdUtil.nextUid();
      }

      var containerId = 'select_container_' + $mdUtil.nextUid();
      selectContainer.attr('id', containerId);
      // Only add aria-owns if element ownership is NOT represented in the DOM.
      if (!element.find('md-select-menu').length) {
        ariaAttrs['aria-owns'] = containerId;
      }
      element.attr(ariaAttrs);

      scope.$on('$destroy', function() {
        $mdSelect
          .destroy()
          .finally(function() {
            if (containerCtrl) {
              containerCtrl.setFocused(false);
              containerCtrl.setHasValue(false);
              containerCtrl.input = null;
            }
            ngModelCtrl.$setTouched();
          });
      });



      function inputCheckValue() {
        // The select counts as having a value if one or more options are selected,
        // or if the input's validity state says it has bad input (eg string in a number input)
        // we must do this on nextTick as the $render is sometimes invoked on nextTick.
        $mdUtil.nextTick(function () {
          containerCtrl && containerCtrl.setHasValue(selectMenuCtrl.selectedLabels().length > 0 || (element[0].validity || {}).badInput);
        });
      }

      function findSelectContainer() {
        selectContainer = angular.element(
          element[0].querySelector('.md-select-menu-container')
        );
        selectScope = scope;
        if (attr.mdContainerClass) {
          var value = selectContainer[0].getAttribute('class') + ' ' + attr.mdContainerClass;
          selectContainer[0].setAttribute('class', value);
        }
        selectMenuCtrl = selectContainer.find('md-select-menu').controller('mdSelectMenu');
        selectMenuCtrl.init(ngModelCtrl, attr.ngModel);
        element.on('$destroy', function() {
          selectContainer.remove();
        });
      }

      function handleKeypress(e) {
        if ($mdConstant.isNavigationKey(e)) {
          // prevent page scrolling on interaction
          e.preventDefault();
          openSelect(e);
        } else {
          if (shouldHandleKey(e, $mdConstant)) {
            e.preventDefault();

            var node = selectMenuCtrl.optNodeForKeyboardSearch(e);
            if (!node || node.hasAttribute('disabled')) return;
            var optionCtrl = angular.element(node).controller('mdOption');
            if (!selectMenuCtrl.isMultiple) {
              selectMenuCtrl.deselect(Object.keys(selectMenuCtrl.selected)[0]);
            }
            selectMenuCtrl.select(optionCtrl.hashKey, optionCtrl.value);
            selectMenuCtrl.refreshViewValue();
          }
        }
      }

      function openSelect() {
        selectScope._mdSelectIsOpen = true;
        element.attr('aria-expanded', 'true');

        $mdSelect.show({
          scope: selectScope,
          preserveScope: true,
          skipCompile: true,
          element: selectContainer,
          target: element[0],
          selectCtrl: mdSelectCtrl,
          preserveElement: true,
          hasBackdrop: true,
          loadingAsync: attr.mdOnOpen ? scope.$eval(attr.mdOnOpen) || true : false
        }).finally(function() {
          selectScope._mdSelectIsOpen = false;
          element.focus();
          element.attr('aria-expanded', 'false');
          ngModelCtrl.$setTouched();
        });
      }

    };
  }
}

function SelectMenuDirective($parse, $mdUtil, $mdConstant, $mdTheming) {
  // We want the scope to be set to 'false' so an isolated scope is not created
  // which would interfere with the md-select-header's access to the
  // parent scope.
  SelectMenuController.$inject = ["$scope", "$attrs", "$element"];
  return {
    restrict: 'E',
    require: ['mdSelectMenu'],
    scope: false,
    controller: SelectMenuController,
    link: {pre: preLink}
  };

  // We use preLink instead of postLink to ensure that the select is initialized before
  // its child options run postLink.
  function preLink(scope, element, attr, ctrls) {
    var selectCtrl = ctrls[0];

    element.addClass('_md');     // private md component indicator for styling

    $mdTheming(element);
    element.on('click', clickListener);
    element.on('keypress', keyListener);

    function keyListener(e) {
      if (e.keyCode == 13 || e.keyCode == 32) {
        clickListener(e);
      }
    }

    function clickListener(ev) {
      var option = $mdUtil.getClosest(ev.target, 'md-option');
      var optionCtrl = option && angular.element(option).data('$mdOptionController');
      if (!option || !optionCtrl) return;
      if (option.hasAttribute('disabled')) {
        ev.stopImmediatePropagation();
        return false;
      }

      var optionHashKey = selectCtrl.hashGetter(optionCtrl.value);
      var isSelected = angular.isDefined(selectCtrl.selected[optionHashKey]);

      scope.$apply(function() {
        if (selectCtrl.isMultiple) {
          if (isSelected) {
            selectCtrl.deselect(optionHashKey);
          } else {
            selectCtrl.select(optionHashKey, optionCtrl.value);
          }
        } else {
          if (!isSelected) {
            selectCtrl.deselect(Object.keys(selectCtrl.selected)[0]);
            selectCtrl.select(optionHashKey, optionCtrl.value);
          }
        }
        selectCtrl.refreshViewValue();
      });
    }
  }

  function SelectMenuController($scope, $attrs, $element) {
    var self = this;
    self.isMultiple = angular.isDefined($attrs.multiple);
    // selected is an object with keys matching all of the selected options' hashed values
    self.selected = {};
    // options is an object with keys matching every option's hash value,
    // and values matching every option's controller.
    self.options = {};

    $scope.$watchCollection(function() {
      return self.options;
    }, function() {
      self.ngModel.$render();
    });

    var deregisterCollectionWatch;
    var defaultIsEmpty;
    self.setMultiple = function(isMultiple) {
      var ngModel = self.ngModel;
      defaultIsEmpty = defaultIsEmpty || ngModel.$isEmpty;

      self.isMultiple = isMultiple;
      if (deregisterCollectionWatch) deregisterCollectionWatch();

      if (self.isMultiple) {
        // We want to delay the render method so that the directive has a chance to load before
        // rendering, this prevents the control being marked as dirty onload.
        var loaded = false;
        var delayedRender = function(val) {
          if (!loaded) {
            $mdUtil.nextTick(function () {
              renderMultiple(val);
              loaded = true;
            });
          } else {
            renderMultiple(val);
          }
        };
        ngModel.$validators['md-multiple'] = validateArray;
        ngModel.$render = delayedRender;

        // watchCollection on the model because by default ngModel only watches the model's
        // reference. This allows the developer to also push and pop from their array.
        $scope.$watchCollection(self.modelBinding, function(value) {
          if (validateArray(value)) delayedRender(value);
        });

        ngModel.$isEmpty = function(value) {
          return !value || value.length === 0;
        };
      } else {
        delete ngModel.$validators['md-multiple'];
        ngModel.$render = renderSingular;
      }

      function validateArray(modelValue, viewValue) {
        // If a value is truthy but not an array, reject it.
        // If value is undefined/falsy, accept that it's an empty array.
        return angular.isArray(modelValue || viewValue || []);
      }
    };

    var searchStr = '';
    var clearSearchTimeout, optNodes, optText;
    var CLEAR_SEARCH_AFTER = 300;

    self.optNodeForKeyboardSearch = function(e) {
      clearSearchTimeout && clearTimeout(clearSearchTimeout);
      clearSearchTimeout = setTimeout(function() {
        clearSearchTimeout = undefined;
        searchStr = '';
        optText = undefined;
        optNodes = undefined;
      }, CLEAR_SEARCH_AFTER);

      searchStr += e.key;
      var search = new RegExp('^' + searchStr, 'i');
      if (!optNodes) {
        optNodes = $element.find('md-option');
        optText = new Array(optNodes.length);
        angular.forEach(optNodes, function(el, i) {
          optText[i] = el.textContent.trim();
        });
      }
      for (var i = 0; i < optText.length; ++i) {
        if (search.test(optText[i])) {
          return optNodes[i];
        }
      }
    };

    self.init = function(ngModel, binding) {
      self.ngModel = ngModel;
      self.modelBinding = binding;

      // Setup a more robust version of isEmpty to ensure value is a valid option
      self.ngModel.$isEmpty = function($viewValue) {
        // We have to transform the viewValue into the hashKey, because otherwise the
        // OptionCtrl may not exist. Developers may have specified a trackBy function.
        return !self.options[self.hashGetter($viewValue)];
      };

      // Allow users to provide `ng-model="foo" ng-model-options="{trackBy: 'foo.id'}"` so
      // that we can properly compare objects set on the model to the available options
      var trackByOption = $mdUtil.getModelOption(ngModel, 'trackBy');

      if (trackByOption) {
        var trackByLocals = {};
        var trackByParsed = $parse(trackByOption);
        self.hashGetter = function(value, valueScope) {
          trackByLocals.$value = value;
          return trackByParsed(valueScope || $scope, trackByLocals);
        };
        // If the user doesn't provide a trackBy, we automatically generate an id for every
        // value passed in
      } else {
        self.hashGetter = function getHashValue(value) {
          if (angular.isObject(value)) {
            return 'object_' + (value.$$mdSelectId || (value.$$mdSelectId = ++selectNextId));
          }
          return value;
        };
      }
      self.setMultiple(self.isMultiple);
    };

    self.selectedLabels = function(opts) {
      opts = opts || {};
      var mode = opts.mode || 'html';
      var selectedOptionEls = $mdUtil.nodesToArray($element[0].querySelectorAll('md-option[selected]'));
      if (selectedOptionEls.length) {
        var mapFn;

        if (mode == 'html') {
          // Map the given element to its innerHTML string. If the element has a child ripple
          // container remove it from the HTML string, before returning the string.
          mapFn = function(el) {
            // If we do not have a `value` or `ng-value`, assume it is an empty option which clears the select
            if (el.hasAttribute('md-option-empty')) {
              return '';
            }

            var html = el.innerHTML;

            // Remove the ripple container from the selected option, copying it would cause a CSP violation.
            var rippleContainer = el.querySelector('.md-ripple-container');
            if (rippleContainer) {
              html = html.replace(rippleContainer.outerHTML, '');
            }

            // Remove the checkbox container, because it will cause the label to wrap inside of the placeholder.
            // It should be not displayed inside of the label element.
            var checkboxContainer = el.querySelector('.md-container');
            if (checkboxContainer) {
              html = html.replace(checkboxContainer.outerHTML, '');
            }

            return html;
          };
        } else if (mode == 'aria') {
          mapFn = function(el) { return el.hasAttribute('aria-label') ? el.getAttribute('aria-label') : el.textContent; };
        }

        // Ensure there are no duplicates; see https://github.com/angular/material/issues/9442
        return $mdUtil.uniq(selectedOptionEls.map(mapFn)).join(', ');
      } else {
        return '';
      }
    };

    self.select = function(hashKey, hashedValue) {
      var option = self.options[hashKey];
      option && option.setSelected(true);
      self.selected[hashKey] = hashedValue;
    };
    self.deselect = function(hashKey) {
      var option = self.options[hashKey];
      option && option.setSelected(false);
      delete self.selected[hashKey];
    };

    self.addOption = function(hashKey, optionCtrl) {
      if (angular.isDefined(self.options[hashKey])) {
        throw new Error('Duplicate md-option values are not allowed in a select. ' +
          'Duplicate value "' + optionCtrl.value + '" found.');
      }

      self.options[hashKey] = optionCtrl;

      // If this option's value was already in our ngModel, go ahead and select it.
      if (angular.isDefined(self.selected[hashKey])) {
        self.select(hashKey, optionCtrl.value);

        // When the current $modelValue of the ngModel Controller is using the same hash as
        // the current option, which will be added, then we can be sure, that the validation
        // of the option has occurred before the option was added properly.
        // This means, that we have to manually trigger a new validation of the current option.
        if (angular.isDefined(self.ngModel.$$rawModelValue) &&
            self.hashGetter(self.ngModel.$$rawModelValue) === hashKey) {
          self.ngModel.$validate();
        }

        self.refreshViewValue();
      }
    };
    self.removeOption = function(hashKey) {
      delete self.options[hashKey];
      // Don't deselect an option when it's removed - the user's ngModel should be allowed
      // to have values that do not match a currently available option.
    };

    self.refreshViewValue = function() {
      var values = [];
      var option;
      for (var hashKey in self.selected) {
        // If this hashKey has an associated option, push that option's value to the model.
        if ((option = self.options[hashKey])) {
          values.push(option.value);
        } else {
          // Otherwise, the given hashKey has no associated option, and we got it
          // from an ngModel value at an earlier time. Push the unhashed value of
          // this hashKey to the model.
          // This allows the developer to put a value in the model that doesn't yet have
          // an associated option.
          values.push(self.selected[hashKey]);
        }
      }
      var usingTrackBy = $mdUtil.getModelOption(self.ngModel, 'trackBy');

      var newVal = self.isMultiple ? values : values[0];
      var prevVal = self.ngModel.$modelValue;

      if (usingTrackBy ? !angular.equals(prevVal, newVal) : (prevVal + '') !== newVal) {
        self.ngModel.$setViewValue(newVal);
        self.ngModel.$render();
      }
    };

    function renderMultiple() {
      var newSelectedValues = self.ngModel.$modelValue || self.ngModel.$viewValue || [];
      if (!angular.isArray(newSelectedValues)) return;

      var oldSelected = Object.keys(self.selected);

      var newSelectedHashes = newSelectedValues.map(self.hashGetter);
      var deselected = oldSelected.filter(function(hash) {
        return newSelectedHashes.indexOf(hash) === -1;
      });

      deselected.forEach(self.deselect);
      newSelectedHashes.forEach(function(hashKey, i) {
        self.select(hashKey, newSelectedValues[i]);
      });
    }

    function renderSingular() {
      var value = self.ngModel.$viewValue || self.ngModel.$modelValue;
      Object.keys(self.selected).forEach(self.deselect);
      self.select(self.hashGetter(value), value);
    }
  }

}

/**
 * @ngdoc directive
 * @name mdOption
 * @restrict E
 * @module material.components.select
 *
 * @description Displays an option in a <a ng-href="/api/directive/mdSelect">md-select</a> box's
 * dropdown menu. Options can be grouped using
 * <a ng-href="/api/directive/mdOptgroup">md-optgroup</a> element directives.
 *
 * ### Option Params
 *
 * When applied, `md-option-empty` will mark the option as "empty" allowing the option to clear the
 * select and put it back in it's default state. You may supply this attribute on any option you
 * wish, however, it is automatically applied to an option whose `value` or `ng-value` are not
 * defined.
 *
 * **Automatically Applied**
 *
 *  - `<md-option>`
 *  - `<md-option value>`
 *  - `<md-option value="">`
 *  - `<md-option ng-value>`
 *  - `<md-option ng-value="">`
 *
 * **NOT Automatically Applied**
 *
 *  - `<md-option ng-value="1">`
 *  - `<md-option ng-value="''">`
 *  - `<md-option ng-value="undefined">`
 *  - `<md-option value="undefined">` (this evaluates to the string `"undefined"`)
 *  - <code ng-non-bindable>&lt;md-option ng-value="{{someValueThatMightBeUndefined}}"&gt;</code>
 *
 * **Note:** A value of `undefined` ***is considered a valid value*** (and does not auto-apply this
 * attribute) since you may wish this to be your "Not Available" or "None" option.
 *
 * **Note:** Using the
 * <a ng-href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/option#Attributes">value</a>
 * attribute from the `<option>` element (as opposed to the `<md-option>` element's
 * <a ng-href="https://docs.angularjs.org/api/ng/directive/ngValue">ng-value</a>) always evaluates
 * to a `string`. This means that `value="null"` will cause a check against `myValue != "null"`
 * rather than `!myValue` or `myValue != null`.
 * Importantly, this also applies to `number` values. `value="1"` will not match up with an
 * `ng-model` like `$scope.selectedValue = 1`. Use `ng-value="1"` in this case and other cases where
 * you have values that are not strings.
 *
 * **Note:** Please see our <a ng-href="/api/directive/mdSelect#selects-and-object-equality">docs on
 * using objects with `md-select`</a> for additional guidance on using the `trackBy` option with
 * `ng-model-options`.
 *
 * @param {expression=} ng-value Binds the given expression to the value of the option.
 * @param {string=} value Attribute to set the value of the option.
 * @param {expression=} ng-repeat <a ng-href="https://docs.angularjs.org/api/ng/directive/ngRepeat">
 *  AngularJS directive</a> that instantiates a template once per item from a collection.
 * @param {boolean=} md-option-empty If the attribute exists, mark the option as "empty" allowing
 * the option to clear the select and put it back in it's default state. You may supply this
 * attribute on any option you wish, however, it is automatically applied to an option whose `value`
 * or `ng-value` are not defined.
 * @param {number=} tabindex The `tabindex` of the option. Defaults to `0`.
 *
 * @usage
 * <hljs lang="html">
 * <md-select ng-model="currentState" placeholder="Select a state">
 *   <md-option ng-value="AL">Alabama</md-option>
 *   <md-option ng-value="AK">Alaska</md-option>
 *   <md-option ng-value="FL">Florida</md-option>
 * </md-select>
 * </hljs>
 *
 * With `ng-repeat`:
 * <hljs lang="html">
 * <md-select ng-model="currentState" placeholder="Select a state">
 *   <md-option ng-value="state" ng-repeat="state in states">{{ state }}</md-option>
 * </md-select>
 * </hljs>
 */
function OptionDirective($mdButtonInkRipple, $mdUtil, $mdTheming) {

  OptionController.$inject = ["$element"];
  return {
    restrict: 'E',
    require: ['mdOption', '^^mdSelectMenu'],
    controller: OptionController,
    compile: compile
  };

  function compile(element, attr) {
    // Manual transclusion to avoid the extra inner <span> that ng-transclude generates
    element.append(angular.element('<div class="md-text">').append(element.contents()));

    element.attr('tabindex', attr.tabindex || '0');

    if (!hasDefinedValue(attr)) {
      element.attr('md-option-empty', '');
    }

    return postLink;
  }

  function hasDefinedValue(attr) {
    var value = attr.value;
    var ngValue = attr.ngValue;

    return value || ngValue;
  }

  function postLink(scope, element, attr, ctrls) {
    var optionCtrl = ctrls[0];
    var selectCtrl = ctrls[1];

    $mdTheming(element);

    if (selectCtrl.isMultiple) {
      element.addClass('md-checkbox-enabled');
      element.prepend(CHECKBOX_SELECTION_INDICATOR.clone());
    }

    if (angular.isDefined(attr.ngValue)) {
      scope.$watch(attr.ngValue, setOptionValue);
    } else if (angular.isDefined(attr.value)) {
      setOptionValue(attr.value);
    } else {
      scope.$watch(function() {
        return element.text().trim();
      }, setOptionValue);
    }

    attr.$observe('disabled', function(disabled) {
      if (disabled) {
        element.attr('tabindex', '-1');
      } else {
        element.attr('tabindex', '0');
      }
    });

    scope.$$postDigest(function() {
      attr.$observe('selected', function(selected) {
        if (!angular.isDefined(selected)) return;
        if (typeof selected == 'string') selected = true;
        if (selected) {
          if (!selectCtrl.isMultiple) {
            selectCtrl.deselect(Object.keys(selectCtrl.selected)[0]);
          }
          selectCtrl.select(optionCtrl.hashKey, optionCtrl.value);
        } else {
          selectCtrl.deselect(optionCtrl.hashKey);
        }
        selectCtrl.refreshViewValue();
      });
    });

    $mdButtonInkRipple.attach(scope, element);
    configureAria();

    function setOptionValue(newValue, oldValue, prevAttempt) {
      if (!selectCtrl.hashGetter) {
        if (!prevAttempt) {
          scope.$$postDigest(function() {
            setOptionValue(newValue, oldValue, true);
          });
        }
        return;
      }
      var oldHashKey = selectCtrl.hashGetter(oldValue, scope);
      var newHashKey = selectCtrl.hashGetter(newValue, scope);

      optionCtrl.hashKey = newHashKey;
      optionCtrl.value = newValue;

      selectCtrl.removeOption(oldHashKey, optionCtrl);
      selectCtrl.addOption(newHashKey, optionCtrl);
    }

    scope.$on('$destroy', function() {
      selectCtrl.removeOption(optionCtrl.hashKey, optionCtrl);
    });

    function configureAria() {
      var ariaAttrs = {
        'role': 'option',
        'aria-selected': 'false'
      };

      if (!element[0].hasAttribute('id')) {
        ariaAttrs.id = 'select_option_' + $mdUtil.nextUid();
      }
      element.attr(ariaAttrs);
    }
  }

  function OptionController($element) {
    this.selected = false;
    this.setSelected = function(isSelected) {
      if (isSelected && !this.selected) {
        $element.attr({
          'selected': 'selected',
          'aria-selected': 'true'
        });
      } else if (!isSelected && this.selected) {
        $element.removeAttr('selected');
        $element.attr('aria-selected', 'false');
      }
      this.selected = isSelected;
    };
  }

}

/**
 * @ngdoc directive
 * @name mdOptgroup
 * @restrict E
 * @module material.components.select
 *
 * @description Displays a label separating groups of
 * <a ng-href="/api/directive/mdOption">md-option</a> element directives in a
 * <a ng-href="/api/directive/mdSelect">md-select</a> box's dropdown menu.
 *
 * **Note:** When using `md-select-header` element directives within a `md-select`, the labels that
 * would normally be added to the <a ng-href="/api/directive/mdOptgroup">md-optgroup</a> directives
 * are omitted, allowing the `md-select-header` to represent the option group label
 * (and possibly more).
 *
 * @usage
 * With label attributes
 * <hljs lang="html">
 * <md-select ng-model="currentState" placeholder="Select a state">
 *   <md-optgroup label="Southern">
 *     <md-option ng-value="AL">Alabama</md-option>
 *     <md-option ng-value="FL">Florida</md-option>
 *   </md-optgroup>
 *   <md-optgroup label="Northern">
 *     <md-option ng-value="AK">Alaska</md-option>
 *     <md-option ng-value="MA">Massachusetts</md-option>
 *   </md-optgroup>
 * </md-select>
 * </hljs>
 *
 * With label elements
 * <hljs lang="html">
 * <md-select ng-model="currentState" placeholder="Select a state">
 *   <md-optgroup>
 *     <label>Southern</label>
 *     <md-option ng-value="AL">Alabama</md-option>
 *     <md-option ng-value="FL">Florida</md-option>
 *   </md-optgroup>
 *   <md-optgroup>
 *     <label>Northern</label>
 *     <md-option ng-value="AK">Alaska</md-option>
 *     <md-option ng-value="MA">Massachusetts</md-option>
 *   </md-optgroup>
 * </md-select>
 * </hljs>
 *
 * @param {string=} label The option group's label.
 */
function OptgroupDirective() {
  return {
    restrict: 'E',
    compile: compile
  };
  function compile(el, attrs) {
    // If we have a select header element, we don't want to add the normal label
    // header.
    if (!hasSelectHeader()) {
      setupLabelElement();
    }

    function hasSelectHeader() {
      return el.parent().find('md-select-header').length;
    }

    function setupLabelElement() {
      var labelElement = el.find('label');
      if (!labelElement.length) {
        labelElement = angular.element('<label>');
        el.prepend(labelElement);
      }
      labelElement.addClass('md-container-ignore');
      labelElement.attr('aria-hidden', 'true');
      if (attrs.label) labelElement.text(attrs.label);
    }
  }
}

function SelectHeaderDirective() {
  return {
    restrict: 'E',
  };
}

function SelectProvider($$interimElementProvider) {
  selectDefaultOptions.$inject = ["$mdSelect", "$mdConstant", "$mdUtil", "$window", "$q", "$$rAF", "$animateCss", "$animate", "$document"];
  return $$interimElementProvider('$mdSelect')
    .setDefaults({
      methods: ['target'],
      options: selectDefaultOptions
    });

  /* @ngInject */
  function selectDefaultOptions($mdSelect, $mdConstant, $mdUtil, $window, $q, $$rAF, $animateCss, $animate, $document) {
    var ERROR_TARGET_EXPECTED = "$mdSelect.show() expected a target element in options.target but got '{0}'!";
    var animator = $mdUtil.dom.animator;
    var keyCodes = $mdConstant.KEY_CODE;

    return {
      parent: 'body',
      themable: true,
      onShow: onShow,
      onRemove: onRemove,
      hasBackdrop: true,
      disableParentScroll: true
    };

    /**
     * Interim-element onRemove logic....
     */
    function onRemove(scope, element, opts) {
      var animationRunner = null;
      var destroyListener = scope.$on('$destroy', function() {
        // Listen for the case where the element was destroyed while there was an
        // ongoing close animation. If this happens, we need to end the animation
        // manually.
        animationRunner.end();
      });

      opts = opts || { };
      opts.cleanupInteraction();
      opts.cleanupResizing();
      opts.hideBackdrop();

      // For navigation $destroy events, do a quick, non-animated removal,
      // but for normal closes (from clicks, etc) animate the removal
      return (opts.$destroy === true) ? cleanElement() : animateRemoval().then(cleanElement);

      /**
       * For normal closes (eg clicks), animate the removal.
       * For forced closes (like $destroy events from navigation),
       * skip the animations
       */
      function animateRemoval() {
        animationRunner = $animateCss(element, {addClass: 'md-leave'});
        return animationRunner.start();
      }

      /**
       * Restore the element to a closed state
       */
      function cleanElement() {
        destroyListener();

        element
          .removeClass('md-active')
          .attr('aria-hidden', 'true')
          .css({
            'display': 'none',
            'top': '',
            'right': '',
            'bottom': '',
            'left': '',
            'font-size': '',
            'min-width': ''
          });
        element.parent().find('md-select-value').removeAttr('aria-hidden');

        announceClosed(opts);

        if (!opts.$destroy && opts.restoreFocus) {
          opts.target.focus();
        }
      }

    }

    /**
     * Interim-element onShow logic....
     */
    function onShow(scope, element, opts) {

      watchAsyncLoad();
      sanitizeAndConfigure(scope, opts);

      opts.hideBackdrop = showBackdrop(scope, element, opts);

      return showDropDown(scope, element, opts)
        .then(function(response) {
          element.attr('aria-hidden', 'false');
          opts.alreadyOpen = true;
          opts.cleanupInteraction = activateInteraction();
          opts.cleanupResizing = activateResizing();
          autoFocus(opts.focusedNode);

          return response;
        }, opts.hideBackdrop);

      // ************************************
      // Closure Functions
      // ************************************

      /**
       *  Attach the select DOM element(s) and animate to the correct positions
       *  and scalings...
       */
      function showDropDown(scope, element, opts) {
        if (opts.parent !== element.parent()) {
          element.parent().attr('aria-owns', element.attr('id'));
        }
        element.parent().find('md-select-value').attr('aria-hidden', 'true');

        opts.parent.append(element);

        return $q(function(resolve, reject) {

          try {

            $animateCss(element, {removeClass: 'md-leave', duration: 0})
              .start()
              .then(positionAndFocusMenu)
              .then(resolve);

          } catch (e) {
            reject(e);
          }

        });
      }

      /**
       * Initialize container and dropDown menu positions/scale, then animate
       * to show.
       */
      function positionAndFocusMenu() {
        return $q(function(resolve) {
          if (opts.isRemoved) return $q.reject(false);

          var info = calculateMenuPositions(scope, element, opts);

          info.container.element.css(animator.toCss(info.container.styles));
          info.dropDown.element.css(animator.toCss(info.dropDown.styles));

          $$rAF(function() {
            element.addClass('md-active');
            info.dropDown.element.css(animator.toCss({transform: ''}));
            autoFocus(opts.focusedNode);

            resolve();
          });

        });
      }

      /**
       * Show modal backdrop element...
       */
      function showBackdrop(scope, element, options) {

        // If we are not within a dialog...
        if (options.disableParentScroll && !$mdUtil.getClosest(options.target, 'MD-DIALOG')) {
          // !! DO this before creating the backdrop; since disableScrollAround()
          //    configures the scroll offset; which is used by mdBackDrop postLink()
          options.restoreScroll = $mdUtil.disableScrollAround(options.element, options.parent);
        } else {
          options.disableParentScroll = false;
        }

        if (options.hasBackdrop) {
          // Override duration to immediately show invisible backdrop
          options.backdrop = $mdUtil.createBackdrop(scope, "md-select-backdrop md-click-catcher");
          $animate.enter(options.backdrop, $document[0].body, null, {duration: 0});
        }

        /**
         * Hide modal backdrop element...
         */
        return function hideBackdrop() {
          if (options.backdrop) options.backdrop.remove();
          if (options.disableParentScroll) options.restoreScroll();

          delete options.restoreScroll;
        };
      }

      /**
       *
       */
      function autoFocus(focusedNode) {
        if (focusedNode && !focusedNode.hasAttribute('disabled')) {
          focusedNode.focus();
        }
      }

      /**
       * Check for valid opts and set some sane defaults
       */
      function sanitizeAndConfigure(scope, options) {
        var selectEl = element.find('md-select-menu');

        if (!options.target) {
          throw new Error($mdUtil.supplant(ERROR_TARGET_EXPECTED, [options.target]));
        }

        angular.extend(options, {
          isRemoved: false,
          target: angular.element(options.target), // make sure it's not a naked DOM node
          parent: angular.element(options.parent),
          selectEl: selectEl,
          contentEl: element.find('md-content'),
          optionNodes: selectEl[0].getElementsByTagName('md-option')
        });
      }

      /**
       * Configure various resize listeners for screen changes
       */
      function activateResizing() {
        var debouncedOnResize = (function(scope, target, options) {

          return function() {
            if (options.isRemoved) return;

            var updates = calculateMenuPositions(scope, target, options);
            var container = updates.container;
            var dropDown = updates.dropDown;

            container.element.css(animator.toCss(container.styles));
            dropDown.element.css(animator.toCss(dropDown.styles));
          };

        })(scope, element, opts);

        var window = angular.element($window);
        window.on('resize', debouncedOnResize);
        window.on('orientationchange', debouncedOnResize);

        // Publish deactivation closure...
        return function deactivateResizing() {

          // Disable resizing handlers
          window.off('resize', debouncedOnResize);
          window.off('orientationchange', debouncedOnResize);
        };
      }

      /**
       *  If asynchronously loading, watch and update internal
       *  '$$loadingAsyncDone' flag
       */
      function watchAsyncLoad() {
        if (opts.loadingAsync && !opts.isRemoved) {
          scope.$$loadingAsyncDone = false;

          $q.when(opts.loadingAsync)
            .then(function() {
              scope.$$loadingAsyncDone = true;
              delete opts.loadingAsync;
            }).then(function() {
              $$rAF(positionAndFocusMenu);
            });
        }
      }

      /**
       *
       */
      function activateInteraction() {
        if (opts.isRemoved) return;

        var dropDown = opts.selectEl;
        var selectCtrl = dropDown.controller('mdSelectMenu') || {};

        element.addClass('md-clickable');

        // Close on backdrop click
        opts.backdrop && opts.backdrop.on('click', onBackdropClick);

        // Escape to close
        // Cycling of options, and closing on enter
        dropDown.on('keydown', onMenuKeyDown);
        dropDown.on('click', checkCloseMenu);

        return function cleanupInteraction() {
          opts.backdrop && opts.backdrop.off('click', onBackdropClick);
          dropDown.off('keydown', onMenuKeyDown);
          dropDown.off('click', checkCloseMenu);

          element.removeClass('md-clickable');
          opts.isRemoved = true;
        };

        // ************************************
        // Closure Functions
        // ************************************

        function onBackdropClick(e) {
          e.preventDefault();
          e.stopPropagation();
          opts.restoreFocus = false;
          $mdUtil.nextTick($mdSelect.hide, true);
        }

        function onMenuKeyDown(ev) {
          ev.preventDefault();
          ev.stopPropagation();

          switch (ev.keyCode) {
            case keyCodes.UP_ARROW:
              return focusPrevOption();
            case keyCodes.DOWN_ARROW:
              return focusNextOption();
            case keyCodes.SPACE:
            case keyCodes.ENTER:
              var option = $mdUtil.getClosest(ev.target, 'md-option');
              if (option) {
                dropDown.triggerHandler({
                  type: 'click',
                  target: option
                });
                ev.preventDefault();
              }
              checkCloseMenu(ev);
              break;
            case keyCodes.TAB:
            case keyCodes.ESCAPE:
              ev.stopPropagation();
              ev.preventDefault();
              opts.restoreFocus = true;
              $mdUtil.nextTick($mdSelect.hide, true);
              break;
            default:
              if (shouldHandleKey(ev, $mdConstant)) {
                var optNode = dropDown.controller('mdSelectMenu').optNodeForKeyboardSearch(ev);
                opts.focusedNode = optNode || opts.focusedNode;
                optNode && optNode.focus();
              }
          }
        }

        function focusOption(direction) {
          var optionsArray = $mdUtil.nodesToArray(opts.optionNodes);
          var index = optionsArray.indexOf(opts.focusedNode);

          var newOption;

          do {
            if (index === -1) {
              // We lost the previously focused element, reset to first option
              index = 0;
            } else if (direction === 'next' && index < optionsArray.length - 1) {
              index++;
            } else if (direction === 'prev' && index > 0) {
              index--;
            }
            newOption = optionsArray[index];
            if (newOption.hasAttribute('disabled')) newOption = undefined;
          } while (!newOption && index < optionsArray.length - 1 && index > 0);

          newOption && newOption.focus();
          opts.focusedNode = newOption;
        }

        function focusNextOption() {
          focusOption('next');
        }

        function focusPrevOption() {
          focusOption('prev');
        }

        function checkCloseMenu(ev) {
          if (ev && (ev.type == 'click') && (ev.currentTarget != dropDown[0])) return;
          if (mouseOnScrollbar()) return;

          var option = $mdUtil.getClosest(ev.target, 'md-option');
          if (option && option.hasAttribute && !option.hasAttribute('disabled')) {
            ev.preventDefault();
            ev.stopPropagation();
            if (!selectCtrl.isMultiple) {
              opts.restoreFocus = true;

              $mdUtil.nextTick(function () {
                $mdSelect.hide(selectCtrl.ngModel.$viewValue);
              }, true);
            }
          }
          /**
           * check if the mouseup event was on a scrollbar
           */
          function mouseOnScrollbar() {
            var clickOnScrollbar = false;
            if (ev && (ev.currentTarget.children.length > 0)) {
              var child = ev.currentTarget.children[0];
              var hasScrollbar = child.scrollHeight > child.clientHeight;
              if (hasScrollbar && child.children.length > 0) {
                var relPosX = ev.pageX - ev.currentTarget.getBoundingClientRect().left;
                if (relPosX > child.querySelector('md-option').offsetWidth)
                  clickOnScrollbar = true;
              }
            }
            return clickOnScrollbar;
          }
        }
      }

    }

    /**
     * To notify listeners that the Select menu has closed,
     * trigger the [optional] user-defined expression
     */
    function announceClosed(opts) {
      var mdSelect = opts.selectCtrl;
      if (mdSelect) {
        var menuController = opts.selectEl.controller('mdSelectMenu');
        mdSelect.setLabelText(menuController ? menuController.selectedLabels() : '');
        mdSelect.triggerClose();
      }
    }


    /**
     * Calculate the
     */
    function calculateMenuPositions(scope, element, opts) {
      var
        containerNode = element[0],
        targetNode = opts.target[0].children[0], // target the label
        parentNode = $document[0].body,
        selectNode = opts.selectEl[0],
        contentNode = opts.contentEl[0],
        parentRect = parentNode.getBoundingClientRect(),
        targetRect = targetNode.getBoundingClientRect(),
        shouldOpenAroundTarget = false,
        bounds = {
          left: parentRect.left + SELECT_EDGE_MARGIN,
          top: SELECT_EDGE_MARGIN,
          bottom: parentRect.height - SELECT_EDGE_MARGIN,
          right: parentRect.width - SELECT_EDGE_MARGIN - ($mdUtil.floatingScrollbars() ? 16 : 0)
        },
        spaceAvailable = {
          top: targetRect.top - bounds.top,
          left: targetRect.left - bounds.left,
          right: bounds.right - (targetRect.left + targetRect.width),
          bottom: bounds.bottom - (targetRect.top + targetRect.height)
        },
        maxWidth = parentRect.width - SELECT_EDGE_MARGIN * 2,
        selectedNode = selectNode.querySelector('md-option[selected]'),
        optionNodes = selectNode.getElementsByTagName('md-option'),
        optgroupNodes = selectNode.getElementsByTagName('md-optgroup'),
        isScrollable = calculateScrollable(element, contentNode),
        centeredNode;

      var loading = isPromiseLike(opts.loadingAsync);
      if (!loading) {
        // If a selected node, center around that
        if (selectedNode) {
          centeredNode = selectedNode;
          // If there are option groups, center around the first option group
        } else if (optgroupNodes.length) {
          centeredNode = optgroupNodes[0];
          // Otherwise - if we are not loading async - center around the first optionNode
        } else if (optionNodes.length) {
          centeredNode = optionNodes[0];
          // In case there are no options, center on whatever's in there... (eg progress indicator)
        } else {
          centeredNode = contentNode.firstElementChild || contentNode;
        }
      } else {
        // If loading, center on progress indicator
        centeredNode = contentNode.firstElementChild || contentNode;
      }

      if (contentNode.offsetWidth > maxWidth) {
        contentNode.style['max-width'] = maxWidth + 'px';
      } else {
        contentNode.style.maxWidth = null;
      }
      if (shouldOpenAroundTarget) {
        contentNode.style['min-width'] = targetRect.width + 'px';
      }

      // Remove padding before we compute the position of the menu
      if (isScrollable) {
        selectNode.classList.add('md-overflow');
      }

      var focusedNode = centeredNode;
      if ((focusedNode.tagName || '').toUpperCase() === 'MD-OPTGROUP') {
        focusedNode = optionNodes[0] || contentNode.firstElementChild || contentNode;
        centeredNode = focusedNode;
      }
      // Cache for autoFocus()
      opts.focusedNode = focusedNode;

      // Get the selectMenuRect *after* max-width is possibly set above
      containerNode.style.display = 'block';
      var selectMenuRect = selectNode.getBoundingClientRect();
      var centeredRect = getOffsetRect(centeredNode);

      if (centeredNode) {
        var centeredStyle = $window.getComputedStyle(centeredNode);
        centeredRect.paddingLeft = parseInt(centeredStyle.paddingLeft, 10) || 0;
        centeredRect.paddingRight = parseInt(centeredStyle.paddingRight, 10) || 0;
      }

      if (isScrollable) {
        var scrollBuffer = contentNode.offsetHeight / 2;
        contentNode.scrollTop = centeredRect.top + centeredRect.height / 2 - scrollBuffer;

        if (spaceAvailable.top < scrollBuffer) {
          contentNode.scrollTop = Math.min(
            centeredRect.top,
            contentNode.scrollTop + scrollBuffer - spaceAvailable.top
          );
        } else if (spaceAvailable.bottom < scrollBuffer) {
          contentNode.scrollTop = Math.max(
            centeredRect.top + centeredRect.height - selectMenuRect.height,
            contentNode.scrollTop - scrollBuffer + spaceAvailable.bottom
          );
        }
      }

      var left, top, transformOrigin, minWidth, fontSize;
      if (shouldOpenAroundTarget) {
        left = targetRect.left;
        top = targetRect.top + targetRect.height;
        transformOrigin = '50% 0';
        if (top + selectMenuRect.height > bounds.bottom) {
          top = targetRect.top - selectMenuRect.height;
          transformOrigin = '50% 100%';
        }
      } else {
        left = (targetRect.left + centeredRect.left - centeredRect.paddingLeft) + 2;
        top = Math.floor(targetRect.top + targetRect.height / 2 - centeredRect.height / 2 -
            centeredRect.top + contentNode.scrollTop) + 2;

        transformOrigin = (centeredRect.left + targetRect.width / 2) + 'px ' +
          (centeredRect.top + centeredRect.height / 2 - contentNode.scrollTop) + 'px 0px';

        minWidth = Math.min(targetRect.width + centeredRect.paddingLeft + centeredRect.paddingRight, maxWidth);

        fontSize = window.getComputedStyle(targetNode)['font-size'];
      }

      // Keep left and top within the window
      var containerRect = containerNode.getBoundingClientRect();
      var scaleX = Math.round(100 * Math.min(targetRect.width / selectMenuRect.width, 1.0)) / 100;
      var scaleY = Math.round(100 * Math.min(targetRect.height / selectMenuRect.height, 1.0)) / 100;

      return {
        container: {
          element: angular.element(containerNode),
          styles: {
            left: Math.floor(clamp(bounds.left, left, bounds.right - containerRect.width)),
            top: Math.floor(clamp(bounds.top, top, bounds.bottom - containerRect.height)),
            'min-width': minWidth,
            'font-size': fontSize
          }
        },
        dropDown: {
          element: angular.element(selectNode),
          styles: {
            transformOrigin: transformOrigin,
            transform: !opts.alreadyOpen ? $mdUtil.supplant('scale({0},{1})', [scaleX, scaleY]) : ""
          }
        }
      };

    }

  }

  function isPromiseLike(obj) {
    return obj && angular.isFunction(obj.then);
  }

  function clamp(min, n, max) {
    return Math.max(min, Math.min(n, max));
  }

  function getOffsetRect(node) {
    return node ? {
      left: node.offsetLeft,
      top: node.offsetTop,
      width: node.offsetWidth,
      height: node.offsetHeight
    } : {left: 0, top: 0, width: 0, height: 0};
  }

  function calculateScrollable(element, contentNode) {
    var isScrollable = false;

    try {
      var oldDisplay = element[0].style.display;

      // Set the element's display to block so that this calculation is correct
      element[0].style.display = 'block';

      isScrollable = contentNode.scrollHeight > contentNode.offsetHeight;

      // Reset it back afterwards
      element[0].style.display = oldDisplay;
    } finally {
      // Nothing to do
    }
    return isScrollable;
  }

}

function shouldHandleKey(ev, $mdConstant) {
  var char = String.fromCharCode(ev.keyCode);
  var isNonUsefulKey = (ev.keyCode <= 31);

  return (char && char.length && !isNonUsefulKey &&
    !$mdConstant.isMetaKey(ev) && !$mdConstant.isFnLockKey(ev) && !$mdConstant.hasModifierKey(ev));
}

})();
(function(){
"use strict";

/**
 * @ngdoc module
 * @name material.components.showHide
 */

// Add additional handlers to ng-show and ng-hide that notify directives
// contained within that they should recompute their size.
// These run in addition to AngularJS's built-in ng-hide and ng-show directives.
angular.module('material.components.showHide', [
  'material.core'
])
  .directive('ngShow', createDirective('ngShow', true))
  .directive('ngHide', createDirective('ngHide', false));


function createDirective(name, targetValue) {
  return ['$mdUtil', '$window', function($mdUtil, $window) {
    return {
      restrict: 'A',
      multiElement: true,
      link: function($scope, $element, $attr) {
        var unregister = $scope.$on('$md-resize-enable', function() {
          unregister();

          var node = $element[0];
          var cachedTransitionStyles = node.nodeType === $window.Node.ELEMENT_NODE ?
            $window.getComputedStyle(node) : {};

          $scope.$watch($attr[name], function(value) {
            if (!!value === targetValue) {
              $mdUtil.nextTick(function() {
                $scope.$broadcast('$md-resize');
              });

              var opts = {
                cachedTransitionStyles: cachedTransitionStyles
              };

              $mdUtil.dom.animator.waitTransitionEnd($element, opts).then(function() {
                $scope.$broadcast('$md-resize');
              });
            }
          });
        });
      }
    };
  }];
}

})();
(function(){
"use strict";

/**
 * @ngdoc module
 * @name material.components.sidenav
 *
 * @description
 * A Sidenav component.
 */
SidenavService.$inject = ["$mdComponentRegistry", "$mdUtil", "$q", "$log"];
SidenavDirective.$inject = ["$mdMedia", "$mdUtil", "$mdConstant", "$mdTheming", "$mdInteraction", "$animate", "$compile", "$parse", "$log", "$q", "$document", "$window", "$$rAF"];
SidenavController.$inject = ["$scope", "$attrs", "$mdComponentRegistry", "$q", "$interpolate"];
angular
  .module('material.components.sidenav', [
    'material.core',
    'material.components.backdrop'
  ])
  .factory('$mdSidenav', SidenavService)
  .directive('mdSidenav', SidenavDirective)
  .directive('mdSidenavFocus', SidenavFocusDirective)
  .controller('$mdSidenavController', SidenavController);


/**
 * @ngdoc service
 * @name $mdSidenav
 * @module material.components.sidenav
 *
 * @description
 * `$mdSidenav` makes it easy to interact with multiple sidenavs in an app. When looking up a
 * sidenav instance, you can either look it up synchronously or wait for it to be initialized
 * asynchronously. This is done by passing the second argument to `$mdSidenav`.
 *
 * @usage
 * <hljs lang="js">
 * // Async lookup for sidenav instance; will resolve when the instance is available
 * $mdSidenav(componentId, true).then(function(instance) {
 *   $log.debug( componentId + "is now ready" );
 * });
 * // Sync lookup for sidenav instance; this will resolve immediately.
 * $mdSidenav(componentId).then(function(instance) {
 *   $log.debug( componentId + "is now ready" );
 * });
 * // Async toggle the given sidenav;
 * // when instance is known ready and lazy lookup is not needed.
 * $mdSidenav(componentId)
 *    .toggle()
 *    .then(function(){
 *      $log.debug('toggled');
 *    });
 * // Async open the given sidenav
 * $mdSidenav(componentId)
 *    .open()
 *    .then(function(){
 *      $log.debug('opened');
 *    });
 * // Async close the given sidenav
 * $mdSidenav(componentId)
 *    .close()
 *    .then(function(){
 *      $log.debug('closed');
 *    });
 * // Async lookup for sidenav instance
 * $mdSidenav(componentId, true).then(function(instance) {
 *   // On close callback to handle close, backdrop click, or escape key pressed.
 *   // Callback happens BEFORE the close action occurs.
 *   instance.onClose(function() {
 *     $log.debug('closing');
 *   });
 * });
 * // Sync check to see if the specified sidenav is set to be open
 * $mdSidenav(componentId).isOpen();
 * // Sync check to whether given sidenav is locked open
 * // If this is true, the sidenav will be open regardless of close()
 * $mdSidenav(componentId).isLockedOpen();
 * </hljs>
 */
function SidenavService($mdComponentRegistry, $mdUtil, $q, $log) {
  var errorMsg = "SideNav '{0}' is not available! Did you use md-component-id='{0}'?";
  var service = {
    find: findInstance,      //  sync  - returns proxy API
    waitFor: waitForInstance //  async - returns promise
  };

  /**
   * Service API that supports three (3) usages:
   * $mdSidenav().find("left")               // sync (must already exist) or returns undefined
   * $mdSidenav("left").toggle();            // sync (must already exist) or returns reject promise;
   * $mdSidenav("left",true).then(function(left) { // async returns instance when available
   *  left.toggle();
   * });
   */
  return function(handle, enableWait) {
    if (angular.isUndefined(handle)) {
      return service;
    }

    var shouldWait = enableWait === true;
    var instance = service.find(handle, shouldWait);
    return !instance && shouldWait ? service.waitFor(handle) :
           !instance && angular.isUndefined(enableWait) ? addLegacyAPI(service, handle) : instance;
  };

  /**
   * For failed instance/handle lookups, older-clients expect an response object with noops
   * that include `rejected promise APIs`
   * @param service
   * @param handle
   * @returns {Object}
   */
  function addLegacyAPI(service, handle) {
    var falseFn = function() {
      return false;
    };
    var rejectFn = function() {
      return $q.when($mdUtil.supplant(errorMsg, [handle || ""]));
    };

    return angular.extend({
      isLockedOpen: falseFn,
      isOpen: falseFn,
      toggle: rejectFn,
      open: rejectFn,
      close: rejectFn,
      onClose: angular.noop,
      then: function(callback) {
        return waitForInstance(handle).then(callback || angular.noop);
      }
    }, service);
  }

  /**
   * Synchronously lookup the controller instance for the specified sidNav instance which has been
   * registered with the markup `md-component-id`
   */
  function findInstance(handle, shouldWait) {
    var instance = $mdComponentRegistry.get(handle);

    if (!instance && !shouldWait) {
      // Report missing instance
      $log.error($mdUtil.supplant(errorMsg, [handle || ""]));

      // The component has not registered itself... most like NOT yet created
      // return null to indicate that the Sidenav is not in the DOM
      return undefined;
    }
    return instance;
  }

  /**
   * Asynchronously wait for the component instantiation,
   * Deferred lookup of component instance using $component registry
   */
  function waitForInstance(handle) {
    return $mdComponentRegistry.when(handle).catch($log.error);
  }
}

/**
 * @ngdoc directive
 * @name mdSidenavFocus
 * @module material.components.sidenav
 *
 * @restrict A
 *
 * @description
 * `mdSidenavFocus` provides a way to specify the focused element when a sidenav opens.
 * This is completely optional, as the sidenav itself is focused by default.
 *
 * @usage
 * <hljs lang="html">
 * <md-sidenav>
 *   <form>
 *     <md-input-container>
 *       <label for="testInput">Label</label>
 *       <input id="testInput" type="text" md-sidenav-focus>
 *     </md-input-container>
 *   </form>
 * </md-sidenav>
 * </hljs>
 **/
function SidenavFocusDirective() {
  return {
    restrict: 'A',
    require: '^mdSidenav',
    link: function(scope, element, attr, sidenavCtrl) {
      // @see $mdUtil.findFocusTarget(...)
    }
  };
}

/**
 * @ngdoc directive
 * @name mdSidenav
 * @module material.components.sidenav
 * @restrict E
 *
 * @description
 * A Sidenav component that can be opened and closed programmatically.
 *
 * By default, upon opening it will slide out on top of the main content area.
 *
 * For keyboard and screen reader accessibility, focus is sent to the sidenav wrapper by default.
 * It can be overridden with the `md-autofocus` directive on the child element you want focused.
 *
 * @usage
 * <hljs lang="html">
 * <div layout="row" ng-controller="MyController">
 *   <md-sidenav md-component-id="left" class="md-sidenav-left">
 *     Left Nav!
 *   </md-sidenav>
 *
 *   <md-content>
 *     Center Content
 *     <md-button ng-click="openLeftMenu()">
 *       Open Left Menu
 *     </md-button>
 *   </md-content>
 *
 *   <md-sidenav md-component-id="right"
 *     md-is-locked-open="$mdMedia('min-width: 333px')"
 *     class="md-sidenav-right">
 *     <form>
 *       <md-input-container>
 *         <label for="testInput">Test input</label>
 *         <input id="testInput" type="text"
 *                ng-model="data" md-autofocus>
 *       </md-input-container>
 *     </form>
 *   </md-sidenav>
 * </div>
 * </hljs>
 *
 * <hljs lang="js">
 * var app = angular.module('myApp', ['ngMaterial']);
 * app.controller('MyController', function($scope, $mdSidenav) {
 *   $scope.openLeftMenu = function() {
 *     $mdSidenav('left').toggle();
 *   };
 * });
 * </hljs>
 *
 * @param {expression=} md-is-open A model bound to whether the sidenav is opened.
 * @param {boolean=} md-disable-backdrop When present in the markup, the sidenav will not show a
 *  backdrop.
 * @param {boolean=} md-disable-close-events When present in the markup, clicking the backdrop or
 *  pressing the 'Escape' key will not close the sidenav.
 * @param {string=} md-component-id componentId to use with $mdSidenav service.
 * @param {expression=} md-is-locked-open When this expression evaluates to true,
 * the sidenav 'locks open': it falls into the content's flow instead
 * of appearing over it. This overrides the `md-is-open` attribute.
 * @param {string=} md-disable-scroll-target Selector, pointing to an element, whose scrolling will
 * be disabled when the sidenav is opened. By default this is the sidenav's direct parent.
 *
* The $mdMedia() service is exposed to the is-locked-open attribute, which
 * can be given a media query or one of the `sm`, `gt-sm`, `md`, `gt-md`, `lg` or `gt-lg` presets.
 * Examples:
 *
 *   - `<md-sidenav md-is-locked-open="shouldLockOpen"></md-sidenav>`
 *   - `<md-sidenav md-is-locked-open="$mdMedia('min-width: 1000px')"></md-sidenav>`
 *   - `<md-sidenav md-is-locked-open="$mdMedia('sm')"></md-sidenav>` (locks open on small screens)
 */
function SidenavDirective($mdMedia, $mdUtil, $mdConstant, $mdTheming, $mdInteraction, $animate,
                          $compile, $parse, $log, $q, $document, $window, $$rAF) {
  return {
    restrict: 'E',
    scope: {
      isOpen: '=?mdIsOpen'
    },
    controller: '$mdSidenavController',
    compile: function(element) {
      element.addClass('md-closed').attr('tabIndex', '-1');
      return postLink;
    }
  };

  /**
   * Directive Post Link function...
   */
  function postLink(scope, element, attr, sidenavCtrl) {
    var lastParentOverFlow;
    var backdrop;
    var disableScrollTarget = null;
    var disableCloseEvents;
    var triggeringInteractionType;
    var triggeringElement = null;
    var previousContainerStyles;
    var promise = $q.when(true);
    var isLockedOpenParsed = $parse(attr.mdIsLockedOpen);
    var ngWindow = angular.element($window);
    var isLocked = function() {
      return isLockedOpenParsed(scope.$parent, {
        $media: function(arg) {
          $log.warn("$media is deprecated for is-locked-open. Use $mdMedia instead.");
          return $mdMedia(arg);
        },
        $mdMedia: $mdMedia
      });
    };

    if (attr.mdDisableScrollTarget) {
      disableScrollTarget = $document[0].querySelector(attr.mdDisableScrollTarget);

      if (disableScrollTarget) {
        disableScrollTarget = angular.element(disableScrollTarget);
      } else {
        $log.warn($mdUtil.supplant('mdSidenav: couldn\'t find element matching ' +
          'selector "{selector}". Falling back to parent.',
          { selector: attr.mdDisableScrollTarget }));
      }
    }

    if (!disableScrollTarget) {
      disableScrollTarget = element.parent();
    }

    // Only create the backdrop if the backdrop isn't disabled.
    if (!attr.hasOwnProperty('mdDisableBackdrop')) {
      backdrop = $mdUtil.createBackdrop(scope, "md-sidenav-backdrop md-opaque ng-enter");
    }

    // If md-disable-close-events is set on the sidenav we will disable
    // backdrop click and Escape key events
    if (attr.hasOwnProperty('mdDisableCloseEvents')) {
      disableCloseEvents = true;
    }

    element.addClass('_md');     // private md component indicator for styling
    $mdTheming(element);

    // The backdrop should inherit the sidenavs theme,
    // because the backdrop will take its parent theme by default.
    if (backdrop) $mdTheming.inherit(backdrop, element);

    element.on('$destroy', function() {
      backdrop && backdrop.remove();
      sidenavCtrl.destroy();
    });

    scope.$on('$destroy', function(){
      backdrop && backdrop.remove();
    });

    scope.$watch(isLocked, updateIsLocked);
    scope.$watch('isOpen', updateIsOpen);


    // Publish special accessor for the Controller instance
    sidenavCtrl.$toggleOpen = toggleOpen;

    /**
     * Toggle the DOM classes to indicate `locked`
     * @param isLocked
     * @param oldValue
     */
    function updateIsLocked(isLocked, oldValue) {
      scope.isLockedOpen = isLocked;
      if (isLocked === oldValue) {
        element.toggleClass('md-locked-open', !!isLocked);
      } else {
        $animate[isLocked ? 'addClass' : 'removeClass'](element, 'md-locked-open');
      }
      if (backdrop) {
        backdrop.toggleClass('md-locked-open', !!isLocked);
      }
    }

    /**
     * Toggle the SideNav view and attach/detach listeners
     * @param isOpen
     */
    function updateIsOpen(isOpen) {
      // Support deprecated md-sidenav-focus attribute as fallback
      var focusEl = $mdUtil.findFocusTarget(element) ||
        $mdUtil.findFocusTarget(element,'[md-sidenav-focus]') || element;
      var parent = element.parent();
      var restorePositioning;

      // If the user hasn't set the disable close events property we are adding
      // click and escape events to close the sidenav
      if (!disableCloseEvents) {
        parent[isOpen ? 'on' : 'off']('keydown', onKeyDown);
        if (backdrop) backdrop[isOpen ? 'on' : 'off']('click', close);
      }

      restorePositioning = updateContainerPositions(parent, isOpen);

      if (isOpen) {
        // Capture upon opening..
        triggeringElement = $document[0].activeElement;
        triggeringInteractionType = $mdInteraction.getLastInteractionType();
      }

      disableParentScroll(isOpen);

      return promise = $q.all([
        isOpen && backdrop ? $animate.enter(backdrop, parent) : backdrop ?
                             $animate.leave(backdrop) : $q.when(true),
        $animate[isOpen ? 'removeClass' : 'addClass'](element, 'md-closed')
      ]).then(function() {
        // Perform focus when animations are ALL done...
        if (scope.isOpen) {
          $$rAF(function() {
            // Notifies child components that the sidenav was opened. Should wait
            // a frame in order to allow for the element height to be computed.
            ngWindow.triggerHandler('resize');
          });

          focusEl && focusEl.focus();
        }

        // Restores the positioning on the sidenav and backdrop.
        restorePositioning && restorePositioning();
      });
    }

    function updateContainerPositions(parent, willOpen) {
      var drawerEl = element[0];
      var scrollTop = parent[0].scrollTop;

      if (willOpen && scrollTop) {
        previousContainerStyles = {
          top: drawerEl.style.top,
          bottom: drawerEl.style.bottom,
          height: drawerEl.style.height
        };

        // When the parent is scrolled down, then we want to be able to show the sidenav at the
        // current scroll position. We're moving the sidenav down to the correct scroll position
        // and apply the height of the parent, to increase the performance. Using 100% as height,
        // will impact the performance heavily.
        var positionStyle = {
          top: scrollTop + 'px',
          bottom: 'auto',
          height: parent[0].clientHeight + 'px'
        };

        // Apply the new position styles to the sidenav and backdrop.
        element.css(positionStyle);
        backdrop.css(positionStyle);
      }

      // When the sidenav is closing and we have previous defined container styles,
      // then we return a restore function, which resets the sidenav and backdrop.
      if (!willOpen && previousContainerStyles) {
        return function() {
          drawerEl.style.top = previousContainerStyles.top;
          drawerEl.style.bottom = previousContainerStyles.bottom;
          drawerEl.style.height = previousContainerStyles.height;

          backdrop[0].style.top = null;
          backdrop[0].style.bottom = null;
          backdrop[0].style.height = null;

          previousContainerStyles = null;
        };
      }
    }

    /**
     * Prevent parent scrolling (when the SideNav is open)
     */
    function disableParentScroll(disabled) {
      if (disabled && !lastParentOverFlow) {
        lastParentOverFlow = disableScrollTarget.css('overflow');
        disableScrollTarget.css('overflow', 'hidden');
      } else if (angular.isDefined(lastParentOverFlow)) {
        disableScrollTarget.css('overflow', lastParentOverFlow);
        lastParentOverFlow = undefined;
      }
    }

    /**
     * Toggle the sideNav view and publish a promise to be resolved when
     * the view animation finishes.
     * @param {boolean} isOpen true to open the sidenav, false to close it
     * @returns {*} promise to be resolved when the view animation finishes
     */
    function toggleOpen(isOpen) {
      if (scope.isOpen === isOpen) {
        return $q.when(true);
      } else {
        if (scope.isOpen && sidenavCtrl.onCloseCb) sidenavCtrl.onCloseCb();

        return $q(function(resolve) {
          // Toggle value to force an async `updateIsOpen()` to run
          scope.isOpen = isOpen;

          $mdUtil.nextTick(function() {
            // When the current `updateIsOpen()` animation finishes
            promise.then(function(result) {

              if (!scope.isOpen && triggeringElement && triggeringInteractionType === 'keyboard') {
                // reset focus to originating element (if available) upon close
                triggeringElement.focus();
                triggeringElement = null;
              }

              resolve(result);
            });
          });
        });
      }
    }

    /**
     * Auto-close sideNav when the `escape` key is pressed.
     * @param {KeyboardEvent} ev keydown event
     */
    function onKeyDown(ev) {
      var isEscape = (ev.keyCode === $mdConstant.KEY_CODE.ESCAPE);
      return isEscape ? close(ev) : $q.when(true);
    }

    /**
     * With backdrop `clicks` or `escape` key-press, immediately apply the CSS close transition...
     * Then notify the controller to close() and perform its own actions.
     * @param {Event} ev
     * @returns {*}
     */
    function close(ev) {
      ev.preventDefault();

      return sidenavCtrl.close();
    }
  }
}

/*
 * @private
 * @ngdoc controller
 * @name SidenavController
 * @module material.components.sidenav
 */
function SidenavController($scope, $attrs, $mdComponentRegistry, $q, $interpolate) {
  var self = this;

  // Use Default internal method until overridden by directive postLink

  // Synchronous getters
  self.isOpen = function() { return !!$scope.isOpen; };
  self.isLockedOpen = function() { return !!$scope.isLockedOpen; };

  // Synchronous setters
  self.onClose = function (callback) {
    self.onCloseCb = callback;
    return self;
  };

  // Async actions
  self.open   = function() { return self.$toggleOpen(true);  };
  self.close  = function() { return self.$toggleOpen(false); };
  self.toggle = function() { return self.$toggleOpen(!$scope.isOpen);  };
  self.$toggleOpen = function(value) { return $q.when($scope.isOpen = value); };

  // Evaluate the component id.
  var rawId = $attrs.mdComponentId;
  var hasDataBinding = rawId && rawId.indexOf($interpolate.startSymbol()) > -1;
  var componentId = hasDataBinding ? $interpolate(rawId)($scope.$parent) : rawId;

  // Register the component.
  self.destroy = $mdComponentRegistry.register(self, componentId);

  // Watch and update the component, if the id has changed.
  if (hasDataBinding) {
    $attrs.$observe('mdComponentId', function(id) {
      if (id && id !== self.$$mdHandle) {
        // `destroy` only deregisters the old component id so we can add the new one.
        self.destroy();
        self.destroy = $mdComponentRegistry.register(self, id);
      }
    });
  }
}

})();
(function(){
"use strict";

/**
 * @ngdoc module
 * @name material.components.slider
 */
SliderDirective.$inject = ["$$rAF", "$window", "$mdAria", "$mdUtil", "$mdConstant", "$mdTheming", "$mdGesture", "$parse", "$log", "$timeout"];
angular.module('material.components.slider', [
  'material.core'
])
.directive('mdSlider', SliderDirective)
.directive('mdSliderContainer', SliderContainerDirective);

/**
 * @type {number} the page size used for stepping when page up/down keys are pressed.
 */
var stepPageSize = 10;
/**
 * @type {number} the multiplier applied to a step when the arrow key is pressed along with
 *  alt, meta, or ctrl.
 */
var modifierMultiplier = 4;

/**
 * @ngdoc directive
 * @name mdSliderContainer
 * @module material.components.slider
 * @restrict E
 * @description
 * The `<md-slider-container>` can hold the slider with two other elements.
 * In this case, the other elements are a `span` for the label and an `input` for displaying
 * the model value.
 *
 * @usage
 * <hljs lang="html">
 *  <md-slider-container>
 *    <span>Red</span>
 *    <md-slider min="0" max="255" ng-model="color.red" aria-label="red" id="red-slider">
 *    </md-slider>
 *    <md-input-container>
 *      <input type="number" ng-model="color.red" aria-label="Red" aria-controls="red-slider">
 *    </md-input-container>
 *  </md-slider-container>
 * </hljs>
 */
function SliderContainerDirective() {
  return {
    controller: function () {},
    compile: function (elem) {
      var slider = elem.find('md-slider');

      if (!slider) {
        return;
      }

      var vertical = slider.attr('md-vertical');

      if (vertical !== undefined) {
        elem.attr('md-vertical', '');
      }

      if (!slider.attr('flex')) {
        slider.attr('flex', '');
      }

      return function postLink(scope, element, attr, ctrl) {
        element.addClass('_md');     // private md component indicator for styling

        // We have to manually stop the $watch on ngDisabled because it exists
        // on the parent scope, and won't be automatically destroyed when
        // the component is destroyed.
        function setDisable(value) {
          element.children().attr('disabled', value);
          element.find('input').attr('disabled', value);
        }

        var stopDisabledWatch = angular.noop;

        if (attr.disabled) {
          setDisable(true);
        }
        else if (attr.ngDisabled) {
          stopDisabledWatch = scope.$watch(attr.ngDisabled, function (value) {
            setDisable(value);
          });
        }

        scope.$on('$destroy', function () {
          stopDisabledWatch();
        });

        var initialMaxWidth;

        /**
         * @param {number} length of the input's string value
         */
        ctrl.fitInputWidthToTextLength = function (length) {
          var input = element[0].querySelector('md-input-container');

          if (input) {
            var computedStyle = getComputedStyle(input);
            var minWidth = parseInt(computedStyle.minWidth);
            var padding = parseInt(computedStyle.paddingLeft) + parseInt(computedStyle.paddingRight);

            initialMaxWidth = initialMaxWidth || parseInt(computedStyle.maxWidth);
            var newMaxWidth = Math.max(initialMaxWidth, minWidth + padding + (minWidth / 2 * length));

            input.style.maxWidth = newMaxWidth + 'px';
          }
        };
      };
    }
  };
}

/**
 * @ngdoc directive
 * @name mdSlider
 * @module material.components.slider
 * @restrict E
 * @description
 * The `<md-slider>` component allows the user to choose from a range of values.
 *
 * As per the [Material Design spec](https://material.io/archive/guidelines/style/color.html#color-color-system)
 * the slider is in the accent color by default. The primary color palette may be used with
 * the `md-primary` class.
 *
 * The slider has two modes:
 * - "normal" mode where the user slides between a wide range of values
 * - "discrete" mode where the user slides between only a few select values
 *
 * To enable discrete mode, add the `md-discrete` attribute to a slider
 * and use the `step` attribute to change the distance between
 * values the user is allowed to pick.
 *
 * When using the keyboard:
 * - pressing the arrow keys will increase or decrease the slider's value by one step
 * - holding the Meta, Control, or Alt key while pressing the arrow keys will
 *   move the slider four steps at a time
 * - pressing the Home key will move the slider to the first allowed value
 * - pressing the End key will move the slider to the last allowed value
 * - pressing the Page Up key will increase the slider value by ten
 * - pressing the Page Down key will decrease the slider value by ten
 *
 * @usage
 * <h4>Normal Mode</h4>
 * <hljs lang="html">
 * <md-slider ng-model="myValue" min="5" max="500">
 * </md-slider>
 * </hljs>
 * <h4>Discrete Mode</h4>
 * <hljs lang="html">
 * <md-slider md-discrete ng-model="myDiscreteValue" step="10" min="10" max="130">
 * </md-slider>
 * </hljs>
 * <h4>Invert Mode</h4>
 * <hljs lang="html">
 * <md-slider md-invert ng-model="myValue" step="10" min="10" max="130">
 * </md-slider>
 * </hljs>
 *
 * @param {expression} ng-model Assignable angular expression to be data-bound.
 *  The expression should evaluate to a `number`.
 * @param {expression=} ng-disabled If this expression evaluates as truthy, the slider will be
 *  disabled.
 * @param {expression=} ng-readonly If this expression evaluates as truthy, the slider will be in
 *  read only mode.
 * @param {boolean=} md-discrete If this attribute exists during initialization, enable discrete
 *  mode. Defaults to `false`.
 * @param {boolean=} md-vertical If this attribute exists during initialization, enable vertical
 *  orientation mode. Defaults to `false`.
 * @param {boolean=} md-invert If this attribute exists during initialization, enable inverted mode.
 *  Defaults to `false`.
 * @param {number=} step The distance between values the user is allowed to pick. Defaults to `1`.
 * @param {number=} min The minimum value the user is allowed to pick. Defaults to `0`.
 * @param {number=} max The maximum value the user is allowed to pick. Defaults to `100`.
 * @param {number=} round The amount of numbers after the decimal point. The maximum is 6 to
 *  prevent scientific notation. Defaults to `3`.
 */
function SliderDirective($$rAF, $window, $mdAria, $mdUtil, $mdConstant, $mdTheming, $mdGesture,
                         $parse, $log, $timeout) {
  return {
    scope: {},
    require: ['?ngModel', '?^mdSliderContainer'],
    template:
      '<div class="md-slider-wrapper">' +
        '<div class="md-slider-content">' +
          '<div class="md-track-container">' +
            '<div class="md-track"></div>' +
            '<div class="md-track md-track-fill"></div>' +
            '<div class="md-track-ticks"></div>' +
          '</div>' +
          '<div class="md-thumb-container">' +
            '<div class="md-thumb"></div>' +
            '<div class="md-focus-thumb"></div>' +
            '<div class="md-focus-ring"></div>' +
            '<div class="md-sign">' +
              '<span class="md-thumb-text"></span>' +
            '</div>' +
            '<div class="md-disabled-thumb"></div>' +
          '</div>' +
        '</div>' +
      '</div>',
    compile: compile
  };

  // **********************************************************
  // Private Methods
  // **********************************************************

  function compile (tElement, tAttrs) {
    var wrapper = angular.element(tElement[0].getElementsByClassName('md-slider-wrapper'));

    var tabIndex = tAttrs.tabindex || 0;
    wrapper.attr('tabindex', tabIndex);

    if (tAttrs.disabled || tAttrs.ngDisabled) wrapper.attr('tabindex', -1);

    wrapper.attr('role', 'slider');

    $mdAria.expect(tElement, 'aria-label');

    return postLink;
  }

  function postLink(scope, element, attr, ctrls) {
    $mdTheming(element);
    var ngModelCtrl = ctrls[0] || {
      // Mock ngModelController if it doesn't exist to give us
      // the minimum functionality needed
      $setViewValue: function(val) {
        this.$viewValue = val;
        this.$viewChangeListeners.forEach(function(cb) { cb(); });
      },
      $parsers: [],
      $formatters: [],
      $viewChangeListeners: []
    };

    var containerCtrl = ctrls[1];
    var container = angular.element($mdUtil.getClosest(element, '_md-slider-container', true));
    var isDisabled = attr.ngDisabled ? angular.bind(null, $parse(attr.ngDisabled), scope.$parent) : function () {
          return element[0].hasAttribute('disabled');
        };

    var thumb = angular.element(element[0].querySelector('.md-thumb'));
    var thumbText = angular.element(element[0].querySelector('.md-thumb-text'));
    var thumbContainer = thumb.parent();
    var trackContainer = angular.element(element[0].querySelector('.md-track-container'));
    var activeTrack = angular.element(element[0].querySelector('.md-track-fill'));
    var tickContainer = angular.element(element[0].querySelector('.md-track-ticks'));
    var wrapper = angular.element(element[0].getElementsByClassName('md-slider-wrapper'));
    var content = angular.element(element[0].getElementsByClassName('md-slider-content'));
    var throttledRefreshDimensions = $mdUtil.throttle(refreshSliderDimensions, 5000);

    // Default values, overridable by attrs
    var DEFAULT_ROUND = 3;
    var vertical = angular.isDefined(attr.mdVertical);
    var discrete = angular.isDefined(attr.mdDiscrete);
    var invert = angular.isDefined(attr.mdInvert);
    angular.isDefined(attr.min) ? attr.$observe('min', updateMin) : updateMin(0);
    angular.isDefined(attr.max) ? attr.$observe('max', updateMax) : updateMax(100);
    angular.isDefined(attr.step)? attr.$observe('step', updateStep) : updateStep(1);
    angular.isDefined(attr.round)? attr.$observe('round', updateRound) : updateRound(DEFAULT_ROUND);

    // We have to manually stop the $watch on ngDisabled because it exists
    // on the parent scope, and won't be automatically destroyed when
    // the component is destroyed.
    var stopDisabledWatch = angular.noop;
    if (attr.ngDisabled) {
      stopDisabledWatch = scope.$parent.$watch(attr.ngDisabled, updateAriaDisabled);
    }

    $mdGesture.register(wrapper, 'drag', { horizontal: !vertical });

    scope.mouseActive = false;

    wrapper
      .on('keydown', keydownListener)
      .on('mousedown', mouseDownListener)
      .on('focus', focusListener)
      .on('blur', blurListener)
      .on('$md.pressdown', onPressDown)
      .on('$md.pressup', onPressUp)
      .on('$md.dragstart', onDragStart)
      .on('$md.drag', onDrag)
      .on('$md.dragend', onDragEnd);

    // On resize, recalculate the slider's dimensions and re-render
    function updateAll() {
      refreshSliderDimensions();
      ngModelRender();
    }
    setTimeout(updateAll, 0);

    var debouncedUpdateAll = $$rAF.throttle(updateAll);
    angular.element($window).on('resize', debouncedUpdateAll);

    scope.$on('$destroy', function() {
      angular.element($window).off('resize', debouncedUpdateAll);
    });

    ngModelCtrl.$render = ngModelRender;
    ngModelCtrl.$viewChangeListeners.push(ngModelRender);
    ngModelCtrl.$formatters.push(minMaxValidator);
    ngModelCtrl.$formatters.push(stepValidator);

    /**
     * Attributes
     */
    var min;
    var max;
    var step;
    var round;
    function updateMin(value) {
      min = parseFloat(value);
      ngModelCtrl.$viewValue = minMaxValidator(ngModelCtrl.$modelValue, min, max);
      wrapper.attr('aria-valuemin', value);
      updateAll();
    }
    function updateMax(value) {
      max = parseFloat(value);
      ngModelCtrl.$viewValue = minMaxValidator(ngModelCtrl.$modelValue, min, max);
      wrapper.attr('aria-valuemax', value);
      updateAll();
    }
    function updateStep(value) {
      step = parseFloat(value);
    }
    function updateRound(value) {
      // Set max round digits to 6, after 6 the input uses scientific notation
      round = minMaxValidator(parseInt(value), 0, 6);
    }
    function updateAriaDisabled() {
      element.attr('aria-disabled', !!isDisabled());
    }

    // Draw the ticks with canvas.
    // The alternative to drawing ticks with canvas is to draw one element for each tick,
    // which could quickly become a performance bottleneck.
    var tickCanvas, tickCtx;
    function redrawTicks() {
      if (!discrete || isDisabled()) return;
      if (angular.isUndefined(step))         return;

      if (step <= 0) {
        var msg = 'Slider step value must be greater than zero when in discrete mode';
        $log.error(msg);
        throw new Error(msg);
      }

      var numSteps = Math.floor((max - min) / step);
      if (!tickCanvas) {
        tickCanvas = angular.element('<canvas>').css('position', 'absolute');
        tickContainer.append(tickCanvas);

        tickCtx = tickCanvas[0].getContext('2d');
      }

      var dimensions = getSliderDimensions();

      // If `dimensions` doesn't have height and width it might be the first attempt so we will refresh dimensions
      if (dimensions && !dimensions.height && !dimensions.width) {
        refreshSliderDimensions();
        dimensions = sliderDimensions;
      }

      tickCanvas[0].width = dimensions.width;
      tickCanvas[0].height = dimensions.height;

      var distance;
      for (var i = 0; i <= numSteps; i++) {
        var trackTicksStyle = $window.getComputedStyle(tickContainer[0]);
        tickCtx.fillStyle = trackTicksStyle.color || 'black';

        distance = Math.floor((vertical ? dimensions.height : dimensions.width) * (i / numSteps));

        tickCtx.fillRect(vertical ? 0 : distance - 1,
          vertical ? distance - 1 : 0,
          vertical ? dimensions.width : 2,
          vertical ? 2 : dimensions.height);
      }
    }

    function clearTicks() {
      if (tickCanvas && tickCtx) {
        var dimensions = getSliderDimensions();
        tickCtx.clearRect(0, 0, dimensions.width, dimensions.height);
      }
    }

    /**
     * Refreshing Dimensions
     */
    var sliderDimensions = {};
    refreshSliderDimensions();
    function refreshSliderDimensions() {
      sliderDimensions = trackContainer[0].getBoundingClientRect();
    }
    function getSliderDimensions() {
      throttledRefreshDimensions();
      return sliderDimensions;
    }

    /**
     * left/right/up/down arrow listener
     * @param {!KeyboardEvent} ev
     */
    function keydownListener(ev) {
      if (isDisabled()) return;
      var keyCodes = $mdConstant.KEY_CODE;

      var changeAmount;
      switch (ev.keyCode) {
        case keyCodes.DOWN_ARROW:
        case keyCodes.LEFT_ARROW:
          ev.preventDefault();
          changeAmount = -step;
          break;
        case keyCodes.UP_ARROW:
        case keyCodes.RIGHT_ARROW:
          ev.preventDefault();
          changeAmount = step;
          break;
        case keyCodes.PAGE_DOWN:
          ev.preventDefault();
          changeAmount = -step * stepPageSize;
          break;
        case keyCodes.PAGE_UP:
          ev.preventDefault();
          changeAmount = step * stepPageSize;
          break;
        case keyCodes.HOME:
          ev.preventDefault();
          ev.stopPropagation();
          updateValue(min);
          break;
        case keyCodes.END:
          ev.preventDefault();
          ev.stopPropagation();
          updateValue(max);
          break;
      }
      if (changeAmount) {
        changeAmount = invert ? -changeAmount : changeAmount;
        if (ev.metaKey || ev.ctrlKey || ev.altKey) {
          changeAmount *= modifierMultiplier;
        }
        ev.preventDefault();
        ev.stopPropagation();
        updateValue(ngModelCtrl.$viewValue + changeAmount);
      }
    }

    /**
     * @param value new slider value used for setting the model value
     */
    function updateValue(value) {
      scope.$evalAsync(function() {
        setModelValue(value);
      });
    }

    function mouseDownListener() {
      redrawTicks();

      scope.mouseActive = true;
      wrapper.removeClass('md-focused');

      $timeout(function() {
        scope.mouseActive = false;
      }, 100);
    }

    function focusListener() {
      if (scope.mouseActive === false) {
        wrapper.addClass('md-focused');
      }
    }

    function blurListener() {
      wrapper.removeClass('md-focused');
      element.removeClass('md-active');
      clearTicks();
    }

    /**
     * ngModel setters and validators
     */
    function setModelValue(value) {
      ngModelCtrl.$setViewValue(minMaxValidator(stepValidator(value)));
    }
    function ngModelRender() {
      if (isNaN(ngModelCtrl.$viewValue)) {
        ngModelCtrl.$viewValue = ngModelCtrl.$modelValue;
      }

      ngModelCtrl.$viewValue = minMaxValidator(ngModelCtrl.$viewValue);

      var percent = valueToPercent(ngModelCtrl.$viewValue);
      scope.modelValue = ngModelCtrl.$viewValue;
      wrapper.attr('aria-valuenow', ngModelCtrl.$viewValue);
      setSliderPercent(percent);
      thumbText.text(ngModelCtrl.$viewValue);
    }

    function minMaxValidator(value, minValue, maxValue) {
      if (angular.isNumber(value)) {
        minValue = angular.isNumber(minValue) ? minValue : min;
        maxValue = angular.isNumber(maxValue) ? maxValue : max;

        return Math.max(minValue, Math.min(maxValue, value));
      }
    }

    function stepValidator(value) {
      if (angular.isNumber(value)) {
        var formattedValue = (Math.round((value - min) / step) * step + min);
        formattedValue = (Math.round(formattedValue * Math.pow(10, round)) / Math.pow(10, round));

        if (containerCtrl && containerCtrl.fitInputWidthToTextLength) {
          $mdUtil.debounce(function () {
            containerCtrl.fitInputWidthToTextLength(formattedValue.toString().length);
          }, 100)();
        }

        return formattedValue;
      }
    }

    /**
     * @param {number} percent 0-1
     */
    function setSliderPercent(percent) {

      percent = clamp(percent);

      var thumbPosition = (percent * 100) + '%';
      var activeTrackPercent = invert ? (1 - percent) * 100 + '%' : thumbPosition;

      if (vertical) {
        thumbContainer.css('bottom', thumbPosition);
      }
      else {
        $mdUtil.bidiProperty(thumbContainer, 'left', 'right', thumbPosition);
      }


      activeTrack.css(vertical ? 'height' : 'width', activeTrackPercent);

      element.toggleClass((invert ? 'md-max' : 'md-min'), percent === 0);
      element.toggleClass((invert ? 'md-min' : 'md-max'), percent === 1);
    }

    /**
     * Slide listeners
     */
    var isDragging = false;

    function onPressDown(ev) {
      if (isDisabled()) return;

      element.addClass('md-active');
      element[0].focus();
      refreshSliderDimensions();

      var exactVal = percentToValue(positionToPercent(vertical ? ev.pointer.y : ev.pointer.x));
      var closestVal = minMaxValidator(stepValidator(exactVal));
      scope.$apply(function() {
        setModelValue(closestVal);
        setSliderPercent(valueToPercent(closestVal));
      });
    }
    function onPressUp(ev) {
      if (isDisabled()) return;

      element.removeClass('md-dragging');

      var exactVal = percentToValue(positionToPercent(vertical ? ev.pointer.y : ev.pointer.x));
      var closestVal = minMaxValidator(stepValidator(exactVal));
      scope.$apply(function() {
        setModelValue(closestVal);
        ngModelRender();
      });
    }
    function onDragStart(ev) {
      if (isDisabled()) return;
      isDragging = true;

      ev.stopPropagation();

      element.addClass('md-dragging');
      setSliderFromEvent(ev);
    }
    function onDrag(ev) {
      if (!isDragging) return;
      ev.stopPropagation();
      setSliderFromEvent(ev);
    }
    function onDragEnd(ev) {
      if (!isDragging) return;
      ev.stopPropagation();
      isDragging = false;
    }

    function setSliderFromEvent(ev) {
      // While panning discrete, update only the
      // visual positioning but not the model value.
      if (discrete) adjustThumbPosition(vertical ? ev.pointer.y : ev.pointer.x);
      else            doSlide(vertical ? ev.pointer.y : ev.pointer.x);
    }

    /**
     * Slide the UI by changing the model value
     * @param x
     */
    function doSlide(x) {
      scope.$evalAsync(function() {
        setModelValue(percentToValue(positionToPercent(x)));
      });
    }

    /**
     * Slide the UI without changing the model (while dragging/panning)
     * @param x
     */
    function adjustThumbPosition(x) {
      var exactVal = percentToValue(positionToPercent(x));
      var closestVal = minMaxValidator(stepValidator(exactVal));
      setSliderPercent(positionToPercent(x));
      thumbText.text(closestVal);
    }

    /**
    * Clamps the value to be between 0 and 1.
    * @param {number} value The value to clamp.
    * @returns {number}
    */
    function clamp(value) {
      return Math.max(0, Math.min(value || 0, 1));
    }

    /**
     * Convert position on slider to percentage value of offset from beginning...
     * @param position
     * @returns {number}
     */
    function positionToPercent(position) {
      var offset = vertical ? sliderDimensions.top : sliderDimensions.left;
      var size = vertical ? sliderDimensions.height : sliderDimensions.width;
      var calc = (position - offset) / size;

      if (!vertical && $mdUtil.bidi() === 'rtl') {
        calc = 1 - calc;
      }

      return Math.max(0, Math.min(1, vertical ? 1 - calc : calc));
    }

    /**
     * Convert percentage offset on slide to equivalent model value
     * @param percent
     * @returns {*}
     */
    function percentToValue(percent) {
      var adjustedPercent = invert ? (1 - percent) : percent;
      return (min + adjustedPercent * (max - min));
    }

    function valueToPercent(val) {
      var percent = (val - min) / (max - min);
      return invert ? (1 - percent) : percent;
    }
  }
}

})();
(function(){
"use strict";

/**
 * @ngdoc module
 * @name material.components.sticky
 * @description
 * Sticky effects for md
 *
 */
MdSticky.$inject = ["$mdConstant", "$$rAF", "$mdUtil", "$compile"];
angular
  .module('material.components.sticky', [
    'material.core',
    'material.components.content'
  ])
  .factory('$mdSticky', MdSticky);

/**
 * @ngdoc service
 * @name $mdSticky
 * @module material.components.sticky
 *
 * @description
 * The `$mdSticky`service provides a mixin to make elements sticky.
 *
 * Whenever the current browser supports stickiness natively, the `$mdSticky` service will just
 * use the native browser stickiness.
 *
 * By default the `$mdSticky` service compiles the cloned element, when not specified through the `elementClone`
 * parameter, in the same scope as the actual element lives.
 *
 *
 * <h3>Notes</h3>
 * When using an element which is containing a compiled directive, which changed its DOM structure during compilation,
 * you should compile the clone yourself using the plain template.<br/><br/>
 * See the right usage below:
 * <hljs lang="js">
 *   angular.module('myModule')
 *     .directive('stickySelect', function($mdSticky, $compile) {
 *       var SELECT_TEMPLATE =
 *         '<md-select ng-model="selected">' +
 *           '<md-option>Option 1</md-option>' +
 *         '</md-select>';
 *
 *       return {
 *         restrict: 'E',
 *         replace: true,
 *         template: SELECT_TEMPLATE,
 *         link: function(scope,element) {
 *           $mdSticky(scope, element, $compile(SELECT_TEMPLATE)(scope));
 *         }
 *       };
 *     });
 * </hljs>
 *
 * @usage
 * <hljs lang="js">
 *   angular.module('myModule')
 *     .directive('stickyText', function($mdSticky, $compile) {
 *       return {
 *         restrict: 'E',
 *         template: '<span>Sticky Text</span>',
 *         link: function(scope,element) {
 *           $mdSticky(scope, element);
 *         }
 *       };
 *     });
 * </hljs>
 *
 * @returns A `$mdSticky` function that takes three arguments:
 *   - `scope`
 *   - `element`: The element that will be 'sticky'
 *   - `elementClone`: A clone of the element, that will be shown
 *     when the user starts scrolling past the original element.
 *     If not provided, it will use the result of `element.clone()` and compiles it in the given scope.
 */
function MdSticky($mdConstant, $$rAF, $mdUtil, $compile) {

  var browserStickySupport = $mdUtil.checkStickySupport();

  /**
   * Registers an element as sticky, used internally by directives to register themselves
   */
  return function registerStickyElement(scope, element, stickyClone) {
    var contentCtrl = element.controller('mdContent');
    if (!contentCtrl) return;

    if (browserStickySupport) {
      element.css({
        position: browserStickySupport,
        top: 0,
        'z-index': 2
      });
    } else {
      var $$sticky = contentCtrl.$element.data('$$sticky');
      if (!$$sticky) {
        $$sticky = setupSticky(contentCtrl);
        contentCtrl.$element.data('$$sticky', $$sticky);
      }

      // Compile our cloned element, when cloned in this service, into the given scope.
      var cloneElement = stickyClone || $compile(element.clone())(scope);

      var deregister = $$sticky.add(element, cloneElement);
      scope.$on('$destroy', deregister);
    }
  };

  function setupSticky(contentCtrl) {
    var contentEl = contentCtrl.$element;

    // Refresh elements is very expensive, so we use the debounced
    // version when possible.
    var debouncedRefreshElements = $$rAF.throttle(refreshElements);

    // setupAugmentedScrollEvents gives us `$scrollstart` and `$scroll`,
    // more reliable than `scroll` on android.
    setupAugmentedScrollEvents(contentEl);
    contentEl.on('$scrollstart', debouncedRefreshElements);
    contentEl.on('$scroll', onScroll);

    var self;
    return self = {
      prev: null,
      current: null, // the currently stickied item
      next: null,
      items: [],
      add: add,
      refreshElements: refreshElements
    };

    /***************
     * Public
     ***************/
    // Add an element and its sticky clone to this content's sticky collection
    function add(element, stickyClone) {
      stickyClone.addClass('md-sticky-clone');

      var item = {
        element: element,
        clone: stickyClone
      };
      self.items.push(item);

      $mdUtil.nextTick(function() {
        contentEl.prepend(item.clone);
      });

      debouncedRefreshElements();

      return function remove() {
        self.items.forEach(function(item, index) {
          if (item.element[0] === element[0]) {
            self.items.splice(index, 1);
            item.clone.remove();
          }
        });
        debouncedRefreshElements();
      };
    }

    function refreshElements() {
      // Sort our collection of elements by their current position in the DOM.
      // We need to do this because our elements' order of being added may not
      // be the same as their order of display.
      self.items.forEach(refreshPosition);
      self.items = self.items.sort(function(a, b) {
        return a.top < b.top ? -1 : 1;
      });

      // Find which item in the list should be active,
      // based upon the content's current scroll position
      var item;
      var currentScrollTop = contentEl.prop('scrollTop');
      for (var i = self.items.length - 1; i >= 0; i--) {
        if (currentScrollTop > self.items[i].top) {
          item = self.items[i];
          break;
        }
      }
      setCurrentItem(item);
    }

    /***************
     * Private
     ***************/

    // Find the `top` of an item relative to the content element,
    // and also the height.
    function refreshPosition(item) {
      // Find the top of an item by adding to the offsetHeight until we reach the
      // content element.
      var current = item.element[0];
      item.top = 0;
      item.left = 0;
      item.right = 0;
      while (current && current !== contentEl[0]) {
        item.top += current.offsetTop;
        item.left += current.offsetLeft;
        if (current.offsetParent) {
          // Compute offsetRight
          item.right += current.offsetParent.offsetWidth - current.offsetWidth - current.offsetLeft;
        }
        current = current.offsetParent;
      }
      item.height = item.element.prop('offsetHeight');

      var defaultVal = $mdUtil.floatingScrollbars() ? '0' : undefined;
      $mdUtil.bidi(item.clone, 'margin-left', item.left, defaultVal);
      $mdUtil.bidi(item.clone, 'margin-right', defaultVal, item.right);
    }

    // As we scroll, push in and select the correct sticky element.
    function onScroll() {
      var scrollTop = contentEl.prop('scrollTop');
      var isScrollingDown = scrollTop > (onScroll.prevScrollTop || 0);

      // Store the previous scroll so we know which direction we are scrolling
      onScroll.prevScrollTop = scrollTop;

      //
      // AT TOP (not scrolling)
      //
      if (scrollTop === 0) {
        // If we're at the top, just clear the current item and return
        setCurrentItem(null);
        return;
      }

      //
      // SCROLLING DOWN (going towards the next item)
      //
      if (isScrollingDown) {

        // If we've scrolled down past the next item's position, sticky it and return
        if (self.next && self.next.top <= scrollTop) {
          setCurrentItem(self.next);
          return;
        }

        // If the next item is close to the current one, push the current one up out of the way
        if (self.current && self.next && self.next.top - scrollTop <= self.next.height) {
          translate(self.current, scrollTop + (self.next.top - self.next.height - scrollTop));
          return;
        }
      }

      //
      // SCROLLING UP (not at the top & not scrolling down; must be scrolling up)
      //
      if (!isScrollingDown) {

        // If we've scrolled up past the previous item's position, sticky it and return
        if (self.current && self.prev && scrollTop < self.current.top) {
          setCurrentItem(self.prev);
          return;
        }

        // If the next item is close to the current one, pull the current one down into view
        if (self.next && self.current && (scrollTop >= (self.next.top - self.current.height))) {
          translate(self.current, scrollTop + (self.next.top - scrollTop - self.current.height));
          return;
        }
      }

      //
      // Otherwise, just move the current item to the proper place (scrolling up or down)
      //
      if (self.current) {
        translate(self.current, scrollTop);
      }
    }

    function setCurrentItem(item) {
      if (self.current === item) return;
      // Deactivate currently active item
      if (self.current) {
        translate(self.current, null);
        setStickyState(self.current, null);
      }

      // Activate new item if given
      if (item) {
        setStickyState(item, 'active');
      }

      self.current = item;
      var index = self.items.indexOf(item);
      // If index === -1, index + 1 = 0. It works out.
      self.next = self.items[index + 1];
      self.prev = self.items[index - 1];
      setStickyState(self.next, 'next');
      setStickyState(self.prev, 'prev');
    }

    function setStickyState(item, state) {
      if (!item || item.state === state) return;
      if (item.state) {
        item.clone.attr('sticky-prev-state', item.state);
        item.element.attr('sticky-prev-state', item.state);
      }
      item.clone.attr('sticky-state', state);
      item.element.attr('sticky-state', state);
      item.state = state;
    }

    function translate(item, amount) {
      if (!item) return;
      if (amount === null || amount === undefined) {
        if (item.translateY) {
          item.translateY = null;
          item.clone.css($mdConstant.CSS.TRANSFORM, '');
        }
      } else {
        item.translateY = amount;

        $mdUtil.bidi(item.clone, $mdConstant.CSS.TRANSFORM,
          'translate3d(' + item.left + 'px,' + amount + 'px,0)',
          'translateY(' + amount + 'px)'
        );
      }
    }
  }


  // Android 4.4 don't accurately give scroll events.
  // To fix this problem, we setup a fake scroll event. We say:
  // > If a scroll or touchmove event has happened in the last DELAY milliseconds,
  //   then send a `$scroll` event every animationFrame.
  // Additionally, we add $scrollstart and $scrollend events.
  function setupAugmentedScrollEvents(element) {
    var SCROLL_END_DELAY = 200;
    var isScrolling;
    var lastScrollTime;
    element.on('scroll touchmove', function() {
      if (!isScrolling) {
        isScrolling = true;
        $$rAF.throttle(loopScrollEvent);
        element.triggerHandler('$scrollstart');
      }
      element.triggerHandler('$scroll');
      lastScrollTime = +$mdUtil.now();
    });

    function loopScrollEvent() {
      if (+$mdUtil.now() - lastScrollTime > SCROLL_END_DELAY) {
        isScrolling = false;
        element.triggerHandler('$scrollend');
      } else {
        element.triggerHandler('$scroll');
        $$rAF.throttle(loopScrollEvent);
      }
    }
  }

}

})();
(function(){
"use strict";

/**
 * @ngdoc module
 * @name material.components.subheader
 * @description
 * SubHeader module
 *
 *  Subheaders are special list tiles that delineate distinct sections of a
 *  list or grid list and are typically related to the current filtering or
 *  sorting criteria. Subheader tiles are either displayed inline with tiles or
 *  can be associated with content, for example, in an adjacent column.
 *
 *  Upon scrolling, subheaders remain pinned to the top of the screen and remain
 *  pinned until pushed on or off screen by the next subheader. @see [Material
 *  Design Specifications](https://material.io/archive/guidelines/components/subheaders.html)
 *
 *  > To improve the visual grouping of content, use the system color for your subheaders.
 *
 */
MdSubheaderDirective.$inject = ["$mdSticky", "$compile", "$mdTheming", "$mdUtil", "$mdAria"];
angular
  .module('material.components.subheader', [
    'material.core',
    'material.components.sticky'
  ])
  .directive('mdSubheader', MdSubheaderDirective);

/**
 * @ngdoc directive
 * @name mdSubheader
 * @module material.components.subheader
 *
 * @restrict E
 *
 * @description
 * The `md-subheader` directive creates a sticky subheader for a section.
 *
 * Developers are able to disable the stickiness of the subheader by using the following markup
 *
 * <hljs lang="html">
 *   <md-subheader class="md-no-sticky">Not Sticky</md-subheader>
 * </hljs>
 *
 * ### Notes
 * - The `md-subheader` directive uses the <a ng-href="api/service/$mdSticky">$mdSticky</a> service
 * to make the subheader sticky.
 *
 * > Whenever the current browser doesn't support stickiness natively, the subheader
 * will be compiled twice to create a sticky clone of the subheader.
 *
 * @usage
 * <hljs lang="html">
 * <md-subheader>Online Friends</md-subheader>
 * </hljs>
 */

function MdSubheaderDirective($mdSticky, $compile, $mdTheming, $mdUtil, $mdAria) {
  return {
    restrict: 'E',
    replace: true,
    transclude: true,
    template: (
    '<div class="md-subheader _md">' +
    '  <div class="md-subheader-inner">' +
    '    <div class="md-subheader-content"></div>' +
    '  </div>' +
    '</div>'
    ),
    link: function postLink(scope, element, attr, controllers, transclude) {
      $mdTheming(element);
      element.addClass('_md');

      // Remove the ngRepeat attribute from the root element, because we don't want to compile
      // the ngRepeat for the sticky clone again.
      $mdUtil.prefixer().removeAttribute(element, 'ng-repeat');

      var outerHTML = element[0].outerHTML;

      function getContent(el) {
        return angular.element(el[0].querySelector('.md-subheader-content'));
      }

      // Set the ARIA attributes on the original element since it keeps it's original place in
      // the DOM, whereas the clones are in reverse order. Should be done after the outerHTML,
      // in order to avoid having multiple element be marked as headers.
      attr.$set('role', 'heading');
      $mdAria.expect(element, 'aria-level', '2');

      // Transclude the user-given contents of the subheader
      // the conventional way.
      transclude(scope, function(clone) {
        getContent(element).append(clone);
      });

      // Create another clone, that uses the outer and inner contents
      // of the element, that will be 'stickied' as the user scrolls.
      if (!element.hasClass('md-no-sticky')) {
        transclude(scope, function(clone) {
          // If the user adds an ng-if or ng-repeat directly to the md-subheader element, the
          // compiled clone below will only be a comment tag (since they replace their elements with
          // a comment) which cannot be properly passed to the $mdSticky; so we wrap it in our own
          // DIV to ensure we have something $mdSticky can use
          var wrapper = $compile('<div class="md-subheader-wrapper" aria-hidden="true">' + outerHTML + '</div>')(scope);

          // Delay initialization until after any `ng-if`/`ng-repeat`/etc has finished before
          // attempting to create the clone
          $mdUtil.nextTick(function() {
            // Append our transcluded clone into the wrapper.
            // We don't have to recompile the element again, because the clone is already
            // compiled in it's transclusion scope. If we recompile the outerHTML of the new clone, we would lose
            // our ngIf's and other previous registered bindings / properties.
            getContent(wrapper).append(clone);
          });

          // Make the element sticky and provide the stickyClone our self, to avoid recompilation of the subheader
          // element.
          $mdSticky(scope, element, wrapper);
        });
      }
    }
  };
}

})();
(function(){
"use strict";

/**
 * @ngdoc module
 * @name material.components.swipe
 * @description Swipe module!
 */
/**
 * @ngdoc directive
 * @module material.components.swipe
 * @name mdSwipeLeft
 *
 * @restrict A
 *
 * @description
 * The md-swipe-left directive allows you to specify custom behavior when an element is swiped
 * left.
 *
 * ### Notes
 * - The `$event.currentTarget` of the swiped element will be `null`, but you can get a
 * reference to the element that actually holds the `md-swipe-left` directive by using
 * `$target.current`
 *
 * > You can see this in action on the <a ng-href="demo/swipe">demo page</a> (Look at the Developer
 * Tools console while swiping).
 *
 * @usage
 * <hljs lang="html">
 * <div md-swipe-left="onSwipeLeft($event, $target)">Swipe me left!</div>
 * </hljs>
 */
/**
 * @ngdoc directive
 * @module material.components.swipe
 * @name mdSwipeRight
 *
 * @restrict A
 *
 * @description
 * The md-swipe-right directive allows you to specify custom behavior when an element is swiped
 * right.
 *
 * ### Notes
 * - The `$event.currentTarget` of the swiped element will be `null`, but you can get a
 * reference to the element that actually holds the `md-swipe-right` directive by using
 * `$target.current`
 *
 * > You can see this in action on the <a ng-href="demo/swipe">demo page</a> (Look at the Developer
 * Tools console while swiping).
 *
 * @usage
 * <hljs lang="html">
 * <div md-swipe-right="onSwipeRight($event, $target)">Swipe me right!</div>
 * </hljs>
 */
/**
 * @ngdoc directive
 * @module material.components.swipe
 * @name mdSwipeUp
 *
 * @restrict A
 *
 * @description
 * The md-swipe-up directive allows you to specify custom behavior when an element is swiped
 * up.
 *
 * ### Notes
 * - The `$event.currentTarget` of the swiped element will be `null`, but you can get a
 * reference to the element that actually holds the `md-swipe-up` directive by using
 * `$target.current`
 *
 * > You can see this in action on the <a ng-href="demo/swipe">demo page</a> (Look at the Developer
 * Tools console while swiping).
 *
 * @usage
 * <hljs lang="html">
 * <div md-swipe-up="onSwipeUp($event, $target)">Swipe me up!</div>
 * </hljs>
 */
/**
 * @ngdoc directive
 * @module material.components.swipe
 * @name mdSwipeDown
 *
 * @restrict A
 *
 * @description
 * The md-swipe-down directive allows you to specify custom behavior when an element is swiped
 * down.
 *
 * ### Notes
 * - The `$event.currentTarget` of the swiped element will be `null`, but you can get a
 * reference to the element that actually holds the `md-swipe-down` directive by using
 * `$target.current`
 *
 * > You can see this in action on the <a ng-href="demo/swipe">demo page</a> (Look at the Developer
 * Tools console while swiping).
 *
 * @usage
 * <hljs lang="html">
 * <div md-swipe-down="onSwipeDown($event, $target)">Swipe me down!</div>
 * </hljs>
 */

angular.module('material.components.swipe', ['material.core'])
    .directive('mdSwipeLeft', getDirective('SwipeLeft'))
    .directive('mdSwipeRight', getDirective('SwipeRight'))
    .directive('mdSwipeUp', getDirective('SwipeUp'))
    .directive('mdSwipeDown', getDirective('SwipeDown'));

function getDirective(name) {
    DirectiveFactory.$inject = ["$parse"];
  var directiveName = 'md' + name;
  var eventName = '$md.' + name.toLowerCase();

  return DirectiveFactory;

  /* @ngInject */
  function DirectiveFactory($parse) {
      return { restrict: 'A', link: postLink };
      function postLink(scope, element, attr) {
        var fn = $parse(attr[directiveName]);
        element.on(eventName, function(ev) {
          var currentTarget = ev.currentTarget;
          scope.$applyAsync(function() { fn(scope, { $event: ev, $target: { current: currentTarget } }); });
        });
      }
    }
}



})();
(function(){
"use strict";

/**
 * @ngdoc module
 * @name material.components.switch
 */

MdSwitch.$inject = ["mdCheckboxDirective", "$mdUtil", "$mdConstant", "$parse", "$$rAF", "$mdGesture", "$timeout"];
angular.module('material.components.switch', [
  'material.core',
  'material.components.checkbox'
])
  .directive('mdSwitch', MdSwitch);

/**
 * @ngdoc directive
 * @module material.components.switch
 * @name mdSwitch
 * @restrict E
 *
 * The switch directive is used very much like the normal [angular checkbox](https://docs.angularjs.org/api/ng/input/input%5Bcheckbox%5D).
 *
 * As per the [Material Design spec](https://material.io/archive/guidelines/style/color.html#color-color-system)
 * the switch is in the accent color by default. The primary color palette may be used with
 * the `md-primary` class.
 *
 * @param {expression} ng-model Assignable angular expression to data-bind to.
 * @param {string=} name Property name of the form under which the control is published.
 * @param {expression=} ng-true-value The value to which the expression should be set when selected.
 * @param {expression=} ng-false-value The value to which the expression should be set when not selected.
 * @param {expression=} ng-change Expression to be executed when the model value changes.
 * @param {expression=} ng-disabled En/Disable based on the expression.
 * @param {boolean=} md-no-ink Use of attribute indicates use of ripple ink effects.
 * @param {string=} aria-label Publish the button label used by screen-readers for accessibility. Defaults to the switch's text.
 * @param {boolean=} md-invert When set to true, the switch will be inverted.
 *
 * @usage
 * <hljs lang="html">
 * <md-switch ng-model="isActive" aria-label="Finished?">
 *   Finished ?
 * </md-switch>
 *
 * <md-switch md-no-ink ng-model="hasInk" aria-label="No Ink Effects">
 *   No Ink Effects
 * </md-switch>
 *
 * <md-switch ng-disabled="true" ng-model="isDisabled" aria-label="Disabled">
 *   Disabled
 * </md-switch>
 *
 * </hljs>
 */
function MdSwitch(mdCheckboxDirective, $mdUtil, $mdConstant, $parse, $$rAF, $mdGesture, $timeout) {
  var checkboxDirective = mdCheckboxDirective[0];

  return {
    restrict: 'E',
    priority: $mdConstant.BEFORE_NG_ARIA,
    transclude: true,
    template:
      '<div class="md-container">' +
        '<div class="md-bar"></div>' +
        '<div class="md-thumb-container">' +
          '<div class="md-thumb" md-ink-ripple md-ink-ripple-checkbox></div>' +
        '</div>'+
      '</div>' +
      '<div ng-transclude class="md-label"></div>',
    require: ['^?mdInputContainer', '?ngModel', '?^form'],
    compile: mdSwitchCompile
  };

  function mdSwitchCompile(element, attr) {
    var checkboxLink = checkboxDirective.compile(element, attr).post;
    // No transition on initial load.
    element.addClass('md-dragging');

    return function (scope, element, attr, ctrls) {
      var containerCtrl = ctrls[0];
      var ngModel = ctrls[1] || $mdUtil.fakeNgModel();
      var formCtrl = ctrls[2];

      var disabledGetter = null;
      if (attr.disabled != null) {
        disabledGetter = function() { return true; };
      } else if (attr.ngDisabled) {
        disabledGetter = $parse(attr.ngDisabled);
      }

      var thumbContainer = angular.element(element[0].querySelector('.md-thumb-container'));
      var switchContainer = angular.element(element[0].querySelector('.md-container'));
      var labelContainer = angular.element(element[0].querySelector('.md-label'));

      // no transition on initial load
      $$rAF(function() {
        element.removeClass('md-dragging');
      });

      checkboxLink(scope, element, attr, ctrls);

      if (disabledGetter) {
        scope.$watch(disabledGetter, function(isDisabled) {
          element.attr('tabindex', isDisabled ? -1 : 0);
        });
      }

      attr.$observe('mdInvert', function(newValue) {
        var isInverted = $mdUtil.parseAttributeBoolean(newValue);

        isInverted ? element.prepend(labelContainer) : element.prepend(switchContainer);

        // Toggle a CSS class to update the margin.
        element.toggleClass('md-inverted', isInverted);
      });

      // These events are triggered by setup drag
      $mdGesture.register(switchContainer, 'drag');
      switchContainer
        .on('$md.dragstart', onDragStart)
        .on('$md.drag', onDrag)
        .on('$md.dragend', onDragEnd);

      var drag;
      function onDragStart(ev) {
        // Don't go if the switch is disabled.
        if (disabledGetter && disabledGetter(scope)) return;
        ev.stopPropagation();

        element.addClass('md-dragging');
        drag = {width: thumbContainer.prop('offsetWidth')};
      }

      function onDrag(ev) {
        if (!drag) return;
        ev.stopPropagation();
        ev.srcEvent && ev.srcEvent.preventDefault();

        var percent = ev.pointer.distanceX / drag.width;

        // if checked, start from right. else, start from left
        var translate = ngModel.$viewValue ?  1 + percent : percent;
        // Make sure the switch stays inside its bounds, 0-1%
        translate = Math.max(0, Math.min(1, translate));

        thumbContainer.css($mdConstant.CSS.TRANSFORM, 'translate3d(' + (100*translate) + '%,0,0)');
        drag.translate = translate;
      }

      function onDragEnd(ev) {
        if (!drag) return;
        ev.stopPropagation();

        element.removeClass('md-dragging');
        thumbContainer.css($mdConstant.CSS.TRANSFORM, '');

        // We changed if there is no distance (this is a click a click),
        // or if the drag distance is >50% of the total.
        var isChanged = ngModel.$viewValue ? drag.translate < 0.5 : drag.translate > 0.5;
        if (isChanged) {
          applyModelValue(!ngModel.$viewValue);
        }
        drag = null;

        // Wait for incoming mouse click
        scope.skipToggle = true;
        $timeout(function() {
          scope.skipToggle = false;
        }, 1);
      }

      function applyModelValue(newValue) {
        scope.$apply(function() {
          ngModel.$setViewValue(newValue);
          ngModel.$render();
        });
      }

    };
  }


}

})();
(function(){
"use strict";

/**
 * @ngdoc module
 * @name material.components.tabs
 * @description
 *
 *  Tabs, created with the `<md-tabs>` directive provide *tabbed* navigation with different styles.
 *  The Tabs component consists of clickable tabs that are aligned horizontally side-by-side.
 *
 *  Features include support for:
 *
 *  - static or dynamic tabs,
 *  - responsive designs,
 *  - accessibility support (ARIA),
 *  - tab pagination,
 *  - external or internal tab content,
 *  - focus indicators and arrow-key navigations,
 *  - programmatic lookup and access to tab controllers, and
 *  - dynamic transitions through different tab contents.
 *
 */
/*
 * @see js folder for tabs implementation
 */
angular.module('material.components.tabs', [
  'material.core',
  'material.components.icon'
]);

})();
(function(){
"use strict";

angular
.module('material.components.tabs')
.service('MdTabsPaginationService', MdTabsPaginationService);

/**
 * @private
 * @module material.components.tabs
 * @name MdTabsPaginationService
 * @description Provides many standalone functions to ease in pagination calculations.
 *
 * Most functions accept the elements and the current offset.
 *
 * The `elements` parameter is typically the value returned from the `getElements()` function of the
 * tabsController.
 *
 * The `offset` parameter is always positive regardless of LTR or RTL (we simply make the LTR one
 * negative when we apply our transform). This is typically the `ctrl.leftOffset` variable in the
 * tabsController.
 *
 * @returns MdTabsPaginationService
 * @constructor
 */
function MdTabsPaginationService() {
  return {
    decreasePageOffset: decreasePageOffset,
    increasePageOffset: increasePageOffset,
    getTabOffsets: getTabOffsets,
    getTotalTabsWidth: getTotalTabsWidth
  };

  /**
   * Returns the offset for the next decreasing page.
   *
   * @param elements
   * @param currentOffset
   * @returns {number}
   */
  function decreasePageOffset(elements, currentOffset) {
    var canvas       = elements.canvas,
        tabOffsets   = getTabOffsets(elements),
        i, firstVisibleTabOffset;

    // Find the first fully visible tab in offset range
    for (i = 0; i < tabOffsets.length; i++) {
      if (tabOffsets[i] >= currentOffset) {
        firstVisibleTabOffset = tabOffsets[i];
        break;
      }
    }

    // Return (the first visible tab offset - the tabs container width) without going negative
    return Math.max(0, firstVisibleTabOffset - canvas.clientWidth);
  }

  /**
   * Returns the offset for the next increasing page.
   *
   * @param elements
   * @param currentOffset
   * @returns {number}
   */
  function increasePageOffset(elements, currentOffset) {
    var canvas       = elements.canvas,
        maxOffset    = getTotalTabsWidth(elements) - canvas.clientWidth,
        tabOffsets   = getTabOffsets(elements),
        i, firstHiddenTabOffset;

    // Find the first partially (or fully) invisible tab
    for (i = 0; i < tabOffsets.length, tabOffsets[i] <= currentOffset + canvas.clientWidth; i++) {
      firstHiddenTabOffset = tabOffsets[i];
    }

    // Return the offset of the first hidden tab, or the maximum offset (whichever is smaller)
    return Math.min(maxOffset, firstHiddenTabOffset);
  }

  /**
   * Returns the offsets of all of the tabs based on their widths.
   *
   * @param elements
   * @returns {number[]}
   */
  function getTabOffsets(elements) {
    var i, tab, currentOffset = 0, offsets = [];

    for (i = 0; i < elements.tabs.length; i++) {
      tab = elements.tabs[i];
      offsets.push(currentOffset);
      currentOffset += tab.offsetWidth;
    }

    return offsets;
  }

  /**
   * Sum the width of all tabs.
   *
   * @param elements
   * @returns {number}
   */
  function getTotalTabsWidth(elements) {
    var sum = 0, i, tab;

    for (i = 0; i < elements.tabs.length; i++) {
      tab = elements.tabs[i];
      sum += tab.offsetWidth;
    }

    return sum;
  }

}

})();
(function(){
"use strict";

/**
 * @ngdoc directive
 * @name mdTab
 * @module material.components.tabs
 *
 * @restrict E
 *
 * @description
 * The `<md-tab>` is a nested directive used within `<md-tabs>` to specify a tab with a **label**
 * and optional *view content*.
 *
 * If the `label` attribute is not specified, then an optional `<md-tab-label>` tag can be used to
 * specify more complex tab header markup. If neither the **label** nor the **md-tab-label** are
 * specified, then the nested markup of the `<md-tab>` is used as the tab header markup.
 *
 * Please note that if you use `<md-tab-label>`, your content **MUST** be wrapped in the
 * `<md-tab-body>` tag.  This is to define a clear separation between the tab content and the tab
 * label.
 *
 * This container is used by the TabsController to show/hide the active tab's content view. This
 * synchronization is automatically managed by the internal TabsController whenever the tab
 * selection changes. Selection changes can be initiated via data binding changes, programmatic
 * invocation, or user gestures.
 *
 * @param {string=} label Optional attribute to specify a simple string as the tab label
 * @param {boolean=} ng-disabled If present and expression evaluates to truthy, disabled tab
 *  selection.
 * @param {string=} md-tab-class Optional attribute to specify a class that will be applied to the
 *  tab's button
 * @param {expression=} md-on-deselect Expression to be evaluated after the tab has been
 *  de-selected.
 * @param {expression=} md-on-select Expression to be evaluated after the tab has been selected.
 * @param {boolean=} md-active When true, sets the active tab.  Note: There can only be one active
 *  tab at a time.
 *
 *
 * @usage
 *
 * <hljs lang="html">
 * <md-tab label="My Tab" md-tab-class="my-content-tab" ng-disabled md-on-select="onSelect()"
 *         md-on-deselect="onDeselect()">
 *   <h3>My Tab content</h3>
 * </md-tab>
 *
 * <md-tab>
 *   <md-tab-label>
 *     <h3>My Tab</h3>
 *   </md-tab-label>
 *   <md-tab-body>
 *     <p>
 *       Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque
 *       laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi
 *       architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia voluptas sit
 *       aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui ratione
 *       voluptatem sequi nesciunt.
 *     </p>
 *   </md-tab-body>
 * </md-tab>
 * </hljs>
 *
 */
angular
    .module('material.components.tabs')
    .directive('mdTab', MdTab);

function MdTab () {
  return {
    require:  '^?mdTabs',
    terminal: true,
    compile:  function (element, attr) {
      var label = firstChild(element, 'md-tab-label'),
          body  = firstChild(element, 'md-tab-body');

      if (label.length === 0) {
        label = angular.element('<md-tab-label></md-tab-label>');
        if (attr.label) label.text(attr.label);
        else label.append(element.contents());

        if (body.length === 0) {
          var contents = element.contents().detach();
          body         = angular.element('<md-tab-body></md-tab-body>');
          body.append(contents);
        }
      }

      element.append(label);
      if (body.html()) element.append(body);

      return postLink;
    },
    scope:    {
      active:   '=?mdActive',
      disabled: '=?ngDisabled',
      select:   '&?mdOnSelect',
      deselect: '&?mdOnDeselect',
      tabClass: '@mdTabClass'
    }
  };

  function postLink (scope, element, attr, ctrl) {
    if (!ctrl) return;
    var index = ctrl.getTabElementIndex(element),
        body  = firstChild(element, 'md-tab-body').remove(),
        label = firstChild(element, 'md-tab-label').remove(),
        data  = ctrl.insertTab({
          scope:    scope,
          parent:   scope.$parent,
          index:    index,
          element:  element,
          template: body.html(),
          label:    label.html()
        }, index);

    scope.select   = scope.select || angular.noop;
    scope.deselect = scope.deselect || angular.noop;

    scope.$watch('active', function (active) { if (active) ctrl.select(data.getIndex(), true); });
    scope.$watch('disabled', function () { ctrl.refreshIndex(); });
    scope.$watch(
        function () {
          return ctrl.getTabElementIndex(element);
        },
        function (newIndex) {
          data.index = newIndex;
          ctrl.updateTabOrder();
        }
    );
    scope.$on('$destroy', function () { ctrl.removeTab(data); });
  }

  function firstChild (element, tagName) {
    var children = element[0].children;
    for (var i = 0, len = children.length; i < len; i++) {
      var child = children[i];
      if (child.tagName === tagName.toUpperCase()) return angular.element(child);
    }
    return angular.element();
  }
}

})();
(function(){
"use strict";

angular
    .module('material.components.tabs')
    .directive('mdTabItem', MdTabItem);

function MdTabItem () {
  return {
    require: '^?mdTabs',
    link:    function link (scope, element, attr, ctrl) {
      if (!ctrl) return;
      ctrl.attachRipple(scope, element);
    }
  };
}

})();
(function(){
"use strict";

angular
    .module('material.components.tabs')
    .directive('mdTabLabel', MdTabLabel);

function MdTabLabel () {
  return { terminal: true };
}


})();
(function(){
"use strict";


MdTabScroll.$inject = ["$parse"];angular.module('material.components.tabs')
    .directive('mdTabScroll', MdTabScroll);

function MdTabScroll ($parse) {
  return {
    restrict: 'A',
    compile: function ($element, attr) {
      var fn = $parse(attr.mdTabScroll, null, true);
      return function ngEventHandler (scope, element) {
        element.on('wheel', function (event) {
          scope.$apply(function () { fn(scope, { $event: event }); });
        });
      };
    }
  };
}

})();
(function(){
"use strict";


MdTabsController.$inject = ["$scope", "$element", "$window", "$mdConstant", "$mdTabInkRipple", "$mdUtil", "$animateCss", "$attrs", "$compile", "$mdTheming", "$mdInteraction", "$timeout", "MdTabsPaginationService"];angular
    .module('material.components.tabs')
    .controller('MdTabsController', MdTabsController);

/**
 * @ngInject
 */
function MdTabsController ($scope, $element, $window, $mdConstant, $mdTabInkRipple, $mdUtil,
                           $animateCss, $attrs, $compile, $mdTheming, $mdInteraction, $timeout,
                           MdTabsPaginationService) {
  // define private properties
  var ctrl      = this,
      locked    = false,
      queue     = [],
      destroyed = false,
      loaded    = false;

  // Define public methods
  ctrl.$onInit            = $onInit;
  ctrl.updatePagination   = $mdUtil.debounce(updatePagination, 100);
  ctrl.redirectFocus      = redirectFocus;
  ctrl.attachRipple       = attachRipple;
  ctrl.insertTab          = insertTab;
  ctrl.removeTab          = removeTab;
  ctrl.select             = select;
  ctrl.scroll             = scroll;
  ctrl.nextPage           = nextPage;
  ctrl.previousPage       = previousPage;
  ctrl.keydown            = keydown;
  ctrl.canPageForward     = canPageForward;
  ctrl.canPageBack        = canPageBack;
  ctrl.refreshIndex       = refreshIndex;
  ctrl.incrementIndex     = incrementIndex;
  ctrl.getTabElementIndex = getTabElementIndex;
  ctrl.updateInkBarStyles = $mdUtil.debounce(updateInkBarStyles, 100);
  ctrl.updateTabOrder     = $mdUtil.debounce(updateTabOrder, 100);
  ctrl.getFocusedTabId    = getFocusedTabId;

  // For AngularJS 1.4 and older, where there are no lifecycle hooks but bindings are pre-assigned,
  // manually call the $onInit hook.
  if (angular.version.major === 1 && angular.version.minor <= 4) {
    this.$onInit();
  }

  /**
   * AngularJS Lifecycle hook for newer AngularJS versions.
   * Bindings are not guaranteed to have been assigned in the controller, but they are in the
   * $onInit hook.
   */
  function $onInit() {
    // Define one-way bindings
    defineOneWayBinding('stretchTabs', handleStretchTabs);

    // Define public properties with change handlers
    defineProperty('focusIndex', handleFocusIndexChange, ctrl.selectedIndex || 0);
    defineProperty('offsetLeft', handleOffsetChange, 0);
    defineProperty('hasContent', handleHasContent, false);
    defineProperty('maxTabWidth', handleMaxTabWidth, getMaxTabWidth());
    defineProperty('shouldPaginate', handleShouldPaginate, false);

    // Define boolean attributes
    defineBooleanAttribute('noInkBar', handleInkBar);
    defineBooleanAttribute('dynamicHeight', handleDynamicHeight);
    defineBooleanAttribute('noPagination');
    defineBooleanAttribute('swipeContent');
    defineBooleanAttribute('noDisconnect');
    defineBooleanAttribute('autoselect');
    defineBooleanAttribute('noSelectClick');
    defineBooleanAttribute('centerTabs', handleCenterTabs, false);
    defineBooleanAttribute('enableDisconnect');

    // Define public properties
    ctrl.scope             = $scope;
    ctrl.parent            = $scope.$parent;
    ctrl.tabs              = [];
    ctrl.lastSelectedIndex = null;
    ctrl.hasFocus          = false;
    ctrl.styleTabItemFocus = false;
    ctrl.shouldCenterTabs  = shouldCenterTabs();
    ctrl.tabContentPrefix  = 'tab-content-';
    ctrl.navigationHint = 'Use the left and right arrow keys to navigate between tabs';

    // Setup the tabs controller after all bindings are available.
    setupTabsController();
  }

  /**
   * Perform setup for the controller, setup events and watcher(s)
   */
  function setupTabsController () {
    ctrl.selectedIndex = ctrl.selectedIndex || 0;
    compileTemplate();
    configureWatchers();
    bindEvents();
    $mdTheming($element);
    $mdUtil.nextTick(function () {
      updateHeightFromContent();
      adjustOffset();
      updateInkBarStyles();
      ctrl.tabs[ ctrl.selectedIndex ] && ctrl.tabs[ ctrl.selectedIndex ].scope.select();
      loaded = true;
      updatePagination();
    });
  }

  /**
   * Compiles the template provided by the user.  This is passed as an attribute from the tabs
   * directive's template function.
   */
  function compileTemplate () {
    var template = $attrs.$mdTabsTemplate,
        element  = angular.element($element[0].querySelector('md-tab-data'));

    element.html(template);
    $compile(element.contents())(ctrl.parent);
    delete $attrs.$mdTabsTemplate;
  }

  /**
   * Binds events used by the tabs component.
   */
  function bindEvents () {
    angular.element($window).on('resize', handleWindowResize);
    $scope.$on('$destroy', cleanup);
  }

  /**
   * Configure watcher(s) used by Tabs
   */
  function configureWatchers () {
    $scope.$watch('$mdTabsCtrl.selectedIndex', handleSelectedIndexChange);
  }

  /**
   * Creates a one-way binding manually rather than relying on AngularJS's isolated scope
   * @param key
   * @param handler
   */
  function defineOneWayBinding (key, handler) {
    var attr = $attrs.$normalize('md-' + key);
    if (handler) defineProperty(key, handler);
    $attrs.$observe(attr, function (newValue) { ctrl[ key ] = newValue; });
  }

  /**
   * Defines boolean attributes with default value set to true. I.e. md-stretch-tabs with no value
   * will be treated as being truthy.
   * @param {string} key
   * @param {Function} handler
   */
  function defineBooleanAttribute (key, handler) {
    var attr = $attrs.$normalize('md-' + key);
    if (handler) defineProperty(key, handler);
    if ($attrs.hasOwnProperty(attr)) updateValue($attrs[attr]);
    $attrs.$observe(attr, updateValue);
    function updateValue (newValue) {
      ctrl[ key ] = newValue !== 'false';
    }
  }

  /**
   * Remove any events defined by this controller
   */
  function cleanup () {
    destroyed = true;
    angular.element($window).off('resize', handleWindowResize);
  }

  // Change handlers

  /**
   * Toggles stretch tabs class and updates inkbar when tab stretching changes.
   */
  function handleStretchTabs () {
    var elements = getElements();
    angular.element(elements.wrapper).toggleClass('md-stretch-tabs', shouldStretchTabs());
    updateInkBarStyles();
  }

  /**
   * Update the value of ctrl.shouldCenterTabs.
   */
  function handleCenterTabs () {
    ctrl.shouldCenterTabs = shouldCenterTabs();
  }

  /**
   * @param {number} newWidth new max tab width in pixels
   * @param {number} oldWidth previous max tab width in pixels
   */
  function handleMaxTabWidth (newWidth, oldWidth) {
    if (newWidth !== oldWidth) {
      var elements = getElements();

      // Set the max width for the real tabs
      angular.forEach(elements.tabs, function(tab) {
        tab.style.maxWidth = newWidth + 'px';
      });

      // Set the max width for the dummy tabs too
      angular.forEach(elements.dummies, function(tab) {
        tab.style.maxWidth = newWidth + 'px';
      });

      $mdUtil.nextTick(ctrl.updateInkBarStyles);
    }
  }

  function handleShouldPaginate (newValue, oldValue) {
    if (newValue !== oldValue) {
      ctrl.maxTabWidth      = getMaxTabWidth();
      ctrl.shouldCenterTabs = shouldCenterTabs();
      $mdUtil.nextTick(function () {
        ctrl.maxTabWidth = getMaxTabWidth();
        adjustOffset(ctrl.selectedIndex);
      });
    }
  }

  /**
   * Add/remove the `md-no-tab-content` class depending on `ctrl.hasContent`
   * @param {boolean} hasContent
   */
  function handleHasContent (hasContent) {
    $element[ hasContent ? 'removeClass' : 'addClass' ]('md-no-tab-content');
  }

  /**
   * Apply ctrl.offsetLeft to the paging element when it changes
   * @param {string|number} left
   */
  function handleOffsetChange (left) {
    var newValue = ((ctrl.shouldCenterTabs || isRtl() ? '' : '-') + left + 'px');

    // Fix double-negative which can happen with RTL support
    newValue = newValue.replace('--', '');

    angular.element(getElements().paging).css($mdConstant.CSS.TRANSFORM,
                                              'translate(' + newValue + ', 0)');
    $scope.$broadcast('$mdTabsPaginationChanged');
  }

  /**
   * Update the UI whenever `ctrl.focusIndex` is updated
   * @param {number} newIndex
   * @param {number} oldIndex
   */
  function handleFocusIndexChange (newIndex, oldIndex) {
    if (newIndex === oldIndex) return;
    if (!getElements().tabs[ newIndex ]) return;
    adjustOffset();
    redirectFocus();
  }

  /**
   * Update the UI whenever the selected index changes. Calls user-defined select/deselect methods.
   * @param {number} newValue selected index's new value
   * @param {number} oldValue selected index's previous value
   */
  function handleSelectedIndexChange (newValue, oldValue) {
    if (newValue === oldValue) return;

    ctrl.selectedIndex     = getNearestSafeIndex(newValue);
    ctrl.lastSelectedIndex = oldValue;
    ctrl.updateInkBarStyles();
    updateHeightFromContent();
    adjustOffset(newValue);
    $scope.$broadcast('$mdTabsChanged');
    ctrl.tabs[ oldValue ] && ctrl.tabs[ oldValue ].scope.deselect();
    ctrl.tabs[ newValue ] && ctrl.tabs[ newValue ].scope.select();
  }

  function getTabElementIndex(tabEl){
    var tabs = $element[0].getElementsByTagName('md-tab');
    return Array.prototype.indexOf.call(tabs, tabEl[0]);
  }

  /**
   * Queues up a call to `handleWindowResize` when a resize occurs while the tabs component is
   * hidden.
   */
  function handleResizeWhenVisible () {
    // if there is already a watcher waiting for resize, do nothing
    if (handleResizeWhenVisible.watcher) return;
    // otherwise, we will abuse the $watch function to check for visible
    handleResizeWhenVisible.watcher = $scope.$watch(function () {
      // since we are checking for DOM size, we use $mdUtil.nextTick() to wait for after the DOM updates
      $mdUtil.nextTick(function () {
        // if the watcher has already run (ie. multiple digests in one cycle), do nothing
        if (!handleResizeWhenVisible.watcher) return;

        if ($element.prop('offsetParent')) {
          handleResizeWhenVisible.watcher();
          handleResizeWhenVisible.watcher = null;

          handleWindowResize();
        }
      }, false);
    });
  }

  // Event handlers / actions

  /**
   * Handle user keyboard interactions
   * @param {KeyboardEvent} event keydown event
   */
  function keydown (event) {
    switch (event.keyCode) {
      case $mdConstant.KEY_CODE.LEFT_ARROW:
        event.preventDefault();
        incrementIndex(-1, true);
        break;
      case $mdConstant.KEY_CODE.RIGHT_ARROW:
        event.preventDefault();
        incrementIndex(1, true);
        break;
      case $mdConstant.KEY_CODE.SPACE:
      case $mdConstant.KEY_CODE.ENTER:
        event.preventDefault();
        if (!locked) select(ctrl.focusIndex);
        break;
      case $mdConstant.KEY_CODE.TAB:
        // On tabbing out of the tablist, reset hasFocus to reset ng-focused and
        // its md-focused class if the focused tab is not the active tab.
        if (ctrl.focusIndex !== ctrl.selectedIndex) {
          ctrl.focusIndex = ctrl.selectedIndex;
        }
        break;
    }
  }

  /**
   * Update the selected index. Triggers a click event on the original `md-tab` element in order
   * to fire user-added click events if canSkipClick or `md-no-select-click` are false.
   * @param index
   * @param canSkipClick Optionally allow not firing the click event if `md-no-select-click` is also true.
   */
  function select (index, canSkipClick) {
    if (!locked) ctrl.focusIndex = ctrl.selectedIndex = index;
    // skip the click event if noSelectClick is enabled
    if (canSkipClick && ctrl.noSelectClick) return;
    // nextTick is required to prevent errors in user-defined click events
    $mdUtil.nextTick(function () {
      ctrl.tabs[ index ].element.triggerHandler('click');
    }, false);
  }

  /**
   * When pagination is on, this makes sure the selected index is in view.
   * @param {WheelEvent} event
   */
  function scroll (event) {
    if (!ctrl.shouldPaginate) return;
    event.preventDefault();
    if (event.deltaY) {
      ctrl.offsetLeft = fixOffset(ctrl.offsetLeft + event.deltaY);
    } else if (event.deltaX) {
      ctrl.offsetLeft = fixOffset(ctrl.offsetLeft + event.deltaX);
    }
  }

  /**
   * Slides the tabs over approximately one page forward.
   */
  function nextPage () {
    if (!ctrl.canPageForward()) { return; }

    var newOffset = MdTabsPaginationService.increasePageOffset(getElements(), ctrl.offsetLeft);

    ctrl.offsetLeft = fixOffset(newOffset);
  }

  /**
   * Slides the tabs over approximately one page backward.
   */
  function previousPage () {
    if (!ctrl.canPageBack()) { return; }

    var newOffset = MdTabsPaginationService.decreasePageOffset(getElements(), ctrl.offsetLeft);

    // Set the new offset
    ctrl.offsetLeft = fixOffset(newOffset);
  }

  /**
   * Update size calculations when the window is resized.
   */
  function handleWindowResize () {
    ctrl.lastSelectedIndex = ctrl.selectedIndex;
    ctrl.offsetLeft        = fixOffset(ctrl.offsetLeft);

    $mdUtil.nextTick(function () {
      ctrl.updateInkBarStyles();
      updatePagination();
    });
  }

  /**
   * Hides or shows the tabs ink bar.
   * @param {boolean} hide A Boolean (not just truthy/falsy) value to determine whether the class
   * should be added or removed.
   */
  function handleInkBar (hide) {
    angular.element(getElements().inkBar).toggleClass('ng-hide', hide);
  }

  /**
   * Enables or disables tabs dynamic height.
   * @param {boolean} value A Boolean (not just truthy/falsy) value to determine whether the class
   * should be added or removed.
   */
  function handleDynamicHeight (value) {
    $element.toggleClass('md-dynamic-height', value);
  }

  /**
   * Remove a tab from the data and select the nearest valid tab.
   * @param {Object} tabData tab to remove
   */
  function removeTab (tabData) {
    if (destroyed) return;
    var selectedIndex = ctrl.selectedIndex,
        tab           = ctrl.tabs.splice(tabData.getIndex(), 1)[ 0 ];
    refreshIndex();
    // when removing a tab, if the selected index did not change, we have to manually trigger the
    //   tab select/deselect events
    if (ctrl.selectedIndex === selectedIndex) {
      tab.scope.deselect();
      ctrl.tabs[ ctrl.selectedIndex ] && ctrl.tabs[ ctrl.selectedIndex ].scope.select();
    }
    $mdUtil.nextTick(function () {
      updatePagination();
      ctrl.offsetLeft = fixOffset(ctrl.offsetLeft);
    });
  }

  /**
   * Create an entry in the tabs array for a new tab at the specified index.
   * @param {Object} tabData tab to insert
   * @param {number} index location to insert the new tab
   * @returns {Object} the inserted tab
   */
  function insertTab (tabData, index) {
    var hasLoaded = loaded;
    var proto = {
          getIndex:     function () { return ctrl.tabs.indexOf(tab); },
          isActive:     function () { return this.getIndex() === ctrl.selectedIndex; },
          isLeft:       function () { return this.getIndex() < ctrl.selectedIndex; },
          isRight:      function () { return this.getIndex() > ctrl.selectedIndex; },
          shouldRender: function () { return !ctrl.noDisconnect || this.isActive(); },
          hasFocus:     function () {
            return ctrl.styleTabItemFocus
                && ctrl.hasFocus && this.getIndex() === ctrl.focusIndex;
          },
          id:           $mdUtil.nextUid(),
          hasContent: !!(tabData.template && tabData.template.trim())
    };
    var tab = angular.extend(proto, tabData);

    if (angular.isDefined(index)) {
      ctrl.tabs.splice(index, 0, tab);
    } else {
      ctrl.tabs.push(tab);
    }
    processQueue();
    updateHasContent();

    $mdUtil.nextTick(function () {
      updatePagination();
      setAriaControls(tab);

      // if autoselect is enabled, select the newly added tab
      if (hasLoaded && ctrl.autoselect) {
        $mdUtil.nextTick(function () {
          $mdUtil.nextTick(function () { select(ctrl.tabs.indexOf(tab)); });
        });
      }
    });
    return tab;
  }

  // Getter methods

  /**
   * Gathers references to all of the DOM elements used by this controller.
   * @returns {Object}
   */
  function getElements () {
    var elements = {};
    var node = $element[0];

    // gather tab bar elements
    elements.wrapper = node.querySelector('md-tabs-wrapper');
    elements.canvas  = elements.wrapper.querySelector('md-tabs-canvas');
    elements.paging  = elements.canvas.querySelector('md-pagination-wrapper');
    elements.inkBar  = elements.paging.querySelector('md-ink-bar');
    elements.nextButton = node.querySelector('md-next-button');
    elements.prevButton = node.querySelector('md-prev-button');

    elements.contents = node.querySelectorAll('md-tabs-content-wrapper > md-tab-content');
    elements.tabs    = elements.paging.querySelectorAll('md-tab-item');
    elements.dummies = elements.canvas.querySelectorAll('md-dummy-tab');

    return elements;
  }

  /**
   * Determines whether or not the left pagination arrow should be enabled.
   * @returns {boolean}
   */
  function canPageBack () {
    // This works for both LTR and RTL
    return ctrl.offsetLeft > 0;
  }

  /**
   * Determines whether or not the right pagination arrow should be enabled.
   * @returns {*|boolean}
   */
  function canPageForward () {
    var elements = getElements();
    var lastTab = elements.tabs[ elements.tabs.length - 1 ];

    if (isRtl()) {
      return ctrl.offsetLeft < elements.paging.offsetWidth - elements.canvas.offsetWidth;
    }

    return lastTab && lastTab.offsetLeft + lastTab.offsetWidth > elements.canvas.clientWidth +
        ctrl.offsetLeft;
  }

  /**
   * Returns currently focused tab item's element ID
   */
  function getFocusedTabId() {
    var focusedTab = ctrl.tabs[ctrl.focusIndex];
    if (!focusedTab || !focusedTab.id) {
      return null;
    }
    return 'tab-item-' + focusedTab.id;
  }

  /**
   * Determines if the UI should stretch the tabs to fill the available space.
   * @returns {*}
   */
  function shouldStretchTabs () {
    switch (ctrl.stretchTabs) {
      case 'always':
        return true;
      case 'never':
        return false;
      default:
        return !ctrl.shouldPaginate
            && $window.matchMedia('(max-width: 600px)').matches;
    }
  }

  /**
   * Determines if the tabs should appear centered.
   * @returns {boolean}
   */
  function shouldCenterTabs () {
    return ctrl.centerTabs && !ctrl.shouldPaginate;
  }

  /**
   * Determines if pagination is necessary to display the tabs within the available space.
   * @returns {boolean} true if pagination is necessary, false otherwise
   */
  function shouldPaginate () {
    var shouldPaginate;
    if (ctrl.noPagination || !loaded) return false;
    var canvasWidth = $element.prop('clientWidth');

    angular.forEach(getElements().tabs, function (tab) {
      canvasWidth -= tab.offsetWidth;
    });

    shouldPaginate = canvasWidth < 0;
    // Work around width calculation issues on IE11 when pagination is enabled.
    // Don't do this on other browsers because it breaks scroll to new tab animation.
    if ($mdUtil.msie) {
      if (shouldPaginate) {
        getElements().paging.style.width = '999999px';
      } else {
        getElements().paging.style.width = undefined;
      }
    }
    return shouldPaginate;
  }

  /**
   * Finds the nearest tab index that is available. This is primarily used for when the active
   * tab is removed.
   * @param newIndex
   * @returns {*}
   */
  function getNearestSafeIndex (newIndex) {
    if (newIndex === -1) return -1;
    var maxOffset = Math.max(ctrl.tabs.length - newIndex, newIndex),
        i, tab;
    for (i = 0; i <= maxOffset; i++) {
      tab = ctrl.tabs[ newIndex + i ];
      if (tab && (tab.scope.disabled !== true)) return tab.getIndex();
      tab = ctrl.tabs[ newIndex - i ];
      if (tab && (tab.scope.disabled !== true)) return tab.getIndex();
    }
    return newIndex;
  }

  // Utility methods

  /**
   * Defines a property using a getter and setter in order to trigger a change handler without
   * using `$watch` to observe changes.
   * @param {PropertyKey} key
   * @param {Function} handler
   * @param {any} value
   */
  function defineProperty (key, handler, value) {
    Object.defineProperty(ctrl, key, {
      get: function () { return value; },
      set: function (newValue) {
        var oldValue = value;
        value        = newValue;
        handler && handler(newValue, oldValue);
      }
    });
  }

  /**
   * Updates whether or not pagination should be displayed.
   */
  function updatePagination () {
    ctrl.maxTabWidth = getMaxTabWidth();
    ctrl.shouldPaginate = shouldPaginate();
  }

  /**
   * @param {Array<HTMLElement>} tabs tab item elements for use in computing total width
   * @returns {number} the width of the tabs in the specified array in pixels
   */
  function calcTabsWidth(tabs) {
    var width = 0;

    angular.forEach(tabs, function (tab) {
      // Uses the larger value between `getBoundingClientRect().width` and `offsetWidth`.  This
      // prevents `offsetWidth` value from being rounded down and causing wrapping issues, but
      // also handles scenarios where `getBoundingClientRect()` is inaccurate (ie. tabs inside
      // of a dialog).
      width += Math.max(tab.offsetWidth, tab.getBoundingClientRect().width);
    });

    return Math.ceil(width);
  }

  /**
   * @returns {number} either the max width as constrained by the container or the max width from
   * the 2017 version of the Material Design spec.
   */
  function getMaxTabWidth() {
    var elements = getElements(),
      containerWidth = elements.canvas.clientWidth,

      // See https://material.io/archive/guidelines/components/tabs.html#tabs-specs
      specMax = 264;

    // Do the spec maximum, or the canvas width; whichever is *smaller* (tabs larger than the canvas
    // width can break the pagination) but not less than 0
    return Math.max(0, Math.min(containerWidth - 1, specMax));
  }

  /**
   * Re-orders the tabs and updates the selected and focus indexes to their new positions.
   * This is triggered by `tabDirective.js` when the user's tabs have been re-ordered.
   */
  function updateTabOrder () {
    var selectedItem   = ctrl.tabs[ ctrl.selectedIndex ],
        focusItem      = ctrl.tabs[ ctrl.focusIndex ];
    ctrl.tabs          = ctrl.tabs.sort(function (a, b) {
      return a.index - b.index;
    });
    ctrl.selectedIndex = ctrl.tabs.indexOf(selectedItem);
    ctrl.focusIndex    = ctrl.tabs.indexOf(focusItem);
  }

  /**
   * This moves the selected or focus index left or right. This is used by the keydown handler.
   * @param {number} inc amount to increment
   * @param {boolean} focus true to increment the focus index, false to increment the selected index
   */
  function incrementIndex (inc, focus) {
    var newIndex,
        key   = focus ? 'focusIndex' : 'selectedIndex',
        index = ctrl[ key ];
    for (newIndex = index + inc;
         ctrl.tabs[ newIndex ] && ctrl.tabs[ newIndex ].scope.disabled;
         newIndex += inc) { /* do nothing */ }

    newIndex = (index + inc + ctrl.tabs.length) % ctrl.tabs.length;

    if (ctrl.tabs[ newIndex ]) {
      ctrl[ key ] = newIndex;
    }
  }

  /**
   * This is used to forward focus to tab container elements. This method is necessary to avoid
   * animation issues when attempting to focus an item that is out of view.
   */
  function redirectFocus () {
    ctrl.styleTabItemFocus = ($mdInteraction.getLastInteractionType() === 'keyboard');
    var tabToFocus = getElements().tabs[ctrl.focusIndex];
    if (tabToFocus) {
      tabToFocus.focus();
    }
  }

  /**
   * Forces the pagination to move the focused tab into view.
   * @param {number=} index of tab to have its offset adjusted
   */
  function adjustOffset (index) {
    var elements = getElements();

    if (!angular.isNumber(index)) index = ctrl.focusIndex;
    if (!elements.tabs[ index ]) return;
    if (ctrl.shouldCenterTabs) return;
    var tab         = elements.tabs[ index ],
        left        = tab.offsetLeft,
        right       = tab.offsetWidth + left,
        extraOffset = 32;

    // If we are selecting the first tab (in LTR and RTL), always set the offset to 0
    if (index === 0) {
      ctrl.offsetLeft = 0;
      return;
    }

    if (isRtl()) {
      var tabWidthsBefore = calcTabsWidth(Array.prototype.slice.call(elements.tabs, 0, index));
      var tabWidthsIncluding = calcTabsWidth(Array.prototype.slice.call(elements.tabs, 0, index + 1));

      ctrl.offsetLeft = Math.min(ctrl.offsetLeft, fixOffset(tabWidthsBefore));
      ctrl.offsetLeft = Math.max(ctrl.offsetLeft, fixOffset(tabWidthsIncluding - elements.canvas.clientWidth));
    } else {
      ctrl.offsetLeft = Math.max(ctrl.offsetLeft, fixOffset(right - elements.canvas.clientWidth + extraOffset));
      ctrl.offsetLeft = Math.min(ctrl.offsetLeft, fixOffset(left));
    }
  }

  /**
   * Iterates through all queued functions and clears the queue. This is used for functions that
   * are called before the UI is ready, such as size calculations.
   */
  function processQueue () {
    queue.forEach(function (func) { $mdUtil.nextTick(func); });
    queue = [];
  }

  /**
   * Determines if the tab content area is needed.
   */
  function updateHasContent () {
    var hasContent = false;
    var i;

    for (i = 0; i < ctrl.tabs.length; i++) {
      if (ctrl.tabs[i].hasContent) {
        hasContent = true;
        break;
      }
    }

    ctrl.hasContent = hasContent;
  }

  /**
   * Moves the indexes to their nearest valid values.
   */
  function refreshIndex () {
    ctrl.selectedIndex = getNearestSafeIndex(ctrl.selectedIndex);
    ctrl.focusIndex    = getNearestSafeIndex(ctrl.focusIndex);
  }

  /**
   * Calculates the content height of the current tab.
   * @returns {*}
   */
  function updateHeightFromContent () {
    if (!ctrl.dynamicHeight) return $element.css('height', '');
    if (!ctrl.tabs.length) return queue.push(updateHeightFromContent);

    var elements = getElements();

    var tabContent    = elements.contents[ ctrl.selectedIndex ],
        contentHeight = tabContent ? tabContent.offsetHeight : 0,
        tabsHeight    = elements.wrapper.offsetHeight,
        newHeight     = contentHeight + tabsHeight,
        currentHeight = $element.prop('clientHeight');

    if (currentHeight === newHeight) return;

    // Adjusts calculations for when the buttons are bottom-aligned since this relies on absolute
    // positioning.  This should probably be cleaned up if a cleaner solution is possible.
    if ($element.attr('md-align-tabs') === 'bottom') {
      currentHeight -= tabsHeight;
      newHeight -= tabsHeight;
      // Need to include bottom border in these calculations
      if ($element.attr('md-border-bottom') !== undefined) {
        ++currentHeight;
      }
    }

    // Lock during animation so the user can't change tabs
    locked = true;

    var fromHeight = { height: currentHeight + 'px' },
        toHeight = { height: newHeight + 'px' };

    // Set the height to the current, specific pixel height to fix a bug on iOS where the height
    // first animates to 0, then back to the proper height causing a visual glitch
    $element.css(fromHeight);

    // Animate the height from the old to the new
    $animateCss($element, {
      from: fromHeight,
      to: toHeight,
      easing: 'cubic-bezier(0.35, 0, 0.25, 1)',
      duration: 0.5
    }).start().done(function () {
      // Then (to fix the same iOS issue as above), disable transitions and remove the specific
      // pixel height so the height can size with browser width/content changes, etc.
      $element.css({
        transition: 'none',
        height: ''
      });

      // In the next tick, re-allow transitions (if we do it all at once, $element.css is "smart"
      // enough to batch it for us instead of doing it immediately, which undoes the original
      // transition: none)
      $mdUtil.nextTick(function() {
        $element.css('transition', '');
      });

      // And unlock so tab changes can occur
      locked = false;
    });
  }

  /**
   * Repositions the ink bar to the selected tab.
   * Parameters are used when calling itself recursively when md-center-tabs is used as we need to
   * run two passes to properly center the tabs. These parameters ensure that we only run two passes
   * and that we don't run indefinitely.
   * @param {number=} previousTotalWidth previous width of pagination wrapper
   * @param {number=} previousWidthOfTabItems previous width of all tab items
   */
  function updateInkBarStyles (previousTotalWidth, previousWidthOfTabItems) {
    if (ctrl.noInkBar) {
      return;
    }
    var elements = getElements();

    if (!elements.tabs[ ctrl.selectedIndex ]) {
      angular.element(elements.inkBar).css({ left: 'auto', right: 'auto' });
      return;
    }

    if (!ctrl.tabs.length) {
      queue.push(ctrl.updateInkBarStyles);
      return;
    }
    // If the element is not visible, we will not be able to calculate sizes until it becomes
    // visible. We should treat that as a resize event rather than just updating the ink bar.
    if (!$element.prop('offsetParent')) {
      handleResizeWhenVisible();
      return;
    }

    var index      = ctrl.selectedIndex,
        totalWidth = elements.paging.offsetWidth,
        tab        = elements.tabs[ index ],
        left       = tab.offsetLeft,
        right      = totalWidth - left - tab.offsetWidth;

    if (ctrl.shouldCenterTabs) {
      // We need to use the same calculate process as in the pagination wrapper, to avoid rounding
      // deviations.
      var totalWidthOfTabItems = calcTabsWidth(elements.tabs);

      if (totalWidth > totalWidthOfTabItems &&
          previousTotalWidth !== totalWidth &&
          previousWidthOfTabItems !== totalWidthOfTabItems) {
        $timeout(updateInkBarStyles, 0, true, totalWidth, totalWidthOfTabItems);
      }
    }
    updateInkBarClassName();
    angular.element(elements.inkBar).css({ left: left + 'px', right: right + 'px' });
  }

  /**
   * Adds left/right classes so that the ink bar will animate properly.
   */
  function updateInkBarClassName () {
    var elements = getElements();
    var newIndex = ctrl.selectedIndex,
        oldIndex = ctrl.lastSelectedIndex,
        ink      = angular.element(elements.inkBar);
    if (!angular.isNumber(oldIndex)) return;
    ink
        .toggleClass('md-left', newIndex < oldIndex)
        .toggleClass('md-right', newIndex > oldIndex);
  }

  /**
   * Takes an offset value and makes sure that it is within the min/max allowed values.
   * @param {number} value
   * @returns {number}
   */
  function fixOffset (value) {
    var elements = getElements();

    if (!elements.tabs.length || !ctrl.shouldPaginate) return 0;

    var lastTab    = elements.tabs[ elements.tabs.length - 1 ],
        totalWidth = lastTab.offsetLeft + lastTab.offsetWidth;

    if (isRtl()) {
      value = Math.min(elements.paging.offsetWidth - elements.canvas.clientWidth, value);
      value = Math.max(0, value);
    } else {
      value = Math.max(0, value);
      value = Math.min(totalWidth - elements.canvas.clientWidth, value);
    }

    return value;
  }

  /**
   * Attaches a ripple to the tab item element.
   * @param scope
   * @param element
   */
  function attachRipple (scope, element) {
    var elements = getElements();
    var options = { colorElement: angular.element(elements.inkBar) };
    $mdTabInkRipple.attach(scope, element, options);
  }

  /**
   * Sets the `aria-controls` attribute to the elements that correspond to the passed-in tab.
   * @param tab
   */
  function setAriaControls (tab) {
    if (tab.hasContent) {
      var nodes = $element[0].querySelectorAll('[md-tab-id="' + tab.id + '"]');
      angular.element(nodes).attr('aria-controls', ctrl.tabContentPrefix + tab.id);
    }
  }

  function isRtl() {
    return ($mdUtil.bidi() === 'rtl');
  }
}

})();
(function(){
"use strict";

/**
 * @ngdoc directive
 * @name mdTabs
 * @module material.components.tabs
 *
 * @restrict E
 *
 * @description
 * The `<md-tabs>` directive serves as the container for 1..n
 * <a ng-href="api/directive/mdTab">`<md-tab>`</a> child directives.
 * In turn, the nested `<md-tab>` directive is used to specify a tab label for the
 * **header button** and <i>optional</i> tab view content that will be associated with each tab
 * button.
 *
 * Below is the markup for its simplest usage:
 *
 *  <hljs lang="html">
 *  <md-tabs>
 *    <md-tab label="Tab #1"></md-tab>
 *    <md-tab label="Tab #2"></md-tab>
 *    <md-tab label="Tab #3"></md-tab>
 *  </md-tabs>
 *  </hljs>
 *
 * Tabs support three (3) usage scenarios:
 *
 *  1. Tabs (buttons only)
 *  2. Tabs with internal view content
 *  3. Tabs with external view content
 *
 * **Tabs-only** support is useful when tab buttons are used for custom navigation regardless of any
 * other components, content, or views.
 *
 * <i><b>Note:</b> If you are using the Tabs component for page-level navigation, please use
 * the <a ng-href="./api/directive/mdNavBar">NavBar component</a> instead. It handles this
 * case a more natively and more performantly.</i>
 *
 * **Tabs with internal views** are the traditional usage where each tab has associated view
 * content and the view switching is managed internally by the Tabs component.
 *
 * **Tabs with external view content** is often useful when content associated with each tab is
 * independently managed and data-binding notifications announce tab selection changes.
 *
 * Additional features also include:
 *
 * *  Content can include any markup.
 * *  If a tab is disabled while active/selected, then the next tab will be auto-selected.
 *
 * ### Explanation of tab stretching
 *
 * Initially, tabs will have an inherent size.  This size will either be defined by how much space
 * is needed to accommodate their text or set by the user through CSS.
 * Calculations will be based on this size.
 *
 * On mobile devices, tabs will be expanded to fill the available horizontal space.
 * When this happens, all tabs will become the same size.
 *
 * On desktops, by default, stretching will never occur.
 *
 * This default behavior can be overridden through the `md-stretch-tabs` attribute.
 * Here is a table showing when stretching will occur:
 *
 * `md-stretch-tabs` | mobile    | desktop
 * ------------------|-----------|--------
 * `auto`            | stretched | ---
 * `always`          | stretched | stretched
 * `never`           | ---       | ---
 *
 * @param {integer=} md-selected Index of the active/selected tab.
 * @param {boolean=} md-no-ink-bar If present, disables the selection ink bar.
 * @param {string=}  md-align-tabs Attribute to indicate position of tab buttons: `bottom` or `top`;
 *  Default is `top`.
 * @param {string=} md-stretch-tabs Attribute to indicate whether or not to stretch tabs: `auto`,
 *  `always`, or `never`; Default is `auto`.
 * @param {boolean=} md-dynamic-height When enabled, the tab wrapper will resize based on the
 *  contents of the selected tab.
 * @param {boolean=} md-border-bottom If present, shows a solid `1px` border between the tabs and
 *  their content.
 * @param {boolean=} md-center-tabs If defined, tabs will be centered provided there is no need
 *  for pagination.
 * @param {boolean=} md-no-pagination When enabled, pagination will remain off.
 * @param {boolean=} md-swipe-content When enabled, swipe gestures will be enabled for the content
 *  area to allow swiping between tabs.
 * @param {boolean=} md-enable-disconnect When enabled, scopes will be disconnected for tabs that
 *  are not being displayed. This provides a performance boost, but may also cause unexpected
 *  issues. It is not recommended for most users.
 * @param {boolean=} md-autoselect When present, any tabs added after the initial load will be
 *  automatically selected.
 * @param {boolean=} md-no-select-click When true, click events will not be fired when the value of
 *  `md-active` on an `md-tab` changes. This is useful when using tabs with UI-Router's child
 *  states, as triggering a click event in that case can cause an extra tab change to occur.
 * @param {string=} md-navigation-hint Attribute to override the default `tablist` navigation hint
 *  that screen readers will announce to provide instructions for navigating between tabs. This is
 *  desirable when you want the hint to be in a different language. Default is "Use the left and
 *  right arrow keys to navigate between tabs".
 *
 * @usage
 * <hljs lang="html">
 * <md-tabs md-selected="selectedIndex" >
 *   <img ng-src="img/angular.png" class="centered">
 *   <md-tab
 *       ng-repeat="tab in tabs | orderBy:predicate:reversed"
 *       md-on-select="onTabSelected(tab)"
 *       md-on-deselect="announceDeselected(tab)"
 *       ng-disabled="tab.disabled">
 *     <md-tab-label>
 *       {{tab.title}}
 *       <img src="img/removeTab.png" ng-click="removeTab(tab)" class="delete">
 *     </md-tab-label>
 *     <md-tab-body>
 *       {{tab.content}}
 *     </md-tab-body>
 *   </md-tab>
 * </md-tabs>
 * </hljs>
 *
 */
MdTabs.$inject = ["$$mdSvgRegistry"];
angular
    .module('material.components.tabs')
    .directive('mdTabs', MdTabs);

function MdTabs ($$mdSvgRegistry) {
  return {
    scope:            {
      navigationHint: '@?mdNavigationHint',
      selectedIndex: '=?mdSelected'
    },
    template:         function (element, attr) {
      attr.$mdTabsTemplate = element.html();
      return '' +
        '<md-tabs-wrapper> ' +
          '<md-tab-data></md-tab-data> ' +
          '<md-prev-button ' +
              'tabindex="-1" ' +
              'role="button" ' +
              'aria-label="Previous Page" ' +
              'aria-disabled="{{!$mdTabsCtrl.canPageBack()}}" ' +
              'ng-class="{ \'md-disabled\': !$mdTabsCtrl.canPageBack() }" ' +
              'ng-if="$mdTabsCtrl.shouldPaginate" ' +
              'ng-click="$mdTabsCtrl.previousPage()"> ' +
            '<md-icon md-svg-src="'+ $$mdSvgRegistry.mdTabsArrow +'"></md-icon> ' +
          '</md-prev-button> ' +
          '<md-next-button ' +
              'tabindex="-1" ' +
              'role="button" ' +
              'aria-label="Next Page" ' +
              'aria-disabled="{{!$mdTabsCtrl.canPageForward()}}" ' +
              'ng-class="{ \'md-disabled\': !$mdTabsCtrl.canPageForward() }" ' +
              'ng-if="$mdTabsCtrl.shouldPaginate" ' +
              'ng-click="$mdTabsCtrl.nextPage()"> ' +
            '<md-icon md-svg-src="'+ $$mdSvgRegistry.mdTabsArrow +'"></md-icon> ' +
          '</md-next-button> ' +
          '<md-tabs-canvas ' +
              'tabindex="{{ $mdTabsCtrl.hasFocus ? -1 : 0 }}" ' +
              'ng-focus="$mdTabsCtrl.redirectFocus()" ' +
              'ng-class="{ ' +
                  '\'md-paginated\': $mdTabsCtrl.shouldPaginate, ' +
                  '\'md-center-tabs\': $mdTabsCtrl.shouldCenterTabs ' +
              '}" ' +
              'ng-keydown="$mdTabsCtrl.keydown($event)"> ' +
            '<md-pagination-wrapper ' +
                'ng-class="{ \'md-center-tabs\': $mdTabsCtrl.shouldCenterTabs }" ' +
                'md-tab-scroll="$mdTabsCtrl.scroll($event)" ' +
                'role="tablist" ' +
                'aria-label="{{::$mdTabsCtrl.navigationHint}}">' +
              '<md-tab-item ' +
                  'tabindex="{{ tab.isActive() ? 0 : -1 }}" ' +
                  'class="md-tab {{::tab.scope.tabClass}}" ' +
                  'ng-repeat="tab in $mdTabsCtrl.tabs" ' +
                  'role="tab" ' +
                  'id="tab-item-{{::tab.id}}" ' +
                  'md-tab-id="{{::tab.id}}" ' +
                  'aria-selected="{{tab.isActive()}}" ' +
                  'aria-disabled="{{tab.scope.disabled || \'false\'}}" ' +
                  'ng-click="$mdTabsCtrl.select(tab.getIndex())" ' +
                  'ng-focus="$mdTabsCtrl.hasFocus = true" ' +
                  'ng-blur="$mdTabsCtrl.hasFocus = false" ' +
                  'ng-class="{ ' +
                      '\'md-active\':    tab.isActive(), ' +
                      '\'md-focused\':   tab.hasFocus(), ' +
                      '\'md-disabled\':  tab.scope.disabled ' +
                  '}" ' +
                  'ng-disabled="tab.scope.disabled" ' +
                  'md-swipe-left="$mdTabsCtrl.nextPage()" ' +
                  'md-swipe-right="$mdTabsCtrl.previousPage()" ' +
                  'md-tabs-template="::tab.label" ' +
                  'md-scope="::tab.parent"></md-tab-item> ' +
              '<md-ink-bar></md-ink-bar> ' +
            '</md-pagination-wrapper> ' +
            '<md-tabs-dummy-wrapper aria-hidden="true" class="md-visually-hidden md-dummy-wrapper"> ' +
              '<md-dummy-tab ' +
                  'class="md-tab" ' +
                  'tabindex="-1" ' +
                  'ng-focus="$mdTabsCtrl.hasFocus = true" ' +
                  'ng-blur="$mdTabsCtrl.hasFocus = false" ' +
                  'ng-repeat="tab in $mdTabsCtrl.tabs" ' +
                  'md-tabs-template="::tab.label" ' +
                  'md-scope="::tab.parent"></md-dummy-tab> ' +
            '</md-tabs-dummy-wrapper> ' +
          '</md-tabs-canvas> ' +
        '</md-tabs-wrapper> ' +
        '<md-tabs-content-wrapper ng-show="$mdTabsCtrl.hasContent && $mdTabsCtrl.selectedIndex >= 0" class="_md"> ' +
          '<md-tab-content ' +
              'id="{{:: $mdTabsCtrl.tabContentPrefix + tab.id}}" ' +
              'class="_md" ' +
              'role="tabpanel" ' +
              'aria-labelledby="tab-item-{{::tab.id}}" ' +
              'md-swipe-left="$mdTabsCtrl.swipeContent && $mdTabsCtrl.incrementIndex(1)" ' +
              'md-swipe-right="$mdTabsCtrl.swipeContent && $mdTabsCtrl.incrementIndex(-1)" ' +
              'ng-if="tab.hasContent" ' +
              'ng-repeat="(index, tab) in $mdTabsCtrl.tabs" ' +
              'ng-class="{ ' +
                '\'md-no-transition\': $mdTabsCtrl.lastSelectedIndex == null, ' +
                '\'md-active\':        tab.isActive(), ' +
                '\'md-left\':          tab.isLeft(), ' +
                '\'md-right\':         tab.isRight(), ' +
                '\'md-no-scroll\':     $mdTabsCtrl.dynamicHeight ' +
              '}"> ' +
            '<div ' +
                'md-tabs-template="::tab.template" ' +
                'md-connected-if="tab.isActive()" ' +
                'md-scope="::tab.parent" ' +
                'ng-if="$mdTabsCtrl.enableDisconnect || tab.shouldRender()"></div> ' +
          '</md-tab-content> ' +
        '</md-tabs-content-wrapper>';
    },
    controller:       'MdTabsController',
    controllerAs:     '$mdTabsCtrl',
    bindToController: true
  };
}

})();
(function(){
"use strict";


MdTabsDummyWrapper.$inject = ["$mdUtil", "$window"];angular
  .module('material.components.tabs')
  .directive('mdTabsDummyWrapper', MdTabsDummyWrapper);

/**
 * @private
 *
 * @param $mdUtil
 * @param $window
 * @returns {{require: string, link: link}}
 * @constructor
 *
 * @ngInject
 */
function MdTabsDummyWrapper ($mdUtil, $window) {
  return {
    require: '^?mdTabs',
    link:    function link (scope, element, attr, ctrl) {
      if (!ctrl) return;

      var observer;
      var disconnect;

      var mutationCallback = function() {
        ctrl.updatePagination();
        ctrl.updateInkBarStyles();
      };

      if ('MutationObserver' in $window) {
        var config = {
          childList: true,
          subtree: true,
          // Per https://bugzilla.mozilla.org/show_bug.cgi?id=1138368, browsers will not fire
          // the childList mutation, once a <span> element's innerText changes.
          // The characterData of the <span> element will change.
          characterData: true
        };

        observer = new MutationObserver(mutationCallback);
        observer.observe(element[0], config);
        disconnect = observer.disconnect.bind(observer);
      } else {
        var debounced = $mdUtil.debounce(mutationCallback, 15, null, false);

        element.on('DOMSubtreeModified', debounced);
        disconnect = element.off.bind(element, 'DOMSubtreeModified', debounced);
      }

      // Disconnect the observer
      scope.$on('$destroy', function() {
        disconnect();
      });
    }
  };
}

})();
(function(){
"use strict";


MdTabsTemplate.$inject = ["$compile", "$mdUtil"];angular
    .module('material.components.tabs')
    .directive('mdTabsTemplate', MdTabsTemplate);

function MdTabsTemplate ($compile, $mdUtil) {
  return {
    restrict: 'A',
    link:     link,
    scope:    {
      template:     '=mdTabsTemplate',
      connected:    '=?mdConnectedIf',
      compileScope: '=mdScope'
    },
    require:  '^?mdTabs'
  };
  function link (scope, element, attr, ctrl) {
    if (!ctrl) return;

    var compileScope = ctrl.enableDisconnect ? scope.compileScope.$new() : scope.compileScope;

    element.html(scope.template);
    $compile(element.contents())(compileScope);

    return $mdUtil.nextTick(handleScope);

    function handleScope () {
      scope.$watch('connected', function (value) { value === false ? disconnect() : reconnect(); });
      scope.$on('$destroy', reconnect);
    }

    function disconnect () {
      if (ctrl.enableDisconnect) $mdUtil.disconnectScope(compileScope);
    }

    function reconnect () {
      if (ctrl.enableDisconnect) $mdUtil.reconnectScope(compileScope);
    }
  }
}

})();
(function(){
"use strict";

/**
 * @ngdoc module
 * @name material.components.toast
 * @description
 * Toast and Snackbar component.
 */
MdToastDirective.$inject = ["$mdToast"];
MdToastProvider.$inject = ["$$interimElementProvider"];
angular.module('material.components.toast', [
  'material.core',
  'material.components.button'
])
  .directive('mdToast', MdToastDirective)
  .provider('$mdToast', MdToastProvider);

/* @ngInject */
function MdToastDirective($mdToast) {
  return {
    restrict: 'E',
    link: function postLink(scope, element) {
      element.addClass('_md');     // private md component indicator for styling

      // When navigation force destroys an interimElement, then
      // listen and $destroy() that interim instance...
      scope.$on('$destroy', function() {
        $mdToast.destroy();
      });
    }
  };
}

/**
 * @ngdoc service
 * @name $mdToast
 * @module material.components.toast
 *
 * @description
 * `$mdToast` is a service to build a toast notification on any position
 * on the screen with an optional duration, and provides a simple promise API.
 *
 * The toast will be always positioned at the `bottom`, when the screen size is
 * between `600px` and `959px` (`sm` breakpoint)
 *
 * ## Restrictions on custom toasts
 * - The toast's template must have an outer `<md-toast>` element.
 * - For a toast action, use element with class `md-action`.
 * - Add the class `md-capsule` for curved corners.
 *
 * ### Custom Presets
 * Developers are also able to create their own preset, which can be easily used without repeating
 * their options each time.
 *
 * <hljs lang="js">
 *   $mdToastProvider.addPreset('testPreset', {
 *     options: function() {
 *       return {
 *         template:
 *           '<md-toast>' +
 *             '<div class="md-toast-content">' +
 *               'This is a custom preset' +
 *             '</div>' +
 *           '</md-toast>',
 *         controllerAs: 'toast',
 *         bindToController: true
 *       };
 *     }
 *   });
 * </hljs>
 *
 * After you created your preset at config phase, you can easily access it.
 *
 * <hljs lang="js">
 *   $mdToast.show(
 *     $mdToast.testPreset()
 *   );
 * </hljs>
 *
 * ## Parent container notes
 *
 * The toast is positioned using absolute positioning relative to its first non-static parent
 * container. Thus, if the requested parent container uses static positioning, we will temporarily
 * set its positioning to `relative` while the toast is visible and reset it when the toast is
 * hidden.
 *
 * Because of this, it is usually best to ensure that the parent container has a fixed height and
 * prevents scrolling by setting the `overflow: hidden;` style. Since the position is based off of
 * the parent's height, the toast may be mispositioned if you allow the parent to scroll.
 *
 * You can, however, have a scrollable element inside of the container; just make sure the
 * container itself does not scroll.
 *
 * <hljs lang="html">
 * <div layout-fill id="toast-container">
 *   <md-content>
 *     I can have lots of content and scroll!
 *   </md-content>
 * </div>
 * </hljs>
 *
 * @usage
 * <hljs lang="html">
 * <div ng-controller="MyController">
 *   <md-button ng-click="openToast()">
 *     Open a Toast!
 *   </md-button>
 * </div>
 * </hljs>
 *
 * <hljs lang="js">
 * var app = angular.module('app', ['ngMaterial']);
 * app.controller('MyController', function($scope, $mdToast) {
 *   $scope.openToast = function($event) {
 *     $mdToast.show($mdToast.simple().textContent('Hello!'));
 *     // Could also do $mdToast.showSimple('Hello');
 *   };
 * });
 * </hljs>
 */

/**
 * @ngdoc method
 * @name $mdToast#showSimple
 *
 * @param {string} message The message to display inside the toast
 * @description
 * Convenience method which builds and shows a simple toast.
 *
 * @returns {promise} A promise that can be resolved with `$mdToast.hide()` or
 * rejected with `$mdToast.cancel()`.
 */

/**
 * @ngdoc method
 * @name $mdToast#simple
 *
 * @description
 * Builds a preconfigured toast.
 *
 * @returns {obj} a `$mdToastPreset` with the following chainable configuration methods.
 *
 * _**Note:** These configuration methods are provided in addition to the methods provided by
 * the `build()` and `show()` methods below._
 *
 * <table class="md-api-table methods">
 *    <thead>
 *      <tr>
 *        <th>Method</th>
 *        <th>Description</th>
 *      </tr>
 *    </thead>
 *    <tbody>
 *      <tr>
 *        <td>`.textContent(string)`</td>
 *        <td>Sets the toast content to the specified string</td>
 *      </tr>
 *      <tr>
 *        <td>`.action(string)`</td>
 *        <td>
 *          Adds an action button. <br/>
 *          If clicked, the promise (returned from `show()`) will resolve with the value `'ok'`;
 *          otherwise, it is resolved with `true` after a `hideDelay` timeout.
 *        </td>
 *      </tr>
 *      <tr>
 *        <td>`.actionKey(string)`</td>
 *        <td>
 *          Adds a hotkey for the action button to the page. <br/>
 *          If the `actionKey` and `Control` key are pressed, the toast's action will be triggered.
 *        </td>
 *      </tr>
 *      <tr>
 *        <td>`.actionHint(string)`</td>
 *        <td>
 *          Text that a screen reader will announce to let the user know how to activate the
 *          action. <br>
 *          If an `actionKey` is defined, this defaults to:
 *          'Press Control-"`actionKey`" to ' followed by the `action`.
 *        </td>
 *      </tr>
 *      <tr>
 *        <td>`.dismissHint(string)`</td>
 *        <td>
 *          Text that a screen reader will announce to let the user know how to dismiss the toast.
 *          <br>Defaults to: "Press Escape to dismiss."
 *        </td>
 *      </tr>
 *      <tr>
 *        <td>`.highlightAction(boolean)`</td>
 *        <td>
 *          Whether or not the action button will have an additional highlight class.<br/>
 *          By default the `accent` color will be applied to the action button.
 *        </td>
 *      </tr>
 *      <tr>
 *        <td>`.highlightClass(string)`</td>
 *        <td>
 *          If set, the given class will be applied to the highlighted action button.<br/>
 *          This allows you to specify the highlight color easily. Highlight classes are
 *          `md-primary`, `md-warn`, and `md-accent`
 *        </td>
 *      </tr>
 *      <tr>
 *        <td>`.capsule(boolean)`</td>
 *        <td>
 *          Whether or not to add the `md-capsule` class to the toast to provide rounded corners
 *        </td>
 *      </tr>
 *      <tr>
 *        <td>`.theme(string)`</td>
 *        <td>
 *          Sets the theme on the toast to the requested theme. Default is `$mdThemingProvider`'s
 *          default.
 *        </td>
 *      </tr>
 *      <tr>
 *        <td>`.toastClass(string)`</td>
 *        <td>Sets a class on the toast element</td>
 *      </tr>
 *    </tbody>
 * </table>
 */

/**
 * @ngdoc method
 * @name $mdToast#updateTextContent
 *
 * @description
 * Updates the content of an existing toast. Useful for updating things like counts, etc.
 */

/**
 * @ngdoc method
 * @name $mdToast#build
 *
 * @description
 * Creates a custom `$mdToastPreset` that you can configure.
 *
 * @returns {obj} a `$mdToastPreset` with the chainable configuration methods for shows' options
 *   (see below).
 */

/**
 * @ngdoc method
 * @name $mdToast#show
 *
 * @description Shows the toast.
 *
 * @param {object} optionsOrPreset Either provide an `$mdToastPreset` returned from `simple()`
 * and `build()`, or an options object with the following properties:
 *
 *   - `templateUrl` - `{string=}`: The url of an html template file that will
 *     be used as the content of the toast. Restrictions: the template must
 *     have an outer `md-toast` element.
 *   - `template` - `{string=}`: Same as templateUrl, except this is an actual
 *     template string.
 *   - `autoWrap` - `{boolean=}`: Whether or not to automatically wrap the template content with a
 *     `<div class="md-toast-content">` if one is not provided. Defaults to true. Can be disabled
 *     if you provide a custom toast directive.
 *   - `scope` - `{object=}`: the scope to link the template / controller to. If none is specified,
 *     it will create a new child scope. This scope will be destroyed when the toast is removed
 *     unless `preserveScope` is set to true.
 *   - `preserveScope` - `{boolean=}`: whether to preserve the scope when the element is removed.
 *     Default is false
 *   - `hideDelay` - `{number=}`: The number of milliseconds the toast should stay active before
 *     automatically closing. Set to `0` or `false` to have the toast stay open until closed
 *     manually via an action in the toast, a hotkey, or a swipe gesture. For accessibility, toasts
 *     should not automatically close when they contain an action.<br>
 *     Defaults to: `3000`.
 *   - `position` - `{string=}`: Sets the position of the toast. <br/>
 *     Available: any combination of `'bottom'`, `'left'`, `'top'`, `'right'`, `'end'`, and
 *     `'start'`. The properties `'end'` and `'start'` are dynamic and can be used for RTL support.
 *     <br/>
 *     Default combination: `'bottom left'`.
 *   - `toastClass` - `{string=}`: A class to set on the toast element.
 *   - `controller` - `{string=}`: The controller to associate with this toast.
 *     The controller will be injected the local `$mdToast.hide()`, which is a function
 *     used to hide the toast.
 *   - `locals` - `{object=}`: An object containing key/value pairs. The keys will
 *     be used as names of values to inject into the controller. For example,
 *     `locals: {three: 3}` would inject `three` into the controller with the value
 *     of 3.
 *   - `bindToController` - `{boolean=}`: bind the locals to the controller, instead of passing
 *     them in.
 *   - `resolve` - `{object=}`: Similar to locals, except it takes promises as values
 *     and the toast will not open until the promises resolve.
 *   - `controllerAs` - `{string=}`: An alias to assign the controller to on the scope.
 *   - `parent` - `{element=}`: The element to append the toast to. Defaults to appending
 *     to the root element of the application.
 *
 * @returns {promise} A promise that can be resolved with `$mdToast.hide()` or
 * rejected with `$mdToast.cancel()`. `$mdToast.hide()` will resolve either with the Boolean
 * value `true` or the value passed as an argument to `$mdToast.hide()`.
 * `$mdToast.cancel()` will resolve the promise with the Boolean value `false`.
 */

/**
 * @ngdoc method
 * @name $mdToast#hide
 *
 * @description
 * Hide an existing toast and resolve the promise returned from `$mdToast.show()`.
 *
 * @param {*=} response An argument for the resolved promise.
 *
 * @returns {promise} A promise that is called when the existing element is removed from the DOM.
 * The promise is resolved with either the Boolean value `true` or the value passed as the
 * argument to `$mdToast.hide()`.
 */

/**
 * @ngdoc method
 * @name $mdToast#cancel
 *
 * @description
 * `DEPRECATED` - The promise returned from opening a toast is used only to notify about the
 * closing of the toast. As such, there isn't any reason to also allow that promise to be rejected,
 * since it's not clear what the difference between resolve and reject would be.
 *
 * Hide the existing toast and reject the promise returned from
 * `$mdToast.show()`.
 *
 * @param {*=} response An argument for the rejected promise.
 *
 * @returns {promise} A promise that is called when the existing element is removed from the DOM
 * The promise is resolved with the Boolean value `false`.
 */

function MdToastProvider($$interimElementProvider) {
  // Differentiate promise resolves: hide timeout (value == true) and hide action clicks
  // (value == ok).
  MdToastController.$inject = ["$mdToast", "$scope", "$log"];
  toastDefaultOptions.$inject = ["$animate", "$mdToast", "$mdUtil", "$mdMedia", "$document"];
  var ACTION_RESOLVE = 'ok';

  var activeToastContent;
  var $mdToast = $$interimElementProvider('$mdToast')
    .setDefaults({
      methods: ['position', 'hideDelay', 'capsule', 'parent', 'position', 'toastClass'],
      options: toastDefaultOptions
    })
    .addPreset('simple', {
      argOption: 'textContent',
      methods: ['textContent', 'content', 'action', 'actionKey', 'actionHint', 'highlightAction',
                'highlightClass', 'theme', 'parent', 'dismissHint'],
      options: /* @ngInject */ ["$mdToast", "$mdTheming", function($mdToast, $mdTheming) {
        return {
          template:
            '<md-toast md-theme="{{ toast.theme }}" ng-class="{\'md-capsule\': toast.capsule}">' +
            '  <div class="md-toast-content" aria-live="polite" aria-relevant="all">' +
            '    <span class="md-toast-text">' +
            '      {{ toast.content }}' +
            '    </span>' +
            '    <span class="md-visually-hidden">{{ toast.dismissHint }}</span>' +
            '    <span class="md-visually-hidden" ng-if="toast.action && toast.actionKey">' +
            '      {{ toast.actionHint }}' +
            '    </span>' +
            '    <md-button class="md-action" ng-if="toast.action" ng-click="toast.resolve()" ' +
            '               ng-class="highlightClasses">' +
            '      {{ toast.action }}' +
            '    </md-button>' +
            '  </div>' +
            '</md-toast>',
          controller: MdToastController,
          theme: $mdTheming.defaultTheme(),
          controllerAs: 'toast',
          bindToController: true
        };
      }]
    })
    .addMethod('updateTextContent', updateTextContent)
    // updateContent is deprecated. Use updateTextContent instead.
    // TODO remove this in 1.2.
    .addMethod('updateContent', updateTextContent);

    function updateTextContent(newContent) {
      activeToastContent = newContent;
    }

    return $mdToast;

  /**
   * Controller for the Toast interim elements.
   * @ngInject
   */
  function MdToastController($mdToast, $scope, $log) {
    // For compatibility with AngularJS 1.6+, we should always use the $onInit hook in
    // interimElements. The $mdCompiler simulates the $onInit hook for all versions.
    this.$onInit = function() {
      var self = this;

      if (self.highlightAction) {
        $scope.highlightClasses = [
          'md-highlight',
          self.highlightClass
        ];
      }

      // If an action is defined and no actionKey is specified, then log a warning.
      if (self.action && !self.actionKey) {
        $log.warn('Toasts with actions should define an actionKey for accessibility.',
          'Details: https://material.angularjs.org/latest/api/service/$mdToast#mdtoast-simple');
      }

      if (self.actionKey && !self.actionHint) {
        self.actionHint = 'Press Control-"' + self.actionKey + '" to ';
      }

      if (!self.dismissHint) {
        self.dismissHint = 'Press Escape to dismiss.';
      }

      $scope.$watch(function() { return activeToastContent; }, function() {
        self.content = activeToastContent;
      });

      this.resolve = function() {
        $mdToast.hide(ACTION_RESOLVE);
      };
    };
  }

  /* @ngInject */
  function toastDefaultOptions($animate, $mdToast, $mdUtil, $mdMedia, $document) {
    var SWIPE_EVENTS = '$md.swipeleft $md.swiperight $md.swipeup $md.swipedown';
    return {
      onShow: onShow,
      onRemove: onRemove,
      toastClass: '',
      position: 'bottom left',
      themable: true,
      hideDelay: 3000,
      autoWrap: true,
      transformTemplate: function(template, options) {
        var shouldAddWrapper = options.autoWrap && template && !/md-toast-content/g.test(template);

        if (shouldAddWrapper) {
          // Root element of template will be <md-toast>. We need to wrap all of its content inside
          // of <div class="md-toast-content">. All templates provided here should be static,
          // developer-controlled content (meaning we're not attempting to guard against XSS).
          var templateRoot = document.createElement('md-template');
          templateRoot.innerHTML = template;

          // Iterate through all root children, to detect possible md-toast directives.
          for (var i = 0; i < templateRoot.children.length; i++) {
            if (templateRoot.children[i].nodeName === 'MD-TOAST') {
              var wrapper = angular.element('<div class="md-toast-content">');

              // Wrap the children of the `md-toast` directive in jqLite, to be able to append
              // multiple nodes with the same execution.
              wrapper.append(angular.element(templateRoot.children[i].childNodes));

              // Append the new wrapped element to the `md-toast` directive.
              templateRoot.children[i].appendChild(wrapper[0]);
            }
          }

          // We have to return the innerHTMl, because we do not want to have the `md-template`
          // element to be the root element of our interimElement.
          return templateRoot.innerHTML;
        }

        return template || '';
      }
    };

    function onShow(scope, element, options) {
      // support deprecated #content method
      // TODO remove support for content in 1.2.
      activeToastContent = options.textContent || options.content;

      var isSmScreen = !$mdMedia('gt-sm');

      element = $mdUtil.extractElementByName(element, 'md-toast', true);
      options.element = element;

      options.onSwipe = function(ev, gesture) {
        // Add the relevant swipe class to the element so it can animate correctly
        var swipe = ev.type.replace('$md.','');
        var direction = swipe.replace('swipe', '');

        // If the swipe direction is down/up but the toast came from top/bottom don't fade away
        // Unless the screen is small, then the toast always on bottom
        if ((direction === 'down' && options.position.indexOf('top') !== -1 && !isSmScreen) ||
            (direction === 'up' && (options.position.indexOf('bottom') !== -1 || isSmScreen))) {
          return;
        }

        if ((direction === 'left' || direction === 'right') && isSmScreen) {
          return;
        }

        element.addClass('md-' + swipe);
        $mdUtil.nextTick($mdToast.cancel);
      };
      options.openClass = toastOpenClass(options.position);

      element.addClass(options.toastClass);

      // 'top left' -> 'md-top md-left'
      options.parent.addClass(options.openClass);

      // static is the default position
      if ($mdUtil.hasComputedStyle(options.parent, 'position', 'static')) {
        options.parent.css('position', 'relative');
      }

      setupActionKeyListener(scope.toast && scope.toast.actionKey ?
        scope.toast.actionKey : undefined);

      element.on(SWIPE_EVENTS, options.onSwipe);
      element.addClass(isSmScreen ? 'md-bottom' : options.position.split(' ').map(function(pos) {
        return 'md-' + pos;
      }).join(' '));

      if (options.parent) {
        options.parent.addClass('md-toast-animating');
      }
      return $animate.enter(element, options.parent).then(function() {
        if (options.parent) {
          options.parent.removeClass('md-toast-animating');
        }
      });
    }

    function onRemove(scope, element, options) {
      if (scope.toast && scope.toast.actionKey) {
        removeActionKeyListener();
      }
      element.off(SWIPE_EVENTS, options.onSwipe);
      if (options.parent) options.parent.addClass('md-toast-animating');
      if (options.openClass) options.parent.removeClass(options.openClass);

      return ((options.$destroy === true) ? element.remove() : $animate.leave(element))
        .then(function () {
          if (options.parent) options.parent.removeClass('md-toast-animating');
          if ($mdUtil.hasComputedStyle(options.parent, 'position', 'static')) {
            options.parent.css('position', '');
          }
        });
    }

    function toastOpenClass(position) {
      // For mobile, always open full-width on bottom
      if (!$mdMedia('gt-xs')) {
        return 'md-toast-open-bottom';
      }

      return 'md-toast-open-' + (position.indexOf('top') > -1 ? 'top' : 'bottom');
    }

    function setupActionKeyListener(actionKey) {
      /**
       * @param {KeyboardEvent} event
       */
      var handleKeyDown = function(event) {
        if (event.key === 'Escape') {
          $mdToast.hide(false);
        }
        if (actionKey && event.key === actionKey && event.ctrlKey) {
          $mdToast.hide(ACTION_RESOLVE);
        }
      };
      $document.on('keydown', handleKeyDown);
    }

    function removeActionKeyListener() {
      $document.off('keydown');
    }
  }
}

})();
(function(){
"use strict";

/**
 * @ngdoc module
 * @name material.components.toolbar
 */
mdToolbarDirective.$inject = ["$$rAF", "$mdConstant", "$mdUtil", "$mdTheming", "$animate"];
angular.module('material.components.toolbar', [
  'material.core',
  'material.components.content'
])
  .directive('mdToolbar', mdToolbarDirective);

/**
 * @ngdoc directive
 * @name mdToolbar
 * @module material.components.toolbar
 * @restrict E
 * @description
 * `md-toolbar` is used to place a toolbar in your app.
 *
 * Toolbars are usually used above a content area to display the title of the
 * current page, and show relevant action buttons for that page.
 *
 * You can change the height of the toolbar by adding either the
 * `md-medium-tall` or `md-tall` class to the toolbar.
 *
 * @usage
 * <hljs lang="html">
 * <div layout="column" layout-fill>
 *   <md-toolbar>
 *
 *     <div class="md-toolbar-tools">
 *       <h2 md-truncate flex>My App's Title</h2>
 *
 *       <md-button>
 *         Right Bar Button
 *       </md-button>
 *     </div>
 *
 *   </md-toolbar>
 *   <md-content>
 *     Hello!
 *   </md-content>
 * </div>
 * </hljs>
 *
 * <i><b>Note:</b> The code above shows usage with the `md-truncate` component which provides an
 * ellipsis if the title is longer than the width of the Toolbar.</i>
 *
 * ## CSS & Styles
 *
 * The `<md-toolbar>` provides a few custom CSS classes that you may use to enhance the
 * functionality of your toolbar.
 *
 * <div>
 * <docs-css-api-table>
 *
 *   <docs-css-selector code="md-toolbar .md-toolbar-tools">
 *     The `md-toolbar-tools` class provides quite a bit of automatic styling for your toolbar
 *     buttons and text. When applied, it will center the buttons and text vertically for you.
 *   </docs-css-selector>
 *
 * </docs-css-api-table>
 * </div>
 *
 * ### Private Classes
 *
 * Currently, the only private class is the `md-toolbar-transitions` class. All other classes are
 * considered public.
 *
 * @param {boolean=} md-scroll-shrink Whether the header should shrink away as
 * the user scrolls down, and reveal itself as the user scrolls up.
 *
 * _**Note (1):** for scrollShrink to work, the toolbar must be a sibling of a
 * `md-content` element, placed before it. See the scroll shrink demo._
 *
 * _**Note (2):** The `md-scroll-shrink` attribute is only parsed on component
 * initialization, it does not watch for scope changes._
 *
 *
 * @param {number=} md-shrink-speed-factor How much to change the speed of the toolbar's
 * shrinking by. For example, if 0.25 is given then the toolbar will shrink
 * at one fourth the rate at which the user scrolls down. Default 0.5.
 *
 */

function mdToolbarDirective($$rAF, $mdConstant, $mdUtil, $mdTheming, $animate) {
  var translateY = angular.bind(null, $mdUtil.supplant, 'translate3d(0,{0}px,0)');

  return {
    template: '',
    restrict: 'E',

    link: function(scope, element, attr) {

      element.addClass('_md');     // private md component indicator for styling
      $mdTheming(element);

      $mdUtil.nextTick(function () {
        element.addClass('_md-toolbar-transitions');     // adding toolbar transitions after digest
      }, false);

      if (angular.isDefined(attr.mdScrollShrink)) {
        setupScrollShrink();
      }

      function setupScrollShrink() {

        var toolbarHeight;
        var contentElement;
        var disableScrollShrink = angular.noop;

        // Current "y" position of scroll
        // Store the last scroll top position
        var y = 0;
        var prevScrollTop = 0;
        var shrinkSpeedFactor = attr.mdShrinkSpeedFactor || 0.5;

        var debouncedContentScroll = $$rAF.throttle(onContentScroll);
        var debouncedUpdateHeight = $mdUtil.debounce(updateToolbarHeight, 5 * 1000);

        // Wait for $mdContentLoaded event from mdContent directive.
        // If the mdContent element is a sibling of our toolbar, hook it up
        // to scroll events.

        scope.$on('$mdContentLoaded', onMdContentLoad);

        // If the toolbar is used inside an ng-if statement, we may miss the
        // $mdContentLoaded event, so we attempt to fake it if we have a
        // md-content close enough.

        attr.$observe('mdScrollShrink', onChangeScrollShrink);

        // If the toolbar has ngShow or ngHide we need to update height immediately as it changed
        // and not wait for $mdUtil.debounce to happen

        if (attr.ngShow) { scope.$watch(attr.ngShow, updateToolbarHeight); }
        if (attr.ngHide) { scope.$watch(attr.ngHide, updateToolbarHeight); }

        // If the scope is destroyed (which could happen with ng-if), make sure
        // to disable scroll shrinking again

        scope.$on('$destroy', disableScrollShrink);

        /**
         *
         */
        function onChangeScrollShrink(shrinkWithScroll) {
          var closestContent = element.parent().find('md-content');

          // If we have a content element, fake the call; this might still fail
          // if the content element isn't a sibling of the toolbar

          if (!contentElement && closestContent.length) {
            onMdContentLoad(null, closestContent);
          }

          // Evaluate the expression
          shrinkWithScroll = scope.$eval(shrinkWithScroll);

          // Disable only if the attribute's expression evaluates to false
          if (shrinkWithScroll === false) {
            disableScrollShrink();
          } else {
            disableScrollShrink = enableScrollShrink();
          }
        }

        /**
         *
         */
        function onMdContentLoad($event, newContentEl) {
          // Toolbar and content must be siblings
          if (newContentEl && element.parent()[0] === newContentEl.parent()[0]) {
            // unhook old content event listener if exists
            if (contentElement) {
              contentElement.off('scroll', debouncedContentScroll);
            }

            contentElement = newContentEl;
            disableScrollShrink = enableScrollShrink();
          }
        }

        /**
         *
         */
        function onContentScroll(e) {
          var scrollTop = e ? e.target.scrollTop : prevScrollTop;

          debouncedUpdateHeight();

          y = Math.min(
            toolbarHeight / shrinkSpeedFactor,
            Math.max(0, y + scrollTop - prevScrollTop)
          );

          element.css($mdConstant.CSS.TRANSFORM, translateY([-y * shrinkSpeedFactor]));
          contentElement.css($mdConstant.CSS.TRANSFORM, translateY([(toolbarHeight - y) * shrinkSpeedFactor]));

          prevScrollTop = scrollTop;

          $mdUtil.nextTick(function() {
            var hasWhiteFrame = element.hasClass('md-whiteframe-z1');

            if (hasWhiteFrame && !y) {
              $animate.removeClass(element, 'md-whiteframe-z1');
            } else if (!hasWhiteFrame && y) {
              $animate.addClass(element, 'md-whiteframe-z1');
            }
          });

        }

        /**
         *
         */
        function enableScrollShrink() {
          if (!contentElement)     return angular.noop;           // no md-content

          contentElement.on('scroll', debouncedContentScroll);
          contentElement.attr('scroll-shrink', 'true');

          $mdUtil.nextTick(updateToolbarHeight, false);

          return function disableScrollShrink() {
            contentElement.off('scroll', debouncedContentScroll);
            contentElement.attr('scroll-shrink', 'false');

            updateToolbarHeight();
          };
        }

        /**
         *
         */
        function updateToolbarHeight() {
          toolbarHeight = element.prop('offsetHeight');
          // Add a negative margin-top the size of the toolbar to the content el.
          // The content will start transformed down the toolbarHeight amount,
          // so everything looks normal.
          //
          // As the user scrolls down, the content will be transformed up slowly
          // to put the content underneath where the toolbar was.
          var margin = (-toolbarHeight * shrinkSpeedFactor) + 'px';

          contentElement.css({
            "margin-top": margin,
            "margin-bottom": margin
          });

          onContentScroll();
        }

      }

    }
  };

}

})();
(function(){
"use strict";

/**
 * @ngdoc module
 * @name material.components.tooltip
 */
MdTooltipDirective.$inject = ["$timeout", "$window", "$$rAF", "$document", "$interpolate", "$mdUtil", "$mdPanel", "$$mdTooltipRegistry"];
angular
    .module('material.components.tooltip', [
      'material.core',
      'material.components.panel'
    ])
    .directive('mdTooltip', MdTooltipDirective)
    .service('$$mdTooltipRegistry', MdTooltipRegistry);


/**
 * @ngdoc directive
 * @name mdTooltip
 * @module material.components.tooltip
 * @description
 * Tooltips are used to describe elements that are interactive and primarily
 * graphical (not textual).
 *
 * Place a `<md-tooltip>` as a child of the element it describes.
 *
 * A tooltip will activate when the user hovers over, focuses, or touches the
 * parent element.
 *
 * @usage
 * <hljs lang="html">
 *   <md-button class="md-fab md-accent" aria-label="Play">
 *     <md-tooltip>Play Music</md-tooltip>
 *     <md-icon md-svg-src="img/icons/ic_play_arrow_24px.svg"></md-icon>
 *   </md-button>
 * </hljs>
 *
 * @param {number=} md-z-index The visual level that the tooltip will appear
 *     in comparison with the rest of the elements of the application.
 * @param {expression=} md-visible Boolean bound to whether the tooltip is
 *     currently visible.
 * @param {number=} md-delay How many milliseconds to wait to show the tooltip
 *     after the user hovers over, focuses, or touches the parent element.
 *     Defaults to 0ms on non-touch devices and 75ms on touch.
 * @param {boolean=} md-autohide If present or provided with a boolean value,
 *     the tooltip will hide on mouse leave, regardless of focus.
 * @param {string=} md-direction The direction that the tooltip is shown,
 *     relative to the parent element. Supports top, right, bottom, and left.
 *     Defaults to bottom.
 */
function MdTooltipDirective($timeout, $window, $$rAF, $document, $interpolate,
    $mdUtil, $mdPanel, $$mdTooltipRegistry) {

  var ENTER_EVENTS = 'focus touchstart mouseenter';
  var LEAVE_EVENTS = 'blur touchcancel mouseleave';
  var TOOLTIP_DEFAULT_Z_INDEX = 100;
  var TOOLTIP_DEFAULT_SHOW_DELAY = 0;
  var TOOLTIP_DEFAULT_DIRECTION = 'bottom';
  var TOOLTIP_DIRECTIONS = {
    top: { x: $mdPanel.xPosition.CENTER, y: $mdPanel.yPosition.ABOVE },
    right: { x: $mdPanel.xPosition.OFFSET_END, y: $mdPanel.yPosition.CENTER },
    bottom: { x: $mdPanel.xPosition.CENTER, y: $mdPanel.yPosition.BELOW },
    left: { x: $mdPanel.xPosition.OFFSET_START, y: $mdPanel.yPosition.CENTER }
  };

  return {
    restrict: 'E',
    priority: 210, // Before ngAria
    scope: {
      mdZIndex: '=?mdZIndex',
      mdDelay: '=?mdDelay',
      mdVisible: '=?mdVisible',
      mdAutohide: '=?mdAutohide',
      mdDirection: '@?mdDirection' // Do not expect expressions.
    },
    link: linkFunc
  };

  function linkFunc(scope, element, attr) {
    // Set constants.
    var tooltipId = 'md-tooltip-' + $mdUtil.nextUid();
    var parent = $mdUtil.getParentWithPointerEvents(element);
    var debouncedOnResize = $$rAF.throttle(updatePosition);
    var mouseActive = false;
    var origin, position, panelPosition, panelRef, autohide, showTimeout,
        elementFocusedOnWindowBlur = null;

    // Set defaults
    setDefaults();

    // Set parent aria-label.
    addAriaLabel();

    // Remove the element from its current DOM position.
    element.detach();

    updatePosition();
    bindEvents();
    configureWatchers();

    function setDefaults() {
      scope.mdZIndex = scope.mdZIndex || TOOLTIP_DEFAULT_Z_INDEX;
      scope.mdDelay = scope.mdDelay || TOOLTIP_DEFAULT_SHOW_DELAY;
      if (!TOOLTIP_DIRECTIONS[scope.mdDirection]) {
        scope.mdDirection = TOOLTIP_DEFAULT_DIRECTION;
      }
    }

    function addAriaLabel(labelText) {
      // Only interpolate the text from the HTML element because otherwise the custom text could
      // be interpolated twice and cause XSS violations.
      var interpolatedText = labelText || $interpolate(element.text().trim())(scope.$parent);

      // Only add the `aria-label` to the parent if there isn't already one, if there isn't an
      // already present `aria-labelledby`, or if the previous `aria-label` was added by the
      // tooltip directive.
      if (
        (!parent.attr('aria-label') && !parent.attr('aria-labelledby')) ||
        parent.attr('md-labeled-by-tooltip')
      ) {
        parent.attr('aria-label', interpolatedText);

        // Set the `md-labeled-by-tooltip` attribute if it has not already been set.
        if (!parent.attr('md-labeled-by-tooltip')) {
          parent.attr('md-labeled-by-tooltip', tooltipId);
        }
      }
    }

    function updatePosition() {
      setDefaults();

      // If the panel has already been created, remove the current origin
      // class from the panel element.
      if (panelRef && panelRef.panelEl) {
        panelRef.panelEl.removeClass(origin);
      }

      // Set the panel element origin class based off of the current
      // mdDirection.
      origin = 'md-origin-' + scope.mdDirection;

      // Create the position of the panel based off of the mdDirection.
      position = TOOLTIP_DIRECTIONS[scope.mdDirection];

      // Using the newly created position object, use the MdPanel
      // panelPosition API to build the panel's position.
      panelPosition = $mdPanel.newPanelPosition()
          .relativeTo(parent)
          .addPanelPosition(position.x, position.y);

      // If the panel has already been created, add the new origin class to
      // the panel element and update it's position with the panelPosition.
      if (panelRef && panelRef.panelEl) {
        panelRef.panelEl.addClass(origin);
        panelRef.updatePosition(panelPosition);
      }
    }

    function bindEvents() {
      // Add a mutationObserver where there is support for it and the need
      // for it in the form of viable host(parent[0]).
      if (parent[0] && 'MutationObserver' in $window) {
        // Use a mutationObserver to tackle #2602.
        var attributeObserver = new MutationObserver(function(mutations) {
          if (isDisabledMutation(mutations)) {
            $mdUtil.nextTick(function() {
              setVisible(false);
            });
          }
        });

        attributeObserver.observe(parent[0], {
          attributes: true
        });
      }

      elementFocusedOnWindowBlur = false;

      $$mdTooltipRegistry.register('scroll', windowScrollEventHandler, true);
      $$mdTooltipRegistry.register('blur', windowBlurEventHandler);
      $$mdTooltipRegistry.register('resize', debouncedOnResize);

      scope.$on('$destroy', onDestroy);

      // To avoid 'synthetic clicks', we listen to mousedown instead of
      // 'click'.
      parent.on('mousedown', mousedownEventHandler);
      parent.on(ENTER_EVENTS, enterEventHandler);

      function isDisabledMutation(mutations) {
        mutations.some(function(mutation) {
          return mutation.attributeName === 'disabled' && parent[0].disabled;
        });
        return false;
      }

      function windowScrollEventHandler() {
        setVisible(false);
      }

      function windowBlurEventHandler() {
        elementFocusedOnWindowBlur = document.activeElement === parent[0];
      }

      function enterEventHandler($event) {
        // Prevent the tooltip from showing when the window is receiving
        // focus.
        if ($event.type === 'focus' && elementFocusedOnWindowBlur) {
          elementFocusedOnWindowBlur = false;
        } else if (!scope.mdVisible) {
          parent.on(LEAVE_EVENTS, leaveEventHandler);
          setVisible(true);

          // If the user is on a touch device, we should bind the tap away
          // after the 'touched' in order to prevent the tooltip being
          // removed immediately.
          if ($event.type === 'touchstart') {
            parent.one('touchend', function() {
              $mdUtil.nextTick(function() {
                $document.one('touchend', leaveEventHandler);
              }, false);
            });
          }
        }
      }

      function leaveEventHandler() {
        autohide = scope.hasOwnProperty('mdAutohide') ?
            scope.mdAutohide :
            attr.hasOwnProperty('mdAutohide');

        if (autohide || mouseActive ||
            $document[0].activeElement !== parent[0]) {
          // When a show timeout is currently in progress, then we have
          // to cancel it, otherwise the tooltip will remain showing
          // without focus or hover.
          if (showTimeout) {
            $timeout.cancel(showTimeout);
            setVisible.queued = false;
            showTimeout = null;
          }

          parent.off(LEAVE_EVENTS, leaveEventHandler);
          parent.triggerHandler('blur');
          setVisible(false);
        }
        mouseActive = false;
      }

      function mousedownEventHandler() {
        mouseActive = true;
      }

      function onDestroy() {
        $$mdTooltipRegistry.deregister('scroll', windowScrollEventHandler, true);
        $$mdTooltipRegistry.deregister('blur', windowBlurEventHandler);
        $$mdTooltipRegistry.deregister('resize', debouncedOnResize);

        parent
            .off(ENTER_EVENTS, enterEventHandler)
            .off(LEAVE_EVENTS, leaveEventHandler)
            .off('mousedown', mousedownEventHandler);

        // Trigger the handler in case any of the tooltips are
        // still visible.
        leaveEventHandler();
        attributeObserver && attributeObserver.disconnect();
      }
    }

    function configureWatchers() {
      if (element[0] && 'MutationObserver' in $window) {
        var attributeObserver = new MutationObserver(function(mutations) {
          mutations.forEach(function(mutation) {
            if (mutation.attributeName === 'md-visible' &&
                !scope.visibleWatcher) {
              scope.visibleWatcher = scope.$watch('mdVisible',
                  onVisibleChanged);
            }
          });
        });

        attributeObserver.observe(element[0], {
          attributes: true
        });

        // Build watcher only if mdVisible is being used.
        if (attr.hasOwnProperty('mdVisible')) {
          scope.visibleWatcher = scope.$watch('mdVisible',
              onVisibleChanged);
        }
      } else {
        // MutationObserver not supported
        scope.visibleWatcher = scope.$watch('mdVisible', onVisibleChanged);
      }

      // Direction watcher
      scope.$watch('mdDirection', updatePosition);

      // Clean up if the element or parent was removed via jqLite's .remove.
      // A couple of notes:
      //   - In these cases the scope might not have been destroyed, which
      //     is why we destroy it manually. An example of this can be having
      //     `md-visible="false"` and adding tooltips while they're
      //     invisible. If `md-visible` becomes true, at some point, you'd
      //     usually get a lot of tooltips.
      //   - We use `.one`, not `.on`, because this only needs to fire once.
      //     If we were using `.on`, it would get thrown into an infinite
      //     loop.
      //   - This kicks off the scope's `$destroy` event which finishes the
      //     cleanup.
      element.one('$destroy', onElementDestroy);
      parent.one('$destroy', onElementDestroy);
      scope.$on('$destroy', function() {
        setVisible(false);
        panelRef && panelRef.destroy();
        attributeObserver && attributeObserver.disconnect();
        element.remove();
      });

      // Updates the aria-label when the element text changes. This watch
      // doesn't need to be set up if the element doesn't have any data
      // bindings.
      if (element.text().indexOf($interpolate.startSymbol()) > -1) {
        scope.$watch(function() {
          return element.text().trim();
        }, addAriaLabel);
      }

      function onElementDestroy() {
        scope.$destroy();
      }
    }

    function setVisible(value) {
      // Break if passed value is already in queue or there is no queue and
      // passed value is current in the controller.
      if (setVisible.queued && setVisible.value === !!value ||
          !setVisible.queued && scope.mdVisible === !!value) {
        return;
      }
      setVisible.value = !!value;

      if (!setVisible.queued) {
        if (value) {
          setVisible.queued = true;
          showTimeout = $timeout(function() {
            scope.mdVisible = setVisible.value;
            setVisible.queued = false;
            showTimeout = null;
            if (!scope.visibleWatcher) {
              onVisibleChanged(scope.mdVisible);
            }
          }, scope.mdDelay);
        } else {
          $mdUtil.nextTick(function() {
            scope.mdVisible = false;
            if (!scope.visibleWatcher) {
              onVisibleChanged(false);
            }
          });
        }
      }
    }

    function onVisibleChanged(isVisible) {
      isVisible ? showTooltip() : hideTooltip();
    }

    function showTooltip() {
      // Do not show the tooltip if the text is empty.
      if (!element[0].textContent.trim()) {
        throw new Error('Text for the tooltip has not been provided. ' +
            'Please include text within the mdTooltip element.');
      }

      if (!panelRef) {
        var attachTo = angular.element(document.body);
        var panelAnimation = $mdPanel.newPanelAnimation()
            .openFrom(parent)
            .closeTo(parent)
            .withAnimation({
              open: 'md-show',
              close: 'md-hide'
            });

        var panelConfig = {
          id: tooltipId,
          attachTo: attachTo,
          contentElement: element,
          propagateContainerEvents: true,
          panelClass: 'md-tooltip',
          animation: panelAnimation,
          position: panelPosition,
          zIndex: scope.mdZIndex,
          focusOnOpen: false,
          onDomAdded: function() {
            panelRef.panelEl.addClass(origin);
          }
        };

        panelRef = $mdPanel.create(panelConfig);
      }

      panelRef.open().then(function() {
        panelRef.panelEl.attr('role', 'tooltip');
      });
    }

    function hideTooltip() {
      panelRef && panelRef.close();
    }
  }

}


/**
 * Service that is used to reduce the amount of listeners that are being
 * registered on the `window` by the tooltip component. Works by collecting
 * the individual event handlers and dispatching them from a global handler.
 *
 * @ngInject
 */
function MdTooltipRegistry() {
  var listeners = {};
  var ngWindow = angular.element(window);

  return {
    register: register,
    deregister: deregister
  };

  /**
   * Global event handler that dispatches the registered handlers in the
   * service.
   * @param {!Event} event Event object passed in by the browser
   */
  function globalEventHandler(event) {
    if (listeners[event.type]) {
      listeners[event.type].forEach(function(currentHandler) {
        currentHandler.call(this, event);
      }, this);
    }
  }

  /**
   * Registers a new handler with the service.
   * @param {string} type Type of event to be registered.
   * @param {!Function} handler Event handler.
   * @param {boolean} useCapture Whether to use event capturing.
   */
  function register(type, handler, useCapture) {
    var handlers = listeners[type] = listeners[type] || [];

    if (!handlers.length) {
      useCapture ? window.addEventListener(type, globalEventHandler, true) :
          ngWindow.on(type, globalEventHandler);
    }

    if (handlers.indexOf(handler) === -1) {
      handlers.push(handler);
    }
  }

  /**
   * Removes an event handler from the service.
   * @param {string} type Type of event handler.
   * @param {!Function} handler The event handler itself.
   * @param {boolean} useCapture Whether the event handler used event capturing.
   */
  function deregister(type, handler, useCapture) {
    var handlers = listeners[type];
    var index = handlers ? handlers.indexOf(handler) : -1;

    if (index > -1) {
      handlers.splice(index, 1);

      if (handlers.length === 0) {
        useCapture ? window.removeEventListener(type, globalEventHandler, true) :
            ngWindow.off(type, globalEventHandler);
      }
    }
  }
}

})();
(function(){
"use strict";

/**
 * @ngdoc module
 * @name material.components.truncate
 */
MdTruncateController.$inject = ["$element"];
angular.module('material.components.truncate', ['material.core'])
  .directive('mdTruncate', MdTruncateDirective);

/**
 * @ngdoc directive
 * @name mdTruncate
 * @module material.components.truncate
 * @restrict AE
 * @description
 *
 * The `md-truncate` component displays a label that will automatically clip text which is wider
 * than the component. By default, it displays an ellipsis, but you may apply the `md-clip` CSS
 * class to override this default and use a standard "clipping" approach.
 *
 * <i><b>Note:</b> The `md-truncate` component does not automatically adjust it's width. You must
 * provide the `flex` attribute, or some other CSS-based width management. See the
 * <a ng-href="./demo/truncate">demos</a> for examples.</i>
 *
 * @usage
 *
 * ### As an Element
 *
 * <hljs lang="html">
 *   <div layout="row">
 *     <md-button>Back</md-button>
 *
 *     <md-truncate flex>Chapter 1 - The Way of the Old West</md-truncate>
 *
 *     <md-button>Forward</md-button>
 *   </div>
 * </hljs>
 *
 * ### As an Attribute
 *
 * <hljs lang="html">
 *   <h2 md-truncate style="max-width: 100px;">Some Title With a Lot of Text</h2>
 * </hljs>
 *
 * ## CSS & Styles
 *
 * `<md-truncate>` provides two CSS classes that you may use to control the type of clipping.
 *
 * <i><b>Note:</b> The `md-truncate` also applies a setting of `width: 0;` when used with the `flex`
 * attribute to fix an issue with the flex element not shrinking properly.</i>
 *
 * <div>
 * <docs-css-api-table>
 *
 *   <docs-css-selector code=".md-ellipsis">
 *     Assigns the "ellipsis" behavior (default) which will cut off mid-word and append an ellipsis
 *     (&hellip;) to the end of the text.
 *   </docs-css-selector>
 *
 *   <docs-css-selector code=".md-clip">
 *     Assigns the "clipping" behavior which will simply chop off the text. This may happen
 *     mid-word or even mid-character.
 *   </docs-css-selector>
 *
 * </docs-css-api-table>
 * </div>
 */
function MdTruncateDirective() {
  return {
    restrict: 'AE',

    controller: MdTruncateController
  };
}

/**
 * Controller for the <md-truncate> component.
 *
 * @param $element The md-truncate element.
 *
 * @constructor
 * @ngInject
 */
function MdTruncateController($element) {
  $element.addClass('md-truncate');
}

})();
(function(){
"use strict";

/**
 * @ngdoc module
 * @name material.components.virtualRepeat
 */
VirtualRepeatContainerController.$inject = ["$$rAF", "$mdUtil", "$mdConstant", "$parse", "$rootScope", "$window", "$scope", "$element", "$attrs"];
VirtualRepeatController.$inject = ["$scope", "$element", "$attrs", "$browser", "$document", "$rootScope", "$$rAF", "$mdUtil"];
VirtualRepeatDirective.$inject = ["$parse"];
angular.module('material.components.virtualRepeat', [
  'material.core',
  'material.components.showHide'
])
.directive('mdVirtualRepeatContainer', VirtualRepeatContainerDirective)
.directive('mdVirtualRepeat', VirtualRepeatDirective)
.directive('mdForceHeight', ForceHeightDirective);


/**
 * @ngdoc directive
 * @name mdVirtualRepeatContainer
 * @module material.components.virtualRepeat
 * @restrict E
 * @description
 * `md-virtual-repeat-container` provides the scroll container for
 * <a ng-href="api/directive/mdVirtualRepeat">md-virtual-repeat</a>.
 *
 * VirtualRepeat is a limited substitute for `ng-repeat` that renders only
 * enough DOM nodes to fill the container, recycling them as the user scrolls.
 *
 * Once an element is not visible anymore, the Virtual Repeat recycles the element and reuses it
 * for another visible item by replacing the previous data set with the set of currently visible
 * elements.
 *
 * ### Common Issues
 *
 * - When having one-time bindings inside of the view template, the Virtual Repeat will not properly
 *   update the bindings for new items, since the view will be recycled.
 * - Directives inside of a Virtual Repeat will be only compiled (linked) once, because those
 *   items will be recycled and used for other items.
 *   The Virtual Repeat just updates the scope bindings.
 *
 *
 * ### Notes
 *
 * > The VirtualRepeat is a similar implementation to the Android
 * [RecyclerView](https://developer.android.com/reference/android/support/v7/widget/RecyclerView.html).
 *
 * <!-- This comment forces a break between blockquotes //-->
 *
 * > Please also review the <a ng-href="api/directive/mdVirtualRepeat">mdVirtualRepeat</a>
 * documentation for more information.
 *
 *
 * @usage
 * <hljs lang="html">
 *
 * <md-virtual-repeat-container md-top-index="topIndex">
 *   <div md-virtual-repeat="i in items" md-item-size="20">Hello {{i}}!</div>
 * </md-virtual-repeat-container>
 * </hljs>
 *
 * @param {boolean=} md-auto-shrink When present and the container will shrink to fit
 *     the number of items in the `md-virtual-repeat`.
 * @param {number=} md-auto-shrink-min Minimum number of items that md-auto-shrink
 *     will shrink to. Default: `0`.
 * @param {boolean=} md-orient-horizontal Whether the container should scroll horizontally.
 *     The default is `false` which indicates vertical orientation and scrolling.
 * @param {number=} md-top-index Binds the index of the item that is at the top of the scroll
 *     container to `$scope`. It can both read and set the scroll position.
 */
function VirtualRepeatContainerDirective() {
  return {
    controller: VirtualRepeatContainerController,
    template: virtualRepeatContainerTemplate,
    compile: function virtualRepeatContainerCompile($element, $attrs) {
      $element
          .addClass('md-virtual-repeat-container')
          .addClass($attrs.hasOwnProperty('mdOrientHorizontal')
              ? 'md-orient-horizontal'
              : 'md-orient-vertical');
    }
  };
}


function virtualRepeatContainerTemplate($element) {
  return '<div class="md-virtual-repeat-scroller" role="presentation">' +
    '<div class="md-virtual-repeat-sizer" role="presentation"></div>' +
    '<div class="md-virtual-repeat-offsetter" role="presentation">' +
      $element[0].innerHTML +
    '</div></div>';
}

/**
 * Number of additional elements to render above and below the visible area inside
 * of the virtual repeat container. A higher number results in less flicker when scrolling
 * very quickly in Safari, but comes with a higher rendering and dirty-checking cost.
 * @const {number}
 */
var NUM_EXTRA = 3;

/** @ngInject */
function VirtualRepeatContainerController($$rAF, $mdUtil, $mdConstant, $parse, $rootScope, $window,
                                          $scope, $element, $attrs) {
  this.$rootScope = $rootScope;
  this.$scope = $scope;
  this.$element = $element;
  this.$attrs = $attrs;

  /** @type {number} The width or height of the container */
  this.size = 0;
  /** @type {number} The scroll width or height of the scroller */
  this.scrollSize = 0;
  /** @type {number} The scrollLeft or scrollTop of the scroller */
  this.scrollOffset = 0;
  /** @type {boolean} Whether the scroller is oriented horizontally */
  this.horizontal = this.$attrs.hasOwnProperty('mdOrientHorizontal');
  /** @type {!VirtualRepeatController} The repeater inside of this container */
  this.repeater = null;
  /** @type {boolean} Whether auto-shrink is enabled */
  this.autoShrink = this.$attrs.hasOwnProperty('mdAutoShrink');
  /** @type {number} Minimum number of items to auto-shrink to */
  this.autoShrinkMin = parseInt(this.$attrs.mdAutoShrinkMin, 10) || 0;
  /** @type {?number} Original container size when shrank */
  this.originalSize = null;
  /** @type {number} Amount to offset the total scroll size by. */
  this.offsetSize = parseInt(this.$attrs.mdOffsetSize, 10) || 0;
  /** @type {?string} height or width element style on the container prior to auto-shrinking. */
  this.oldElementSize = null;
  /** @type {!number} Maximum amount of pixels allowed for a single DOM element */
  this.maxElementPixels = $mdConstant.ELEMENT_MAX_PIXELS;

  if (this.$attrs.mdTopIndex) {
    /** @type {function(angular.Scope): number} Binds to topIndex on AngularJS scope */
    this.bindTopIndex = $parse(this.$attrs.mdTopIndex);
    /** @type {number} The index of the item that is at the top of the scroll container */
    this.topIndex = this.bindTopIndex(this.$scope);

    if (!angular.isDefined(this.topIndex)) {
      this.topIndex = 0;
      this.bindTopIndex.assign(this.$scope, 0);
    }

    this.$scope.$watch(this.bindTopIndex, angular.bind(this, function(newIndex) {
      if (newIndex !== this.topIndex) {
        this.scrollToIndex(newIndex);
      }
    }));
  } else {
    this.topIndex = 0;
  }

  this.scroller = $element[0].querySelector('.md-virtual-repeat-scroller');
  this.sizer = this.scroller.querySelector('.md-virtual-repeat-sizer');
  this.offsetter = this.scroller.querySelector('.md-virtual-repeat-offsetter');

  // After the DOM stabilizes, measure the initial size of the container and
  // make a best effort at re-measuring as it changes.
  var boundUpdateSize = angular.bind(this, this.updateSize);

  $$rAF(angular.bind(this, function() {
    boundUpdateSize();

    var debouncedUpdateSize = $mdUtil.debounce(boundUpdateSize, 10, null, false);
    var jWindow = angular.element($window);

    // Make one more attempt to get the size if it is 0.
    // This is not by any means a perfect approach, but there's really no
    // silver bullet here.
    if (!this.size) {
      debouncedUpdateSize();
    }

    jWindow.on('resize', debouncedUpdateSize);
    $scope.$on('$destroy', function() {
      jWindow.off('resize', debouncedUpdateSize);
    });

    $scope.$emit('$md-resize-enable');
    $scope.$on('$md-resize', boundUpdateSize);
  }));
}


/** Called by the md-virtual-repeat inside of the container at startup. */
VirtualRepeatContainerController.prototype.register = function(repeaterCtrl) {
  this.repeater = repeaterCtrl;

  angular.element(this.scroller)
      .on('scroll wheel touchmove touchend', angular.bind(this, this.handleScroll_));
};


/** @return {boolean} Whether the container is configured for horizontal scrolling. */
VirtualRepeatContainerController.prototype.isHorizontal = function() {
  return this.horizontal;
};


/** @return {number} The size (width or height) of the container. */
VirtualRepeatContainerController.prototype.getSize = function() {
  return this.size;
};


/**
 * Resizes the container.
 * @private
 * @param {number} size The new size to set.
 */
VirtualRepeatContainerController.prototype.setSize_ = function(size) {
  var dimension = this.getDimensionName_();

  this.size = size;
  this.$element[0].style[dimension] = size + 'px';
};


VirtualRepeatContainerController.prototype.unsetSize_ = function() {
  this.$element[0].style[this.getDimensionName_()] = this.oldElementSize;
  this.oldElementSize = null;
};


/** Instructs the container to re-measure its size. */
VirtualRepeatContainerController.prototype.updateSize = function() {
  // If the original size is already determined, we can skip the update.
  if (this.originalSize) return;

  var size = this.isHorizontal()
      ? this.$element[0].clientWidth
      : this.$element[0].clientHeight;

  if (size) {
    this.size = size;
  }

  // Recheck the scroll position after updating the size. This resolves
  // problems that can result if the scroll position was measured while the
  // element was display: none or detached from the document.
  this.handleScroll_();

  this.repeater && this.repeater.containerUpdated();
};


/** @return {number} The container's scrollHeight or scrollWidth. */
VirtualRepeatContainerController.prototype.getScrollSize = function() {
  return this.scrollSize;
};

/**
 * @returns {string} either width or height dimension
 * @private
 */
VirtualRepeatContainerController.prototype.getDimensionName_ = function() {
  return this.isHorizontal() ? 'width' : 'height';
};


/**
 * Sets the scroller element to the specified size.
 * @private
 * @param {number} size The new size.
 */
VirtualRepeatContainerController.prototype.sizeScroller_ = function(size) {
  var dimension =  this.getDimensionName_();
  var crossDimension = this.isHorizontal() ? 'height' : 'width';

  // Clear any existing dimensions.
  this.sizer.innerHTML = '';

  // If the size falls within the browser's maximum explicit size for a single element, we can
  // set the size and be done. Otherwise, we have to create children that add up the the desired
  // size.
  if (size < this.maxElementPixels) {
    this.sizer.style[dimension] = size + 'px';
  } else {
    this.sizer.style[dimension] = 'auto';
    this.sizer.style[crossDimension] = 'auto';

    // Divide the total size we have to render into N max-size pieces.
    var numChildren = Math.floor(size / this.maxElementPixels);

    // Element template to clone for each max-size piece.
    var sizerChild = document.createElement('div');
    sizerChild.style[dimension] = this.maxElementPixels + 'px';
    sizerChild.style[crossDimension] = '1px';

    for (var i = 0; i < numChildren; i++) {
      this.sizer.appendChild(sizerChild.cloneNode(false));
    }

    // Re-use the element template for the remainder.
    sizerChild.style[dimension] = (size - (numChildren * this.maxElementPixels)) + 'px';
    this.sizer.appendChild(sizerChild);
  }
};


/**
 * If auto-shrinking is enabled, shrinks or unshrinks as appropriate.
 * @private
 * @param {number} size The new size.
 */
VirtualRepeatContainerController.prototype.autoShrink_ = function(size) {
  var shrinkSize = Math.max(size, this.autoShrinkMin * this.repeater.getItemSize());

  if (this.autoShrink && shrinkSize !== this.size) {
    if (this.oldElementSize === null) {
      this.oldElementSize = this.$element[0].style[this.getDimensionName_()];
    }

    var currentSize = this.originalSize || this.size;

    if (!currentSize || shrinkSize < currentSize) {
      if (!this.originalSize) {
        this.originalSize = this.size;
      }

      // Now we update the containers size, because shrinking is enabled.
      this.setSize_(shrinkSize);
    } else if (this.originalSize !== null) {
      // Set the size back to our initial size.
      this.unsetSize_();

      var _originalSize = this.originalSize;
      this.originalSize = null;

      // We determine the repeaters size again, if the original size was zero.
      // The originalSize needs to be null, to be able to determine the size.
      if (!_originalSize) this.updateSize();

      // Apply the original size or the determined size back to the container, because
      // it has been overwritten before, in the shrink block.
      this.setSize_(_originalSize || this.size);
    }

    this.repeater.containerUpdated();
  }
};


/**
 * Sets the scrollHeight or scrollWidth. Called by the repeater based on
 * its item count and item size.
 * @param {number} itemsSize The total size of the items.
 */
VirtualRepeatContainerController.prototype.setScrollSize = function(itemsSize) {
  var size = itemsSize + this.offsetSize;
  if (this.scrollSize === size) return;

  this.sizeScroller_(size);
  this.autoShrink_(size);
  this.scrollSize = size;
};


/** @return {number} The container's current scroll offset. */
VirtualRepeatContainerController.prototype.getScrollOffset = function() {
  return this.scrollOffset;
};

/**
 * Scrolls to a given scrollTop position.
 * @param {number} position
 */
VirtualRepeatContainerController.prototype.scrollTo = function(position) {
  this.scroller[this.isHorizontal() ? 'scrollLeft' : 'scrollTop'] = position;
  this.handleScroll_();
};

/**
 * Scrolls the item with the given index to the top of the scroll container.
 * @param {number} index
 */
VirtualRepeatContainerController.prototype.scrollToIndex = function(index) {
  var itemSize = this.repeater.getItemSize();
  var itemsLength = this.repeater.itemsLength;
  if (index > itemsLength) {
    index = itemsLength - 1;
  }
  this.scrollTo(itemSize * index);
};

VirtualRepeatContainerController.prototype.resetScroll = function() {
  this.scrollTo(0);
};


VirtualRepeatContainerController.prototype.handleScroll_ = function() {
  var ltr = document.dir !== 'rtl' && document.body.dir !== 'rtl';
  if (!ltr && !this.maxSize) {
    this.scroller.scrollLeft = this.scrollSize;
    this.maxSize = this.scroller.scrollLeft;
  }
  var offset = this.isHorizontal() ?
      (ltr?this.scroller.scrollLeft : this.maxSize - this.scroller.scrollLeft)
      : this.scroller.scrollTop;
  if (this.scrollSize < this.size) return;
  if (offset > this.scrollSize - this.size) {
    offset = this.scrollSize - this.size;
  }
  if (offset === this.scrollOffset) return;

  var itemSize = this.repeater.getItemSize();
  if (!itemSize) return;

  var numItems = Math.max(0, Math.floor(offset / itemSize) - NUM_EXTRA);

  var transform = (this.isHorizontal() ? 'translateX(' : 'translateY(') +
      (!this.isHorizontal() || ltr ? (numItems * itemSize) : - (numItems * itemSize))  + 'px)';

  this.scrollOffset = offset;
  this.offsetter.style.webkitTransform = transform;
  this.offsetter.style.transform = transform;

  if (this.bindTopIndex) {
    var topIndex = Math.floor(offset / itemSize);
    if (topIndex !== this.topIndex && topIndex < this.repeater.getItemCount()) {
      this.topIndex = topIndex;
      this.bindTopIndex.assign(this.$scope, topIndex);
      if (!this.$rootScope.$$phase) this.$scope.$digest();
    }
  }

  this.repeater.containerUpdated();
};


/**
 * @ngdoc directive
 * @name mdVirtualRepeat
 * @module material.components.virtualRepeat
 * @restrict A
 * @priority 1000
 * @description
 * The `md-virtual-repeat` attribute is applied to a template that is repeated using virtual
 * scrolling. This provides smooth and performant scrolling through very large lists of elements.
 *
 * Virtual repeat is a limited substitute for `ng-repeat` that renders only
 * enough DOM nodes to fill the container, recycling them as the user scrolls.
 *
 * ### Notes
 *
 * - Arrays are supported for iteration by default.
 * - An object can used use if `md-on-demand` is specified and the object implements the interface
 *   described in the `md-on-demand` <a ng-href="#attributes">documentation</a>.
 * - `trackBy`, `as` alias, and `(key, value)` syntax from `ng-repeat` are not supported.
 *
 * ### On-Demand Async Item Loading
 *
 * When using the `md-on-demand` attribute and loading some asynchronous data,
 * the `getItemAtIndex` function will mostly return nothing.
 *
 * <hljs lang="js">
 *   DynamicItems.prototype.getItemAtIndex = function(index) {
 *     if (this.pages[index]) {
 *       return this.pages[index];
 *     } else {
 *       // This is an asynchronous action and does not return any value.
 *       this.loadPage(index);
 *     }
 *   };
 * </hljs>
 *
 * This means that the Virtual Repeat will not have any value for the given index.<br/>
 * After the data loading completes, the user expects the Virtual Repeat to recognize the change.
 *
 * To make sure that the Virtual Repeat properly detects any change, you need to run the operation
 * in another digest.
 *
 * <hljs lang="js">
 *   DynamicItems.prototype.loadPage = function(index) {
 *     var self = this;
 *
 *     // Trigger a new digest by using $timeout
 *     $timeout(function() {
 *       self.pages[index] = Data;
 *     });
 *   };
 * </hljs>
 *
 * > <b>Note:</b> Please also review the
 *   <a ng-href="api/directive/mdVirtualRepeatContainer">VirtualRepeatContainer</a> documentation
 *   for more information.
 *
 * @usage
 * <hljs lang="html">
 * <md-virtual-repeat-container>
 *   <div md-virtual-repeat="i in items">Hello {{i}}!</div>
 * </md-virtual-repeat-container>
 *
 * <md-virtual-repeat-container md-orient-horizontal>
 *   <div md-virtual-repeat="i in items" md-item-size="20">Hello {{i}}!</div>
 * </md-virtual-repeat-container>
 * </hljs>
 *
 * @param {expression=} md-extra-name Evaluates to an additional name to which the current iterated
 *   item can be assigned on the repeated scope (needed for use in `md-autocomplete`).
 * @param {number=} md-item-size Optional height or width of the repeated elements (which **must be
 *   identical for each element**). Virtual repeat will attempt to read the size from the DOM,
 *   if missing, but it still assumes that all repeated nodes have the **same height**
 *   (when scrolling vertically) or **same width** (when scrolling horizontally).
 * @param {boolean=} md-on-demand When present, treats the `md-virtual-repeat` argument as an object
 *   that can fetch rows rather than an array.
 *
 *   **NOTE:** This object **must** implement the following interface with two methods:
 *
 *   - `getItemAtIndex` - `{function(index): Object}`: The item at that `index` or `null` if it is
 *     not yet loaded (it should start downloading the item in that case).
 *   - `getLength` - `{function(): number}`: The data length to which the repeater container
 *     should be sized. Ideally, when the count is known, this method should return it.
 *     Otherwise, return a higher number than the currently loaded items to produce an
 *     infinite-scroll behavior.
 */
function VirtualRepeatDirective($parse) {
  return {
    controller: VirtualRepeatController,
    priority: 1000,
    require: ['mdVirtualRepeat', '^^mdVirtualRepeatContainer'],
    restrict: 'A',
    terminal: true,
    transclude: 'element',
    compile: function VirtualRepeatCompile($element, $attrs) {
      var expression = $attrs.mdVirtualRepeat;
      var match = expression.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)\s*$/);
      var repeatName = match[1];
      var repeatListExpression = $parse(match[2]);
      var extraName = $attrs.mdExtraName && $parse($attrs.mdExtraName);

      return function VirtualRepeatLink($scope, $element, $attrs, ctrl, $transclude) {
        ctrl[0].link_(ctrl[1], $transclude, repeatName, repeatListExpression, extraName);
      };
    }
  };
}


/** @ngInject */
function VirtualRepeatController($scope, $element, $attrs, $browser, $document, $rootScope,
    $$rAF, $mdUtil) {
  this.$scope = $scope;
  this.$element = $element;
  this.$attrs = $attrs;
  this.$browser = $browser;
  this.$document = $document;
  this.$mdUtil = $mdUtil;
  this.$rootScope = $rootScope;
  this.$$rAF = $$rAF;

  /** @type {boolean} Whether we are in on-demand mode. */
  this.onDemand = $mdUtil.parseAttributeBoolean($attrs.mdOnDemand);
  /** @type {!Function} Backup reference to $browser.$$checkUrlChange */
  this.browserCheckUrlChange = $browser.$$checkUrlChange;
  /** @type {number} Most recent starting repeat index (based on scroll offset) */
  this.newStartIndex = 0;
  /** @type {number} Most recent ending repeat index (based on scroll offset) */
  this.newEndIndex = 0;
  /** @type {number} Most recent end visible index (based on scroll offset) */
  this.newVisibleEnd = 0;
  /** @type {number} Previous starting repeat index (based on scroll offset) */
  this.startIndex = 0;
  /** @type {number} Previous ending repeat index (based on scroll offset) */
  this.endIndex = 0;
  /** @type {?number} Height/width of repeated elements. */
  this.itemSize = $scope.$eval($attrs.mdItemSize) || null;

  /** @type {boolean} Whether this is the first time that items are rendered. */
  this.isFirstRender = true;

  /**
   * @private {boolean} Whether the items in the list are already being updated. Used to prevent
   *     nested calls to virtualRepeatUpdate_.
   */
  this.isVirtualRepeatUpdating_ = false;

  /** @type {number} Most recently seen length of items. */
  this.itemsLength = 0;

  /**
   * @type {!Function} Unwatch callback for item size (when md-items-size is
   *     not specified), or angular.noop otherwise.
   */
  this.unwatchItemSize_ = angular.noop;

  /**
   * Presently rendered blocks by repeat index.
   * @type {Object<number, !VirtualRepeatController.Block>}
   */
  this.blocks = {};
  /** @type {Array<!VirtualRepeatController.Block>} A pool of presently unused blocks. */
  this.pooledBlocks = [];

  $scope.$on('$destroy', angular.bind(this, this.cleanupBlocks_));
}


/**
 * An object representing a repeated item.
 * @typedef {{element: !jqLite, new: boolean, scope: !angular.Scope}}
 */
VirtualRepeatController.Block;


/**
 * Called at startup by the md-virtual-repeat postLink function.
 * @param {!VirtualRepeatContainerController} container The container's controller.
 * @param {!Function} transclude The repeated element's bound transclude function.
 * @param {string} repeatName The left hand side of the repeat expression, indicating
 *     the name for each item in the array.
 * @param {!Function} repeatListExpression A compiled expression based on the right hand side
 *     of the repeat expression. Points to the array to repeat over.
 * @param {string|undefined} extraName The optional extra repeatName.
 */
VirtualRepeatController.prototype.link_ =
    function(container, transclude, repeatName, repeatListExpression, extraName) {
  this.container = container;
  this.transclude = transclude;
  this.repeatName = repeatName;
  this.rawRepeatListExpression = repeatListExpression;
  this.extraName = extraName;
  this.sized = false;

  this.repeatListExpression = angular.bind(this, this.repeatListExpression_);

  this.container.register(this);
};


/** @private Cleans up unused blocks. */
VirtualRepeatController.prototype.cleanupBlocks_ = function() {
  angular.forEach(this.pooledBlocks, function cleanupBlock(block) {
    block.element.remove();
  });
};


/** @private Attempts to set itemSize by measuring a repeated element in the dom */
VirtualRepeatController.prototype.readItemSize_ = function() {
  if (this.itemSize) {
    // itemSize was successfully read in a different asynchronous call.
    return;
  }

  this.items = this.repeatListExpression(this.$scope);
  this.parentNode = this.$element[0].parentNode;
  var block = this.getBlock_(0);
  if (!block.element[0].parentNode) {
    this.parentNode.appendChild(block.element[0]);
  }

  this.itemSize = block.element[0][
      this.container.isHorizontal() ? 'offsetWidth' : 'offsetHeight'] || null;

  this.blocks[0] = block;
  this.poolBlock_(0);

  if (this.itemSize) {
    this.containerUpdated();
  }
};


/**
 * Returns the user-specified repeat list, transforming it into an array-like
 * object in the case of infinite scroll/dynamic load mode.
 * @param {!angular.Scope} scope The scope.
 * @return {!Array|!Object} An array or array-like object for iteration.
 */
VirtualRepeatController.prototype.repeatListExpression_ = function(scope) {
  var repeatList = this.rawRepeatListExpression(scope);

  if (this.onDemand && repeatList) {
    var virtualList = new VirtualRepeatModelArrayLike(repeatList);
    virtualList.$$includeIndexes(this.newStartIndex, this.newVisibleEnd);
    return virtualList;
  } else {
    return repeatList;
  }
};


/**
 * Called by the container. Informs us that the container's scroll or size has
 * changed.
 */
VirtualRepeatController.prototype.containerUpdated = function() {
  // If itemSize is unknown, attempt to measure it.
  if (!this.itemSize) {
    // Make sure to clean up watchers if we can (see #8178)
    if (this.unwatchItemSize_ && this.unwatchItemSize_ !== angular.noop){
      this.unwatchItemSize_();
    }
    this.unwatchItemSize_ = this.$scope.$watchCollection(
        this.repeatListExpression,
        angular.bind(this, function(items) {
          if (items && items.length) {
            this.readItemSize_();
          }
        }));
    if (!this.$rootScope.$$phase) this.$scope.$digest();

    return;
  } else if (!this.sized) {
    this.items = this.repeatListExpression(this.$scope);
  }

  if (!this.sized) {
    this.unwatchItemSize_();
    this.sized = true;
    this.$scope.$watchCollection(this.repeatListExpression,
        angular.bind(this, function(items, oldItems) {
          if (!this.isVirtualRepeatUpdating_) {
            this.virtualRepeatUpdate_(items, oldItems);
          }
        }));
  }

  this.updateIndexes_();

  if (this.newStartIndex !== this.startIndex ||
      this.newEndIndex !== this.endIndex ||
      this.container.getScrollOffset() > this.container.getScrollSize()) {
    if (this.items instanceof VirtualRepeatModelArrayLike) {
      this.items.$$includeIndexes(this.newStartIndex, this.newEndIndex);
    }
    this.virtualRepeatUpdate_(this.items, this.items);
  }
};


/**
 * Called by the container. Returns the size of a single repeated item.
 * @return {?number} size of a repeated item.
 */
VirtualRepeatController.prototype.getItemSize = function() {
  return this.itemSize;
};


/**
 * Called by the container.
 * @return {?number} the most recently seen length of items.
 */
VirtualRepeatController.prototype.getItemCount = function() {
  return this.itemsLength;
};


/**
 * Updates the order and visible offset of repeated blocks in response to scrolling
 * or updates to `items`.
 * @param {Array} items visible elements
 * @param {Array} oldItems previously visible elements
 * @private
 */
VirtualRepeatController.prototype.virtualRepeatUpdate_ = function(items, oldItems) {
  this.isVirtualRepeatUpdating_ = true;

  var itemsLength = items && items.length || 0;
  var lengthChanged = false;

  // If the number of items shrank, keep the scroll position.
  if (this.items && itemsLength < this.items.length && this.container.getScrollOffset() !== 0) {
    this.items = items;
    var previousScrollOffset = this.container.getScrollOffset();
    this.container.resetScroll();
    this.container.scrollTo(previousScrollOffset);
  }

  if (itemsLength !== this.itemsLength) {
    lengthChanged = true;
    this.itemsLength = itemsLength;
  }

  this.items = items;
  if (items !== oldItems || lengthChanged) {
    this.updateIndexes_();
  }

  this.parentNode = this.$element[0].parentNode;

  if (lengthChanged) {
    this.container.setScrollSize(itemsLength * this.itemSize);
  }

  // Detach and pool any blocks that are no longer in the viewport.
  Object.keys(this.blocks).forEach(function(blockIndex) {
    var index = parseInt(blockIndex, 10);
    if (index < this.newStartIndex || index >= this.newEndIndex) {
      this.poolBlock_(index);
    }
  }, this);

  // Add needed blocks.
  // For performance reasons, temporarily block browser url checks as we digest
  // the restored block scopes ($$checkUrlChange reads window.location to
  // check for changes and trigger route change, etc, which we don't need when
  // trying to scroll at 60fps).
  this.$browser.$$checkUrlChange = angular.noop;

  var i, block,
      newStartBlocks = [],
      newEndBlocks = [];

  // Collect blocks at the top.
  for (i = this.newStartIndex; i < this.newEndIndex && this.blocks[i] == null; i++) {
    block = this.getBlock_(i);
    this.updateBlock_(block, i);
    newStartBlocks.push(block);
  }

  // Update blocks that are already rendered.
  for (; this.blocks[i] != null; i++) {
    this.updateBlock_(this.blocks[i], i);
  }
  var maxIndex = i - 1;

  // Collect blocks at the end.
  for (; i < this.newEndIndex; i++) {
    block = this.getBlock_(i);
    this.updateBlock_(block, i);
    newEndBlocks.push(block);
  }

  // Attach collected blocks to the document.
  if (newStartBlocks.length) {
    this.parentNode.insertBefore(
        this.domFragmentFromBlocks_(newStartBlocks),
        this.$element[0].nextSibling);
  }
  if (newEndBlocks.length) {
    this.parentNode.insertBefore(
        this.domFragmentFromBlocks_(newEndBlocks),
        this.blocks[maxIndex] && this.blocks[maxIndex].element[0].nextSibling);
  }

  // Restore $$checkUrlChange.
  this.$browser.$$checkUrlChange = this.browserCheckUrlChange;

  this.startIndex = this.newStartIndex;
  this.endIndex = this.newEndIndex;

  if (this.isFirstRender) {
    this.isFirstRender = false;
    var firstRenderStartIndex = this.$attrs.mdStartIndex ?
      this.$scope.$eval(this.$attrs.mdStartIndex) :
      this.container.topIndex;

    // The first call to virtualRepeatUpdate_ may not be when the virtual repeater is ready.
    // Introduce a slight delay so that the update happens when it is actually ready.
    this.$mdUtil.nextTick(function() {
      this.container.scrollToIndex(firstRenderStartIndex);
    }.bind(this));
  }

  this.isVirtualRepeatUpdating_ = false;
};


/**
 * @param {number} index Where the block is to be in the repeated list.
 * @return {!VirtualRepeatController.Block} A new or pooled block to place at the specified index.
 * @private
 */
VirtualRepeatController.prototype.getBlock_ = function(index) {
  if (this.pooledBlocks.length) {
    return this.pooledBlocks.pop();
  }

  var block;
  this.transclude(angular.bind(this, function(clone, scope) {
    block = {
      element: clone,
      new: true,
      scope: scope
    };

    this.updateScope_(scope, index);
    this.parentNode.appendChild(clone[0]);
  }));

  return block;
};


/**
 * Updates and if not in a digest cycle, digests the specified block's scope to the data
 * at the specified index.
 * @param {!VirtualRepeatController.Block} block The block whose scope should be updated.
 * @param {number} index The index to set.
 * @private
 */
VirtualRepeatController.prototype.updateBlock_ = function(block, index) {
  this.blocks[index] = block;

  if (!block.new &&
      (block.scope.$index === index && block.scope[this.repeatName] === this.items[index])) {
    return;
  }
  block.new = false;

  // Update and digest the block's scope.
  this.updateScope_(block.scope, index);

  // Perform digest before reattaching the block.
  // Any resulting synchronous DOM mutations should be much faster as a result.
  // This might break some directives.
  if (!this.$rootScope.$$phase) {
    block.scope.$digest();
  }
};


/**
 * Updates scope to the data at the specified index.
 * @param {!angular.Scope} scope The scope which should be updated.
 * @param {number} index The index to set.
 * @private
 */
VirtualRepeatController.prototype.updateScope_ = function(scope, index) {
  scope.$index = index;
  scope[this.repeatName] = this.items && this.items[index];
  if (this.extraName) scope[this.extraName(this.$scope)] = this.items[index];
};


/**
 * Pools the block at the specified index (Pulls its element out of the dom and stores it).
 * @param {number} index The index at which the block to pool is stored.
 * @private
 */
VirtualRepeatController.prototype.poolBlock_ = function(index) {
  this.pooledBlocks.push(this.blocks[index]);
  this.parentNode.removeChild(this.blocks[index].element[0]);
  delete this.blocks[index];
};


/**
 * Produces a dom fragment containing the elements from the list of blocks.
 * @param {!Array<!VirtualRepeatController.Block>} blocks The blocks whose elements
 *     should be added to the document fragment.
 * @return {DocumentFragment}
 * @private
 */
VirtualRepeatController.prototype.domFragmentFromBlocks_ = function(blocks) {
  var fragment = this.$document[0].createDocumentFragment();
  blocks.forEach(function(block) {
    fragment.appendChild(block.element[0]);
  });
  return fragment;
};


/**
 * Updates start and end indexes based on length of repeated items and container size.
 * @private
 */
VirtualRepeatController.prototype.updateIndexes_ = function() {
  var itemsLength = this.items ? this.items.length : 0;
  var containerLength = Math.ceil(this.container.getSize() / this.itemSize);

  this.newStartIndex = Math.max(0, Math.min(
      itemsLength - containerLength,
      Math.floor(this.container.getScrollOffset() / this.itemSize)));
  this.newVisibleEnd = this.newStartIndex + containerLength + NUM_EXTRA;
  this.newEndIndex = Math.min(itemsLength, this.newVisibleEnd);
  this.newStartIndex = Math.max(0, this.newStartIndex - NUM_EXTRA);
};

/**
 * This VirtualRepeatModelArrayLike class enforces the interface requirements
 * for infinite scrolling within a mdVirtualRepeatContainer.
 *
 * @param {Object} model An object with this interface must implement the following interface with
 * two (2) methods:
 *
 * getItemAtIndex: function(index) -> item at that index or null if it is not yet
 *     loaded (It should start downloading the item in that case).
 *
 * getLength: function() -> number The data length to which the repeater container
 *     should be sized. Ideally, when the count is known, this method should return it.
 *     Otherwise, return a higher number than the currently loaded items to produce an
 *     infinite-scroll behavior.
 *
 * @usage
 * <hljs lang="html">
 *  <md-virtual-repeat-container md-orient-horizontal>
 *    <div md-virtual-repeat="i in items" md-on-demand>
 *      Hello {{i}}!
 *    </div>
 *  </md-virtual-repeat-container>
 * </hljs>
 *
 */
function VirtualRepeatModelArrayLike(model) {
  if (!angular.isFunction(model.getItemAtIndex) ||
      !angular.isFunction(model.getLength)) {
    throw Error('When md-on-demand is enabled, the Object passed to md-virtual-repeat must ' +
        'implement functions getItemAtIndex() and getLength().');
  }

  this.model = model;
}

/**
 * @param {number} start
 * @param {number} end
 */
VirtualRepeatModelArrayLike.prototype.$$includeIndexes = function(start, end) {
  for (var i = start; i < end; i++) {
    if (!this.hasOwnProperty(i)) {
      this[i] = this.model.getItemAtIndex(i);
    }
  }
  this.length = this.model.getLength();
};

/**
 * @ngdoc directive
 * @name mdForceHeight
 * @module material.components.virtualRepeat
 * @restrict A
 * @description
 *
 * Force an element to have a certain `px` height. This is used in place of a style tag in order to
 * conform to the
 * <a href="https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Security-Policy/script-src">
 *   Content Security Policy</a> regarding `unsafe-inline` `<style>` tags.
 *
 * This directive is related to <a ng-href="api/directive/mdVirtualRepeat">mdVirtualRepeat</a>.
 *
 * @usage
 * <hljs lang="html">
 *   <div md-force-height="'100px'"></div>
 * </hljs>
 */
function ForceHeightDirective($mdUtil) {
  return {
    restrict: 'A',
    link: function(scope, element, attrs) {
      var height = scope.$eval(attrs.mdForceHeight) || null;

      if (height && element) {
        element[0].style.height = height;
      }
    }
  };
}
ForceHeightDirective.$inject = ['$mdUtil'];

})();
(function(){
"use strict";

/**
 * @ngdoc module
 * @name material.components.whiteframe
 */
MdWhiteframeDirective.$inject = ["$log"];
angular
  .module('material.components.whiteframe', ['material.core'])
  .directive('mdWhiteframe', MdWhiteframeDirective);

/**
 * @ngdoc directive
 * @module material.components.whiteframe
 * @name mdWhiteframe
 *
 * @description
 * The md-whiteframe directive allows you to apply an elevation shadow to an element.
 *
 * The attribute values needs to be a number between 1 and 24 or -1.
 * When set to -1 no style is applied.
 *
 * ### Notes
 * - If there is no value specified it defaults to 4dp.
 * - If the value is not valid it defaults to 4dp.

 * @usage
 * <hljs lang="html">
 * <div md-whiteframe="3">
 *   <span>Elevation of 3dp</span>
 * </div>
 * </hljs>
 *
 * <hljs lang="html">
 * <div md-whiteframe="-1">
 *   <span>No elevation shadow applied</span>
 * </div>
 * </hljs>
 *
 * <hljs lang="html">
 * <div ng-init="elevation = 5" md-whiteframe="{{elevation}}">
 *   <span>Elevation of 5dp with an interpolated value</span>
 * </div>
 * </hljs>
 */
function MdWhiteframeDirective($log) {
  var DISABLE_DP = -1;
  var MIN_DP = 1;
  var MAX_DP = 24;
  var DEFAULT_DP = 4;

  return {
    link: postLink
  };

  function postLink(scope, element, attr) {
    var oldClass = '';

    attr.$observe('mdWhiteframe', function(elevation) {
      elevation = parseInt(elevation, 10) || DEFAULT_DP;

      if (elevation != DISABLE_DP && (elevation > MAX_DP || elevation < MIN_DP)) {
        $log.warn('md-whiteframe attribute value is invalid. It should be a number between ' + MIN_DP + ' and ' + MAX_DP, element[0]);
        elevation = DEFAULT_DP;
      }

      var newClass = elevation == DISABLE_DP ? '' : 'md-whiteframe-' + elevation + 'dp';
      attr.$updateClass(newClass, oldClass);
      oldClass = newClass;
    });
  }
}


})();
(function(){ 
angular.module("material.core").constant("$MD_THEME_CSS", "md-autocomplete.md-THEME_NAME-theme{background:\"{{background-hue-1}}\"}md-autocomplete.md-THEME_NAME-theme[disabled]:not([md-floating-label]){background:\"{{background-hue-2}}\"}md-autocomplete.md-THEME_NAME-theme button md-icon path{fill:\"{{background-600}}\"}md-autocomplete.md-THEME_NAME-theme button:after{background:\"{{background-600-0.3}}\"}md-autocomplete.md-THEME_NAME-theme input{color:\"{{foreground-1}}\"}md-autocomplete.md-THEME_NAME-theme.md-accent md-input-container.md-input-focused .md-input{border-color:\"{{accent-color}}\"}md-autocomplete.md-THEME_NAME-theme.md-accent md-input-container.md-input-focused label,md-autocomplete.md-THEME_NAME-theme.md-accent md-input-container.md-input-focused md-icon{color:\"{{accent-color}}\"}md-autocomplete.md-THEME_NAME-theme.md-accent md-progress-linear .md-container{background-color:\"{{accent-100}}\"}md-autocomplete.md-THEME_NAME-theme.md-accent md-progress-linear .md-bar{background-color:\"{{accent-color}}\"}md-autocomplete.md-THEME_NAME-theme.md-warn md-input-container.md-input-focused .md-input{border-color:\"{{warn-A700}}\"}md-autocomplete.md-THEME_NAME-theme.md-warn md-input-container.md-input-focused label,md-autocomplete.md-THEME_NAME-theme.md-warn md-input-container.md-input-focused md-icon{color:\"{{warn-A700}}\"}md-autocomplete.md-THEME_NAME-theme.md-warn md-progress-linear .md-container{background-color:\"{{warn-100}}\"}md-autocomplete.md-THEME_NAME-theme.md-warn md-progress-linear .md-bar{background-color:\"{{warn-color}}\"}.md-autocomplete-standard-list-container.md-THEME_NAME-theme,.md-autocomplete-suggestions-container.md-THEME_NAME-theme{background:\"{{background-hue-1}}\"}.md-autocomplete-standard-list-container.md-THEME_NAME-theme li,.md-autocomplete-suggestions-container.md-THEME_NAME-theme li{color:\"{{foreground-1}}\"}.md-autocomplete-standard-list-container.md-THEME_NAME-theme li#selected_option,.md-autocomplete-standard-list-container.md-THEME_NAME-theme li:hover,.md-autocomplete-suggestions-container.md-THEME_NAME-theme li#selected_option,.md-autocomplete-suggestions-container.md-THEME_NAME-theme li:hover{background:\"{{background-500-0.18}}\"}md-backdrop{background-color:\"{{background-900-0.0}}\"}md-backdrop.md-opaque.md-THEME_NAME-theme{background-color:\"{{background-900-1.0}}\"}md-bottom-sheet.md-THEME_NAME-theme{background-color:\"{{background-color}}\";border-top-color:\"{{background-hue-3}}\"}md-bottom-sheet.md-THEME_NAME-theme.md-list md-list-item{color:\"{{foreground-1}}\"}md-bottom-sheet.md-THEME_NAME-theme .md-subheader{background-color:\"{{background-color}}\";color:\"{{foreground-1}}\"}.md-button.md-THEME_NAME-theme:not([disabled]).md-focused,.md-button.md-THEME_NAME-theme:not([disabled]):hover{background-color:\"{{background-500-0.2}}\"}.md-button.md-THEME_NAME-theme:not([disabled]).md-icon-button:hover{background-color:transparent}.md-button.md-THEME_NAME-theme.md-fab md-icon{color:\"{{accent-contrast}}\"}.md-button.md-THEME_NAME-theme.md-primary{color:\"{{primary-color}}\"}.md-button.md-THEME_NAME-theme.md-primary.md-fab,.md-button.md-THEME_NAME-theme.md-primary.md-raised{color:\"{{primary-contrast}}\";background-color:\"{{primary-color}}\"}.md-button.md-THEME_NAME-theme.md-primary.md-fab:not([disabled]) md-icon,.md-button.md-THEME_NAME-theme.md-primary.md-raised:not([disabled]) md-icon{color:\"{{primary-contrast}}\"}.md-button.md-THEME_NAME-theme.md-primary.md-fab:not([disabled]).md-focused,.md-button.md-THEME_NAME-theme.md-primary.md-fab:not([disabled]):hover,.md-button.md-THEME_NAME-theme.md-primary.md-raised:not([disabled]).md-focused,.md-button.md-THEME_NAME-theme.md-primary.md-raised:not([disabled]):hover{background-color:\"{{primary-600}}\"}.md-button.md-THEME_NAME-theme.md-primary:not([disabled]) md-icon{color:\"{{primary-color}}\"}.md-button.md-THEME_NAME-theme.md-fab{background-color:\"{{accent-color}}\";color:\"{{accent-contrast}}\"}.md-button.md-THEME_NAME-theme.md-fab:not([disabled]) .md-icon{color:\"{{accent-contrast}}\"}.md-button.md-THEME_NAME-theme.md-fab:not([disabled]).md-focused,.md-button.md-THEME_NAME-theme.md-fab:not([disabled]):hover{background-color:\"{{accent-A700}}\"}.md-button.md-THEME_NAME-theme.md-raised{color:\"{{background-900}}\";background-color:\"{{background-50}}\"}.md-button.md-THEME_NAME-theme.md-raised:not([disabled]) md-icon{color:\"{{background-900}}\"}.md-button.md-THEME_NAME-theme.md-raised:not([disabled]):hover{background-color:\"{{background-50}}\"}.md-button.md-THEME_NAME-theme.md-raised:not([disabled]).md-focused{background-color:\"{{background-200}}\"}.md-button.md-THEME_NAME-theme.md-warn{color:\"{{warn-color}}\"}.md-button.md-THEME_NAME-theme.md-warn.md-fab,.md-button.md-THEME_NAME-theme.md-warn.md-raised{color:\"{{warn-contrast}}\";background-color:\"{{warn-color}}\"}.md-button.md-THEME_NAME-theme.md-warn.md-fab:not([disabled]) md-icon,.md-button.md-THEME_NAME-theme.md-warn.md-raised:not([disabled]) md-icon{color:\"{{warn-contrast}}\"}.md-button.md-THEME_NAME-theme.md-warn.md-fab:not([disabled]).md-focused,.md-button.md-THEME_NAME-theme.md-warn.md-fab:not([disabled]):hover,.md-button.md-THEME_NAME-theme.md-warn.md-raised:not([disabled]).md-focused,.md-button.md-THEME_NAME-theme.md-warn.md-raised:not([disabled]):hover{background-color:\"{{warn-600}}\"}.md-button.md-THEME_NAME-theme.md-warn:not([disabled]) md-icon{color:\"{{warn-color}}\"}.md-button.md-THEME_NAME-theme.md-accent{color:\"{{accent-color}}\"}.md-button.md-THEME_NAME-theme.md-accent.md-fab,.md-button.md-THEME_NAME-theme.md-accent.md-raised{color:\"{{accent-contrast}}\";background-color:\"{{accent-color}}\"}.md-button.md-THEME_NAME-theme.md-accent.md-fab:not([disabled]) md-icon,.md-button.md-THEME_NAME-theme.md-accent.md-raised:not([disabled]) md-icon{color:\"{{accent-contrast}}\"}.md-button.md-THEME_NAME-theme.md-accent.md-fab:not([disabled]).md-focused,.md-button.md-THEME_NAME-theme.md-accent.md-fab:not([disabled]):hover,.md-button.md-THEME_NAME-theme.md-accent.md-raised:not([disabled]).md-focused,.md-button.md-THEME_NAME-theme.md-accent.md-raised:not([disabled]):hover{background-color:\"{{accent-A700}}\"}.md-button.md-THEME_NAME-theme.md-accent:not([disabled]) md-icon{color:\"{{accent-color}}\"}.md-button.md-THEME_NAME-theme.md-accent[disabled],.md-button.md-THEME_NAME-theme.md-fab[disabled],.md-button.md-THEME_NAME-theme.md-raised[disabled],.md-button.md-THEME_NAME-theme.md-warn[disabled],.md-button.md-THEME_NAME-theme[disabled]{color:\"{{foreground-3}}\";cursor:default}.md-button.md-THEME_NAME-theme.md-accent[disabled] md-icon,.md-button.md-THEME_NAME-theme.md-fab[disabled] md-icon,.md-button.md-THEME_NAME-theme.md-raised[disabled] md-icon,.md-button.md-THEME_NAME-theme.md-warn[disabled] md-icon,.md-button.md-THEME_NAME-theme[disabled] md-icon{color:\"{{foreground-3}}\"}.md-button.md-THEME_NAME-theme.md-fab[disabled],.md-button.md-THEME_NAME-theme.md-raised[disabled]{background-color:\"{{foreground-4}}\"}.md-button.md-THEME_NAME-theme[disabled]{background-color:transparent}._md a.md-THEME_NAME-theme:not(.md-button).md-primary{color:\"{{primary-color}}\"}._md a.md-THEME_NAME-theme:not(.md-button).md-primary:hover{color:\"{{primary-700}}\"}._md a.md-THEME_NAME-theme:not(.md-button).md-accent{color:\"{{accent-color}}\"}._md a.md-THEME_NAME-theme:not(.md-button).md-accent:hover{color:\"{{accent-A700}}\"}._md a.md-THEME_NAME-theme:not(.md-button).md-warn{color:\"{{warn-color}}\"}._md a.md-THEME_NAME-theme:not(.md-button).md-warn:hover{color:\"{{warn-700}}\"}md-card.md-THEME_NAME-theme{color:\"{{foreground-1}}\";background-color:\"{{background-hue-1}}\";border-radius:2px}md-card.md-THEME_NAME-theme .md-card-image{border-radius:2px 2px 0 0}md-card.md-THEME_NAME-theme md-card-header md-card-avatar md-icon{color:\"{{background-color}}\";background-color:\"{{foreground-3}}\"}md-card.md-THEME_NAME-theme md-card-header md-card-header-text .md-subhead,md-card.md-THEME_NAME-theme md-card-title md-card-title-text:not(:only-child) .md-subhead{color:\"{{foreground-2}}\"}md-checkbox.md-THEME_NAME-theme .md-ripple{color:\"{{accent-A700}}\"}md-checkbox.md-THEME_NAME-theme.md-checked .md-ripple{color:\"{{background-600}}\"}md-checkbox.md-THEME_NAME-theme.md-checked.md-focused .md-container:before{background-color:\"{{accent-color-0.26}}\"}md-checkbox.md-THEME_NAME-theme .md-ink-ripple{color:\"{{foreground-2}}\"}md-checkbox.md-THEME_NAME-theme.md-checked .md-ink-ripple{color:\"{{accent-color-0.87}}\"}md-checkbox.md-THEME_NAME-theme:not(.md-checked) .md-icon{border-color:\"{{foreground-2}}\"}md-checkbox.md-THEME_NAME-theme.md-checked .md-icon{background-color:\"{{accent-color-0.87}}\"}md-checkbox.md-THEME_NAME-theme.md-checked .md-icon:after{border-color:\"{{accent-contrast-0.87}}\"}md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary .md-ripple{color:\"{{primary-600}}\"}md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-ripple{color:\"{{background-600}}\"}md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary .md-ink-ripple{color:\"{{foreground-2}}\"}md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-ink-ripple{color:\"{{primary-color-0.87}}\"}md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary:not(.md-checked) .md-icon{border-color:\"{{foreground-2}}\"}md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-icon{background-color:\"{{primary-color-0.87}}\"}md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked.md-focused .md-container:before{background-color:\"{{primary-color-0.26}}\"}md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-icon:after{border-color:\"{{primary-contrast-0.87}}\"}md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary .md-indeterminate[disabled] .md-container{color:\"{{foreground-3}}\"}md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn .md-ripple{color:\"{{warn-600}}\"}md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn .md-ink-ripple{color:\"{{foreground-2}}\"}md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-ink-ripple{color:\"{{warn-color-0.87}}\"}md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn:not(.md-checked) .md-icon{border-color:\"{{foreground-2}}\"}md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-icon{background-color:\"{{warn-color-0.87}}\"}md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked.md-focused:not([disabled]) .md-container:before{background-color:\"{{warn-color-0.26}}\"}md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-icon:after{border-color:\"{{background-200}}\"}md-checkbox.md-THEME_NAME-theme[disabled]:not(.md-checked) .md-icon{border-color:\"{{foreground-3}}\"}md-checkbox.md-THEME_NAME-theme[disabled].md-checked .md-icon{background-color:\"{{foreground-3}}\"}md-checkbox.md-THEME_NAME-theme[disabled].md-checked .md-icon:after{border-color:\"{{background-200}}\"}md-checkbox.md-THEME_NAME-theme[disabled] .md-icon:after{border-color:\"{{foreground-3}}\"}md-checkbox.md-THEME_NAME-theme[disabled] .md-label{color:\"{{foreground-3}}\"}md-chips.md-THEME_NAME-theme .md-chips{box-shadow:0 1px \"{{foreground-4}}\"}md-chips.md-THEME_NAME-theme .md-chips.md-focused{box-shadow:0 2px \"{{primary-color}}\"}md-chips.md-THEME_NAME-theme .md-chips .md-chip-input-container input{color:\"{{foreground-1}}\"}md-chips.md-THEME_NAME-theme .md-chips .md-chip-input-container input:-moz-placeholder,md-chips.md-THEME_NAME-theme .md-chips .md-chip-input-container input::-moz-placeholder{color:\"{{foreground-3}}\"}md-chips.md-THEME_NAME-theme .md-chips .md-chip-input-container input:-ms-input-placeholder{color:\"{{foreground-3}}\"}md-chips.md-THEME_NAME-theme .md-chips .md-chip-input-container input::-webkit-input-placeholder{color:\"{{foreground-3}}\"}md-chips.md-THEME_NAME-theme md-chip{background:\"{{background-300}}\";color:\"{{background-800}}\"}md-chips.md-THEME_NAME-theme md-chip md-icon{color:\"{{background-700}}\"}md-chips.md-THEME_NAME-theme md-chip.md-focused{background:\"{{primary-color}}\";color:\"{{primary-contrast}}\"}md-chips.md-THEME_NAME-theme md-chip.md-focused md-icon{color:\"{{primary-contrast}}\"}md-chips.md-THEME_NAME-theme md-chip._md-chip-editing{background:transparent;color:\"{{background-800}}\"}md-chips.md-THEME_NAME-theme md-chip-remove .md-button md-icon path{fill:\"{{background-500}}\"}.md-contact-suggestion span.md-contact-email{color:\"{{background-400}}\"}md-content.md-THEME_NAME-theme{color:\"{{foreground-1}}\";background-color:\"{{background-default}}\"}.md-THEME_NAME-theme .md-calendar{background:\"{{background-hue-1}}\";color:\"{{foreground-1-0.87}}\"}.md-THEME_NAME-theme .md-calendar tr:last-child td{border-bottom-color:\"{{background-hue-2}}\"}.md-THEME_NAME-theme .md-calendar-day-header{background:\"{{background-500-0.32}}\";color:\"{{foreground-1-0.87}}\"}.md-THEME_NAME-theme .md-calendar-date.md-calendar-date-today .md-calendar-date-selection-indicator{border:1px solid \"{{primary-500}}\"}.md-THEME_NAME-theme .md-calendar-date.md-calendar-date-today.md-calendar-date-disabled{color:\"{{primary-500-0.6}}\"}.md-calendar-date.md-focus .md-THEME_NAME-theme .md-calendar-date-selection-indicator,.md-THEME_NAME-theme .md-calendar-date-selection-indicator:hover{background:\"{{background-500-0.32}}\"}.md-THEME_NAME-theme .md-calendar-date.md-calendar-selected-date .md-calendar-date-selection-indicator,.md-THEME_NAME-theme .md-calendar-date.md-focus.md-calendar-selected-date .md-calendar-date-selection-indicator{background:\"{{primary-500}}\";color:\"{{primary-500-contrast}}\";border-color:transparent}.md-THEME_NAME-theme .md-calendar-date-disabled,.md-THEME_NAME-theme .md-calendar-month-label-disabled{color:\"{{foreground-3}}\"}.md-THEME_NAME-theme .md-calendar-month-label md-icon,.md-THEME_NAME-theme .md-datepicker-input{color:\"{{foreground-1}}\"}.md-THEME_NAME-theme .md-datepicker-input:-moz-placeholder,.md-THEME_NAME-theme .md-datepicker-input::-moz-placeholder{color:\"{{foreground-3}}\"}.md-THEME_NAME-theme .md-datepicker-input:-ms-input-placeholder{color:\"{{foreground-3}}\"}.md-THEME_NAME-theme .md-datepicker-input::-webkit-input-placeholder{color:\"{{foreground-3}}\"}.md-THEME_NAME-theme .md-datepicker-input-container{border-bottom-color:\"{{foreground-4}}\"}.md-THEME_NAME-theme .md-datepicker-input-container.md-datepicker-focused{border-bottom-color:\"{{primary-color}}\"}.md-accent .md-THEME_NAME-theme .md-datepicker-input-container.md-datepicker-focused{border-bottom-color:\"{{accent-color}}\"}.md-THEME_NAME-theme .md-datepicker-input-container.md-datepicker-invalid,.md-warn .md-THEME_NAME-theme .md-datepicker-input-container.md-datepicker-focused{border-bottom-color:\"{{warn-A700}}\"}.md-THEME_NAME-theme .md-datepicker-calendar-pane{border-color:\"{{background-hue-1}}\"}.md-THEME_NAME-theme .md-datepicker-triangle-button .md-datepicker-expand-triangle{border-top-color:\"{{foreground-2}}\"}.md-THEME_NAME-theme .md-datepicker-open .md-datepicker-calendar-icon{color:\"{{primary-color}}\"}.md-accent .md-THEME_NAME-theme .md-datepicker-open .md-datepicker-calendar-icon,.md-THEME_NAME-theme .md-datepicker-open.md-accent .md-datepicker-calendar-icon{color:\"{{accent-color}}\"}.md-THEME_NAME-theme .md-datepicker-open.md-warn .md-datepicker-calendar-icon,.md-warn .md-THEME_NAME-theme .md-datepicker-open .md-datepicker-calendar-icon{color:\"{{warn-A700}}\"}.md-THEME_NAME-theme .md-datepicker-calendar{background:\"{{background-hue-1}}\"}.md-THEME_NAME-theme .md-datepicker-input-mask-opaque{box-shadow:0 0 0 9999px \"{{background-hue-1}}\"}.md-THEME_NAME-theme .md-datepicker-open .md-datepicker-input-container{background:\"{{background-hue-1}}\"}md-dialog.md-THEME_NAME-theme{border-radius:4px;background-color:\"{{background-hue-1}}\";color:\"{{foreground-1}}\"}md-dialog.md-THEME_NAME-theme.md-content-overflow .md-actions,md-dialog.md-THEME_NAME-theme.md-content-overflow md-dialog-actions,md-divider.md-THEME_NAME-theme{border-top-color:\"{{foreground-4}}\"}.layout-gt-lg-row>md-divider.md-THEME_NAME-theme,.layout-gt-md-row>md-divider.md-THEME_NAME-theme,.layout-gt-sm-row>md-divider.md-THEME_NAME-theme,.layout-gt-xs-row>md-divider.md-THEME_NAME-theme,.layout-lg-row>md-divider.md-THEME_NAME-theme,.layout-md-row>md-divider.md-THEME_NAME-theme,.layout-row>md-divider.md-THEME_NAME-theme,.layout-sm-row>md-divider.md-THEME_NAME-theme,.layout-xl-row>md-divider.md-THEME_NAME-theme,.layout-xs-row>md-divider.md-THEME_NAME-theme{border-right-color:\"{{foreground-4}}\"}md-icon.md-THEME_NAME-theme{color:\"{{foreground-2}}\"}md-icon.md-THEME_NAME-theme.md-primary{color:\"{{primary-color}}\"}md-icon.md-THEME_NAME-theme.md-accent{color:\"{{accent-color}}\"}md-icon.md-THEME_NAME-theme.md-warn{color:\"{{warn-color}}\"}md-input-container.md-THEME_NAME-theme .md-input{color:\"{{foreground-1}}\";border-color:\"{{foreground-4}}\"}md-input-container.md-THEME_NAME-theme .md-input:-moz-placeholder,md-input-container.md-THEME_NAME-theme .md-input::-moz-placeholder{color:\"{{foreground-3}}\"}md-input-container.md-THEME_NAME-theme .md-input:-ms-input-placeholder{color:\"{{foreground-3}}\"}md-input-container.md-THEME_NAME-theme .md-input::-webkit-input-placeholder{color:\"{{foreground-3}}\"}md-input-container.md-THEME_NAME-theme>md-icon{color:\"{{foreground-1}}\"}md-input-container.md-THEME_NAME-theme .md-placeholder,md-input-container.md-THEME_NAME-theme label{color:\"{{foreground-3}}\"}md-input-container.md-THEME_NAME-theme label.md-required:after{color:\"{{warn-A700}}\"}md-input-container.md-THEME_NAME-theme:not(.md-input-focused):not(.md-input-invalid) label.md-required:after{color:\"{{foreground-2}}\"}md-input-container.md-THEME_NAME-theme .md-input-message-animation,md-input-container.md-THEME_NAME-theme .md-input-messages-animation{color:\"{{warn-A700}}\"}md-input-container.md-THEME_NAME-theme .md-input-message-animation .md-char-counter,md-input-container.md-THEME_NAME-theme .md-input-messages-animation .md-char-counter{color:\"{{foreground-1}}\"}md-input-container.md-THEME_NAME-theme.md-input-focused .md-input:-moz-placeholder,md-input-container.md-THEME_NAME-theme.md-input-focused .md-input::-moz-placeholder{color:\"{{foreground-2}}\"}md-input-container.md-THEME_NAME-theme.md-input-focused .md-input:-ms-input-placeholder{color:\"{{foreground-2}}\"}md-input-container.md-THEME_NAME-theme.md-input-focused .md-input::-webkit-input-placeholder{color:\"{{foreground-2}}\"}md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-has-value label{color:\"{{foreground-2}}\"}md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused .md-input,md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-resized .md-input{border-color:\"{{primary-color}}\"}md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused label,md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused md-icon{color:\"{{primary-color}}\"}md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused.md-accent .md-input{border-color:\"{{accent-color}}\"}md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused.md-accent label,md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused.md-accent md-icon{color:\"{{accent-color}}\"}md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused.md-warn .md-input{border-color:\"{{warn-A700}}\"}md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused.md-warn label,md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused.md-warn md-icon{color:\"{{warn-A700}}\"}md-input-container.md-THEME_NAME-theme.md-input-invalid .md-input{border-color:\"{{warn-A700}}\"}md-input-container.md-THEME_NAME-theme.md-input-invalid .md-char-counter,md-input-container.md-THEME_NAME-theme.md-input-invalid .md-input-message-animation,md-input-container.md-THEME_NAME-theme.md-input-invalid label{color:\"{{warn-A700}}\"}[disabled] md-input-container.md-THEME_NAME-theme .md-input,md-input-container.md-THEME_NAME-theme .md-input[disabled]{border-bottom-color:transparent;color:\"{{foreground-3}}\";background-image:linear-gradient(90deg,\"{{foreground-3}}\" 0,\"{{foreground-3}}\" 33%,transparent 0);background-image:-ms-linear-gradient(left,transparent 0,\"{{foreground-3}}\" 100%)}md-list.md-THEME_NAME-theme md-list-item.md-2-line .md-list-item-text h3,md-list.md-THEME_NAME-theme md-list-item.md-2-line .md-list-item-text h4,md-list.md-THEME_NAME-theme md-list-item.md-3-line .md-list-item-text h3,md-list.md-THEME_NAME-theme md-list-item.md-3-line .md-list-item-text h4{color:\"{{foreground-1}}\"}md-list.md-THEME_NAME-theme md-list-item.md-2-line .md-list-item-text p,md-list.md-THEME_NAME-theme md-list-item.md-3-line .md-list-item-text p{color:\"{{foreground-2}}\"}md-list.md-THEME_NAME-theme .md-proxy-focus.md-focused div.md-no-style{background-color:\"{{background-100}}\"}md-list.md-THEME_NAME-theme md-list-item .md-avatar-icon{background-color:\"{{foreground-3}}\";color:\"{{background-color}}\"}md-list.md-THEME_NAME-theme md-list-item>md-icon{color:\"{{foreground-2}}\"}md-list.md-THEME_NAME-theme md-list-item>md-icon.md-highlight{color:\"{{primary-color}}\"}md-list.md-THEME_NAME-theme md-list-item>md-icon.md-highlight.md-accent{color:\"{{accent-color}}\"}md-menu-content.md-THEME_NAME-theme{background-color:\"{{background-hue-1}}\"}md-menu-content.md-THEME_NAME-theme md-menu-item{color:\"{{foreground-1}}\"}md-menu-content.md-THEME_NAME-theme md-menu-item md-icon{color:\"{{foreground-2}}\"}md-menu-content.md-THEME_NAME-theme md-menu-item .md-button[disabled],md-menu-content.md-THEME_NAME-theme md-menu-item .md-button[disabled] md-icon{color:\"{{foreground-3}}\"}md-menu-content.md-THEME_NAME-theme md-menu-divider{background-color:\"{{foreground-4}}\"}md-menu-bar.md-THEME_NAME-theme>button.md-button{color:\"{{foreground-1}}\";border-radius:2px}md-menu-bar.md-THEME_NAME-theme md-menu>button{color:\"{{foreground-1}}\"}md-menu-bar.md-THEME_NAME-theme md-menu.md-open>button,md-menu-bar.md-THEME_NAME-theme md-menu>button:focus{outline:none;background-color:\"{{ background-500-0.18}}\"}md-menu-bar.md-THEME_NAME-theme.md-open:not(.md-keyboard-mode) md-menu:hover>button{background-color:\"{{ background-500-0.18}}\"}md-menu-bar.md-THEME_NAME-theme:not(.md-keyboard-mode):not(.md-open) md-menu button:focus,md-menu-bar.md-THEME_NAME-theme:not(.md-keyboard-mode):not(.md-open) md-menu button:hover{background:transparent}md-menu-content.md-THEME_NAME-theme .md-menu>.md-button:after{color:\"{{foreground-2}}\"}md-menu-content.md-THEME_NAME-theme .md-menu.md-open>.md-button{background-color:\"{{ background-500-0.18}}\"}md-toolbar.md-THEME_NAME-theme.md-menu-toolbar{background-color:\"{{background-hue-1}}\";color:\"{{foreground-1}}\"}md-toolbar.md-THEME_NAME-theme.md-menu-toolbar md-toolbar-filler{background-color:\"{{primary-color}}\";color:\"{{primary-contrast}}\"}md-toolbar.md-THEME_NAME-theme.md-menu-toolbar md-toolbar-filler md-icon{color:\"{{primary-contrast}}\"}md-nav-bar.md-THEME_NAME-theme .md-nav-bar{background-color:transparent;border-color:\"{{foreground-4}}\"}md-nav-bar.md-THEME_NAME-theme .md-button._md-nav-button.md-unselected{color:\"{{foreground-2}}\"}md-nav-bar.md-THEME_NAME-theme .md-button._md-nav-button[disabled]{color:\"{{foreground-3}}\"}md-nav-bar.md-THEME_NAME-theme md-nav-ink-bar{color:\"{{accent-color}}\";background:\"{{accent-color}}\"}md-nav-bar.md-THEME_NAME-theme.md-accent>.md-nav-bar{background-color:\"{{accent-color}}\"}md-nav-bar.md-THEME_NAME-theme.md-accent>.md-nav-bar .md-button._md-nav-button{color:\"{{accent-A100}}\"}md-nav-bar.md-THEME_NAME-theme.md-accent>.md-nav-bar .md-button._md-nav-button.md-active,md-nav-bar.md-THEME_NAME-theme.md-accent>.md-nav-bar .md-button._md-nav-button.md-focused{color:\"{{accent-contrast}}\"}md-nav-bar.md-THEME_NAME-theme.md-accent>.md-nav-bar .md-button._md-nav-button.md-focused{background:\"{{accent-contrast-0.1}}\"}md-nav-bar.md-THEME_NAME-theme.md-accent>.md-nav-bar md-nav-ink-bar{color:\"{{primary-600-1}}\";background:\"{{primary-600-1}}\"}md-nav-bar.md-THEME_NAME-theme.md-warn>.md-nav-bar{background-color:\"{{warn-color}}\"}md-nav-bar.md-THEME_NAME-theme.md-warn>.md-nav-bar .md-button._md-nav-button{color:\"{{warn-100}}\"}md-nav-bar.md-THEME_NAME-theme.md-warn>.md-nav-bar .md-button._md-nav-button.md-active,md-nav-bar.md-THEME_NAME-theme.md-warn>.md-nav-bar .md-button._md-nav-button.md-focused{color:\"{{warn-contrast}}\"}md-nav-bar.md-THEME_NAME-theme.md-warn>.md-nav-bar .md-button._md-nav-button.md-focused{background:\"{{warn-contrast-0.1}}\"}md-nav-bar.md-THEME_NAME-theme.md-primary>.md-nav-bar{background-color:\"{{primary-color}}\"}md-nav-bar.md-THEME_NAME-theme.md-primary>.md-nav-bar .md-button._md-nav-button{color:\"{{primary-100}}\"}md-nav-bar.md-THEME_NAME-theme.md-primary>.md-nav-bar .md-button._md-nav-button.md-active,md-nav-bar.md-THEME_NAME-theme.md-primary>.md-nav-bar .md-button._md-nav-button.md-focused{color:\"{{primary-contrast}}\"}md-nav-bar.md-THEME_NAME-theme.md-primary>.md-nav-bar .md-button._md-nav-button.md-focused{background:\"{{primary-contrast-0.1}}\"}md-toolbar>md-nav-bar.md-THEME_NAME-theme>.md-nav-bar{background-color:\"{{primary-color}}\"}md-toolbar>md-nav-bar.md-THEME_NAME-theme>.md-nav-bar .md-button._md-nav-button{color:\"{{primary-100}}\"}md-toolbar>md-nav-bar.md-THEME_NAME-theme>.md-nav-bar .md-button._md-nav-button.md-active,md-toolbar>md-nav-bar.md-THEME_NAME-theme>.md-nav-bar .md-button._md-nav-button.md-focused{color:\"{{primary-contrast}}\"}md-toolbar>md-nav-bar.md-THEME_NAME-theme>.md-nav-bar .md-button._md-nav-button.md-focused{background:\"{{primary-contrast-0.1}}\"}md-toolbar.md-accent>md-nav-bar.md-THEME_NAME-theme>.md-nav-bar{background-color:\"{{accent-color}}\"}md-toolbar.md-accent>md-nav-bar.md-THEME_NAME-theme>.md-nav-bar .md-button._md-nav-button{color:\"{{accent-A100}}\"}md-toolbar.md-accent>md-nav-bar.md-THEME_NAME-theme>.md-nav-bar .md-button._md-nav-button.md-active,md-toolbar.md-accent>md-nav-bar.md-THEME_NAME-theme>.md-nav-bar .md-button._md-nav-button.md-focused{color:\"{{accent-contrast}}\"}md-toolbar.md-accent>md-nav-bar.md-THEME_NAME-theme>.md-nav-bar .md-button._md-nav-button.md-focused{background:\"{{accent-contrast-0.1}}\"}md-toolbar.md-accent>md-nav-bar.md-THEME_NAME-theme>.md-nav-bar md-nav-ink-bar{color:\"{{primary-600-1}}\";background:\"{{primary-600-1}}\"}md-toolbar.md-warn>md-nav-bar.md-THEME_NAME-theme>.md-nav-bar{background-color:\"{{warn-color}}\"}md-toolbar.md-warn>md-nav-bar.md-THEME_NAME-theme>.md-nav-bar .md-button._md-nav-button{color:\"{{warn-100}}\"}md-toolbar.md-warn>md-nav-bar.md-THEME_NAME-theme>.md-nav-bar .md-button._md-nav-button.md-active,md-toolbar.md-warn>md-nav-bar.md-THEME_NAME-theme>.md-nav-bar .md-button._md-nav-button.md-focused{color:\"{{warn-contrast}}\"}md-toolbar.md-warn>md-nav-bar.md-THEME_NAME-theme>.md-nav-bar .md-button._md-nav-button.md-focused{background:\"{{warn-contrast-0.1}}\"}._md-panel-backdrop.md-THEME_NAME-theme{background-color:\"{{background-900-1.0}}\"}md-progress-circular.md-THEME_NAME-theme path{stroke:\"{{primary-color}}\"}md-progress-circular.md-THEME_NAME-theme.md-warn path{stroke:\"{{warn-color}}\"}md-progress-circular.md-THEME_NAME-theme.md-accent path{stroke:\"{{accent-color}}\"}md-progress-linear.md-THEME_NAME-theme .md-container{background-color:\"{{primary-100}}\"}md-progress-linear.md-THEME_NAME-theme .md-bar{background-color:\"{{primary-color}}\"}md-progress-linear.md-THEME_NAME-theme.md-warn .md-container{background-color:\"{{warn-100}}\"}md-progress-linear.md-THEME_NAME-theme.md-warn .md-bar{background-color:\"{{warn-color}}\"}md-progress-linear.md-THEME_NAME-theme.md-accent .md-container{background-color:\"{{accent-100}}\"}md-progress-linear.md-THEME_NAME-theme.md-accent .md-bar{background-color:\"{{accent-color}}\"}md-progress-linear.md-THEME_NAME-theme[md-mode=buffer].md-primary .md-bar1{background-color:\"{{primary-100}}\"}md-progress-linear.md-THEME_NAME-theme[md-mode=buffer].md-primary .md-dashed:before{background:radial-gradient(\"{{primary-100}}\" 0,\"{{primary-100}}\" 16%,transparent 42%)}md-progress-linear.md-THEME_NAME-theme[md-mode=buffer].md-warn .md-bar1{background-color:\"{{warn-100}}\"}md-progress-linear.md-THEME_NAME-theme[md-mode=buffer].md-warn .md-dashed:before{background:radial-gradient(\"{{warn-100}}\" 0,\"{{warn-100}}\" 16%,transparent 42%)}md-progress-linear.md-THEME_NAME-theme[md-mode=buffer].md-accent .md-bar1{background-color:\"{{accent-100}}\"}md-progress-linear.md-THEME_NAME-theme[md-mode=buffer].md-accent .md-dashed:before{background:radial-gradient(\"{{accent-100}}\" 0,\"{{accent-100}}\" 16%,transparent 42%)}md-radio-button.md-THEME_NAME-theme .md-off{border-color:\"{{foreground-2}}\"}md-radio-button.md-THEME_NAME-theme .md-on{background-color:\"{{accent-color-0.87}}\"}md-radio-button.md-THEME_NAME-theme.md-checked .md-off{border-color:\"{{accent-color-0.87}}\"}md-radio-button.md-THEME_NAME-theme.md-checked .md-ink-ripple{color:\"{{accent-color-0.87}}\"}md-radio-button.md-THEME_NAME-theme .md-container .md-ripple{color:\"{{accent-A700}}\"}md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary .md-on,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary .md-on,md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary .md-on,md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary .md-on{background-color:\"{{primary-color-0.87}}\"}md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-off,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary.md-checked .md-off,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary .md-checked .md-off,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary .md-checked .md-off,md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-off,md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary.md-checked .md-off,md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary .md-checked .md-off,md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary .md-checked .md-off{border-color:\"{{primary-color-0.87}}\"}md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-ink-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary.md-checked .md-ink-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary .md-checked .md-ink-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary .md-checked .md-ink-ripple,md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-ink-ripple,md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary.md-checked .md-ink-ripple,md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary .md-checked .md-ink-ripple,md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary .md-checked .md-ink-ripple{color:\"{{primary-color-0.87}}\"}md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary .md-container .md-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary .md-container .md-ripple,md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary .md-container .md-ripple,md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary .md-container .md-ripple{color:\"{{primary-600}}\"}md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn .md-on,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn .md-on,md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn .md-on,md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn .md-on{background-color:\"{{warn-color-0.87}}\"}md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-off,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn.md-checked .md-off,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn .md-checked .md-off,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn .md-checked .md-off,md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-off,md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn.md-checked .md-off,md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn .md-checked .md-off,md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn .md-checked .md-off{border-color:\"{{warn-color-0.87}}\"}md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-ink-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn.md-checked .md-ink-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn .md-checked .md-ink-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn .md-checked .md-ink-ripple,md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-ink-ripple,md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn.md-checked .md-ink-ripple,md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn .md-checked .md-ink-ripple,md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn .md-checked .md-ink-ripple{color:\"{{warn-color-0.87}}\"}md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn .md-container .md-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn .md-container .md-ripple,md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn .md-container .md-ripple,md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn .md-container .md-ripple{color:\"{{warn-600}}\"}md-radio-button.md-THEME_NAME-theme[disabled],md-radio-group.md-THEME_NAME-theme[disabled]{color:\"{{foreground-3}}\"}md-radio-button.md-THEME_NAME-theme[disabled] .md-container .md-off,md-radio-button.md-THEME_NAME-theme[disabled] .md-container .md-on,md-radio-group.md-THEME_NAME-theme[disabled] .md-container .md-off,md-radio-group.md-THEME_NAME-theme[disabled] .md-container .md-on{border-color:\"{{foreground-3}}\"}md-radio-group.md-THEME_NAME-theme .md-checked .md-ink-ripple{color:\"{{accent-color-0.26}}\"}md-radio-group.md-THEME_NAME-theme .md-checked:not([disabled]).md-primary .md-ink-ripple,md-radio-group.md-THEME_NAME-theme.md-primary .md-checked:not([disabled]) .md-ink-ripple{color:\"{{primary-color-0.26}}\"}md-radio-group.md-THEME_NAME-theme.md-focused.ng-empty>md-radio-button:first-child .md-container:before{background-color:\"{{foreground-3-0.26}}\"}md-radio-group.md-THEME_NAME-theme.md-focused:not(:empty) .md-checked .md-container:before{background-color:\"{{accent-color-0.26}}\"}md-radio-group.md-THEME_NAME-theme.md-focused:not(:empty) .md-checked.md-primary .md-container:before,md-radio-group.md-THEME_NAME-theme.md-focused:not(:empty).md-primary .md-checked .md-container:before{background-color:\"{{primary-color-0.26}}\"}md-radio-group.md-THEME_NAME-theme.md-focused:not(:empty) .md-checked.md-warn .md-container:before,md-radio-group.md-THEME_NAME-theme.md-focused:not(:empty).md-warn .md-checked .md-container:before{background-color:\"{{warn-color-0.26}}\"}md-input-container md-select.md-THEME_NAME-theme .md-select-value span:first-child:after{color:\"{{warn-A700}}\"}md-input-container:not(.md-input-focused):not(.md-input-invalid) md-select.md-THEME_NAME-theme .md-select-value span:first-child:after{color:\"{{foreground-3}}\"}md-input-container.md-input-focused:not(.md-input-has-value) md-select.md-THEME_NAME-theme .md-select-value,md-input-container.md-input-focused:not(.md-input-has-value) md-select.md-THEME_NAME-theme .md-select-value.md-select-placeholder{color:\"{{primary-color}}\"}md-input-container.md-input-invalid md-select.md-THEME_NAME-theme .md-select-value{color:\"{{warn-A700}}\"!important;border-bottom-color:\"{{warn-A700}}\"!important}md-input-container.md-input-invalid md-select.md-THEME_NAME-theme.md-no-underline .md-select-value{border-bottom-color:transparent!important}md-input-container:not(.md-input-invalid).md-input-focused.md-accent .md-select-value{border-color:\"{{accent-color}}\"}md-input-container:not(.md-input-invalid).md-input-focused.md-accent .md-select-value span{color:\"{{accent-color}}\"}md-input-container:not(.md-input-invalid).md-input-focused.md-warn .md-select-value{border-color:\"{{warn-A700}}\"}md-input-container:not(.md-input-invalid).md-input-focused.md-warn .md-select-value span{color:\"{{warn-A700}}\"}md-select.md-THEME_NAME-theme[disabled] .md-select-value{border-bottom-color:transparent;background-image:linear-gradient(90deg,\"{{foreground-3}}\" 0,\"{{foreground-3}}\" 33%,transparent 0);background-image:-ms-linear-gradient(left,transparent 0,\"{{foreground-3}}\" 100%)}md-select.md-THEME_NAME-theme .md-select-value{border-bottom-color:\"{{foreground-4}}\"}md-select.md-THEME_NAME-theme .md-select-value.md-select-placeholder{color:\"{{foreground-3}}\"}md-select.md-THEME_NAME-theme .md-select-value span:first-child:after{color:\"{{warn-A700}}\"}md-select.md-THEME_NAME-theme.md-no-underline .md-select-value{border-bottom-color:transparent!important}md-select.md-THEME_NAME-theme.ng-invalid.ng-touched .md-select-value{color:\"{{warn-A700}}\"!important;border-bottom-color:\"{{warn-A700}}\"!important}md-select.md-THEME_NAME-theme.ng-invalid.ng-touched.md-no-underline .md-select-value{border-bottom-color:transparent!important}md-select.md-THEME_NAME-theme:not([disabled]):focus .md-select-value{border-bottom-color:\"{{primary-color}}\";color:\"{{ foreground-1 }}\"}md-select.md-THEME_NAME-theme:not([disabled]):focus .md-select-value.md-select-placeholder{color:\"{{ foreground-1 }}\"}md-select.md-THEME_NAME-theme:not([disabled]):focus.md-no-underline .md-select-value{border-bottom-color:transparent!important}md-select.md-THEME_NAME-theme:not([disabled]):focus.md-accent .md-select-value{border-bottom-color:\"{{accent-color}}\"}md-select.md-THEME_NAME-theme:not([disabled]):focus.md-warn .md-select-value{border-bottom-color:\"{{warn-color}}\"}md-select.md-THEME_NAME-theme[disabled] .md-select-icon,md-select.md-THEME_NAME-theme[disabled] .md-select-value,md-select.md-THEME_NAME-theme[disabled] .md-select-value.md-select-placeholder{color:\"{{foreground-3}}\"}md-select.md-THEME_NAME-theme .md-select-icon{color:\"{{foreground-2}}\"}md-select-menu.md-THEME_NAME-theme md-content{background-color:\"{{background-hue-1}}\"}md-select-menu.md-THEME_NAME-theme md-content md-optgroup{color:\"{{foreground-2}}\"}md-select-menu.md-THEME_NAME-theme md-content md-option{color:\"{{foreground-1}}\"}md-select-menu.md-THEME_NAME-theme md-content md-option[disabled] .md-text{color:\"{{foreground-3}}\"}md-select-menu.md-THEME_NAME-theme md-content md-option:not([disabled]):focus,md-select-menu.md-THEME_NAME-theme md-content md-option:not([disabled]):hover{background-color:\"{{background-500-0.18}}\"}md-select-menu.md-THEME_NAME-theme md-content md-option[selected]{color:\"{{primary-500}}\"}md-select-menu.md-THEME_NAME-theme md-content md-option[selected]:focus{color:\"{{primary-600}}\"}md-select-menu.md-THEME_NAME-theme md-content md-option[selected].md-accent{color:\"{{accent-color}}\"}md-select-menu.md-THEME_NAME-theme md-content md-option[selected].md-accent:focus{color:\"{{accent-A700}}\"}.md-checkbox-enabled.md-THEME_NAME-theme .md-ripple{color:\"{{primary-600}}\"}.md-checkbox-enabled.md-THEME_NAME-theme[selected] .md-ripple{color:\"{{background-600}}\"}.md-checkbox-enabled.md-THEME_NAME-theme .md-ink-ripple{color:\"{{foreground-2}}\"}.md-checkbox-enabled.md-THEME_NAME-theme[selected] .md-ink-ripple{color:\"{{primary-color-0.87}}\"}.md-checkbox-enabled.md-THEME_NAME-theme:not(.md-checked) .md-icon{border-color:\"{{foreground-2}}\"}.md-checkbox-enabled.md-THEME_NAME-theme[selected] .md-icon{background-color:\"{{primary-color-0.87}}\"}.md-checkbox-enabled.md-THEME_NAME-theme[selected].md-focused .md-container:before{background-color:\"{{primary-color-0.26}}\"}.md-checkbox-enabled.md-THEME_NAME-theme[selected] .md-icon:after{border-color:\"{{primary-contrast-0.87}}\"}.md-checkbox-enabled.md-THEME_NAME-theme .md-indeterminate[disabled] .md-container{color:\"{{foreground-3}}\"}.md-checkbox-enabled.md-THEME_NAME-theme md-option .md-text{color:\"{{foreground-1}}\"}md-sidenav.md-THEME_NAME-theme,md-sidenav.md-THEME_NAME-theme md-content{background-color:\"{{background-hue-1}}\"}md-slider.md-THEME_NAME-theme .md-track{background-color:\"{{foreground-3}}\"}md-slider.md-THEME_NAME-theme .md-track-ticks{color:\"{{background-contrast}}\"}md-slider.md-THEME_NAME-theme .md-focus-ring{background-color:\"{{accent-A200-0.2}}\"}md-slider.md-THEME_NAME-theme .md-disabled-thumb{border-color:\"{{background-color}}\";background-color:\"{{background-color}}\"}md-slider.md-THEME_NAME-theme.md-min .md-thumb:after{background-color:\"{{background-color}}\";border-color:\"{{foreground-3}}\"}md-slider.md-THEME_NAME-theme.md-min .md-focus-ring{background-color:\"{{foreground-3-0.38}}\"}md-slider.md-THEME_NAME-theme.md-min[md-discrete] .md-thumb:after{background-color:\"{{background-contrast}}\";border-color:transparent}md-slider.md-THEME_NAME-theme.md-min[md-discrete] .md-sign{background-color:\"{{background-400}}\"}md-slider.md-THEME_NAME-theme.md-min[md-discrete] .md-sign:after{border-top-color:\"{{background-400}}\"}md-slider.md-THEME_NAME-theme.md-min[md-discrete][md-vertical] .md-sign:after{border-top-color:transparent;border-left-color:\"{{background-400}}\"}md-slider.md-THEME_NAME-theme .md-track.md-track-fill{background-color:\"{{accent-color}}\"}md-slider.md-THEME_NAME-theme .md-thumb:after{border-color:\"{{accent-color}}\";background-color:\"{{accent-color}}\"}md-slider.md-THEME_NAME-theme .md-sign{background-color:\"{{accent-color}}\"}md-slider.md-THEME_NAME-theme .md-sign:after{border-top-color:\"{{accent-color}}\"}md-slider.md-THEME_NAME-theme[md-vertical] .md-sign:after{border-top-color:transparent;border-left-color:\"{{accent-color}}\"}md-slider.md-THEME_NAME-theme .md-thumb-text{color:\"{{accent-contrast}}\"}md-slider.md-THEME_NAME-theme.md-warn .md-focus-ring{background-color:\"{{warn-200-0.38}}\"}md-slider.md-THEME_NAME-theme.md-warn .md-track.md-track-fill{background-color:\"{{warn-color}}\"}md-slider.md-THEME_NAME-theme.md-warn .md-thumb:after{border-color:\"{{warn-color}}\";background-color:\"{{warn-color}}\"}md-slider.md-THEME_NAME-theme.md-warn .md-sign{background-color:\"{{warn-color}}\"}md-slider.md-THEME_NAME-theme.md-warn .md-sign:after{border-top-color:\"{{warn-color}}\"}md-slider.md-THEME_NAME-theme.md-warn[md-vertical] .md-sign:after{border-top-color:transparent;border-left-color:\"{{warn-color}}\"}md-slider.md-THEME_NAME-theme.md-warn .md-thumb-text{color:\"{{warn-contrast}}\"}md-slider.md-THEME_NAME-theme.md-primary .md-focus-ring{background-color:\"{{primary-200-0.38}}\"}md-slider.md-THEME_NAME-theme.md-primary .md-track.md-track-fill{background-color:\"{{primary-color}}\"}md-slider.md-THEME_NAME-theme.md-primary .md-thumb:after{border-color:\"{{primary-color}}\";background-color:\"{{primary-color}}\"}md-slider.md-THEME_NAME-theme.md-primary .md-sign{background-color:\"{{primary-color}}\"}md-slider.md-THEME_NAME-theme.md-primary .md-sign:after{border-top-color:\"{{primary-color}}\"}md-slider.md-THEME_NAME-theme.md-primary[md-vertical] .md-sign:after{border-top-color:transparent;border-left-color:\"{{primary-color}}\"}md-slider.md-THEME_NAME-theme.md-primary .md-thumb-text{color:\"{{primary-contrast}}\"}md-slider.md-THEME_NAME-theme[disabled] .md-thumb:after{border-color:transparent}md-slider.md-THEME_NAME-theme[disabled]:not(.md-min) .md-thumb:after,md-slider.md-THEME_NAME-theme[disabled][md-discrete] .md-thumb:after{background-color:\"{{foreground-3}}\";border-color:transparent}md-slider.md-THEME_NAME-theme[disabled][readonly] .md-sign{background-color:\"{{background-400}}\"}md-slider.md-THEME_NAME-theme[disabled][readonly] .md-sign:after{border-top-color:\"{{background-400}}\"}md-slider.md-THEME_NAME-theme[disabled][readonly][md-vertical] .md-sign:after{border-top-color:transparent;border-left-color:\"{{background-400}}\"}md-slider.md-THEME_NAME-theme[disabled][readonly] .md-disabled-thumb{border-color:transparent;background-color:transparent}md-slider-container[disabled]>:first-child:not(md-slider),md-slider-container[disabled]>:last-child:not(md-slider){color:\"{{foreground-3}}\"}.md-subheader.md-THEME_NAME-theme{color:\"{{ foreground-2-0.23 }}\";background-color:\"{{background-default}}\"}.md-subheader.md-THEME_NAME-theme.md-primary{color:\"{{primary-color}}\"}.md-subheader.md-THEME_NAME-theme.md-accent{color:\"{{accent-color}}\"}.md-subheader.md-THEME_NAME-theme.md-warn{color:\"{{warn-color}}\"}md-switch.md-THEME_NAME-theme .md-ink-ripple{color:\"{{background-500}}\"}md-switch.md-THEME_NAME-theme .md-thumb{background-color:\"{{background-50}}\"}md-switch.md-THEME_NAME-theme .md-bar{background-color:\"{{background-500}}\"}md-switch.md-THEME_NAME-theme.md-focused:not(.md-checked) .md-thumb:before,md-switch.md-THEME_NAME-theme.md-focused[disabled] .md-thumb:before{background-color:\"{{foreground-4}}\"}md-switch.md-THEME_NAME-theme.md-checked:not([disabled]) .md-ink-ripple{color:\"{{accent-color}}\"}md-switch.md-THEME_NAME-theme.md-checked:not([disabled]) .md-thumb{background-color:\"{{accent-color}}\"}md-switch.md-THEME_NAME-theme.md-checked:not([disabled]) .md-bar{background-color:\"{{accent-color-0.5}}\"}md-switch.md-THEME_NAME-theme.md-checked:not([disabled]).md-focused .md-thumb:before{background-color:\"{{accent-color-0.26}}\"}md-switch.md-THEME_NAME-theme.md-checked:not([disabled]).md-primary .md-ink-ripple{color:\"{{primary-color}}\"}md-switch.md-THEME_NAME-theme.md-checked:not([disabled]).md-primary .md-thumb{background-color:\"{{primary-color}}\"}md-switch.md-THEME_NAME-theme.md-checked:not([disabled]).md-primary .md-bar{background-color:\"{{primary-color-0.5}}\"}md-switch.md-THEME_NAME-theme.md-checked:not([disabled]).md-primary.md-focused .md-thumb:before{background-color:\"{{primary-color-0.26}}\"}md-switch.md-THEME_NAME-theme.md-checked:not([disabled]).md-warn .md-ink-ripple{color:\"{{warn-color}}\"}md-switch.md-THEME_NAME-theme.md-checked:not([disabled]).md-warn .md-thumb{background-color:\"{{warn-color}}\"}md-switch.md-THEME_NAME-theme.md-checked:not([disabled]).md-warn .md-bar{background-color:\"{{warn-color-0.5}}\"}md-switch.md-THEME_NAME-theme.md-checked:not([disabled]).md-warn.md-focused .md-thumb:before{background-color:\"{{warn-color-0.26}}\"}md-switch.md-THEME_NAME-theme[disabled] .md-thumb{background-color:\"{{background-400}}\"}md-switch.md-THEME_NAME-theme[disabled] .md-bar{background-color:\"{{foreground-4}}\"}md-tabs.md-THEME_NAME-theme md-tabs-wrapper{background-color:transparent;border-color:\"{{foreground-4}}\"}md-tabs.md-THEME_NAME-theme .md-paginator md-icon{color:\"{{primary-color}}\"}md-tabs.md-THEME_NAME-theme md-ink-bar{color:\"{{accent-color}}\";background:\"{{accent-color}}\"}md-tabs.md-THEME_NAME-theme .md-tab{color:\"{{foreground-2}}\"}md-tabs.md-THEME_NAME-theme .md-tab[disabled],md-tabs.md-THEME_NAME-theme .md-tab[disabled] md-icon{color:\"{{foreground-3}}\"}md-tabs.md-THEME_NAME-theme .md-tab.md-active,md-tabs.md-THEME_NAME-theme .md-tab.md-active md-icon,md-tabs.md-THEME_NAME-theme .md-tab.md-focused,md-tabs.md-THEME_NAME-theme .md-tab.md-focused md-icon{color:\"{{primary-color}}\"}md-tabs.md-THEME_NAME-theme .md-tab.md-focused{background:\"{{primary-color-0.1}}\"}md-tabs.md-THEME_NAME-theme .md-tab .md-ripple-container{color:\"{{accent-A100}}\"}md-tabs.md-THEME_NAME-theme.md-accent>md-tabs-wrapper{background-color:\"{{accent-color}}\"}md-tabs.md-THEME_NAME-theme.md-accent>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]),md-tabs.md-THEME_NAME-theme.md-accent>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]) md-icon{color:\"{{accent-A100}}\"}md-tabs.md-THEME_NAME-theme.md-accent>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-active,md-tabs.md-THEME_NAME-theme.md-accent>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-active md-icon,md-tabs.md-THEME_NAME-theme.md-accent>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-focused,md-tabs.md-THEME_NAME-theme.md-accent>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-focused md-icon{color:\"{{accent-contrast}}\"}md-tabs.md-THEME_NAME-theme.md-accent>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-focused{background:\"{{accent-contrast-0.1}}\"}md-tabs.md-THEME_NAME-theme.md-accent>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-ink-bar{color:\"{{primary-600-1}}\";background:\"{{primary-600-1}}\"}md-tabs.md-THEME_NAME-theme.md-primary>md-tabs-wrapper{background-color:\"{{primary-color}}\"}md-tabs.md-THEME_NAME-theme.md-primary>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]),md-tabs.md-THEME_NAME-theme.md-primary>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]) md-icon{color:\"{{primary-100}}\"}md-tabs.md-THEME_NAME-theme.md-primary>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-active,md-tabs.md-THEME_NAME-theme.md-primary>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-active md-icon,md-tabs.md-THEME_NAME-theme.md-primary>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-focused,md-tabs.md-THEME_NAME-theme.md-primary>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-focused md-icon{color:\"{{primary-contrast}}\"}md-tabs.md-THEME_NAME-theme.md-primary>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-focused{background:\"{{primary-contrast-0.1}}\"}md-tabs.md-THEME_NAME-theme.md-warn>md-tabs-wrapper{background-color:\"{{warn-color}}\"}md-tabs.md-THEME_NAME-theme.md-warn>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]),md-tabs.md-THEME_NAME-theme.md-warn>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]) md-icon{color:\"{{warn-100}}\"}md-tabs.md-THEME_NAME-theme.md-warn>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-active,md-tabs.md-THEME_NAME-theme.md-warn>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-active md-icon,md-tabs.md-THEME_NAME-theme.md-warn>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-focused,md-tabs.md-THEME_NAME-theme.md-warn>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-focused md-icon{color:\"{{warn-contrast}}\"}md-tabs.md-THEME_NAME-theme.md-warn>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-focused{background:\"{{warn-contrast-0.1}}\"}md-toolbar>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper{background-color:\"{{primary-color}}\"}md-toolbar>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]),md-toolbar>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]) md-icon{color:\"{{primary-100}}\"}md-toolbar>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-active,md-toolbar>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-active md-icon,md-toolbar>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-focused,md-toolbar>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-focused md-icon{color:\"{{primary-contrast}}\"}md-toolbar>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-focused{background:\"{{primary-contrast-0.1}}\"}md-toolbar.md-accent>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper{background-color:\"{{accent-color}}\"}md-toolbar.md-accent>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]),md-toolbar.md-accent>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]) md-icon{color:\"{{accent-A100}}\"}md-toolbar.md-accent>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-active,md-toolbar.md-accent>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-active md-icon,md-toolbar.md-accent>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-focused,md-toolbar.md-accent>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-focused md-icon{color:\"{{accent-contrast}}\"}md-toolbar.md-accent>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-focused{background:\"{{accent-contrast-0.1}}\"}md-toolbar.md-accent>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-ink-bar{color:\"{{primary-600-1}}\";background:\"{{primary-600-1}}\"}md-toolbar.md-warn>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper{background-color:\"{{warn-color}}\"}md-toolbar.md-warn>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]),md-toolbar.md-warn>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]) md-icon{color:\"{{warn-100}}\"}md-toolbar.md-warn>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-active,md-toolbar.md-warn>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-active md-icon,md-toolbar.md-warn>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-focused,md-toolbar.md-warn>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-focused md-icon{color:\"{{warn-contrast}}\"}md-toolbar.md-warn>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-focused{background:\"{{warn-contrast-0.1}}\"}md-toast.md-THEME_NAME-theme .md-toast-content{background-color:#323232;color:\"{{background-50}}\"}md-toast.md-THEME_NAME-theme .md-toast-content .md-button{color:\"{{background-50}}\"}md-toast.md-THEME_NAME-theme .md-toast-content .md-button.md-highlight{color:\"{{accent-color}}\"}md-toast.md-THEME_NAME-theme .md-toast-content .md-button.md-highlight.md-primary{color:\"{{primary-color}}\"}md-toast.md-THEME_NAME-theme .md-toast-content .md-button.md-highlight.md-warn{color:\"{{warn-color}}\"}md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar){background-color:\"{{primary-color}}\";color:\"{{primary-contrast}}\"}md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar) md-icon{color:\"{{primary-contrast}}\";fill:\"{{primary-contrast}}\"}md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar) .md-button[disabled] md-icon{color:\"{{primary-contrast-0.26}}\";fill:\"{{primary-contrast-0.26}}\"}md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar).md-accent{background-color:\"{{accent-color}}\";color:\"{{accent-contrast}}\"}md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar).md-accent .md-ink-ripple{color:\"{{accent-contrast}}\"}md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar).md-accent md-icon{color:\"{{accent-contrast}}\";fill:\"{{accent-contrast}}\"}md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar).md-accent .md-button[disabled] md-icon{color:\"{{accent-contrast-0.26}}\";fill:\"{{accent-contrast-0.26}}\"}md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar).md-warn{background-color:\"{{warn-color}}\";color:\"{{warn-contrast}}\"}.md-panel.md-tooltip.md-THEME_NAME-theme{color:\"{{background-700-contrast}}\";background-color:\"{{background-700}}\"}body.md-THEME_NAME-theme,html.md-THEME_NAME-theme{color:\"{{foreground-1}}\";background-color:\"{{background-color}}\"}"); 
})();


})(window, window.angular);;window.ngMaterial={version:{full: "1.1.19"}};;//! moment.js

;(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    global.moment = factory()
}(this, (function () { 'use strict';

    var hookCallback;

    function hooks () {
        return hookCallback.apply(null, arguments);
    }

    // This is done to register the method called with moment()
    // without creating circular dependencies.
    function setHookCallback (callback) {
        hookCallback = callback;
    }

    function isArray(input) {
        return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
    }

    function isObject(input) {
        // IE8 will treat undefined and null as object if it wasn't for
        // input != null
        return input != null && Object.prototype.toString.call(input) === '[object Object]';
    }

    function isObjectEmpty(obj) {
        if (Object.getOwnPropertyNames) {
            return (Object.getOwnPropertyNames(obj).length === 0);
        } else {
            var k;
            for (k in obj) {
                if (obj.hasOwnProperty(k)) {
                    return false;
                }
            }
            return true;
        }
    }

    function isUndefined(input) {
        return input === void 0;
    }

    function isNumber(input) {
        return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';
    }

    function isDate(input) {
        return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
    }

    function map(arr, fn) {
        var res = [], i;
        for (i = 0; i < arr.length; ++i) {
            res.push(fn(arr[i], i));
        }
        return res;
    }

    function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
    }

    function extend(a, b) {
        for (var i in b) {
            if (hasOwnProp(b, i)) {
                a[i] = b[i];
            }
        }

        if (hasOwnProp(b, 'toString')) {
            a.toString = b.toString;
        }

        if (hasOwnProp(b, 'valueOf')) {
            a.valueOf = b.valueOf;
        }

        return a;
    }

    function createUTC (input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, true).utc();
    }

    function defaultParsingFlags() {
        // We need to deep clone this object.
        return {
            empty           : false,
            unusedTokens    : [],
            unusedInput     : [],
            overflow        : -2,
            charsLeftOver   : 0,
            nullInput       : false,
            invalidMonth    : null,
            invalidFormat   : false,
            userInvalidated : false,
            iso             : false,
            parsedDateParts : [],
            meridiem        : null,
            rfc2822         : false,
            weekdayMismatch : false
        };
    }

    function getParsingFlags(m) {
        if (m._pf == null) {
            m._pf = defaultParsingFlags();
        }
        return m._pf;
    }

    var some;
    if (Array.prototype.some) {
        some = Array.prototype.some;
    } else {
        some = function (fun) {
            var t = Object(this);
            var len = t.length >>> 0;

            for (var i = 0; i < len; i++) {
                if (i in t && fun.call(this, t[i], i, t)) {
                    return true;
                }
            }

            return false;
        };
    }

    function isValid(m) {
        if (m._isValid == null) {
            var flags = getParsingFlags(m);
            var parsedParts = some.call(flags.parsedDateParts, function (i) {
                return i != null;
            });
            var isNowValid = !isNaN(m._d.getTime()) &&
                flags.overflow < 0 &&
                !flags.empty &&
                !flags.invalidMonth &&
                !flags.invalidWeekday &&
                !flags.weekdayMismatch &&
                !flags.nullInput &&
                !flags.invalidFormat &&
                !flags.userInvalidated &&
                (!flags.meridiem || (flags.meridiem && parsedParts));

            if (m._strict) {
                isNowValid = isNowValid &&
                    flags.charsLeftOver === 0 &&
                    flags.unusedTokens.length === 0 &&
                    flags.bigHour === undefined;
            }

            if (Object.isFrozen == null || !Object.isFrozen(m)) {
                m._isValid = isNowValid;
            }
            else {
                return isNowValid;
            }
        }
        return m._isValid;
    }

    function createInvalid (flags) {
        var m = createUTC(NaN);
        if (flags != null) {
            extend(getParsingFlags(m), flags);
        }
        else {
            getParsingFlags(m).userInvalidated = true;
        }

        return m;
    }

    // Plugins that add properties should also add the key here (null value),
    // so we can properly clone ourselves.
    var momentProperties = hooks.momentProperties = [];

    function copyConfig(to, from) {
        var i, prop, val;

        if (!isUndefined(from._isAMomentObject)) {
            to._isAMomentObject = from._isAMomentObject;
        }
        if (!isUndefined(from._i)) {
            to._i = from._i;
        }
        if (!isUndefined(from._f)) {
            to._f = from._f;
        }
        if (!isUndefined(from._l)) {
            to._l = from._l;
        }
        if (!isUndefined(from._strict)) {
            to._strict = from._strict;
        }
        if (!isUndefined(from._tzm)) {
            to._tzm = from._tzm;
        }
        if (!isUndefined(from._isUTC)) {
            to._isUTC = from._isUTC;
        }
        if (!isUndefined(from._offset)) {
            to._offset = from._offset;
        }
        if (!isUndefined(from._pf)) {
            to._pf = getParsingFlags(from);
        }
        if (!isUndefined(from._locale)) {
            to._locale = from._locale;
        }

        if (momentProperties.length > 0) {
            for (i = 0; i < momentProperties.length; i++) {
                prop = momentProperties[i];
                val = from[prop];
                if (!isUndefined(val)) {
                    to[prop] = val;
                }
            }
        }

        return to;
    }

    var updateInProgress = false;

    // Moment prototype object
    function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        if (!this.isValid()) {
            this._d = new Date(NaN);
        }
        // Prevent infinite loop in case updateOffset creates new moment
        // objects.
        if (updateInProgress === false) {
            updateInProgress = true;
            hooks.updateOffset(this);
            updateInProgress = false;
        }
    }

    function isMoment (obj) {
        return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
    }

    function absFloor (number) {
        if (number < 0) {
            // -0 -> 0
            return Math.ceil(number) || 0;
        } else {
            return Math.floor(number);
        }
    }

    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion,
            value = 0;

        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            value = absFloor(coercedNumber);
        }

        return value;
    }

    // compare two arrays, return the number of differences
    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;
        for (i = 0; i < len; i++) {
            if ((dontConvert && array1[i] !== array2[i]) ||
                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }

    function warn(msg) {
        if (hooks.suppressDeprecationWarnings === false &&
                (typeof console !==  'undefined') && console.warn) {
            console.warn('Deprecation warning: ' + msg);
        }
    }

    function deprecate(msg, fn) {
        var firstTime = true;

        return extend(function () {
            if (hooks.deprecationHandler != null) {
                hooks.deprecationHandler(null, msg);
            }
            if (firstTime) {
                var args = [];
                var arg;
                for (var i = 0; i < arguments.length; i++) {
                    arg = '';
                    if (typeof arguments[i] === 'object') {
                        arg += '\n[' + i + '] ';
                        for (var key in arguments[0]) {
                            arg += key + ': ' + arguments[0][key] + ', ';
                        }
                        arg = arg.slice(0, -2); // Remove trailing comma and space
                    } else {
                        arg = arguments[i];
                    }
                    args.push(arg);
                }
                warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + (new Error()).stack);
                firstTime = false;
            }
            return fn.apply(this, arguments);
        }, fn);
    }

    var deprecations = {};

    function deprecateSimple(name, msg) {
        if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(name, msg);
        }
        if (!deprecations[name]) {
            warn(msg);
            deprecations[name] = true;
        }
    }

    hooks.suppressDeprecationWarnings = false;
    hooks.deprecationHandler = null;

    function isFunction(input) {
        return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
    }

    function set (config) {
        var prop, i;
        for (i in config) {
            prop = config[i];
            if (isFunction(prop)) {
                this[i] = prop;
            } else {
                this['_' + i] = prop;
            }
        }
        this._config = config;
        // Lenient ordinal parsing accepts just a number in addition to
        // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
        // TODO: Remove "ordinalParse" fallback in next major release.
        this._dayOfMonthOrdinalParseLenient = new RegExp(
            (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +
                '|' + (/\d{1,2}/).source);
    }

    function mergeConfigs(parentConfig, childConfig) {
        var res = extend({}, parentConfig), prop;
        for (prop in childConfig) {
            if (hasOwnProp(childConfig, prop)) {
                if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                    res[prop] = {};
                    extend(res[prop], parentConfig[prop]);
                    extend(res[prop], childConfig[prop]);
                } else if (childConfig[prop] != null) {
                    res[prop] = childConfig[prop];
                } else {
                    delete res[prop];
                }
            }
        }
        for (prop in parentConfig) {
            if (hasOwnProp(parentConfig, prop) &&
                    !hasOwnProp(childConfig, prop) &&
                    isObject(parentConfig[prop])) {
                // make sure changes to properties don't modify parent config
                res[prop] = extend({}, res[prop]);
            }
        }
        return res;
    }

    function Locale(config) {
        if (config != null) {
            this.set(config);
        }
    }

    var keys;

    if (Object.keys) {
        keys = Object.keys;
    } else {
        keys = function (obj) {
            var i, res = [];
            for (i in obj) {
                if (hasOwnProp(obj, i)) {
                    res.push(i);
                }
            }
            return res;
        };
    }

    var defaultCalendar = {
        sameDay : '[Today at] LT',
        nextDay : '[Tomorrow at] LT',
        nextWeek : 'dddd [at] LT',
        lastDay : '[Yesterday at] LT',
        lastWeek : '[Last] dddd [at] LT',
        sameElse : 'L'
    };

    function calendar (key, mom, now) {
        var output = this._calendar[key] || this._calendar['sameElse'];
        return isFunction(output) ? output.call(mom, now) : output;
    }

    var defaultLongDateFormat = {
        LTS  : 'h:mm:ss A',
        LT   : 'h:mm A',
        L    : 'MM/DD/YYYY',
        LL   : 'MMMM D, YYYY',
        LLL  : 'MMMM D, YYYY h:mm A',
        LLLL : 'dddd, MMMM D, YYYY h:mm A'
    };

    function longDateFormat (key) {
        var format = this._longDateFormat[key],
            formatUpper = this._longDateFormat[key.toUpperCase()];

        if (format || !formatUpper) {
            return format;
        }

        this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
            return val.slice(1);
        });

        return this._longDateFormat[key];
    }

    var defaultInvalidDate = 'Invalid date';

    function invalidDate () {
        return this._invalidDate;
    }

    var defaultOrdinal = '%d';
    var defaultDayOfMonthOrdinalParse = /\d{1,2}/;

    function ordinal (number) {
        return this._ordinal.replace('%d', number);
    }

    var defaultRelativeTime = {
        future : 'in %s',
        past   : '%s ago',
        s  : 'a few seconds',
        ss : '%d seconds',
        m  : 'a minute',
        mm : '%d minutes',
        h  : 'an hour',
        hh : '%d hours',
        d  : 'a day',
        dd : '%d days',
        M  : 'a month',
        MM : '%d months',
        y  : 'a year',
        yy : '%d years'
    };

    function relativeTime (number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return (isFunction(output)) ?
            output(number, withoutSuffix, string, isFuture) :
            output.replace(/%d/i, number);
    }

    function pastFuture (diff, output) {
        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
        return isFunction(format) ? format(output) : format.replace(/%s/i, output);
    }

    var aliases = {};

    function addUnitAlias (unit, shorthand) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
    }

    function normalizeUnits(units) {
        return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
    }

    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {},
            normalizedProp,
            prop;

        for (prop in inputObject) {
            if (hasOwnProp(inputObject, prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }

        return normalizedInput;
    }

    var priorities = {};

    function addUnitPriority(unit, priority) {
        priorities[unit] = priority;
    }

    function getPrioritizedUnits(unitsObj) {
        var units = [];
        for (var u in unitsObj) {
            units.push({unit: u, priority: priorities[u]});
        }
        units.sort(function (a, b) {
            return a.priority - b.priority;
        });
        return units;
    }

    function zeroFill(number, targetLength, forceSign) {
        var absNumber = '' + Math.abs(number),
            zerosToFill = targetLength - absNumber.length,
            sign = number >= 0;
        return (sign ? (forceSign ? '+' : '') : '-') +
            Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
    }

    var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

    var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

    var formatFunctions = {};

    var formatTokenFunctions = {};

    // token:    'M'
    // padded:   ['MM', 2]
    // ordinal:  'Mo'
    // callback: function () { this.month() + 1 }
    function addFormatToken (token, padded, ordinal, callback) {
        var func = callback;
        if (typeof callback === 'string') {
            func = function () {
                return this[callback]();
            };
        }
        if (token) {
            formatTokenFunctions[token] = func;
        }
        if (padded) {
            formatTokenFunctions[padded[0]] = function () {
                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
            };
        }
        if (ordinal) {
            formatTokenFunctions[ordinal] = function () {
                return this.localeData().ordinal(func.apply(this, arguments), token);
            };
        }
    }

    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, '');
        }
        return input.replace(/\\/g, '');
    }

    function makeFormatFunction(format) {
        var array = format.match(formattingTokens), i, length;

        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }

        return function (mom) {
            var output = '', i;
            for (i = 0; i < length; i++) {
                output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];
            }
            return output;
        };
    }

    // format date using native date object
    function formatMoment(m, format) {
        if (!m.isValid()) {
            return m.localeData().invalidDate();
        }

        format = expandFormat(format, m.localeData());
        formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

        return formatFunctions[format](m);
    }

    function expandFormat(format, locale) {
        var i = 5;

        function replaceLongDateFormatTokens(input) {
            return locale.longDateFormat(input) || input;
        }

        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }

        return format;
    }

    var match1         = /\d/;            //       0 - 9
    var match2         = /\d\d/;          //      00 - 99
    var match3         = /\d{3}/;         //     000 - 999
    var match4         = /\d{4}/;         //    0000 - 9999
    var match6         = /[+-]?\d{6}/;    // -999999 - 999999
    var match1to2      = /\d\d?/;         //       0 - 99
    var match3to4      = /\d\d\d\d?/;     //     999 - 9999
    var match5to6      = /\d\d\d\d\d\d?/; //   99999 - 999999
    var match1to3      = /\d{1,3}/;       //       0 - 999
    var match1to4      = /\d{1,4}/;       //       0 - 9999
    var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999

    var matchUnsigned  = /\d+/;           //       0 - inf
    var matchSigned    = /[+-]?\d+/;      //    -inf - inf

    var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
    var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

    var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

    // any word (or two) characters or numbers including two/three word month in arabic.
    // includes scottish gaelic two word and hyphenated months
    var matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i;

    var regexes = {};

    function addRegexToken (token, regex, strictRegex) {
        regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
            return (isStrict && strictRegex) ? strictRegex : regex;
        };
    }

    function getParseRegexForToken (token, config) {
        if (!hasOwnProp(regexes, token)) {
            return new RegExp(unescapeFormat(token));
        }

        return regexes[token](config._strict, config._locale);
    }

    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
    function unescapeFormat(s) {
        return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
        }));
    }

    function regexEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }

    var tokens = {};

    function addParseToken (token, callback) {
        var i, func = callback;
        if (typeof token === 'string') {
            token = [token];
        }
        if (isNumber(callback)) {
            func = function (input, array) {
                array[callback] = toInt(input);
            };
        }
        for (i = 0; i < token.length; i++) {
            tokens[token[i]] = func;
        }
    }

    function addWeekParseToken (token, callback) {
        addParseToken(token, function (input, array, config, token) {
            config._w = config._w || {};
            callback(input, config._w, config, token);
        });
    }

    function addTimeToArrayFromToken(token, input, config) {
        if (input != null && hasOwnProp(tokens, token)) {
            tokens[token](input, config._a, config, token);
        }
    }

    var YEAR = 0;
    var MONTH = 1;
    var DATE = 2;
    var HOUR = 3;
    var MINUTE = 4;
    var SECOND = 5;
    var MILLISECOND = 6;
    var WEEK = 7;
    var WEEKDAY = 8;

    // FORMATTING

    addFormatToken('Y', 0, 0, function () {
        var y = this.year();
        return y <= 9999 ? '' + y : '+' + y;
    });

    addFormatToken(0, ['YY', 2], 0, function () {
        return this.year() % 100;
    });

    addFormatToken(0, ['YYYY',   4],       0, 'year');
    addFormatToken(0, ['YYYYY',  5],       0, 'year');
    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

    // ALIASES

    addUnitAlias('year', 'y');

    // PRIORITIES

    addUnitPriority('year', 1);

    // PARSING

    addRegexToken('Y',      matchSigned);
    addRegexToken('YY',     match1to2, match2);
    addRegexToken('YYYY',   match1to4, match4);
    addRegexToken('YYYYY',  match1to6, match6);
    addRegexToken('YYYYYY', match1to6, match6);

    addParseToken(['YYYYY', 'YYYYYY'], YEAR);
    addParseToken('YYYY', function (input, array) {
        array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
    });
    addParseToken('YY', function (input, array) {
        array[YEAR] = hooks.parseTwoDigitYear(input);
    });
    addParseToken('Y', function (input, array) {
        array[YEAR] = parseInt(input, 10);
    });

    // HELPERS

    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }

    function isLeapYear(year) {
        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
    }

    // HOOKS

    hooks.parseTwoDigitYear = function (input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
    };

    // MOMENTS

    var getSetYear = makeGetSet('FullYear', true);

    function getIsLeapYear () {
        return isLeapYear(this.year());
    }

    function makeGetSet (unit, keepTime) {
        return function (value) {
            if (value != null) {
                set$1(this, unit, value);
                hooks.updateOffset(this, keepTime);
                return this;
            } else {
                return get(this, unit);
            }
        };
    }

    function get (mom, unit) {
        return mom.isValid() ?
            mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
    }

    function set$1 (mom, unit, value) {
        if (mom.isValid() && !isNaN(value)) {
            if (unit === 'FullYear' && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value, mom.month(), daysInMonth(value, mom.month()));
            }
            else {
                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
            }
        }
    }

    // MOMENTS

    function stringGet (units) {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
            return this[units]();
        }
        return this;
    }


    function stringSet (units, value) {
        if (typeof units === 'object') {
            units = normalizeObjectUnits(units);
            var prioritized = getPrioritizedUnits(units);
            for (var i = 0; i < prioritized.length; i++) {
                this[prioritized[i].unit](units[prioritized[i].unit]);
            }
        } else {
            units = normalizeUnits(units);
            if (isFunction(this[units])) {
                return this[units](value);
            }
        }
        return this;
    }

    function mod(n, x) {
        return ((n % x) + x) % x;
    }

    var indexOf;

    if (Array.prototype.indexOf) {
        indexOf = Array.prototype.indexOf;
    } else {
        indexOf = function (o) {
            // I know
            var i;
            for (i = 0; i < this.length; ++i) {
                if (this[i] === o) {
                    return i;
                }
            }
            return -1;
        };
    }

    function daysInMonth(year, month) {
        if (isNaN(year) || isNaN(month)) {
            return NaN;
        }
        var modMonth = mod(month, 12);
        year += (month - modMonth) / 12;
        return modMonth === 1 ? (isLeapYear(year) ? 29 : 28) : (31 - modMonth % 7 % 2);
    }

    // FORMATTING

    addFormatToken('M', ['MM', 2], 'Mo', function () {
        return this.month() + 1;
    });

    addFormatToken('MMM', 0, 0, function (format) {
        return this.localeData().monthsShort(this, format);
    });

    addFormatToken('MMMM', 0, 0, function (format) {
        return this.localeData().months(this, format);
    });

    // ALIASES

    addUnitAlias('month', 'M');

    // PRIORITY

    addUnitPriority('month', 8);

    // PARSING

    addRegexToken('M',    match1to2);
    addRegexToken('MM',   match1to2, match2);
    addRegexToken('MMM',  function (isStrict, locale) {
        return locale.monthsShortRegex(isStrict);
    });
    addRegexToken('MMMM', function (isStrict, locale) {
        return locale.monthsRegex(isStrict);
    });

    addParseToken(['M', 'MM'], function (input, array) {
        array[MONTH] = toInt(input) - 1;
    });

    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
        var month = config._locale.monthsParse(input, token, config._strict);
        // if we didn't find a month name, mark the date as invalid.
        if (month != null) {
            array[MONTH] = month;
        } else {
            getParsingFlags(config).invalidMonth = input;
        }
    });

    // LOCALES

    var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
    var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
    function localeMonths (m, format) {
        if (!m) {
            return isArray(this._months) ? this._months :
                this._months['standalone'];
        }
        return isArray(this._months) ? this._months[m.month()] :
            this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
    }

    var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
    function localeMonthsShort (m, format) {
        if (!m) {
            return isArray(this._monthsShort) ? this._monthsShort :
                this._monthsShort['standalone'];
        }
        return isArray(this._monthsShort) ? this._monthsShort[m.month()] :
            this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
    }

    function handleStrictParse(monthName, format, strict) {
        var i, ii, mom, llc = monthName.toLocaleLowerCase();
        if (!this._monthsParse) {
            // this is not used
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
            for (i = 0; i < 12; ++i) {
                mom = createUTC([2000, i]);
                this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
                this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
            }
        }

        if (strict) {
            if (format === 'MMM') {
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === 'MMM') {
                ii = indexOf.call(this._shortMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }

    function localeMonthsParse (monthName, format, strict) {
        var i, mom, regex;

        if (this._monthsParseExact) {
            return handleStrictParse.call(this, monthName, format, strict);
        }

        if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
        }

        // TODO: add sorting
        // Sorting makes sure if one month (or abbr) is a prefix of another
        // see sorting in computeMonthsParse
        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, i]);
            if (strict && !this._longMonthsParse[i]) {
                this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
                this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
            }
            if (!strict && !this._monthsParse[i]) {
                regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
                return i;
            } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
                return i;
            } else if (!strict && this._monthsParse[i].test(monthName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function setMonth (mom, value) {
        var dayOfMonth;

        if (!mom.isValid()) {
            // No op
            return mom;
        }

        if (typeof value === 'string') {
            if (/^\d+$/.test(value)) {
                value = toInt(value);
            } else {
                value = mom.localeData().monthsParse(value);
                // TODO: Another silent failure?
                if (!isNumber(value)) {
                    return mom;
                }
            }
        }

        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
        return mom;
    }

    function getSetMonth (value) {
        if (value != null) {
            setMonth(this, value);
            hooks.updateOffset(this, true);
            return this;
        } else {
            return get(this, 'Month');
        }
    }

    function getDaysInMonth () {
        return daysInMonth(this.year(), this.month());
    }

    var defaultMonthsShortRegex = matchWord;
    function monthsShortRegex (isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsShortStrictRegex;
            } else {
                return this._monthsShortRegex;
            }
        } else {
            if (!hasOwnProp(this, '_monthsShortRegex')) {
                this._monthsShortRegex = defaultMonthsShortRegex;
            }
            return this._monthsShortStrictRegex && isStrict ?
                this._monthsShortStrictRegex : this._monthsShortRegex;
        }
    }

    var defaultMonthsRegex = matchWord;
    function monthsRegex (isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsStrictRegex;
            } else {
                return this._monthsRegex;
            }
        } else {
            if (!hasOwnProp(this, '_monthsRegex')) {
                this._monthsRegex = defaultMonthsRegex;
            }
            return this._monthsStrictRegex && isStrict ?
                this._monthsStrictRegex : this._monthsRegex;
        }
    }

    function computeMonthsParse () {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }

        var shortPieces = [], longPieces = [], mixedPieces = [],
            i, mom;
        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, i]);
            shortPieces.push(this.monthsShort(mom, ''));
            longPieces.push(this.months(mom, ''));
            mixedPieces.push(this.months(mom, ''));
            mixedPieces.push(this.monthsShort(mom, ''));
        }
        // Sorting makes sure if one month (or abbr) is a prefix of another it
        // will match the longer piece.
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 12; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
        }
        for (i = 0; i < 24; i++) {
            mixedPieces[i] = regexEscape(mixedPieces[i]);
        }

        this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._monthsShortRegex = this._monthsRegex;
        this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
        this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
    }

    function createDate (y, m, d, h, M, s, ms) {
        // can't just apply() to create a date:
        // https://stackoverflow.com/q/181348
        var date;
        // the date constructor remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
            // preserve leap years using a full 400 year cycle, then reset
            date = new Date(y + 400, m, d, h, M, s, ms);
            if (isFinite(date.getFullYear())) {
                date.setFullYear(y);
            }
        } else {
            date = new Date(y, m, d, h, M, s, ms);
        }

        return date;
    }

    function createUTCDate (y) {
        var date;
        // the Date.UTC function remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
            var args = Array.prototype.slice.call(arguments);
            // preserve leap years using a full 400 year cycle, then reset
            args[0] = y + 400;
            date = new Date(Date.UTC.apply(null, args));
            if (isFinite(date.getUTCFullYear())) {
                date.setUTCFullYear(y);
            }
        } else {
            date = new Date(Date.UTC.apply(null, arguments));
        }

        return date;
    }

    // start-of-first-week - start-of-year
    function firstWeekOffset(year, dow, doy) {
        var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
            fwd = 7 + dow - doy,
            // first-week day local weekday -- which local weekday is fwd
            fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

        return -fwdlw + fwd - 1;
    }

    // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
        var localWeekday = (7 + weekday - dow) % 7,
            weekOffset = firstWeekOffset(year, dow, doy),
            dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
            resYear, resDayOfYear;

        if (dayOfYear <= 0) {
            resYear = year - 1;
            resDayOfYear = daysInYear(resYear) + dayOfYear;
        } else if (dayOfYear > daysInYear(year)) {
            resYear = year + 1;
            resDayOfYear = dayOfYear - daysInYear(year);
        } else {
            resYear = year;
            resDayOfYear = dayOfYear;
        }

        return {
            year: resYear,
            dayOfYear: resDayOfYear
        };
    }

    function weekOfYear(mom, dow, doy) {
        var weekOffset = firstWeekOffset(mom.year(), dow, doy),
            week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
            resWeek, resYear;

        if (week < 1) {
            resYear = mom.year() - 1;
            resWeek = week + weeksInYear(resYear, dow, doy);
        } else if (week > weeksInYear(mom.year(), dow, doy)) {
            resWeek = week - weeksInYear(mom.year(), dow, doy);
            resYear = mom.year() + 1;
        } else {
            resYear = mom.year();
            resWeek = week;
        }

        return {
            week: resWeek,
            year: resYear
        };
    }

    function weeksInYear(year, dow, doy) {
        var weekOffset = firstWeekOffset(year, dow, doy),
            weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
    }

    // FORMATTING

    addFormatToken('w', ['ww', 2], 'wo', 'week');
    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

    // ALIASES

    addUnitAlias('week', 'w');
    addUnitAlias('isoWeek', 'W');

    // PRIORITIES

    addUnitPriority('week', 5);
    addUnitPriority('isoWeek', 5);

    // PARSING

    addRegexToken('w',  match1to2);
    addRegexToken('ww', match1to2, match2);
    addRegexToken('W',  match1to2);
    addRegexToken('WW', match1to2, match2);

    addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
        week[token.substr(0, 1)] = toInt(input);
    });

    // HELPERS

    // LOCALES

    function localeWeek (mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }

    var defaultLocaleWeek = {
        dow : 0, // Sunday is the first day of the week.
        doy : 6  // The week that contains Jan 6th is the first week of the year.
    };

    function localeFirstDayOfWeek () {
        return this._week.dow;
    }

    function localeFirstDayOfYear () {
        return this._week.doy;
    }

    // MOMENTS

    function getSetWeek (input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    function getSetISOWeek (input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    // FORMATTING

    addFormatToken('d', 0, 'do', 'day');

    addFormatToken('dd', 0, 0, function (format) {
        return this.localeData().weekdaysMin(this, format);
    });

    addFormatToken('ddd', 0, 0, function (format) {
        return this.localeData().weekdaysShort(this, format);
    });

    addFormatToken('dddd', 0, 0, function (format) {
        return this.localeData().weekdays(this, format);
    });

    addFormatToken('e', 0, 0, 'weekday');
    addFormatToken('E', 0, 0, 'isoWeekday');

    // ALIASES

    addUnitAlias('day', 'd');
    addUnitAlias('weekday', 'e');
    addUnitAlias('isoWeekday', 'E');

    // PRIORITY
    addUnitPriority('day', 11);
    addUnitPriority('weekday', 11);
    addUnitPriority('isoWeekday', 11);

    // PARSING

    addRegexToken('d',    match1to2);
    addRegexToken('e',    match1to2);
    addRegexToken('E',    match1to2);
    addRegexToken('dd',   function (isStrict, locale) {
        return locale.weekdaysMinRegex(isStrict);
    });
    addRegexToken('ddd',   function (isStrict, locale) {
        return locale.weekdaysShortRegex(isStrict);
    });
    addRegexToken('dddd',   function (isStrict, locale) {
        return locale.weekdaysRegex(isStrict);
    });

    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
        var weekday = config._locale.weekdaysParse(input, token, config._strict);
        // if we didn't get a weekday name, mark the date as invalid
        if (weekday != null) {
            week.d = weekday;
        } else {
            getParsingFlags(config).invalidWeekday = input;
        }
    });

    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
        week[token] = toInt(input);
    });

    // HELPERS

    function parseWeekday(input, locale) {
        if (typeof input !== 'string') {
            return input;
        }

        if (!isNaN(input)) {
            return parseInt(input, 10);
        }

        input = locale.weekdaysParse(input);
        if (typeof input === 'number') {
            return input;
        }

        return null;
    }

    function parseIsoWeekday(input, locale) {
        if (typeof input === 'string') {
            return locale.weekdaysParse(input) % 7 || 7;
        }
        return isNaN(input) ? null : input;
    }

    // LOCALES
    function shiftWeekdays (ws, n) {
        return ws.slice(n, 7).concat(ws.slice(0, n));
    }

    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
    function localeWeekdays (m, format) {
        var weekdays = isArray(this._weekdays) ? this._weekdays :
            this._weekdays[(m && m !== true && this._weekdays.isFormat.test(format)) ? 'format' : 'standalone'];
        return (m === true) ? shiftWeekdays(weekdays, this._week.dow)
            : (m) ? weekdays[m.day()] : weekdays;
    }

    var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
    function localeWeekdaysShort (m) {
        return (m === true) ? shiftWeekdays(this._weekdaysShort, this._week.dow)
            : (m) ? this._weekdaysShort[m.day()] : this._weekdaysShort;
    }

    var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
    function localeWeekdaysMin (m) {
        return (m === true) ? shiftWeekdays(this._weekdaysMin, this._week.dow)
            : (m) ? this._weekdaysMin[m.day()] : this._weekdaysMin;
    }

    function handleStrictParse$1(weekdayName, format, strict) {
        var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._minWeekdaysParse = [];

            for (i = 0; i < 7; ++i) {
                mom = createUTC([2000, 1]).day(i);
                this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
                this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
                this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
            }
        }

        if (strict) {
            if (format === 'dddd') {
                ii = indexOf.call(this._weekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === 'dddd') {
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }

    function localeWeekdaysParse (weekdayName, format, strict) {
        var i, mom, regex;

        if (this._weekdaysParseExact) {
            return handleStrictParse$1.call(this, weekdayName, format, strict);
        }

        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._minWeekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._fullWeekdaysParse = [];
        }

        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already

            mom = createUTC([2000, 1]).day(i);
            if (strict && !this._fullWeekdaysParse[i]) {
                this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\\.?') + '$', 'i');
                this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\\.?') + '$', 'i');
                this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\\.?') + '$', 'i');
            }
            if (!this._weekdaysParse[i]) {
                regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function getSetDayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        if (input != null) {
            input = parseWeekday(input, this.localeData());
            return this.add(input - day, 'd');
        } else {
            return day;
        }
    }

    function getSetLocaleDayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, 'd');
    }

    function getSetISODayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }

        // behaves the same as moment#day except
        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
        // as a setter, sunday should belong to the previous week.

        if (input != null) {
            var weekday = parseIsoWeekday(input, this.localeData());
            return this.day(this.day() % 7 ? weekday : weekday - 7);
        } else {
            return this.day() || 7;
        }
    }

    var defaultWeekdaysRegex = matchWord;
    function weekdaysRegex (isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysStrictRegex;
            } else {
                return this._weekdaysRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                this._weekdaysRegex = defaultWeekdaysRegex;
            }
            return this._weekdaysStrictRegex && isStrict ?
                this._weekdaysStrictRegex : this._weekdaysRegex;
        }
    }

    var defaultWeekdaysShortRegex = matchWord;
    function weekdaysShortRegex (isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysShortStrictRegex;
            } else {
                return this._weekdaysShortRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysShortRegex')) {
                this._weekdaysShortRegex = defaultWeekdaysShortRegex;
            }
            return this._weekdaysShortStrictRegex && isStrict ?
                this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
        }
    }

    var defaultWeekdaysMinRegex = matchWord;
    function weekdaysMinRegex (isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysMinStrictRegex;
            } else {
                return this._weekdaysMinRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysMinRegex')) {
                this._weekdaysMinRegex = defaultWeekdaysMinRegex;
            }
            return this._weekdaysMinStrictRegex && isStrict ?
                this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
        }
    }


    function computeWeekdaysParse () {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }

        var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],
            i, mom, minp, shortp, longp;
        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, 1]).day(i);
            minp = this.weekdaysMin(mom, '');
            shortp = this.weekdaysShort(mom, '');
            longp = this.weekdays(mom, '');
            minPieces.push(minp);
            shortPieces.push(shortp);
            longPieces.push(longp);
            mixedPieces.push(minp);
            mixedPieces.push(shortp);
            mixedPieces.push(longp);
        }
        // Sorting makes sure if one weekday (or abbr) is a prefix of another it
        // will match the longer piece.
        minPieces.sort(cmpLenRev);
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 7; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
            mixedPieces[i] = regexEscape(mixedPieces[i]);
        }

        this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._weekdaysShortRegex = this._weekdaysRegex;
        this._weekdaysMinRegex = this._weekdaysRegex;

        this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
        this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
        this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
    }

    // FORMATTING

    function hFormat() {
        return this.hours() % 12 || 12;
    }

    function kFormat() {
        return this.hours() || 24;
    }

    addFormatToken('H', ['HH', 2], 0, 'hour');
    addFormatToken('h', ['hh', 2], 0, hFormat);
    addFormatToken('k', ['kk', 2], 0, kFormat);

    addFormatToken('hmm', 0, 0, function () {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
    });

    addFormatToken('hmmss', 0, 0, function () {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +
            zeroFill(this.seconds(), 2);
    });

    addFormatToken('Hmm', 0, 0, function () {
        return '' + this.hours() + zeroFill(this.minutes(), 2);
    });

    addFormatToken('Hmmss', 0, 0, function () {
        return '' + this.hours() + zeroFill(this.minutes(), 2) +
            zeroFill(this.seconds(), 2);
    });

    function meridiem (token, lowercase) {
        addFormatToken(token, 0, 0, function () {
            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
        });
    }

    meridiem('a', true);
    meridiem('A', false);

    // ALIASES

    addUnitAlias('hour', 'h');

    // PRIORITY
    addUnitPriority('hour', 13);

    // PARSING

    function matchMeridiem (isStrict, locale) {
        return locale._meridiemParse;
    }

    addRegexToken('a',  matchMeridiem);
    addRegexToken('A',  matchMeridiem);
    addRegexToken('H',  match1to2);
    addRegexToken('h',  match1to2);
    addRegexToken('k',  match1to2);
    addRegexToken('HH', match1to2, match2);
    addRegexToken('hh', match1to2, match2);
    addRegexToken('kk', match1to2, match2);

    addRegexToken('hmm', match3to4);
    addRegexToken('hmmss', match5to6);
    addRegexToken('Hmm', match3to4);
    addRegexToken('Hmmss', match5to6);

    addParseToken(['H', 'HH'], HOUR);
    addParseToken(['k', 'kk'], function (input, array, config) {
        var kInput = toInt(input);
        array[HOUR] = kInput === 24 ? 0 : kInput;
    });
    addParseToken(['a', 'A'], function (input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
    });
    addParseToken(['h', 'hh'], function (input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmmss', function (input, array, config) {
        var pos1 = input.length - 4;
        var pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('Hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
    });
    addParseToken('Hmmss', function (input, array, config) {
        var pos1 = input.length - 4;
        var pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
    });

    // LOCALES

    function localeIsPM (input) {
        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
        // Using charAt should be more compatible.
        return ((input + '').toLowerCase().charAt(0) === 'p');
    }

    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
    function localeMeridiem (hours, minutes, isLower) {
        if (hours > 11) {
            return isLower ? 'pm' : 'PM';
        } else {
            return isLower ? 'am' : 'AM';
        }
    }


    // MOMENTS

    // Setting the hour should keep the time, because the user explicitly
    // specified which hour they want. So trying to maintain the same hour (in
    // a new timezone) makes sense. Adding/subtracting hours does not follow
    // this rule.
    var getSetHour = makeGetSet('Hours', true);

    var baseConfig = {
        calendar: defaultCalendar,
        longDateFormat: defaultLongDateFormat,
        invalidDate: defaultInvalidDate,
        ordinal: defaultOrdinal,
        dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
        relativeTime: defaultRelativeTime,

        months: defaultLocaleMonths,
        monthsShort: defaultLocaleMonthsShort,

        week: defaultLocaleWeek,

        weekdays: defaultLocaleWeekdays,
        weekdaysMin: defaultLocaleWeekdaysMin,
        weekdaysShort: defaultLocaleWeekdaysShort,

        meridiemParse: defaultLocaleMeridiemParse
    };

    // internal storage for locale config files
    var locales = {};
    var localeFamilies = {};
    var globalLocale;

    function normalizeLocale(key) {
        return key ? key.toLowerCase().replace('_', '-') : key;
    }

    // pick the locale from the array
    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
    function chooseLocale(names) {
        var i = 0, j, next, locale, split;

        while (i < names.length) {
            split = normalizeLocale(names[i]).split('-');
            j = split.length;
            next = normalizeLocale(names[i + 1]);
            next = next ? next.split('-') : null;
            while (j > 0) {
                locale = loadLocale(split.slice(0, j).join('-'));
                if (locale) {
                    return locale;
                }
                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                    //the next array item is better than a shallower substring of this one
                    break;
                }
                j--;
            }
            i++;
        }
        return globalLocale;
    }

    function loadLocale(name) {
        var oldLocale = null;
        // TODO: Find a better way to register and load all the locales in Node
        if (!locales[name] && (typeof module !== 'undefined') &&
                module && module.exports) {
            try {
                oldLocale = globalLocale._abbr;
                var aliasedRequire = require;
                aliasedRequire('./locale/' + name);
                getSetGlobalLocale(oldLocale);
            } catch (e) {}
        }
        return locales[name];
    }

    // This function will load locale and then set the global locale.  If
    // no arguments are passed in, it will simply return the current global
    // locale key.
    function getSetGlobalLocale (key, values) {
        var data;
        if (key) {
            if (isUndefined(values)) {
                data = getLocale(key);
            }
            else {
                data = defineLocale(key, values);
            }

            if (data) {
                // moment.duration._locale = moment._locale = data;
                globalLocale = data;
            }
            else {
                if ((typeof console !==  'undefined') && console.warn) {
                    //warn user if arguments are passed but the locale could not be set
                    console.warn('Locale ' + key +  ' not found. Did you forget to load it?');
                }
            }
        }

        return globalLocale._abbr;
    }

    function defineLocale (name, config) {
        if (config !== null) {
            var locale, parentConfig = baseConfig;
            config.abbr = name;
            if (locales[name] != null) {
                deprecateSimple('defineLocaleOverride',
                        'use moment.updateLocale(localeName, config) to change ' +
                        'an existing locale. moment.defineLocale(localeName, ' +
                        'config) should only be used for creating a new locale ' +
                        'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
                parentConfig = locales[name]._config;
            } else if (config.parentLocale != null) {
                if (locales[config.parentLocale] != null) {
                    parentConfig = locales[config.parentLocale]._config;
                } else {
                    locale = loadLocale(config.parentLocale);
                    if (locale != null) {
                        parentConfig = locale._config;
                    } else {
                        if (!localeFamilies[config.parentLocale]) {
                            localeFamilies[config.parentLocale] = [];
                        }
                        localeFamilies[config.parentLocale].push({
                            name: name,
                            config: config
                        });
                        return null;
                    }
                }
            }
            locales[name] = new Locale(mergeConfigs(parentConfig, config));

            if (localeFamilies[name]) {
                localeFamilies[name].forEach(function (x) {
                    defineLocale(x.name, x.config);
                });
            }

            // backwards compat for now: also set the locale
            // make sure we set the locale AFTER all child locales have been
            // created, so we won't end up with the child locale set.
            getSetGlobalLocale(name);


            return locales[name];
        } else {
            // useful for testing
            delete locales[name];
            return null;
        }
    }

    function updateLocale(name, config) {
        if (config != null) {
            var locale, tmpLocale, parentConfig = baseConfig;
            // MERGE
            tmpLocale = loadLocale(name);
            if (tmpLocale != null) {
                parentConfig = tmpLocale._config;
            }
            config = mergeConfigs(parentConfig, config);
            locale = new Locale(config);
            locale.parentLocale = locales[name];
            locales[name] = locale;

            // backwards compat for now: also set the locale
            getSetGlobalLocale(name);
        } else {
            // pass null for config to unupdate, useful for tests
            if (locales[name] != null) {
                if (locales[name].parentLocale != null) {
                    locales[name] = locales[name].parentLocale;
                } else if (locales[name] != null) {
                    delete locales[name];
                }
            }
        }
        return locales[name];
    }

    // returns locale data
    function getLocale (key) {
        var locale;

        if (key && key._locale && key._locale._abbr) {
            key = key._locale._abbr;
        }

        if (!key) {
            return globalLocale;
        }

        if (!isArray(key)) {
            //short-circuit everything else
            locale = loadLocale(key);
            if (locale) {
                return locale;
            }
            key = [key];
        }

        return chooseLocale(key);
    }

    function listLocales() {
        return keys(locales);
    }

    function checkOverflow (m) {
        var overflow;
        var a = m._a;

        if (a && getParsingFlags(m).overflow === -2) {
            overflow =
                a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :
                a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
                a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
                a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :
                a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :
                a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
                -1;

            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                overflow = DATE;
            }
            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
                overflow = WEEK;
            }
            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
                overflow = WEEKDAY;
            }

            getParsingFlags(m).overflow = overflow;
        }

        return m;
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function currentDateArray(config) {
        // hooks is actually the exported moment object
        var nowValue = new Date(hooks.now());
        if (config._useUTC) {
            return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
        }
        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
    }

    // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]
    function configFromArray (config) {
        var i, date, input = [], currentDate, expectedWeekday, yearToUse;

        if (config._d) {
            return;
        }

        currentDate = currentDateArray(config);

        //compute day of the year from weeks and weekdays
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
        }

        //if the day of the year is set, figure out what it is
        if (config._dayOfYear != null) {
            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

            if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
                getParsingFlags(config)._overflowDayOfYear = true;
            }

            date = createUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }

        // Default to current date.
        // * if no year, month, day of month are given, default to today
        // * if day of month is given, default month and year
        // * if month is given, default only year
        // * if year is given, don't default anything
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }

        // Zero out whatever was not defaulted, including time
        for (; i < 7; i++) {
            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
        }

        // Check for 24:00:00.000
        if (config._a[HOUR] === 24 &&
                config._a[MINUTE] === 0 &&
                config._a[SECOND] === 0 &&
                config._a[MILLISECOND] === 0) {
            config._nextDay = true;
            config._a[HOUR] = 0;
        }

        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
        expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();

        // Apply timezone offset from input. The actual utcOffset can be changed
        // with parseZone.
        if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }

        if (config._nextDay) {
            config._a[HOUR] = 24;
        }

        // check for mismatching day of week
        if (config._w && typeof config._w.d !== 'undefined' && config._w.d !== expectedWeekday) {
            getParsingFlags(config).weekdayMismatch = true;
        }
    }

    function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;

        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;

            // TODO: We need to take the current isoWeekYear, but that depends on
            // how we interpret now (local, utc, fixed offset). So create
            // a now version of current config (take local/utc/offset flags, and
            // create now).
            weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
            week = defaults(w.W, 1);
            weekday = defaults(w.E, 1);
            if (weekday < 1 || weekday > 7) {
                weekdayOverflow = true;
            }
        } else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;

            var curWeek = weekOfYear(createLocal(), dow, doy);

            weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

            // Default to current week.
            week = defaults(w.w, curWeek.week);

            if (w.d != null) {
                // weekday -- low day numbers are considered next week
                weekday = w.d;
                if (weekday < 0 || weekday > 6) {
                    weekdayOverflow = true;
                }
            } else if (w.e != null) {
                // local weekday -- counting starts from beginning of week
                weekday = w.e + dow;
                if (w.e < 0 || w.e > 6) {
                    weekdayOverflow = true;
                }
            } else {
                // default to beginning of week
                weekday = dow;
            }
        }
        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
            getParsingFlags(config)._overflowWeeks = true;
        } else if (weekdayOverflow != null) {
            getParsingFlags(config)._overflowWeekday = true;
        } else {
            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
            config._a[YEAR] = temp.year;
            config._dayOfYear = temp.dayOfYear;
        }
    }

    // iso 8601 regex
    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
    var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
    var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;

    var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;

    var isoDates = [
        ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
        ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
        ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
        ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
        ['YYYY-DDD', /\d{4}-\d{3}/],
        ['YYYY-MM', /\d{4}-\d\d/, false],
        ['YYYYYYMMDD', /[+-]\d{10}/],
        ['YYYYMMDD', /\d{8}/],
        // YYYYMM is NOT allowed by the standard
        ['GGGG[W]WWE', /\d{4}W\d{3}/],
        ['GGGG[W]WW', /\d{4}W\d{2}/, false],
        ['YYYYDDD', /\d{7}/]
    ];

    // iso time formats and regexes
    var isoTimes = [
        ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
        ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
        ['HH:mm:ss', /\d\d:\d\d:\d\d/],
        ['HH:mm', /\d\d:\d\d/],
        ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
        ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
        ['HHmmss', /\d\d\d\d\d\d/],
        ['HHmm', /\d\d\d\d/],
        ['HH', /\d\d/]
    ];

    var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

    // date from iso format
    function configFromISO(config) {
        var i, l,
            string = config._i,
            match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
            allowTime, dateFormat, timeFormat, tzFormat;

        if (match) {
            getParsingFlags(config).iso = true;

            for (i = 0, l = isoDates.length; i < l; i++) {
                if (isoDates[i][1].exec(match[1])) {
                    dateFormat = isoDates[i][0];
                    allowTime = isoDates[i][2] !== false;
                    break;
                }
            }
            if (dateFormat == null) {
                config._isValid = false;
                return;
            }
            if (match[3]) {
                for (i = 0, l = isoTimes.length; i < l; i++) {
                    if (isoTimes[i][1].exec(match[3])) {
                        // match[2] should be 'T' or space
                        timeFormat = (match[2] || ' ') + isoTimes[i][0];
                        break;
                    }
                }
                if (timeFormat == null) {
                    config._isValid = false;
                    return;
                }
            }
            if (!allowTime && timeFormat != null) {
                config._isValid = false;
                return;
            }
            if (match[4]) {
                if (tzRegex.exec(match[4])) {
                    tzFormat = 'Z';
                } else {
                    config._isValid = false;
                    return;
                }
            }
            config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
            configFromStringAndFormat(config);
        } else {
            config._isValid = false;
        }
    }

    // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
    var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;

    function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
        var result = [
            untruncateYear(yearStr),
            defaultLocaleMonthsShort.indexOf(monthStr),
            parseInt(dayStr, 10),
            parseInt(hourStr, 10),
            parseInt(minuteStr, 10)
        ];

        if (secondStr) {
            result.push(parseInt(secondStr, 10));
        }

        return result;
    }

    function untruncateYear(yearStr) {
        var year = parseInt(yearStr, 10);
        if (year <= 49) {
            return 2000 + year;
        } else if (year <= 999) {
            return 1900 + year;
        }
        return year;
    }

    function preprocessRFC2822(s) {
        // Remove comments and folding whitespace and replace multiple-spaces with a single space
        return s.replace(/\([^)]*\)|[\n\t]/g, ' ').replace(/(\s\s+)/g, ' ').replace(/^\s\s*/, '').replace(/\s\s*$/, '');
    }

    function checkWeekday(weekdayStr, parsedInput, config) {
        if (weekdayStr) {
            // TODO: Replace the vanilla JS Date object with an indepentent day-of-week check.
            var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
                weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();
            if (weekdayProvided !== weekdayActual) {
                getParsingFlags(config).weekdayMismatch = true;
                config._isValid = false;
                return false;
            }
        }
        return true;
    }

    var obsOffsets = {
        UT: 0,
        GMT: 0,
        EDT: -4 * 60,
        EST: -5 * 60,
        CDT: -5 * 60,
        CST: -6 * 60,
        MDT: -6 * 60,
        MST: -7 * 60,
        PDT: -7 * 60,
        PST: -8 * 60
    };

    function calculateOffset(obsOffset, militaryOffset, numOffset) {
        if (obsOffset) {
            return obsOffsets[obsOffset];
        } else if (militaryOffset) {
            // the only allowed military tz is Z
            return 0;
        } else {
            var hm = parseInt(numOffset, 10);
            var m = hm % 100, h = (hm - m) / 100;
            return h * 60 + m;
        }
    }

    // date and time from ref 2822 format
    function configFromRFC2822(config) {
        var match = rfc2822.exec(preprocessRFC2822(config._i));
        if (match) {
            var parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);
            if (!checkWeekday(match[1], parsedArray, config)) {
                return;
            }

            config._a = parsedArray;
            config._tzm = calculateOffset(match[8], match[9], match[10]);

            config._d = createUTCDate.apply(null, config._a);
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);

            getParsingFlags(config).rfc2822 = true;
        } else {
            config._isValid = false;
        }
    }

    // date from iso format or fallback
    function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);

        if (matched !== null) {
            config._d = new Date(+matched[1]);
            return;
        }

        configFromISO(config);
        if (config._isValid === false) {
            delete config._isValid;
        } else {
            return;
        }

        configFromRFC2822(config);
        if (config._isValid === false) {
            delete config._isValid;
        } else {
            return;
        }

        // Final attempt, use Input Fallback
        hooks.createFromInputFallback(config);
    }

    hooks.createFromInputFallback = deprecate(
        'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +
        'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +
        'discouraged and will be removed in an upcoming major release. Please refer to ' +
        'http://momentjs.com/guides/#/warnings/js-date/ for more info.',
        function (config) {
            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
        }
    );

    // constant that refers to the ISO standard
    hooks.ISO_8601 = function () {};

    // constant that refers to the RFC 2822 form
    hooks.RFC_2822 = function () {};

    // date from string and format string
    function configFromStringAndFormat(config) {
        // TODO: Move this to another part of the creation flow to prevent circular deps
        if (config._f === hooks.ISO_8601) {
            configFromISO(config);
            return;
        }
        if (config._f === hooks.RFC_2822) {
            configFromRFC2822(config);
            return;
        }
        config._a = [];
        getParsingFlags(config).empty = true;

        // This array is used to make a Date, either with `new Date` or `Date.UTC`
        var string = '' + config._i,
            i, parsedInput, tokens, token, skipped,
            stringLength = string.length,
            totalParsedInputLength = 0;

        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

        for (i = 0; i < tokens.length; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
            // console.log('token', token, 'parsedInput', parsedInput,
            //         'regex', getParseRegexForToken(token, config));
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    getParsingFlags(config).unusedInput.push(skipped);
                }
                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                totalParsedInputLength += parsedInput.length;
            }
            // don't parse if it's not a known token
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    getParsingFlags(config).empty = false;
                }
                else {
                    getParsingFlags(config).unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            }
            else if (config._strict && !parsedInput) {
                getParsingFlags(config).unusedTokens.push(token);
            }
        }

        // add remaining unparsed input length to the string
        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
            getParsingFlags(config).unusedInput.push(string);
        }

        // clear _12h flag if hour is <= 12
        if (config._a[HOUR] <= 12 &&
            getParsingFlags(config).bigHour === true &&
            config._a[HOUR] > 0) {
            getParsingFlags(config).bigHour = undefined;
        }

        getParsingFlags(config).parsedDateParts = config._a.slice(0);
        getParsingFlags(config).meridiem = config._meridiem;
        // handle meridiem
        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

        configFromArray(config);
        checkOverflow(config);
    }


    function meridiemFixWrap (locale, hour, meridiem) {
        var isPm;

        if (meridiem == null) {
            // nothing to do
            return hour;
        }
        if (locale.meridiemHour != null) {
            return locale.meridiemHour(hour, meridiem);
        } else if (locale.isPM != null) {
            // Fallback
            isPm = locale.isPM(meridiem);
            if (isPm && hour < 12) {
                hour += 12;
            }
            if (!isPm && hour === 12) {
                hour = 0;
            }
            return hour;
        } else {
            // this is not supposed to happen
            return hour;
        }
    }

    // date from string and array of format strings
    function configFromStringAndArray(config) {
        var tempConfig,
            bestMoment,

            scoreToBeat,
            i,
            currentScore;

        if (config._f.length === 0) {
            getParsingFlags(config).invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }

        for (i = 0; i < config._f.length; i++) {
            currentScore = 0;
            tempConfig = copyConfig({}, config);
            if (config._useUTC != null) {
                tempConfig._useUTC = config._useUTC;
            }
            tempConfig._f = config._f[i];
            configFromStringAndFormat(tempConfig);

            if (!isValid(tempConfig)) {
                continue;
            }

            // if there is any input that was not parsed add a penalty for that format
            currentScore += getParsingFlags(tempConfig).charsLeftOver;

            //or tokens
            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

            getParsingFlags(tempConfig).score = currentScore;

            if (scoreToBeat == null || currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
            }
        }

        extend(config, bestMoment || tempConfig);
    }

    function configFromObject(config) {
        if (config._d) {
            return;
        }

        var i = normalizeObjectUnits(config._i);
        config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
            return obj && parseInt(obj, 10);
        });

        configFromArray(config);
    }

    function createFromConfig (config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
            // Adding is smart enough around DST
            res.add(1, 'd');
            res._nextDay = undefined;
        }

        return res;
    }

    function prepareConfig (config) {
        var input = config._i,
            format = config._f;

        config._locale = config._locale || getLocale(config._l);

        if (input === null || (format === undefined && input === '')) {
            return createInvalid({nullInput: true});
        }

        if (typeof input === 'string') {
            config._i = input = config._locale.preparse(input);
        }

        if (isMoment(input)) {
            return new Moment(checkOverflow(input));
        } else if (isDate(input)) {
            config._d = input;
        } else if (isArray(format)) {
            configFromStringAndArray(config);
        } else if (format) {
            configFromStringAndFormat(config);
        }  else {
            configFromInput(config);
        }

        if (!isValid(config)) {
            config._d = null;
        }

        return config;
    }

    function configFromInput(config) {
        var input = config._i;
        if (isUndefined(input)) {
            config._d = new Date(hooks.now());
        } else if (isDate(input)) {
            config._d = new Date(input.valueOf());
        } else if (typeof input === 'string') {
            configFromString(config);
        } else if (isArray(input)) {
            config._a = map(input.slice(0), function (obj) {
                return parseInt(obj, 10);
            });
            configFromArray(config);
        } else if (isObject(input)) {
            configFromObject(config);
        } else if (isNumber(input)) {
            // from milliseconds
            config._d = new Date(input);
        } else {
            hooks.createFromInputFallback(config);
        }
    }

    function createLocalOrUTC (input, format, locale, strict, isUTC) {
        var c = {};

        if (locale === true || locale === false) {
            strict = locale;
            locale = undefined;
        }

        if ((isObject(input) && isObjectEmpty(input)) ||
                (isArray(input) && input.length === 0)) {
            input = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale;
        c._i = input;
        c._f = format;
        c._strict = strict;

        return createFromConfig(c);
    }

    function createLocal (input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, false);
    }

    var prototypeMin = deprecate(
        'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
        function () {
            var other = createLocal.apply(null, arguments);
            if (this.isValid() && other.isValid()) {
                return other < this ? this : other;
            } else {
                return createInvalid();
            }
        }
    );

    var prototypeMax = deprecate(
        'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
        function () {
            var other = createLocal.apply(null, arguments);
            if (this.isValid() && other.isValid()) {
                return other > this ? this : other;
            } else {
                return createInvalid();
            }
        }
    );

    // Pick a moment m from moments so that m[fn](other) is true for all
    // other. This relies on the function fn to be transitive.
    //
    // moments should either be an array of moment objects or an array, whose
    // first element is an array of moment objects.
    function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
            moments = moments[0];
        }
        if (!moments.length) {
            return createLocal();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
            if (!moments[i].isValid() || moments[i][fn](res)) {
                res = moments[i];
            }
        }
        return res;
    }

    // TODO: Use [].sort instead?
    function min () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isBefore', args);
    }

    function max () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isAfter', args);
    }

    var now = function () {
        return Date.now ? Date.now() : +(new Date());
    };

    var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];

    function isDurationValid(m) {
        for (var key in m) {
            if (!(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
                return false;
            }
        }

        var unitHasDecimal = false;
        for (var i = 0; i < ordering.length; ++i) {
            if (m[ordering[i]]) {
                if (unitHasDecimal) {
                    return false; // only allow non-integers for smallest unit
                }
                if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
                    unitHasDecimal = true;
                }
            }
        }

        return true;
    }

    function isValid$1() {
        return this._isValid;
    }

    function createInvalid$1() {
        return createDuration(NaN);
    }

    function Duration (duration) {
        var normalizedInput = normalizeObjectUnits(duration),
            years = normalizedInput.year || 0,
            quarters = normalizedInput.quarter || 0,
            months = normalizedInput.month || 0,
            weeks = normalizedInput.week || normalizedInput.isoWeek || 0,
            days = normalizedInput.day || 0,
            hours = normalizedInput.hour || 0,
            minutes = normalizedInput.minute || 0,
            seconds = normalizedInput.second || 0,
            milliseconds = normalizedInput.millisecond || 0;

        this._isValid = isDurationValid(normalizedInput);

        // representation for dateAddRemove
        this._milliseconds = +milliseconds +
            seconds * 1e3 + // 1000
            minutes * 6e4 + // 1000 * 60
            hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
        // Because of dateAddRemove treats 24 hours as different from a
        // day when working around DST, we need to store them separately
        this._days = +days +
            weeks * 7;
        // It is impossible to translate months into days without knowing
        // which months you are are talking about, so we have to store
        // it separately.
        this._months = +months +
            quarters * 3 +
            years * 12;

        this._data = {};

        this._locale = getLocale();

        this._bubble();
    }

    function isDuration (obj) {
        return obj instanceof Duration;
    }

    function absRound (number) {
        if (number < 0) {
            return Math.round(-1 * number) * -1;
        } else {
            return Math.round(number);
        }
    }

    // FORMATTING

    function offset (token, separator) {
        addFormatToken(token, 0, 0, function () {
            var offset = this.utcOffset();
            var sign = '+';
            if (offset < 0) {
                offset = -offset;
                sign = '-';
            }
            return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
        });
    }

    offset('Z', ':');
    offset('ZZ', '');

    // PARSING

    addRegexToken('Z',  matchShortOffset);
    addRegexToken('ZZ', matchShortOffset);
    addParseToken(['Z', 'ZZ'], function (input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(matchShortOffset, input);
    });

    // HELPERS

    // timezone chunker
    // '+10:00' > ['10',  '00']
    // '-1530'  > ['-15', '30']
    var chunkOffset = /([\+\-]|\d\d)/gi;

    function offsetFromString(matcher, string) {
        var matches = (string || '').match(matcher);

        if (matches === null) {
            return null;
        }

        var chunk   = matches[matches.length - 1] || [];
        var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];
        var minutes = +(parts[1] * 60) + toInt(parts[2]);

        return minutes === 0 ?
          0 :
          parts[0] === '+' ? minutes : -minutes;
    }

    // Return a moment from input, that is local/utc/zone equivalent to model.
    function cloneWithOffset(input, model) {
        var res, diff;
        if (model._isUTC) {
            res = model.clone();
            diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
            // Use low-level api, because this fn is low-level api.
            res._d.setTime(res._d.valueOf() + diff);
            hooks.updateOffset(res, false);
            return res;
        } else {
            return createLocal(input).local();
        }
    }

    function getDateOffset (m) {
        // On Firefox.24 Date#getTimezoneOffset returns a floating point.
        // https://github.com/moment/moment/pull/1871
        return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
    }

    // HOOKS

    // This function will be called whenever a moment is mutated.
    // It is intended to keep the offset in sync with the timezone.
    hooks.updateOffset = function () {};

    // MOMENTS

    // keepLocalTime = true means only change the timezone, without
    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
    // +0200, so we adjust the time as needed, to be valid.
    //
    // Keeping the time actually adds/subtracts (one hour)
    // from the actual represented time. That is why we call updateOffset
    // a second time. In case it wants us to change the offset again
    // _changeInProgress == true case, then we have to adjust, because
    // there is no such time in the given timezone.
    function getSetOffset (input, keepLocalTime, keepMinutes) {
        var offset = this._offset || 0,
            localAdjust;
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        if (input != null) {
            if (typeof input === 'string') {
                input = offsetFromString(matchShortOffset, input);
                if (input === null) {
                    return this;
                }
            } else if (Math.abs(input) < 16 && !keepMinutes) {
                input = input * 60;
            }
            if (!this._isUTC && keepLocalTime) {
                localAdjust = getDateOffset(this);
            }
            this._offset = input;
            this._isUTC = true;
            if (localAdjust != null) {
                this.add(localAdjust, 'm');
            }
            if (offset !== input) {
                if (!keepLocalTime || this._changeInProgress) {
                    addSubtract(this, createDuration(input - offset, 'm'), 1, false);
                } else if (!this._changeInProgress) {
                    this._changeInProgress = true;
                    hooks.updateOffset(this, true);
                    this._changeInProgress = null;
                }
            }
            return this;
        } else {
            return this._isUTC ? offset : getDateOffset(this);
        }
    }

    function getSetZone (input, keepLocalTime) {
        if (input != null) {
            if (typeof input !== 'string') {
                input = -input;
            }

            this.utcOffset(input, keepLocalTime);

            return this;
        } else {
            return -this.utcOffset();
        }
    }

    function setOffsetToUTC (keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
    }

    function setOffsetToLocal (keepLocalTime) {
        if (this._isUTC) {
            this.utcOffset(0, keepLocalTime);
            this._isUTC = false;

            if (keepLocalTime) {
                this.subtract(getDateOffset(this), 'm');
            }
        }
        return this;
    }

    function setOffsetToParsedOffset () {
        if (this._tzm != null) {
            this.utcOffset(this._tzm, false, true);
        } else if (typeof this._i === 'string') {
            var tZone = offsetFromString(matchOffset, this._i);
            if (tZone != null) {
                this.utcOffset(tZone);
            }
            else {
                this.utcOffset(0, true);
            }
        }
        return this;
    }

    function hasAlignedHourOffset (input) {
        if (!this.isValid()) {
            return false;
        }
        input = input ? createLocal(input).utcOffset() : 0;

        return (this.utcOffset() - input) % 60 === 0;
    }

    function isDaylightSavingTime () {
        return (
            this.utcOffset() > this.clone().month(0).utcOffset() ||
            this.utcOffset() > this.clone().month(5).utcOffset()
        );
    }

    function isDaylightSavingTimeShifted () {
        if (!isUndefined(this._isDSTShifted)) {
            return this._isDSTShifted;
        }

        var c = {};

        copyConfig(c, this);
        c = prepareConfig(c);

        if (c._a) {
            var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
            this._isDSTShifted = this.isValid() &&
                compareArrays(c._a, other.toArray()) > 0;
        } else {
            this._isDSTShifted = false;
        }

        return this._isDSTShifted;
    }

    function isLocal () {
        return this.isValid() ? !this._isUTC : false;
    }

    function isUtcOffset () {
        return this.isValid() ? this._isUTC : false;
    }

    function isUtc () {
        return this.isValid() ? this._isUTC && this._offset === 0 : false;
    }

    // ASP.NET json date format regex
    var aspNetRegex = /^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/;

    // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
    // and further modified to allow for strings containing both week and day
    var isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

    function createDuration (input, key) {
        var duration = input,
            // matching against regexp is expensive, do it on demand
            match = null,
            sign,
            ret,
            diffRes;

        if (isDuration(input)) {
            duration = {
                ms : input._milliseconds,
                d  : input._days,
                M  : input._months
            };
        } else if (isNumber(input)) {
            duration = {};
            if (key) {
                duration[key] = input;
            } else {
                duration.milliseconds = input;
            }
        } else if (!!(match = aspNetRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            duration = {
                y  : 0,
                d  : toInt(match[DATE])                         * sign,
                h  : toInt(match[HOUR])                         * sign,
                m  : toInt(match[MINUTE])                       * sign,
                s  : toInt(match[SECOND])                       * sign,
                ms : toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match
            };
        } else if (!!(match = isoRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            duration = {
                y : parseIso(match[2], sign),
                M : parseIso(match[3], sign),
                w : parseIso(match[4], sign),
                d : parseIso(match[5], sign),
                h : parseIso(match[6], sign),
                m : parseIso(match[7], sign),
                s : parseIso(match[8], sign)
            };
        } else if (duration == null) {// checks for null or undefined
            duration = {};
        } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
            diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));

            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months;
        }

        ret = new Duration(duration);

        if (isDuration(input) && hasOwnProp(input, '_locale')) {
            ret._locale = input._locale;
        }

        return ret;
    }

    createDuration.fn = Duration.prototype;
    createDuration.invalid = createInvalid$1;

    function parseIso (inp, sign) {
        // We'd normally use ~~inp for this, but unfortunately it also
        // converts floats to ints.
        // inp may be undefined, so careful calling replace on it.
        var res = inp && parseFloat(inp.replace(',', '.'));
        // apply sign while we're at it
        return (isNaN(res) ? 0 : res) * sign;
    }

    function positiveMomentsDifference(base, other) {
        var res = {};

        res.months = other.month() - base.month() +
            (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, 'M').isAfter(other)) {
            --res.months;
        }

        res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

        return res;
    }

    function momentsDifference(base, other) {
        var res;
        if (!(base.isValid() && other.isValid())) {
            return {milliseconds: 0, months: 0};
        }

        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
            res = positiveMomentsDifference(base, other);
        } else {
            res = positiveMomentsDifference(other, base);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months;
        }

        return res;
    }

    // TODO: remove 'name' arg after deprecation is removed
    function createAdder(direction, name) {
        return function (val, period) {
            var dur, tmp;
            //invert the arguments, but complain about it
            if (period !== null && !isNaN(+period)) {
                deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' +
                'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
                tmp = val; val = period; period = tmp;
            }

            val = typeof val === 'string' ? +val : val;
            dur = createDuration(val, period);
            addSubtract(this, dur, direction);
            return this;
        };
    }

    function addSubtract (mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds,
            days = absRound(duration._days),
            months = absRound(duration._months);

        if (!mom.isValid()) {
            // No op
            return;
        }

        updateOffset = updateOffset == null ? true : updateOffset;

        if (months) {
            setMonth(mom, get(mom, 'Month') + months * isAdding);
        }
        if (days) {
            set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
        }
        if (milliseconds) {
            mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
        }
        if (updateOffset) {
            hooks.updateOffset(mom, days || months);
        }
    }

    var add      = createAdder(1, 'add');
    var subtract = createAdder(-1, 'subtract');

    function getCalendarFormat(myMoment, now) {
        var diff = myMoment.diff(now, 'days', true);
        return diff < -6 ? 'sameElse' :
                diff < -1 ? 'lastWeek' :
                diff < 0 ? 'lastDay' :
                diff < 1 ? 'sameDay' :
                diff < 2 ? 'nextDay' :
                diff < 7 ? 'nextWeek' : 'sameElse';
    }

    function calendar$1 (time, formats) {
        // We want to compare the start of today, vs this.
        // Getting start-of-today depends on whether we're local/utc/offset or not.
        var now = time || createLocal(),
            sod = cloneWithOffset(now, this).startOf('day'),
            format = hooks.calendarFormat(this, sod) || 'sameElse';

        var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);

        return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
    }

    function clone () {
        return new Moment(this);
    }

    function isAfter (input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units) || 'millisecond';
        if (units === 'millisecond') {
            return this.valueOf() > localInput.valueOf();
        } else {
            return localInput.valueOf() < this.clone().startOf(units).valueOf();
        }
    }

    function isBefore (input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units) || 'millisecond';
        if (units === 'millisecond') {
            return this.valueOf() < localInput.valueOf();
        } else {
            return this.clone().endOf(units).valueOf() < localInput.valueOf();
        }
    }

    function isBetween (from, to, units, inclusivity) {
        var localFrom = isMoment(from) ? from : createLocal(from),
            localTo = isMoment(to) ? to : createLocal(to);
        if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
            return false;
        }
        inclusivity = inclusivity || '()';
        return (inclusivity[0] === '(' ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) &&
            (inclusivity[1] === ')' ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
    }

    function isSame (input, units) {
        var localInput = isMoment(input) ? input : createLocal(input),
            inputMs;
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units) || 'millisecond';
        if (units === 'millisecond') {
            return this.valueOf() === localInput.valueOf();
        } else {
            inputMs = localInput.valueOf();
            return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
        }
    }

    function isSameOrAfter (input, units) {
        return this.isSame(input, units) || this.isAfter(input, units);
    }

    function isSameOrBefore (input, units) {
        return this.isSame(input, units) || this.isBefore(input, units);
    }

    function diff (input, units, asFloat) {
        var that,
            zoneDelta,
            output;

        if (!this.isValid()) {
            return NaN;
        }

        that = cloneWithOffset(input, this);

        if (!that.isValid()) {
            return NaN;
        }

        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

        units = normalizeUnits(units);

        switch (units) {
            case 'year': output = monthDiff(this, that) / 12; break;
            case 'month': output = monthDiff(this, that); break;
            case 'quarter': output = monthDiff(this, that) / 3; break;
            case 'second': output = (this - that) / 1e3; break; // 1000
            case 'minute': output = (this - that) / 6e4; break; // 1000 * 60
            case 'hour': output = (this - that) / 36e5; break; // 1000 * 60 * 60
            case 'day': output = (this - that - zoneDelta) / 864e5; break; // 1000 * 60 * 60 * 24, negate dst
            case 'week': output = (this - that - zoneDelta) / 6048e5; break; // 1000 * 60 * 60 * 24 * 7, negate dst
            default: output = this - that;
        }

        return asFloat ? output : absFloor(output);
    }

    function monthDiff (a, b) {
        // difference in months
        var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
            // b is in (anchor - 1 month, anchor + 1 month)
            anchor = a.clone().add(wholeMonthDiff, 'months'),
            anchor2, adjust;

        if (b - anchor < 0) {
            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor - anchor2);
        } else {
            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor2 - anchor);
        }

        //check for negative zero, return zero if negative zero
        return -(wholeMonthDiff + adjust) || 0;
    }

    hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
    hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

    function toString () {
        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
    }

    function toISOString(keepOffset) {
        if (!this.isValid()) {
            return null;
        }
        var utc = keepOffset !== true;
        var m = utc ? this.clone().utc() : this;
        if (m.year() < 0 || m.year() > 9999) {
            return formatMoment(m, utc ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ');
        }
        if (isFunction(Date.prototype.toISOString)) {
            // native implementation is ~50x faster, use it when we can
            if (utc) {
                return this.toDate().toISOString();
            } else {
                return new Date(this.valueOf() + this.utcOffset() * 60 * 1000).toISOString().replace('Z', formatMoment(m, 'Z'));
            }
        }
        return formatMoment(m, utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ');
    }

    /**
     * Return a human readable representation of a moment that can
     * also be evaluated to get a new moment which is the same
     *
     * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
     */
    function inspect () {
        if (!this.isValid()) {
            return 'moment.invalid(/* ' + this._i + ' */)';
        }
        var func = 'moment';
        var zone = '';
        if (!this.isLocal()) {
            func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
            zone = 'Z';
        }
        var prefix = '[' + func + '("]';
        var year = (0 <= this.year() && this.year() <= 9999) ? 'YYYY' : 'YYYYYY';
        var datetime = '-MM-DD[T]HH:mm:ss.SSS';
        var suffix = zone + '[")]';

        return this.format(prefix + year + datetime + suffix);
    }

    function format (inputString) {
        if (!inputString) {
            inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
        }
        var output = formatMoment(this, inputString);
        return this.localeData().postformat(output);
    }

    function from (time, withoutSuffix) {
        if (this.isValid() &&
                ((isMoment(time) && time.isValid()) ||
                 createLocal(time).isValid())) {
            return createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }

    function fromNow (withoutSuffix) {
        return this.from(createLocal(), withoutSuffix);
    }

    function to (time, withoutSuffix) {
        if (this.isValid() &&
                ((isMoment(time) && time.isValid()) ||
                 createLocal(time).isValid())) {
            return createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }

    function toNow (withoutSuffix) {
        return this.to(createLocal(), withoutSuffix);
    }

    // If passed a locale key, it will set the locale for this
    // instance.  Otherwise, it will return the locale configuration
    // variables for this instance.
    function locale (key) {
        var newLocaleData;

        if (key === undefined) {
            return this._locale._abbr;
        } else {
            newLocaleData = getLocale(key);
            if (newLocaleData != null) {
                this._locale = newLocaleData;
            }
            return this;
        }
    }

    var lang = deprecate(
        'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
        function (key) {
            if (key === undefined) {
                return this.localeData();
            } else {
                return this.locale(key);
            }
        }
    );

    function localeData () {
        return this._locale;
    }

    var MS_PER_SECOND = 1000;
    var MS_PER_MINUTE = 60 * MS_PER_SECOND;
    var MS_PER_HOUR = 60 * MS_PER_MINUTE;
    var MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;

    // actual modulo - handles negative numbers (for dates before 1970):
    function mod$1(dividend, divisor) {
        return (dividend % divisor + divisor) % divisor;
    }

    function localStartOfDate(y, m, d) {
        // the date constructor remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
            // preserve leap years using a full 400 year cycle, then reset
            return new Date(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
            return new Date(y, m, d).valueOf();
        }
    }

    function utcStartOfDate(y, m, d) {
        // Date.UTC remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
            // preserve leap years using a full 400 year cycle, then reset
            return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
            return Date.UTC(y, m, d);
        }
    }

    function startOf (units) {
        var time;
        units = normalizeUnits(units);
        if (units === undefined || units === 'millisecond' || !this.isValid()) {
            return this;
        }

        var startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

        switch (units) {
            case 'year':
                time = startOfDate(this.year(), 0, 1);
                break;
            case 'quarter':
                time = startOfDate(this.year(), this.month() - this.month() % 3, 1);
                break;
            case 'month':
                time = startOfDate(this.year(), this.month(), 1);
                break;
            case 'week':
                time = startOfDate(this.year(), this.month(), this.date() - this.weekday());
                break;
            case 'isoWeek':
                time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));
                break;
            case 'day':
            case 'date':
                time = startOfDate(this.year(), this.month(), this.date());
                break;
            case 'hour':
                time = this._d.valueOf();
                time -= mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR);
                break;
            case 'minute':
                time = this._d.valueOf();
                time -= mod$1(time, MS_PER_MINUTE);
                break;
            case 'second':
                time = this._d.valueOf();
                time -= mod$1(time, MS_PER_SECOND);
                break;
        }

        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
    }

    function endOf (units) {
        var time;
        units = normalizeUnits(units);
        if (units === undefined || units === 'millisecond' || !this.isValid()) {
            return this;
        }

        var startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

        switch (units) {
            case 'year':
                time = startOfDate(this.year() + 1, 0, 1) - 1;
                break;
            case 'quarter':
                time = startOfDate(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;
                break;
            case 'month':
                time = startOfDate(this.year(), this.month() + 1, 1) - 1;
                break;
            case 'week':
                time = startOfDate(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;
                break;
            case 'isoWeek':
                time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;
                break;
            case 'day':
            case 'date':
                time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
                break;
            case 'hour':
                time = this._d.valueOf();
                time += MS_PER_HOUR - mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR) - 1;
                break;
            case 'minute':
                time = this._d.valueOf();
                time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
                break;
            case 'second':
                time = this._d.valueOf();
                time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
                break;
        }

        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
    }

    function valueOf () {
        return this._d.valueOf() - ((this._offset || 0) * 60000);
    }

    function unix () {
        return Math.floor(this.valueOf() / 1000);
    }

    function toDate () {
        return new Date(this.valueOf());
    }

    function toArray () {
        var m = this;
        return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
    }

    function toObject () {
        var m = this;
        return {
            years: m.year(),
            months: m.month(),
            date: m.date(),
            hours: m.hours(),
            minutes: m.minutes(),
            seconds: m.seconds(),
            milliseconds: m.milliseconds()
        };
    }

    function toJSON () {
        // new Date(NaN).toJSON() === null
        return this.isValid() ? this.toISOString() : null;
    }

    function isValid$2 () {
        return isValid(this);
    }

    function parsingFlags () {
        return extend({}, getParsingFlags(this));
    }

    function invalidAt () {
        return getParsingFlags(this).overflow;
    }

    function creationData() {
        return {
            input: this._i,
            format: this._f,
            locale: this._locale,
            isUTC: this._isUTC,
            strict: this._strict
        };
    }

    // FORMATTING

    addFormatToken(0, ['gg', 2], 0, function () {
        return this.weekYear() % 100;
    });

    addFormatToken(0, ['GG', 2], 0, function () {
        return this.isoWeekYear() % 100;
    });

    function addWeekYearFormatToken (token, getter) {
        addFormatToken(0, [token, token.length], 0, getter);
    }

    addWeekYearFormatToken('gggg',     'weekYear');
    addWeekYearFormatToken('ggggg',    'weekYear');
    addWeekYearFormatToken('GGGG',  'isoWeekYear');
    addWeekYearFormatToken('GGGGG', 'isoWeekYear');

    // ALIASES

    addUnitAlias('weekYear', 'gg');
    addUnitAlias('isoWeekYear', 'GG');

    // PRIORITY

    addUnitPriority('weekYear', 1);
    addUnitPriority('isoWeekYear', 1);


    // PARSING

    addRegexToken('G',      matchSigned);
    addRegexToken('g',      matchSigned);
    addRegexToken('GG',     match1to2, match2);
    addRegexToken('gg',     match1to2, match2);
    addRegexToken('GGGG',   match1to4, match4);
    addRegexToken('gggg',   match1to4, match4);
    addRegexToken('GGGGG',  match1to6, match6);
    addRegexToken('ggggg',  match1to6, match6);

    addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
        week[token.substr(0, 2)] = toInt(input);
    });

    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
        week[token] = hooks.parseTwoDigitYear(input);
    });

    // MOMENTS

    function getSetWeekYear (input) {
        return getSetWeekYearHelper.call(this,
                input,
                this.week(),
                this.weekday(),
                this.localeData()._week.dow,
                this.localeData()._week.doy);
    }

    function getSetISOWeekYear (input) {
        return getSetWeekYearHelper.call(this,
                input, this.isoWeek(), this.isoWeekday(), 1, 4);
    }

    function getISOWeeksInYear () {
        return weeksInYear(this.year(), 1, 4);
    }

    function getWeeksInYear () {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }

    function getSetWeekYearHelper(input, week, weekday, dow, doy) {
        var weeksTarget;
        if (input == null) {
            return weekOfYear(this, dow, doy).year;
        } else {
            weeksTarget = weeksInYear(input, dow, doy);
            if (week > weeksTarget) {
                week = weeksTarget;
            }
            return setWeekAll.call(this, input, week, weekday, dow, doy);
        }
    }

    function setWeekAll(weekYear, week, weekday, dow, doy) {
        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
            date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

        this.year(date.getUTCFullYear());
        this.month(date.getUTCMonth());
        this.date(date.getUTCDate());
        return this;
    }

    // FORMATTING

    addFormatToken('Q', 0, 'Qo', 'quarter');

    // ALIASES

    addUnitAlias('quarter', 'Q');

    // PRIORITY

    addUnitPriority('quarter', 7);

    // PARSING

    addRegexToken('Q', match1);
    addParseToken('Q', function (input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
    });

    // MOMENTS

    function getSetQuarter (input) {
        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
    }

    // FORMATTING

    addFormatToken('D', ['DD', 2], 'Do', 'date');

    // ALIASES

    addUnitAlias('date', 'D');

    // PRIORITY
    addUnitPriority('date', 9);

    // PARSING

    addRegexToken('D',  match1to2);
    addRegexToken('DD', match1to2, match2);
    addRegexToken('Do', function (isStrict, locale) {
        // TODO: Remove "ordinalParse" fallback in next major release.
        return isStrict ?
          (locale._dayOfMonthOrdinalParse || locale._ordinalParse) :
          locale._dayOfMonthOrdinalParseLenient;
    });

    addParseToken(['D', 'DD'], DATE);
    addParseToken('Do', function (input, array) {
        array[DATE] = toInt(input.match(match1to2)[0]);
    });

    // MOMENTS

    var getSetDayOfMonth = makeGetSet('Date', true);

    // FORMATTING

    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

    // ALIASES

    addUnitAlias('dayOfYear', 'DDD');

    // PRIORITY
    addUnitPriority('dayOfYear', 4);

    // PARSING

    addRegexToken('DDD',  match1to3);
    addRegexToken('DDDD', match3);
    addParseToken(['DDD', 'DDDD'], function (input, array, config) {
        config._dayOfYear = toInt(input);
    });

    // HELPERS

    // MOMENTS

    function getSetDayOfYear (input) {
        var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
        return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
    }

    // FORMATTING

    addFormatToken('m', ['mm', 2], 0, 'minute');

    // ALIASES

    addUnitAlias('minute', 'm');

    // PRIORITY

    addUnitPriority('minute', 14);

    // PARSING

    addRegexToken('m',  match1to2);
    addRegexToken('mm', match1to2, match2);
    addParseToken(['m', 'mm'], MINUTE);

    // MOMENTS

    var getSetMinute = makeGetSet('Minutes', false);

    // FORMATTING

    addFormatToken('s', ['ss', 2], 0, 'second');

    // ALIASES

    addUnitAlias('second', 's');

    // PRIORITY

    addUnitPriority('second', 15);

    // PARSING

    addRegexToken('s',  match1to2);
    addRegexToken('ss', match1to2, match2);
    addParseToken(['s', 'ss'], SECOND);

    // MOMENTS

    var getSetSecond = makeGetSet('Seconds', false);

    // FORMATTING

    addFormatToken('S', 0, 0, function () {
        return ~~(this.millisecond() / 100);
    });

    addFormatToken(0, ['SS', 2], 0, function () {
        return ~~(this.millisecond() / 10);
    });

    addFormatToken(0, ['SSS', 3], 0, 'millisecond');
    addFormatToken(0, ['SSSS', 4], 0, function () {
        return this.millisecond() * 10;
    });
    addFormatToken(0, ['SSSSS', 5], 0, function () {
        return this.millisecond() * 100;
    });
    addFormatToken(0, ['SSSSSS', 6], 0, function () {
        return this.millisecond() * 1000;
    });
    addFormatToken(0, ['SSSSSSS', 7], 0, function () {
        return this.millisecond() * 10000;
    });
    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
        return this.millisecond() * 100000;
    });
    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
        return this.millisecond() * 1000000;
    });


    // ALIASES

    addUnitAlias('millisecond', 'ms');

    // PRIORITY

    addUnitPriority('millisecond', 16);

    // PARSING

    addRegexToken('S',    match1to3, match1);
    addRegexToken('SS',   match1to3, match2);
    addRegexToken('SSS',  match1to3, match3);

    var token;
    for (token = 'SSSS'; token.length <= 9; token += 'S') {
        addRegexToken(token, matchUnsigned);
    }

    function parseMs(input, array) {
        array[MILLISECOND] = toInt(('0.' + input) * 1000);
    }

    for (token = 'S'; token.length <= 9; token += 'S') {
        addParseToken(token, parseMs);
    }
    // MOMENTS

    var getSetMillisecond = makeGetSet('Milliseconds', false);

    // FORMATTING

    addFormatToken('z',  0, 0, 'zoneAbbr');
    addFormatToken('zz', 0, 0, 'zoneName');

    // MOMENTS

    function getZoneAbbr () {
        return this._isUTC ? 'UTC' : '';
    }

    function getZoneName () {
        return this._isUTC ? 'Coordinated Universal Time' : '';
    }

    var proto = Moment.prototype;

    proto.add               = add;
    proto.calendar          = calendar$1;
    proto.clone             = clone;
    proto.diff              = diff;
    proto.endOf             = endOf;
    proto.format            = format;
    proto.from              = from;
    proto.fromNow           = fromNow;
    proto.to                = to;
    proto.toNow             = toNow;
    proto.get               = stringGet;
    proto.invalidAt         = invalidAt;
    proto.isAfter           = isAfter;
    proto.isBefore          = isBefore;
    proto.isBetween         = isBetween;
    proto.isSame            = isSame;
    proto.isSameOrAfter     = isSameOrAfter;
    proto.isSameOrBefore    = isSameOrBefore;
    proto.isValid           = isValid$2;
    proto.lang              = lang;
    proto.locale            = locale;
    proto.localeData        = localeData;
    proto.max               = prototypeMax;
    proto.min               = prototypeMin;
    proto.parsingFlags      = parsingFlags;
    proto.set               = stringSet;
    proto.startOf           = startOf;
    proto.subtract          = subtract;
    proto.toArray           = toArray;
    proto.toObject          = toObject;
    proto.toDate            = toDate;
    proto.toISOString       = toISOString;
    proto.inspect           = inspect;
    proto.toJSON            = toJSON;
    proto.toString          = toString;
    proto.unix              = unix;
    proto.valueOf           = valueOf;
    proto.creationData      = creationData;
    proto.year       = getSetYear;
    proto.isLeapYear = getIsLeapYear;
    proto.weekYear    = getSetWeekYear;
    proto.isoWeekYear = getSetISOWeekYear;
    proto.quarter = proto.quarters = getSetQuarter;
    proto.month       = getSetMonth;
    proto.daysInMonth = getDaysInMonth;
    proto.week           = proto.weeks        = getSetWeek;
    proto.isoWeek        = proto.isoWeeks     = getSetISOWeek;
    proto.weeksInYear    = getWeeksInYear;
    proto.isoWeeksInYear = getISOWeeksInYear;
    proto.date       = getSetDayOfMonth;
    proto.day        = proto.days             = getSetDayOfWeek;
    proto.weekday    = getSetLocaleDayOfWeek;
    proto.isoWeekday = getSetISODayOfWeek;
    proto.dayOfYear  = getSetDayOfYear;
    proto.hour = proto.hours = getSetHour;
    proto.minute = proto.minutes = getSetMinute;
    proto.second = proto.seconds = getSetSecond;
    proto.millisecond = proto.milliseconds = getSetMillisecond;
    proto.utcOffset            = getSetOffset;
    proto.utc                  = setOffsetToUTC;
    proto.local                = setOffsetToLocal;
    proto.parseZone            = setOffsetToParsedOffset;
    proto.hasAlignedHourOffset = hasAlignedHourOffset;
    proto.isDST                = isDaylightSavingTime;
    proto.isLocal              = isLocal;
    proto.isUtcOffset          = isUtcOffset;
    proto.isUtc                = isUtc;
    proto.isUTC                = isUtc;
    proto.zoneAbbr = getZoneAbbr;
    proto.zoneName = getZoneName;
    proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
    proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
    proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
    proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
    proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);

    function createUnix (input) {
        return createLocal(input * 1000);
    }

    function createInZone () {
        return createLocal.apply(null, arguments).parseZone();
    }

    function preParsePostFormat (string) {
        return string;
    }

    var proto$1 = Locale.prototype;

    proto$1.calendar        = calendar;
    proto$1.longDateFormat  = longDateFormat;
    proto$1.invalidDate     = invalidDate;
    proto$1.ordinal         = ordinal;
    proto$1.preparse        = preParsePostFormat;
    proto$1.postformat      = preParsePostFormat;
    proto$1.relativeTime    = relativeTime;
    proto$1.pastFuture      = pastFuture;
    proto$1.set             = set;

    proto$1.months            =        localeMonths;
    proto$1.monthsShort       =        localeMonthsShort;
    proto$1.monthsParse       =        localeMonthsParse;
    proto$1.monthsRegex       = monthsRegex;
    proto$1.monthsShortRegex  = monthsShortRegex;
    proto$1.week = localeWeek;
    proto$1.firstDayOfYear = localeFirstDayOfYear;
    proto$1.firstDayOfWeek = localeFirstDayOfWeek;

    proto$1.weekdays       =        localeWeekdays;
    proto$1.weekdaysMin    =        localeWeekdaysMin;
    proto$1.weekdaysShort  =        localeWeekdaysShort;
    proto$1.weekdaysParse  =        localeWeekdaysParse;

    proto$1.weekdaysRegex       =        weekdaysRegex;
    proto$1.weekdaysShortRegex  =        weekdaysShortRegex;
    proto$1.weekdaysMinRegex    =        weekdaysMinRegex;

    proto$1.isPM = localeIsPM;
    proto$1.meridiem = localeMeridiem;

    function get$1 (format, index, field, setter) {
        var locale = getLocale();
        var utc = createUTC().set(setter, index);
        return locale[field](utc, format);
    }

    function listMonthsImpl (format, index, field) {
        if (isNumber(format)) {
            index = format;
            format = undefined;
        }

        format = format || '';

        if (index != null) {
            return get$1(format, index, field, 'month');
        }

        var i;
        var out = [];
        for (i = 0; i < 12; i++) {
            out[i] = get$1(format, i, field, 'month');
        }
        return out;
    }

    // ()
    // (5)
    // (fmt, 5)
    // (fmt)
    // (true)
    // (true, 5)
    // (true, fmt, 5)
    // (true, fmt)
    function listWeekdaysImpl (localeSorted, format, index, field) {
        if (typeof localeSorted === 'boolean') {
            if (isNumber(format)) {
                index = format;
                format = undefined;
            }

            format = format || '';
        } else {
            format = localeSorted;
            index = format;
            localeSorted = false;

            if (isNumber(format)) {
                index = format;
                format = undefined;
            }

            format = format || '';
        }

        var locale = getLocale(),
            shift = localeSorted ? locale._week.dow : 0;

        if (index != null) {
            return get$1(format, (index + shift) % 7, field, 'day');
        }

        var i;
        var out = [];
        for (i = 0; i < 7; i++) {
            out[i] = get$1(format, (i + shift) % 7, field, 'day');
        }
        return out;
    }

    function listMonths (format, index) {
        return listMonthsImpl(format, index, 'months');
    }

    function listMonthsShort (format, index) {
        return listMonthsImpl(format, index, 'monthsShort');
    }

    function listWeekdays (localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
    }

    function listWeekdaysShort (localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
    }

    function listWeekdaysMin (localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
    }

    getSetGlobalLocale('en', {
        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (toInt(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        }
    });

    // Side effect imports

    hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);
    hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);

    var mathAbs = Math.abs;

    function abs () {
        var data           = this._data;

        this._milliseconds = mathAbs(this._milliseconds);
        this._days         = mathAbs(this._days);
        this._months       = mathAbs(this._months);

        data.milliseconds  = mathAbs(data.milliseconds);
        data.seconds       = mathAbs(data.seconds);
        data.minutes       = mathAbs(data.minutes);
        data.hours         = mathAbs(data.hours);
        data.months        = mathAbs(data.months);
        data.years         = mathAbs(data.years);

        return this;
    }

    function addSubtract$1 (duration, input, value, direction) {
        var other = createDuration(input, value);

        duration._milliseconds += direction * other._milliseconds;
        duration._days         += direction * other._days;
        duration._months       += direction * other._months;

        return duration._bubble();
    }

    // supports only 2.0-style add(1, 's') or add(duration)
    function add$1 (input, value) {
        return addSubtract$1(this, input, value, 1);
    }

    // supports only 2.0-style subtract(1, 's') or subtract(duration)
    function subtract$1 (input, value) {
        return addSubtract$1(this, input, value, -1);
    }

    function absCeil (number) {
        if (number < 0) {
            return Math.floor(number);
        } else {
            return Math.ceil(number);
        }
    }

    function bubble () {
        var milliseconds = this._milliseconds;
        var days         = this._days;
        var months       = this._months;
        var data         = this._data;
        var seconds, minutes, hours, years, monthsFromDays;

        // if we have a mix of positive and negative values, bubble down first
        // check: https://github.com/moment/moment/issues/2166
        if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
                (milliseconds <= 0 && days <= 0 && months <= 0))) {
            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
            days = 0;
            months = 0;
        }

        // The following code bubbles up values, see the tests for
        // examples of what that means.
        data.milliseconds = milliseconds % 1000;

        seconds           = absFloor(milliseconds / 1000);
        data.seconds      = seconds % 60;

        minutes           = absFloor(seconds / 60);
        data.minutes      = minutes % 60;

        hours             = absFloor(minutes / 60);
        data.hours        = hours % 24;

        days += absFloor(hours / 24);

        // convert days to months
        monthsFromDays = absFloor(daysToMonths(days));
        months += monthsFromDays;
        days -= absCeil(monthsToDays(monthsFromDays));

        // 12 months -> 1 year
        years = absFloor(months / 12);
        months %= 12;

        data.days   = days;
        data.months = months;
        data.years  = years;

        return this;
    }

    function daysToMonths (days) {
        // 400 years have 146097 days (taking into account leap year rules)
        // 400 years have 12 months === 4800
        return days * 4800 / 146097;
    }

    function monthsToDays (months) {
        // the reverse of daysToMonths
        return months * 146097 / 4800;
    }

    function as (units) {
        if (!this.isValid()) {
            return NaN;
        }
        var days;
        var months;
        var milliseconds = this._milliseconds;

        units = normalizeUnits(units);

        if (units === 'month' || units === 'quarter' || units === 'year') {
            days = this._days + milliseconds / 864e5;
            months = this._months + daysToMonths(days);
            switch (units) {
                case 'month':   return months;
                case 'quarter': return months / 3;
                case 'year':    return months / 12;
            }
        } else {
            // handle milliseconds separately because of floating point math errors (issue #1867)
            days = this._days + Math.round(monthsToDays(this._months));
            switch (units) {
                case 'week'   : return days / 7     + milliseconds / 6048e5;
                case 'day'    : return days         + milliseconds / 864e5;
                case 'hour'   : return days * 24    + milliseconds / 36e5;
                case 'minute' : return days * 1440  + milliseconds / 6e4;
                case 'second' : return days * 86400 + milliseconds / 1000;
                // Math.floor prevents floating point math errors here
                case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
                default: throw new Error('Unknown unit ' + units);
            }
        }
    }

    // TODO: Use this.as('ms')?
    function valueOf$1 () {
        if (!this.isValid()) {
            return NaN;
        }
        return (
            this._milliseconds +
            this._days * 864e5 +
            (this._months % 12) * 2592e6 +
            toInt(this._months / 12) * 31536e6
        );
    }

    function makeAs (alias) {
        return function () {
            return this.as(alias);
        };
    }

    var asMilliseconds = makeAs('ms');
    var asSeconds      = makeAs('s');
    var asMinutes      = makeAs('m');
    var asHours        = makeAs('h');
    var asDays         = makeAs('d');
    var asWeeks        = makeAs('w');
    var asMonths       = makeAs('M');
    var asQuarters     = makeAs('Q');
    var asYears        = makeAs('y');

    function clone$1 () {
        return createDuration(this);
    }

    function get$2 (units) {
        units = normalizeUnits(units);
        return this.isValid() ? this[units + 's']() : NaN;
    }

    function makeGetter(name) {
        return function () {
            return this.isValid() ? this._data[name] : NaN;
        };
    }

    var milliseconds = makeGetter('milliseconds');
    var seconds      = makeGetter('seconds');
    var minutes      = makeGetter('minutes');
    var hours        = makeGetter('hours');
    var days         = makeGetter('days');
    var months       = makeGetter('months');
    var years        = makeGetter('years');

    function weeks () {
        return absFloor(this.days() / 7);
    }

    var round = Math.round;
    var thresholds = {
        ss: 44,         // a few seconds to seconds
        s : 45,         // seconds to minute
        m : 45,         // minutes to hour
        h : 22,         // hours to day
        d : 26,         // days to month
        M : 11          // months to year
    };

    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }

    function relativeTime$1 (posNegDuration, withoutSuffix, locale) {
        var duration = createDuration(posNegDuration).abs();
        var seconds  = round(duration.as('s'));
        var minutes  = round(duration.as('m'));
        var hours    = round(duration.as('h'));
        var days     = round(duration.as('d'));
        var months   = round(duration.as('M'));
        var years    = round(duration.as('y'));

        var a = seconds <= thresholds.ss && ['s', seconds]  ||
                seconds < thresholds.s   && ['ss', seconds] ||
                minutes <= 1             && ['m']           ||
                minutes < thresholds.m   && ['mm', minutes] ||
                hours   <= 1             && ['h']           ||
                hours   < thresholds.h   && ['hh', hours]   ||
                days    <= 1             && ['d']           ||
                days    < thresholds.d   && ['dd', days]    ||
                months  <= 1             && ['M']           ||
                months  < thresholds.M   && ['MM', months]  ||
                years   <= 1             && ['y']           || ['yy', years];

        a[2] = withoutSuffix;
        a[3] = +posNegDuration > 0;
        a[4] = locale;
        return substituteTimeAgo.apply(null, a);
    }

    // This function allows you to set the rounding function for relative time strings
    function getSetRelativeTimeRounding (roundingFunction) {
        if (roundingFunction === undefined) {
            return round;
        }
        if (typeof(roundingFunction) === 'function') {
            round = roundingFunction;
            return true;
        }
        return false;
    }

    // This function allows you to set a threshold for relative time strings
    function getSetRelativeTimeThreshold (threshold, limit) {
        if (thresholds[threshold] === undefined) {
            return false;
        }
        if (limit === undefined) {
            return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        if (threshold === 's') {
            thresholds.ss = limit - 1;
        }
        return true;
    }

    function humanize (withSuffix) {
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }

        var locale = this.localeData();
        var output = relativeTime$1(this, !withSuffix, locale);

        if (withSuffix) {
            output = locale.pastFuture(+this, output);
        }

        return locale.postformat(output);
    }

    var abs$1 = Math.abs;

    function sign(x) {
        return ((x > 0) - (x < 0)) || +x;
    }

    function toISOString$1() {
        // for ISO strings we do not use the normal bubbling rules:
        //  * milliseconds bubble up until they become hours
        //  * days do not bubble at all
        //  * months bubble up until they become years
        // This is because there is no context-free conversion between hours and days
        // (think of clock changes)
        // and also not between days and months (28-31 days per month)
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }

        var seconds = abs$1(this._milliseconds) / 1000;
        var days         = abs$1(this._days);
        var months       = abs$1(this._months);
        var minutes, hours, years;

        // 3600 seconds -> 60 minutes -> 1 hour
        minutes           = absFloor(seconds / 60);
        hours             = absFloor(minutes / 60);
        seconds %= 60;
        minutes %= 60;

        // 12 months -> 1 year
        years  = absFloor(months / 12);
        months %= 12;


        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
        var Y = years;
        var M = months;
        var D = days;
        var h = hours;
        var m = minutes;
        var s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';
        var total = this.asSeconds();

        if (!total) {
            // this is the same as C#'s (Noda) and python (isodate)...
            // but not other JS (goog.date)
            return 'P0D';
        }

        var totalSign = total < 0 ? '-' : '';
        var ymSign = sign(this._months) !== sign(total) ? '-' : '';
        var daysSign = sign(this._days) !== sign(total) ? '-' : '';
        var hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';

        return totalSign + 'P' +
            (Y ? ymSign + Y + 'Y' : '') +
            (M ? ymSign + M + 'M' : '') +
            (D ? daysSign + D + 'D' : '') +
            ((h || m || s) ? 'T' : '') +
            (h ? hmsSign + h + 'H' : '') +
            (m ? hmsSign + m + 'M' : '') +
            (s ? hmsSign + s + 'S' : '');
    }

    var proto$2 = Duration.prototype;

    proto$2.isValid        = isValid$1;
    proto$2.abs            = abs;
    proto$2.add            = add$1;
    proto$2.subtract       = subtract$1;
    proto$2.as             = as;
    proto$2.asMilliseconds = asMilliseconds;
    proto$2.asSeconds      = asSeconds;
    proto$2.asMinutes      = asMinutes;
    proto$2.asHours        = asHours;
    proto$2.asDays         = asDays;
    proto$2.asWeeks        = asWeeks;
    proto$2.asMonths       = asMonths;
    proto$2.asQuarters     = asQuarters;
    proto$2.asYears        = asYears;
    proto$2.valueOf        = valueOf$1;
    proto$2._bubble        = bubble;
    proto$2.clone          = clone$1;
    proto$2.get            = get$2;
    proto$2.milliseconds   = milliseconds;
    proto$2.seconds        = seconds;
    proto$2.minutes        = minutes;
    proto$2.hours          = hours;
    proto$2.days           = days;
    proto$2.weeks          = weeks;
    proto$2.months         = months;
    proto$2.years          = years;
    proto$2.humanize       = humanize;
    proto$2.toISOString    = toISOString$1;
    proto$2.toString       = toISOString$1;
    proto$2.toJSON         = toISOString$1;
    proto$2.locale         = locale;
    proto$2.localeData     = localeData;

    proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);
    proto$2.lang = lang;

    // Side effect imports

    // FORMATTING

    addFormatToken('X', 0, 0, 'unix');
    addFormatToken('x', 0, 0, 'valueOf');

    // PARSING

    addRegexToken('x', matchSigned);
    addRegexToken('X', matchTimestamp);
    addParseToken('X', function (input, array, config) {
        config._d = new Date(parseFloat(input, 10) * 1000);
    });
    addParseToken('x', function (input, array, config) {
        config._d = new Date(toInt(input));
    });

    // Side effect imports


    hooks.version = '2.24.0';

    setHookCallback(createLocal);

    hooks.fn                    = proto;
    hooks.min                   = min;
    hooks.max                   = max;
    hooks.now                   = now;
    hooks.utc                   = createUTC;
    hooks.unix                  = createUnix;
    hooks.months                = listMonths;
    hooks.isDate                = isDate;
    hooks.locale                = getSetGlobalLocale;
    hooks.invalid               = createInvalid;
    hooks.duration              = createDuration;
    hooks.isMoment              = isMoment;
    hooks.weekdays              = listWeekdays;
    hooks.parseZone             = createInZone;
    hooks.localeData            = getLocale;
    hooks.isDuration            = isDuration;
    hooks.monthsShort           = listMonthsShort;
    hooks.weekdaysMin           = listWeekdaysMin;
    hooks.defineLocale          = defineLocale;
    hooks.updateLocale          = updateLocale;
    hooks.locales               = listLocales;
    hooks.weekdaysShort         = listWeekdaysShort;
    hooks.normalizeUnits        = normalizeUnits;
    hooks.relativeTimeRounding  = getSetRelativeTimeRounding;
    hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
    hooks.calendarFormat        = getCalendarFormat;
    hooks.prototype             = proto;

    // currently HTML5 input type only supports 24-hour formats
    hooks.HTML5_FMT = {
        DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm',             // <input type="datetime-local" />
        DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss',  // <input type="datetime-local" step="1" />
        DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS',   // <input type="datetime-local" step="0.001" />
        DATE: 'YYYY-MM-DD',                             // <input type="date" />
        TIME: 'HH:mm',                                  // <input type="time" />
        TIME_SECONDS: 'HH:mm:ss',                       // <input type="time" step="1" />
        TIME_MS: 'HH:mm:ss.SSS',                        // <input type="time" step="0.001" />
        WEEK: 'GGGG-[W]WW',                             // <input type="week" />
        MONTH: 'YYYY-MM'                                // <input type="month" />
    };

    return hooks;

})));
;/* angular-moment.js / v1.3.0 / (c) 2013, 2014, 2015, 2016, 2017, 2018 Uri Shaked / MIT Licence */

'format amd';
/* global define */

(function () {
	'use strict';

	function isUndefinedOrNull(val) {
		return angular.isUndefined(val) || val === null;
	}

	function requireMoment() {
		try {
			return require('moment'); // Using nw.js or browserify?
		} catch (e) {
			throw new Error('Please install moment via npm. Please reference to: https://github.com/urish/angular-moment'); // Add wiki/troubleshooting section?
		}
	}

	function angularMoment(angular, moment) {

		if(typeof moment === 'undefined') {
			if(typeof require === 'function') {
				moment = requireMoment();
			}else{
				throw new Error('Moment cannot be found by angular-moment! Please reference to: https://github.com/urish/angular-moment'); // Add wiki/troubleshooting section?
			}
		}

		/**
		 * @ngdoc overview
		 * @name angularMoment
		 *
		 * @description
		 * angularMoment module provides moment.js functionality for angular.js apps.
		 */
		angular.module('angularMoment', [])

		/**
		 * @ngdoc object
		 * @name angularMoment.config:angularMomentConfig
		 *
		 * @description
		 * Common configuration of the angularMoment module
		 */
			.constant('angularMomentConfig', {
				/**
				 * @ngdoc property
				 * @name angularMoment.config.angularMomentConfig#preprocess
				 * @propertyOf angularMoment.config:angularMomentConfig
				 * @returns {function} A preprocessor function that will be applied on all incoming dates
				 *
				 * @description
				 * Defines a preprocessor function to apply on all input dates (e.g. the input of `am-time-ago`,
				 * `amCalendar`, etc.). The function must return a `moment` object.
				 *
				 * @example
				 *   // Causes angular-moment to always treat the input values as unix timestamps
				 *   angularMomentConfig.preprocess = function(value) {
				 * 	   return moment.unix(value);
				 *   }
				 */
				preprocess: null,

				/**
				 * @ngdoc property
				 * @name angularMoment.config.angularMomentConfig#timezone
				 * @propertyOf angularMoment.config:angularMomentConfig
				 * @returns {string} The default timezone
				 *
				 * @description
				 * The default timezone (e.g. 'Europe/London'). Empty string by default (does not apply
				 * any timezone shift).
				 *
				 * NOTE: This option requires moment-timezone >= 0.3.0.
				 */
				timezone: null,

				/**
				 * @ngdoc property
				 * @name angularMoment.config.angularMomentConfig#format
				 * @propertyOf angularMoment.config:angularMomentConfig
				 * @returns {string} The pre-conversion format of the date
				 *
				 * @description
				 * Specify the format of the input date. Essentially it's a
				 * default and saves you from specifying a format in every
				 * element. Overridden by element attr. Null by default.
				 */
				format: null,

				/**
				 * @ngdoc property
				 * @name angularMoment.config.angularMomentConfig#statefulFilters
				 * @propertyOf angularMoment.config:angularMomentConfig
				 * @returns {boolean} Whether angular-moment filters should be stateless (or not)
				 *
				 * @description
				 * Specifies whether the filters included with angular-moment are stateful.
				 * Stateful filters will automatically re-evaluate whenever you change the timezone
				 * or locale settings, but may negatively impact performance. true by default.
				 */
				statefulFilters: true
			})

		/**
		 * @ngdoc object
		 * @name angularMoment.object:moment
		 *
		 * @description
		 * moment global (as provided by the moment.js library)
		 */
			.constant('moment', moment)

		/**
		 * @ngdoc object
		 * @name angularMoment.config:amTimeAgoConfig
		 * @module angularMoment
		 *
		 * @description
		 * configuration specific to the amTimeAgo directive
		 */
			.constant('amTimeAgoConfig', {
				/**
				 * @ngdoc property
				 * @name angularMoment.config.amTimeAgoConfig#withoutSuffix
				 * @propertyOf angularMoment.config:amTimeAgoConfig
				 * @returns {boolean} Whether to include a suffix in am-time-ago directive
				 *
				 * @description
				 * Defaults to false.
				 */
				withoutSuffix: false,

				/**
				 * @ngdoc property
				 * @name angularMoment.config.amTimeAgoConfig#serverTime
				 * @propertyOf angularMoment.config:amTimeAgoConfig
				 * @returns {number} Server time in milliseconds since the epoch
				 *
				 * @description
				 * If set, time ago will be calculated relative to the given value.
				 * If null, local time will be used. Defaults to null.
				 */
				serverTime: null,

				/**
				 * @ngdoc property
				 * @name angularMoment.config.amTimeAgoConfig#titleFormat
				 * @propertyOf angularMoment.config:amTimeAgoConfig
				 * @returns {string} The format of the date to be displayed in the title of the element. If null,
				 *        the directive set the title of the element.
				 *
				 * @description
				 * The format of the date used for the title of the element. null by default.
				 */
				titleFormat: null,

				/**
				 * @ngdoc property
				 * @name angularMoment.config.amTimeAgoConfig#fullDateThreshold
				 * @propertyOf angularMoment.config:amTimeAgoConfig
				 * @returns {number} The minimum number of days for showing a full date instead of relative time
				 *
				 * @description
				 * The threshold for displaying a full date. The default is null, which means the date will always
				 * be relative, and full date will never be displayed.
				 */
				fullDateThreshold: null,

				/**
				 * @ngdoc property
				 * @name angularMoment.config.amTimeAgoConfig#fullDateFormat
				 * @propertyOf angularMoment.config:amTimeAgoConfig
				 * @returns {string} The format to use when displaying a full date.
				 *
				 * @description
				 * Specify the format of the date when displayed as full date. null by default.
				 */
				fullDateFormat: null,

				fullDateThresholdUnit: 'day'
			})

		/**
		 * @ngdoc directive
		 * @name angularMoment.directive:amTimeAgo
		 * @module angularMoment
		 *
		 * @restrict A
		 */
			.directive('amTimeAgo', ['$window', 'moment', 'amMoment', 'amTimeAgoConfig', function ($window, moment, amMoment, amTimeAgoConfig) {

				return function (scope, element, attr) {
					var activeTimeout = null;
					var currentValue;
					var withoutSuffix = amTimeAgoConfig.withoutSuffix;
					var titleFormat = amTimeAgoConfig.titleFormat;
					var fullDateThreshold = amTimeAgoConfig.fullDateThreshold;
					var fullDateFormat = amTimeAgoConfig.fullDateFormat;
					var fullDateThresholdUnit = amTimeAgoConfig.fullDateThresholdUnit;

					var localDate = new Date().getTime();
					var modelName = attr.amTimeAgo;
					var currentFrom;
					var isTimeElement = ('TIME' === element[0].nodeName.toUpperCase());
					var setTitleTime = !element.attr('title');

					function getNow() {
						var now;
						if (currentFrom) {
							now = currentFrom;
						} else if (amTimeAgoConfig.serverTime) {
							var localNow = new Date().getTime();
							var nowMillis = localNow - localDate + amTimeAgoConfig.serverTime;
							now = moment(nowMillis);
						}
						else {
							now = moment();
						}
						return now;
					}

					function cancelTimer() {
						if (activeTimeout) {
							$window.clearTimeout(activeTimeout);
							activeTimeout = null;
						}
					}

					function updateTime(momentInstance) {
						var timeAgo = getNow().diff(momentInstance, fullDateThresholdUnit);
						var showFullDate = fullDateThreshold && timeAgo >= fullDateThreshold;

						if (showFullDate) {
							element.text(momentInstance.format(fullDateFormat));
						} else {
							element.text(momentInstance.from(getNow(), withoutSuffix));
						}

						if (titleFormat && setTitleTime) {
							element.attr('title', momentInstance.format(titleFormat));
						}

						if (!showFullDate) {
							var howOld = Math.abs(getNow().diff(momentInstance, 'minute'));
							var secondsUntilUpdate = 3600;
							if (howOld < 1) {
								secondsUntilUpdate = 1;
							} else if (howOld < 60) {
								secondsUntilUpdate = 30;
							} else if (howOld < 180) {
								secondsUntilUpdate = 300;
							}

							activeTimeout = $window.setTimeout(function () {
								updateTime(momentInstance);
							}, secondsUntilUpdate * 1000);
						}
					}

					function updateDateTimeAttr(value) {
						if (isTimeElement) {
							element.attr('datetime', value);
						}
					}

					function updateMoment() {
						cancelTimer();
						if (currentValue) {
							var momentValue = amMoment.preprocessDate(currentValue);
							updateTime(momentValue);
							updateDateTimeAttr(momentValue.toISOString());
						}
					}

					scope.$watch(modelName, function (value) {
						if (isUndefinedOrNull(value) || (value === '')) {
							cancelTimer();
							if (currentValue) {
								element.text('');
								updateDateTimeAttr('');
								currentValue = null;
							}
							return;
						}

						currentValue = value;
						updateMoment();
					});

					if (angular.isDefined(attr.amFrom)) {
						scope.$watch(attr.amFrom, function (value) {
							if (isUndefinedOrNull(value) || (value === '')) {
								currentFrom = null;
							} else {
								currentFrom = moment(value);
							}
							updateMoment();
						});
					}

					if (angular.isDefined(attr.amWithoutSuffix)) {
						scope.$watch(attr.amWithoutSuffix, function (value) {
							if (typeof value === 'boolean') {
								withoutSuffix = value;
								updateMoment();
							} else {
								withoutSuffix = amTimeAgoConfig.withoutSuffix;
							}
						});
					}

					attr.$observe('amFullDateThreshold', function (newValue) {
						fullDateThreshold = newValue;
						updateMoment();
					});

					attr.$observe('amFullDateFormat', function (newValue) {
						fullDateFormat = newValue;
						updateMoment();
					});

					attr.$observe('amFullDateThresholdUnit', function (newValue) {
						fullDateThresholdUnit = newValue;
						updateMoment();
					});

					scope.$on('$destroy', function () {
						cancelTimer();
					});

					scope.$on('amMoment:localeChanged', function () {
						updateMoment();
					});
				};
			}])

		/**
		 * @ngdoc service
		 * @name angularMoment.service.amMoment
		 * @module angularMoment
		 */
			.service('amMoment', ['moment', '$rootScope', '$log', 'angularMomentConfig', function (moment, $rootScope, $log, angularMomentConfig) {
				var defaultTimezone = null;

				/**
				 * @ngdoc function
				 * @name angularMoment.service.amMoment#changeLocale
				 * @methodOf angularMoment.service.amMoment
				 *
				 * @description
				 * Changes the locale for moment.js and updates all the am-time-ago directive instances
				 * with the new locale. Also broadcasts an `amMoment:localeChanged` event on $rootScope.
				 *
				 * @param {string} locale Locale code (e.g. en, es, ru, pt-br, etc.)
				 * @param {object} customization object of locale strings to override
				 */
				this.changeLocale = function (locale, customization) {
					var result = moment.locale(locale, customization);
					if (angular.isDefined(locale)) {
						$rootScope.$broadcast('amMoment:localeChanged');

					}
					return result;
				};

				/**
				 * @ngdoc function
				 * @name angularMoment.service.amMoment#changeTimezone
				 * @methodOf angularMoment.service.amMoment
				 *
				 * @description
				 * Changes the default timezone for amCalendar, amDateFormat and amTimeAgo. Also broadcasts an
				 * `amMoment:timezoneChanged` event on $rootScope.
				 *
				 * Note: this method works only if moment-timezone > 0.3.0 is loaded
				 *
				 * @param {string} timezone Timezone name (e.g. UTC)
				 */
				this.changeTimezone = function (timezone) {
					if (moment.tz && moment.tz.setDefault) {
						moment.tz.setDefault(timezone);
						$rootScope.$broadcast('amMoment:timezoneChanged');
					} else {
						$log.warn('angular-moment: changeTimezone() works only with moment-timezone.js v0.3.0 or greater.');
					}
					angularMomentConfig.timezone = timezone;
					defaultTimezone = timezone;
				};

				/**
				 * @ngdoc function
				 * @name angularMoment.service.amMoment#preprocessDate
				 * @methodOf angularMoment.service.amMoment
				 *
				 * @description
				 * Preprocess a given value and convert it into a Moment instance appropriate for use in the
				 * am-time-ago directive and the filters. The behavior of this function can be overriden by
				 * setting `angularMomentConfig.preprocess`.
				 *
				 * @param {*} value The value to be preprocessed
				 * @return {Moment} A `moment` object
				 */
				this.preprocessDate = function (value) {
					// Configure the default timezone if needed
					if (defaultTimezone !== angularMomentConfig.timezone) {
						this.changeTimezone(angularMomentConfig.timezone);
					}

					if (angularMomentConfig.preprocess) {
						return angularMomentConfig.preprocess(value);
					}

					if (!isNaN(parseFloat(value)) && isFinite(value)) {
						// Milliseconds since the epoch
						return moment(parseInt(value, 10));
					}

					// else just returns the value as-is.
					return moment(value);
				};
			}])

		/**
		 * @ngdoc filter
		 * @name angularMoment.filter:amParse
		 * @module angularMoment
		 */
			.filter('amParse', ['moment', function (moment) {
				return function (value, format) {
					return moment(value, format);
				};
			}])

		/**
		 * @ngdoc filter
		 * @name angularMoment.filter:amFromUnix
		 * @module angularMoment
		 */
			.filter('amFromUnix', ['moment', function (moment) {
				return function (value) {
					return moment.unix(value);
				};
			}])

		/**
		 * @ngdoc filter
		 * @name angularMoment.filter:amUtc
		 * @module angularMoment
		 */
			.filter('amUtc', ['moment', function (moment) {
				return function (value) {
					return moment.utc(value);
				};
			}])

		/**
		 * @ngdoc filter
		 * @name angularMoment.filter:amUtcOffset
		 * @module angularMoment
		 *
		 * @description
		 * Adds a UTC offset to the given timezone object. The offset can be a number of minutes, or a string such as
		 * '+0300', '-0300' or 'Z'.
		 */
			.filter('amUtcOffset', ['amMoment', function (amMoment) {
				function amUtcOffset(value, offset) {
					return amMoment.preprocessDate(value).utcOffset(offset);
				}

				return amUtcOffset;
			}])

		/**
		 * @ngdoc filter
		 * @name angularMoment.filter:amLocal
		 * @module angularMoment
		 */
			.filter('amLocal', ['moment', function (moment) {
				return function (value) {
					return moment.isMoment(value) ? value.local() : null;
				};
			}])

		/**
		 * @ngdoc filter
		 * @name angularMoment.filter:amTimezone
		 * @module angularMoment
		 *
		 * @description
		 * Apply a timezone onto a given moment object, e.g. 'America/Phoenix').
		 *
		 * You need to include moment-timezone.js for timezone support.
		 */
			.filter('amTimezone', ['amMoment', 'angularMomentConfig', '$log', function (amMoment, angularMomentConfig, $log) {
				function amTimezone(value, timezone) {
					var aMoment = amMoment.preprocessDate(value);

					if (!timezone) {
						return aMoment;
					}

					if (aMoment.tz) {
						return aMoment.tz(timezone);
					} else {
						$log.warn('angular-moment: named timezone specified but moment.tz() is undefined. Did you forget to include moment-timezone.js ?');
						return aMoment;
					}
				}

				return amTimezone;
			}])

		/**
		 * @ngdoc filter
		 * @name angularMoment.filter:amCalendar
		 * @module angularMoment
		 */
			.filter('amCalendar', ['moment', 'amMoment', 'angularMomentConfig', function (moment, amMoment, angularMomentConfig) {
				function amCalendarFilter(value, referenceTime, formats) {
					if (isUndefinedOrNull(value)) {
						return '';
					}

					var date = amMoment.preprocessDate(value);
					return date.isValid() ? date.calendar(referenceTime, formats) : '';
				}

				// Since AngularJS 1.3, filters have to explicitly define being stateful
				// (this is no longer the default).
				amCalendarFilter.$stateful = angularMomentConfig.statefulFilters;

				return amCalendarFilter;
			}])

		/**
		 * @ngdoc filter
		 * @name angularMoment.filter:amDifference
		 * @module angularMoment
		 */
			.filter('amDifference', ['moment', 'amMoment', 'angularMomentConfig', function (moment, amMoment, angularMomentConfig) {
				function amDifferenceFilter(value, otherValue, unit, usePrecision) {
					if (isUndefinedOrNull(value)) {
						return '';
					}

					var date = amMoment.preprocessDate(value);
					var date2 = !isUndefinedOrNull(otherValue) ? amMoment.preprocessDate(otherValue) : moment();

					if (!date.isValid() || !date2.isValid()) {
						return '';
					}

					return date.diff(date2, unit, usePrecision);
				}

				amDifferenceFilter.$stateful = angularMomentConfig.statefulFilters;

				return amDifferenceFilter;
			}])

		/**
		 * @ngdoc filter
		 * @name angularMoment.filter:amDateFormat
		 * @module angularMoment
		 * @function
		 */
			.filter('amDateFormat', ['moment', 'amMoment', 'angularMomentConfig', function (moment, amMoment, angularMomentConfig) {
				function amDateFormatFilter(value, format) {
					if (isUndefinedOrNull(value)) {
						return '';
					}

					var date = amMoment.preprocessDate(value);
					if (!date.isValid()) {
						return '';
					}

					return date.format(format);
				}

				amDateFormatFilter.$stateful = angularMomentConfig.statefulFilters;

				return amDateFormatFilter;
			}])

		/**
		 * @ngdoc filter
		 * @name angularMoment.filter:amDurationFormat
		 * @module angularMoment
		 * @function
		 */
			.filter('amDurationFormat', ['moment', 'angularMomentConfig', function (moment, angularMomentConfig) {
				function amDurationFormatFilter(value, format, suffix) {
					if (isUndefinedOrNull(value)) {
						return '';
					}

					return moment.duration(value, format).humanize(suffix);
				}

				amDurationFormatFilter.$stateful = angularMomentConfig.statefulFilters;

				return amDurationFormatFilter;
			}])

		/**
		 * @ngdoc filter
		 * @name angularMoment.filter:amTimeAgo
		 * @module angularMoment
		 * @function
		 */
			.filter('amTimeAgo', ['moment', 'amMoment', 'angularMomentConfig', function (moment, amMoment, angularMomentConfig) {
				function amTimeAgoFilter(value, suffix, from) {
					var date, dateFrom;

					if (isUndefinedOrNull(value)) {
						return '';
					}

					value = amMoment.preprocessDate(value);
					date = moment(value);
					if (!date.isValid()) {
						return '';
					}

					dateFrom = moment(from);
					if (!isUndefinedOrNull(from) && dateFrom.isValid()) {
						return date.from(dateFrom, suffix);
					}

					return date.fromNow(suffix);
				}

				amTimeAgoFilter.$stateful = angularMomentConfig.statefulFilters;

				return amTimeAgoFilter;
			}])

		/**
		 * @ngdoc filter
		 * @name angularMoment.filter:amSubtract
		 * @module angularMoment
		 * @function
		 */
			.filter('amSubtract', ['moment', 'angularMomentConfig', function (moment, angularMomentConfig) {
				function amSubtractFilter(value, amount, type) {

					if (isUndefinedOrNull(value)) {
						return '';
					}

					return moment(value).subtract(parseInt(amount, 10), type);
				}

				amSubtractFilter.$stateful = angularMomentConfig.statefulFilters;

				return amSubtractFilter;
			}])

		/**
		 * @ngdoc filter
		 * @name angularMoment.filter:amAdd
		 * @module angularMoment
		 * @function
		 */
			.filter('amAdd', ['moment', 'angularMomentConfig', function (moment, angularMomentConfig) {
				function amAddFilter(value, amount, type) {

					if (isUndefinedOrNull(value)) {
						return '';
					}

					return moment(value).add(parseInt(amount, 10), type);
				}

				amAddFilter.$stateful = angularMomentConfig.statefulFilters;

				return amAddFilter;
			}])

		/**
		 * @ngdoc filter
		 * @name angularMoment.filter:amStartOf
		 * @module angularMoment
		 * @function
		 */
			.filter('amStartOf', ['moment', 'angularMomentConfig', function (moment, angularMomentConfig) {
				function amStartOfFilter(value, type) {

					if (isUndefinedOrNull(value)) {
						return '';
					}

					return moment(value).startOf(type);
				}

				amStartOfFilter.$stateful = angularMomentConfig.statefulFilters;

				return amStartOfFilter;
			}])

		/**
		 * @ngdoc filter
		 * @name angularMoment.filter:amEndOf
		 * @module angularMoment
		 * @function
		 */
			.filter('amEndOf', ['moment', 'angularMomentConfig', function (moment, angularMomentConfig) {
				function amEndOfFilter(value, type) {

					if (isUndefinedOrNull(value)) {
						return '';
					}

					return moment(value).endOf(type);
				}

				amEndOfFilter.$stateful = angularMomentConfig.statefulFilters;

				return amEndOfFilter;
 			}]);

		return 'angularMoment';
	}

	var isElectron = window && window.process && window.process.type;
	if (typeof define === 'function' && define.amd) {
		define(['angular', 'moment'], angularMoment);
	} else if (typeof module !== 'undefined' && module && module.exports && (typeof require === 'function') && !isElectron) {
		module.exports = angularMoment(require('angular'), require('moment'));
	} else {
		angularMoment(angular, (typeof global !== 'undefined' && typeof global.moment !== 'undefined' ? global : window).moment);
	}
})();
;// https://github.com/awerlang/angular-responsive-tables
!function(){"use strict";function getFirstHeaderInRow(tr){for(var th=tr.firstChild;th&&"TH"!==th.tagName;){if("TD"===th.tagName){th=null;break}th=th.nextSibling}return th}function getHeaders(element){return[].filter.call(element.children().children().children(),function(it){return"TH"===it.tagName})}function updateTitle(td,th){var title=th&&th.textContent;!title||!td.getAttribute("data-title-override")&&td.getAttribute("data-title")||(td.setAttribute("data-title",title),td.setAttribute("data-title-override",title))}function colspan(td){var colspan=td.getAttribute("colspan");return colspan?parseInt(colspan):1}function wtResponsiveTable(){return{restrict:"A",controller:["$element",function($element){angular.extend(this,{contains:function(td){var tableEl=$element[0],el=td;do{if(el===tableEl)return!0;if("TABLE"===el.tagName)return!1;el=el.parentElement}while(el);throw new Error("Table element not found for "+td)},getHeader:function(td){var firstHeader=getFirstHeaderInRow(td.parentElement);if(firstHeader)return firstHeader;var headers=getHeaders($element);if(headers.length){var row=td.parentElement,headerIndex=0,found=Array.prototype.some.call(row.children,function(value,index){return"TD"!==value.tagName?!1:value===td?!0:void(headerIndex+=colspan(value))});return found?headers[headerIndex]:null}}})}],compile:function(element,attrs){element.addClass("responsive");var headers=getHeaders(element);if(headers.length){var rows=[].filter.call(element.children(),function(it){return"TBODY"===it.tagName})[0].children;Array.prototype.forEach.call(rows,function(row){var headerIndex=0;[].forEach.call(row.children,function(value,index){if("TD"===value.tagName){var th=getFirstHeaderInRow(value.parentElement);th=th||headers[headerIndex],updateTitle(value,th),headerIndex+=colspan(value)}})})}}}}function wtResponsiveDynamic(){return{restrict:"E",require:"?^^wtResponsiveTable",link:function(scope,element,attrs,tableCtrl){tableCtrl&&tableCtrl.contains(element[0])&&setTimeout(function(){[].forEach.call(element[0].parentElement.children,function(td){if("TD"===td.tagName){var th=tableCtrl.getHeader(td);updateTitle(td,th)}})},0)}}}angular.module("wt.responsive",[]).directive("wtResponsiveTable",[wtResponsiveTable]).directive("td",[wtResponsiveDynamic])}();;var App = {
    MODULE_NAME: "mapfre",
    URL_BASE: "/MapCotizador/api/", //CUALQUIER URL
    VERSION: "v5.4",
};

var Tabs = {
    "propuesta": {
        "porcentaje": undefined,
        "estado": "UNDEFINED"
    },
    "vehiculo": {
        "porcentaje": undefined,
        "estado": "UNDEFINED"
    },
    "tomador": {
        "porcentaje": undefined,
        "estado": "UNDEFINED"
    },
    "asegurado": {
        "porcentaje": undefined,
        "estado": "UNDEFINED"
    },
    "hojaAnexa": {
        "porcentaje": undefined,
        "estado": "UNDEFINED"
    },
    "documento": {
        "porcentaje": undefined,
        "estado": "UNDEFINED"
    },
    "riesgo": {
        "porcentaje": undefined,
        "estado": "UNDEFINED"
    },
    "hogar": {
        "porcentaje": undefined,
        "estado": "UNDEFINED"
    },
    "multiriesgo": {
        "porcentaje": undefined,
        "estado": "UNDEFINED"
    }
};

var UrlImpresiones = {
    "Vehiculo": {
        "cartaOferta": App.URL_BASE+"impresion/vehiculo/cartaoferta",
        "cartaPropuesta":App.URL_BASE+'impresion/vehiculo/propuesta',
        "cartaCobertura":App.URL_BASE+"impresion/certificadocobertura",
        "cartaVerde":App.URL_BASE+"impresion/cartaverde",
    },
    "Flota": {
        "cartaOferta": App.URL_BASE+"impresion/flota/cartaoferta",
        "cartaPropuesta":App.URL_BASE+'impresion/propuesta',
        "cartaCobertura":App.URL_BASE+"impresion/certificadocobertura",
        "cartaVerde":App.URL_BASE+"impresion/cartaverde",
    },
     "Hogar": {
        "cartaOferta": App.URL_BASE+"impresion/hogar/cartaoferta",
        "cartaPropuesta":App.URL_BASE+'impresion/propuesta',
        "cartaCobertura":App.URL_BASE+"impresion/certificadocobertura",
        "cartaVerde":App.URL_BASE+"impresion/cartaverde",
        "imprimirFormulario":App.URL_BASE+"impresion/propuesta",
    },
    "Propuesta Hogar": {
        "cartaOferta": App.URL_BASE+"impresion/hogar/cartaoferta",
        "cartaPropuesta":App.URL_BASE+'impresion/propuesta',
        "cartaCobertura":App.URL_BASE+"impresion/certificadocobertura",
        "cartaVerde":App.URL_BASE+"impresion/cartaverde",
        "imprimirFormulario":App.URL_BASE+"impresion/propuesta",
    },
     "Multiriesgos": {
        "cartaOferta": App.URL_BASE+"impresion/multirriesgo/cartaoferta",
        "cartaPropuesta":App.URL_BASE+'impresion/propuesta',
        "cartaCobertura":App.URL_BASE+"impresion/certificadocobertura",
        "cartaVerde":App.URL_BASE+"impresion/cartaverde",
    }
   

};
;var Menu = [
    {
        modulo: "cotizador",
        moduloTitulo : "COTIZADOR",
        moduloIcono : "fa fa-calculator",
        componentes: [
            {   
                titulo: "VEHICULO",
                icono: "fa fa-car",
                url: "cotizacion-vehiculo/"
            },
            {   
                titulo: "FLOTA",
                icono: "fa fa-car",
                imagen: "images/flota1.png",
                url: "flota/"
            },
             {   
                titulo: "HOGAR",
                icono: "fa fa-car",
                url: "cotizacion-hogar/"
            }
        ]
    },    
    {
        modulo: "propuesta",
        moduloTitulo : "PROPUESTA",
        moduloIcono : "fa fa-file",
        componentes: [
            {   
                titulo: "VEHICULO",
                icono: "fa fa-car",
                url: "propuesta-vehiculo/propuesta"
            },
            {   
                titulo: "FLOTA",
                icono: "fa fa-car",
                imagen: "images/flota1.png",
                url: "propuesta-flota/propuesta"
            }
        ]
	}
    ,
	{
        modulo: "preferencia",
        moduloTitulo : "CONFIGURACIONES",
        moduloIcono : "fa fa-cog",
        componentes: [
            {   
                titulo: "PREFERENCIAS",
                icono: "fa fa-asterisk",
                url: "preferencia"
            }
        ]
    },
	{
        modulo: "suplemento",
        moduloTitulo : "SUPLEMENTO",
        moduloIcono : "fa fa-book",
		url: "suplemento",
        componentes: [
            
        ],
		
    }
];

;/*
 * App setup del proyecto, se registra el módulo y sus depenencias
 */
var app = angular.module(App.MODULE_NAME, ['ngRoute', 'ngTasty', 'ngMaterial', 'ngAnimate','smart-table', 'ngFileUpload','angularMoment','wt.responsive']);
;/*
 * Se configuran las rutas de la aplicación
 */
app.config([
    '$routeProvider', '$httpProvider', '$controllerProvider', '$compileProvider', '$filterProvider', '$provide','$locationProvider','$logProvider',
    function($routeProvider, $httpProvider, $controllerProvider, $compileProvider, $filterProvider, $provide, $locationProvider, $logProvider) {


        app.register = {
            controller: $controllerProvider.register,
            directive: $compileProvider.directive,
            filter: $filterProvider.register,
            factory: $provide.factory,
            service: $provide.service
        };
        $logProvider.debugEnabled(true); /**cuando esta en true apareceran los mensajes, si es false no aparece mas**/

        /*
         * Se registran los interceptors de keycloak.
         */
        //$httpProvider.interceptors.push('errorInterceptor');
        //$httpProvider.interceptors.push('authInterceptor');
        var interceptor = ['$q', '$window', '$location', '$injector', function($q, $window, $location, $injector) {
            return {
                request: function (config) {
                    if (config.url.indexOf("login")==-1 && config.url.indexOf("api")!=-1){
                        var canceller = $q.defer();

                        /*$injector.get("SessionService").permiso($window.sessionStorage["token"]).then(function(response){
                            console.log(response);
                            //return true;
                            console.log(config);

                        });;*/
                        //console.log(auth);
                        config.headers["Authorization"] = "Bearer " + $window.sessionStorage["token"];
                        config.headers["Access-Control-Allow-Origin"] = "*";
                        config.headers["Access-Control-Allow-Methods"] = "GET, POST, OPTIONS, PUT, PATCH, DELETE";
                        config.headers["Access-Control-Allow-Headers"] = "X-Requested-With,content-type";
                        config.headers["Accept"]="application/json, text/plain, text/html, application/pdf";
                        config.headers["Access-Control-Allow-Credentials"] = "true";
                    }
                    //config.url("");

                    return config;
                },

                requestError: function(rejection) {
                    return $q.reject(rejection);
                },

                response: function (response) {
                    var tokenValid= response.headers("jwt-valid");
                  
                    /**
                    llamar al servicio de token y actualizar el nuevo token, en caso que el tokenValid sea false**/
                    if (tokenValid=="False")
                    {
                        var countLlamadas=countRefreshToken();
                            if (countLlamadas==1)
                            {

                                actualizarToken().then(function(response)
                                {
                                    if (!response.data.error)
                                    {
                                        if (response.data.token !=null)
                                        {
                                            $window.sessionStorage["token"] = response.data.token;
                                        }
                                    }
                                    else
                                    {
                                        Message.error(response.data.mensaje);
                                    }
                                });
                            }
                            
                        

                        return response || $q.when(response);

                    }
                    else
                    {

                        resetRefreshToken();
                        return response || $q.when(response);
                    }



                },

                // Revoke client authentication if 401 is received

                responseError: function(rejection) {
                    if (rejection.status == 401){
                        $window.sessionStorage.clear();
                        $location.path("/login");
                    }else if(rejection.status == 403){
                        $window.sessionStorage.clear();
                        $location.path("/login");
                    }else{
                        return $q.reject(rejection);
                    }
                }
            };
        }];

        $httpProvider.interceptors.push(interceptor);

        /*
         * Route resolver que se utiliza para restringir las páginas que necesitan
         * que el usuario este logeado en el sistema para acceder a al misma.
         */
        var resolve = {
            /***ACCESO A PAGINAS PRIVADAS ****/
            init: [ '$window', '$location', function ($window, $location) {
                //console.log("Este es el token = "+$window.sessionStorage.token);
                if (typeof $window.sessionStorage.token == 'undefined') {
                    $location.url("login");
                }
            }]
        };

        /*
         * Route resolver que se utiliza para evitar que se accedan a páginas de caracter público
         * cuando el usuario está logeado.
         */
        var publicResolve = {

            /***ACCESO A PAGINAS PUBLICAS ****/
            /*
            init: ['keycloakLauncher', '$location', function (keycloakLauncher, $location) {
                if (keycloakLauncher.loggedIn) {
                    $location.url("/dashboard");
                }
            }]
            */
        };




        var _isNotMobile = (function() {
            var check = false;
            var plataforma ='';
            (function(a){
                if(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|ipad|iris|kindle|Android|Silk|lge |maemo|midp|mmp|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i.test(navigator.userAgent)
                    || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(navigator.userAgent.substr(0,4)))
                    check = true
            })(navigator.userAgent||navigator.vendor||window.opera);
            if (check == false){
                plataforma ='desktop';

            }else{
                plataforma ='mobile';
            }
            return plataforma;
        })();
       var path = (_isNotMobile);


       
        /*
         * Se definen las rutas de la aplicación
         */
        $routeProvider
            .when('/', {
                templateUrl: 'partials/login/login.html',
                controller: 'LoginCtrl',
                resolve: resolve
            })
            .when('/dashboard', {
                templateUrl: 'partials/dashboard-partial.html',
                controller:'HeaderCtrl',
                resolve: resolve
            })
            .when('/prueba', {
                templateUrl: 'partials/dashboard-partial.html',
                resolve: resolve
            })


            /****** PROPUESTA ******/
            			
			/*Propuesta vehiculos
			*/
			.when('/propuesta-vehiculo', {
                templateUrl: 'partials/propuesta-vehiculo/desktop/propuesta-vehiculo-form.html',
                controller: 'PropuestaVehiculoFormCtrl',
                subtipo:'Vehículos',
                resolve: resolve
            })
            .when('/propuesta-vehiculo/vehiculo', {
                templateUrl: 'partials/propuesta-vehiculo/desktop/vehiculo-form.html',
                controller: 'VehiculoFormCtrl',
                subtipo:'Vehiculos',
                resolve: resolve
            })

            /**
             * SE COMENTA PARA PODER PROBAR LA NAVEGACION ENTRE MODULOS DESDE LA VERSION MOBILE
             */
            /* .when('/propuesta-vehiculo/propuesta', {
                templateUrl: 'partials/propuesta-vehiculo/'+path+'/propuesta-vehiculo-form.html',
                controller: 'PropuestaVehiculoFormCtrl',
                subtipo: 'Vehiculos',
                resolve: resolve
            })
            .when('/propuesta-vehiculo/propuesta/:numeroCotizacion', {
                templateUrl: 'partials/propuesta-vehiculo/'+path+'/propuesta-vehiculo-form.html',
                controller: 'PropuestaVehiculoFormCtrl',
                subtipo: 'Vehiculos',
                resolve: resolve
            }) */

            
            .when('/propuesta-vehiculo/propuesta', {
                templateUrl: 'partials/propuesta-vehiculo/desktop/propuesta-vehiculo-form.html',
                controller: 'PropuestaVehiculoFormCtrl',
                subtipo: 'Vehiculos',
                resolve: resolve
            })
            .when('/propuesta-vehiculo/propuesta/:numeroCotizacion', {
                templateUrl: 'partials/propuesta-vehiculo/desktop/propuesta-vehiculo-form.html',
                controller: 'PropuestaVehiculoFormCtrl',
                subtipo: 'Vehiculos',
                resolve: resolve
            })
            .when('/propuesta-vehiculo/propuesta/bcp/:numeroCotizacion', {
                templateUrl: 'partials/propuesta-vehiculo/desktop/propuesta-vehiculo-bcp.html',
                controller: 'PropuestaVehiculoBCPCtrl',
                subtipo: 'Vehiculos',
                resolve: resolve
            })
            .when('/propuesta-vehiculo/vehiculo/bcp/:numeroCotizacion', {
                templateUrl: 'partials/propuesta-vehiculo/desktop/propuesta-vehiculo-bcp.html',
                controller: 'PropuestaVehiculoBCPCtrl',
                subtipo: 'Vehiculos',
                resolve: resolve
            })
            .when('/propuesta-vehiculo/tomador/bcp/:numeroCotizacion', {
                templateUrl: 'partials/propuesta-vehiculo/desktop/propuesta-vehiculo-bcp.html',
                controller: 'PropuestaVehiculoBCPCtrl',
                subtipo: 'Vehiculos',
                resolve: resolve
            })
            .when('/propuesta-vehiculo/asegurado/bcp/:numeroCotizacion', {
                templateUrl: 'partials/propuesta-vehiculo/desktop/propuesta-vehiculo-bcp.html',
                controller: 'PropuestaVehiculoBCPCtrl',
                subtipo: 'Vehiculos',
                resolve: resolve
            })
            .when('/propuesta-vehiculo/hojas-anexas/bcp/:numeroCotizacion', {
                templateUrl: 'partials/propuesta-vehiculo/desktop/propuesta-vehiculo-bcp.html',
                controller: 'PropuestaVehiculoBCPCtrl',
                subtipo: 'Vehiculos',
                resolve: resolve
            })
            .when('/propuesta-vehiculo/documentos/bcp/:numeroCotizacion', {
                templateUrl: 'partials/propuesta-vehiculo/desktop/propuesta-vehiculo-bcp.html',
                controller: 'PropuestaVehiculoBCPCtrl',
                subtipo: 'Vehiculos',
                resolve: resolve
            })



            .when('/propuesta-vehiculo/tomador', {
                templateUrl: 'partials/propuesta-flota/desktop/tomador-form.html',
                controller: 'TomadorFormCtrl',
                tipo: 'Tomador',
                subtipo:'Vehiculos',
                resolve: resolve
            })
            .when('/propuesta-vehiculo/asegurado', {
                templateUrl: 'partials/propuesta-flota/desktop/tomador-form.html',
                controller: 'TomadorFormCtrl',
                tipo: 'Asegurado',
                subtipo:'Vehiculos',
                resolve: resolve
            })
            .when('/propuesta-vehiculo/hojas-anexas', {
                templateUrl: 'partials/propuesta-flota/desktop/hojas-anexas-form.html',
                controller: 'HojasAnexasFormCtrl',
                subtipo:'Vehiculos',
                resolve: resolve
            })
            .when('/propuesta-vehiculo/documentos', {
                templateUrl: 'partials/propuesta-flota/desktop/documentos-form.html',
                controller: 'DocumentosFormCtrl',
                subtipo:'Vehiculos', 
                resolve: resolve
            })
            
            /*Flota
             */
            .when('/propuesta-flota', {
                templateUrl: 'partials/propuesta-vehiculo/desktop/propuesta-vehiculo-form.html',
                controller: 'PropuestaVehiculoFormCtrl',    
                subtipo:'Flota', 
                resolve: resolve
                
            })
            .when('/propuesta-flota/vehiculo', {
                templateUrl: 'partials/propuesta-vehiculo/desktop/vehiculo-form.html',
                controller: 'VehiculoFormCtrl',
                subtipo:'Flota',
                resolve: resolve
            })
           
            .when('/propuesta-flota/riesgo', {
                templateUrl: 'partials/propuesta-flota/desktop/riesgo-form.html',
                controller: 'RiesgoFormCtrl',
                subtipo:'Flota',
                resolve: resolve
            })
            .when('/propuesta-flota/riesgo-agregar', {
                templateUrl: 'partials/propuesta-flota/desktop/riesgo-agregar-form.html',
                controller: 'RiesgoAgregarFormCtrl',
                subtipo:'Flota',
                resolve: resolve
            })
            .when('/propuesta-flota/propuesta', {
                templateUrl: 'partials/propuesta-vehiculo/desktop/propuesta-vehiculo-form.html',
                controller: 'PropuestaVehiculoFormCtrl',
                tipo: 'Propuesta',
                subtipo:'Flota', 
                resolve: resolve
            })
            
            .when('/propuesta-flota/propuesta/:numeroCotizacion', {
                templateUrl: 'partials/propuesta-vehiculo/desktop/propuesta-vehiculo-form.html',
                controller: 'PropuestaVehiculoFormCtrl',
                tipo: 'Propuesta',
                subtipo:'Flota', 
                resolve: resolve
            })
            .when('/propuesta-flota/tomador', {
                templateUrl: 'partials/propuesta-flota/desktop/tomador-form.html',
                controller: 'TomadorFormCtrl',
                tipo: 'Tomador',
                subtipo:'Flota',
                resolve: resolve
            })
            .when('/propuesta-flota/asegurado', {
                templateUrl: 'partials/propuesta-flota/desktop/asegurado-flota-form.html',
                controller: 'AseguradoFlotaFormCtrl',
                tipo: 'Asegurado',
                subtipo:'Flota',
                resolve: resolve
            })
            .when('/propuesta-flota/asegurado-agregar', {
                templateUrl: 'partials/propuesta-flota/desktop/tomador-form.html',
                controller: 'TomadorFormCtrl',
                tipo: 'Asegurado',
                subtipo:'Flota',
                resolve: resolve
            })
            .when('/propuesta-flota/hojas-anexas', {
                templateUrl: 'partials/propuesta-flota/desktop/hojas-anexas-form.html',
                controller: 'HojasAnexasFormCtrl',
                subtipo:'Flota',
                resolve: resolve
            })
            .when('/propuesta-flota/documentos', {
                templateUrl: 'partials/propuesta-flota/desktop/documentos-form.html',
                controller: 'DocumentosFormCtrl',
                subtipo:'Flota', 
                resolve: resolve
            })
            //bcp propuesta flota
            .when('/propuesta-flota/propuesta/bcp/:numeroCotizacion', {
                templateUrl: 'partials/propuesta-vehiculo/desktop/propuesta-vehiculo-bcp.html',
                controller: 'PropuestaVehiculoBCPCtrl',
                subtipo: 'Vehiculos',
                resolve: resolve
            })
            .when('/propuesta-flota/riesgo/bcp/:numeroCotizacion', {
                templateUrl: 'partials/propuesta-vehiculo/desktop/propuesta-vehiculo-bcp.html',
                controller: 'PropuestaVehiculoBCPCtrl',
                subtipo: 'Vehiculos',
                resolve: resolve
            })
            .when('/propuesta-flota/tomador/bcp/:numeroCotizacion', {
                templateUrl: 'partials/propuesta-vehiculo/desktop/propuesta-vehiculo-bcp.html',
                controller: 'PropuestaVehiculoBCPCtrl',
                subtipo: 'Vehiculos',
                resolve: resolve
            })
            .when('/propuesta-flota/asegurado/bcp/:numeroCotizacion', {
                templateUrl: 'partials/propuesta-vehiculo/desktop/propuesta-vehiculo-bcp.html',
                controller: 'PropuestaVehiculoBCPCtrl',
                subtipo: 'Vehiculos',
                resolve: resolve
            })
            .when('/propuesta-flota/hojas-anexas/bcp/:numeroCotizacion', {
                templateUrl: 'partials/propuesta-vehiculo/desktop/propuesta-vehiculo-bcp.html',
                controller: 'PropuestaVehiculoBCPCtrl',
                subtipo: 'Vehiculos',
                resolve: resolve
            })
            .when('/propuesta-flota/documentos/bcp/:numeroCotizacion', {
                templateUrl: 'partials/propuesta-vehiculo/desktop/propuesta-vehiculo-bcp.html',
                controller: 'PropuestaVehiculoBCPCtrl',
                subtipo: 'Vehiculos',
                resolve: resolve
            })




            
             .when('/login', {
                templateUrl: 'partials/login/login.html',
                controller: 'LoginCtrl',
                resolve: resolve
            })
              .when('/error403', {
                templateUrl: 'partials/pagina403.html',
               
                resolve: resolve
            })
            
            /****** PREFERENCIA ******/
            
            .when('/preferencia', {
                templateUrl: 'partials/preferencia/preferencia-list.html',
                controller: 'PreferenciaListCtrl',
                resolve: resolve
            })

            
            
            /****** SUPLEMENTO ******/
            .when('/suplemento', {
                templateUrl: 'partials/suplemento/suplemento-list.html',
                controller: 'SuplementoListCtrl',
                resolve: resolve
            })
            .when('/suplemento/:cotizacion/cambiar-auto', {
                templateUrl: 'partials/suplemento/suplemento-cambio-auto.html',
                controller: 'SuplementoCambioAutoCtrl', 
                resolve: resolve
            })
            .when('/suplemento/:cotizacion/anulacion', {
                templateUrl: 'partials/suplemento/suplemento-anulacion.html',
                controller: 'SuplementoAnulacionCtrl', 
                resolve: resolve
            })
            .when('/suplemento/:cotizacion/cambiar-auto/documentos', {
                templateUrl: 'partials/suplemento/suplemento-documentos.html',
                controller: 'SuplementoDocumentosCtrl',
                resolve: resolve
            })
            .when('/suplemento/:cotizacion/cambiar-auto/hojas-anexas', {
                templateUrl: 'partials/suplemento/suplemento-hojas-anexas.html',
                controller: 'SuplementoHojasAnexasCtrl',
                resolve: resolve
            })
            .when('/suplemento/:cotizacion/anulacion/documentos', {
                templateUrl: 'partials/suplemento/suplemento-documentos.html',
                controller: 'SuplementoDocumentosCtrl',
                resolve: resolve
            })
            
            /****** COTIZACION ******/
			.when('/cotizacion-vehiculo', {
                templateUrl: 'partials/cotizacion-vehiculo/'+path+'/cotizacion-vehiculo-form.html',
                controller: path=='desktop'?'CotizacionVehiculoFormCtrl': 'CotizacionVehiculoMobileFormCtrl',
                resolve: resolve
            })
            
            .when('/cotizacion-vehiculo/:numeroCotizacion', {
                templateUrl: 'partials/cotizacion-vehiculo/'+path+'/cotizacion-vehiculo-form.html',
                controller: path=='desktop'?'CotizacionVehiculoFormCtrl': 'CotizacionVehiculoMobileFormCtrl',
                resolve: resolve
            })
            .when('/cotizacion-vehiculo/bcp/:numeroCotizacion', {
                templateUrl: 'partials/propuesta-vehiculo/desktop/propuesta-vehiculo-bcp.html',
                controller: 'PropuestaVehiculoBCPCtrl',
                subtipo: 'Vehiculos',
                resolve: resolve
            })

            .when('/cotizacion-hogar', {
                templateUrl: 'partials/cotizacion-hogar/'+path+'/cotizacion-hogar-form.html',
                controller: path=='desktop'?'CotizacionHogarFormCtrl': 'CotizacionHogarMobileFormCtrl',
                subtipo: 'Hogar',
                resolve: resolve
            })

             .when('/cotizacion-hogar/:numeroCotizacion', {
                templateUrl: 'partials/cotizacion-hogar/'+path+'/cotizacion-hogar-form.html',
                controller: path=='desktop'?'CotizacionHogarFormCtrl': 'CotizacionHogarMobileFormCtrl',
                subtipo: 'Hogar',
                resolve: resolve
            })
            .when('/cotizacion-hogar/bcp/:numeroCotizacion', {
                templateUrl: 'partials/propuesta-vehiculo/desktop/propuesta-vehiculo-bcp.html',
                controller: 'PropuestaVehiculoBCPCtrl',
                subtipo: 'Hogar',
                resolve: resolve
            })
            /**propuesta hogar**/
             
            .when('/propuesta-hogar/propuesta', {
                templateUrl: 'partials/cotizacion-hogar-propuesta/desktop/propuesta-hogar-form.html',
                controller: 'PropuestaHogarFormCtrl',
                subtipo: 'Propuesta Hogar',
                resolve: resolve
            })

            .when('/propuesta-hogar/propuesta/bcp/:numeroCotizacion', {
                templateUrl: 'partials/propuesta-vehiculo/desktop/propuesta-vehiculo-bcp.html',
                controller: 'PropuestaVehiculoBCPCtrl',
                subtipo: 'Propuesta Hogar',
                resolve: resolve
            })



            .when('/propuesta-hogar/propuesta/:numeroCotizacion', {
                templateUrl: 'partials/cotizacion-hogar-propuesta/desktop/propuesta-hogar-form.html',
                controller: 'PropuestaHogarFormCtrl',
                subtipo: 'Propuesta Hogar',
                resolve: resolve
            })
            .when('/propuesta-hogar/hogar', {
                templateUrl: 'partials/propuesta-hogar/desktop/hogar-form.html',
                 controller: 'HogarFormCtrl',
                 subtipo: 'Propuesta Hogar',
                 resolve: resolve
            })

             .when('/propuesta-hogar/hogar/bcp/:numeroCotizacion', {
                templateUrl: 'partials/propuesta-vehiculo/desktop/propuesta-vehiculo-bcp.html',
                controller: 'PropuestaVehiculoBCPCtrl',
                 subtipo: 'Propuesta Hogar',
                 resolve: resolve
            })


             .when('/propuesta-hogar/tomador', {
                templateUrl: 'partials/propuesta-flota/desktop/tomador-form.html',
                controller: 'TomadorFormCtrl',
                tipo: 'Tomador',
                subtipo: 'Propuesta Hogar',
                resolve: resolve
            })
            .when('/propuesta-hogar/tomador/bcp/:numeroCotizacion', {
                templateUrl: 'partials/propuesta-vehiculo/desktop/propuesta-vehiculo-bcp.html',
                controller: 'PropuestaVehiculoBCPCtrl',
                tipo: 'Tomador',
                subtipo: 'Propuesta Hogar',
                resolve: resolve
            })

             .when('/propuesta-hogar/asegurado', {
                templateUrl: 'partials/propuesta-flota/desktop/tomador-form.html',
                controller: 'TomadorFormCtrl',
                tipo: 'Asegurado',
                subtipo:'Propuesta Hogar',
                resolve: resolve
            })
            .when('/propuesta-hogar/asegurado/bcp/:numeroCotizacion', {
                templateUrl: 'partials/propuesta-vehiculo/desktop/propuesta-vehiculo-bcp.html',
                controller: 'PropuestaVehiculoBCPCtrl',
                tipo: 'Asegurado',
                subtipo:'Propuesta Hogar',
                resolve: resolve
            })


             .when('/propuesta-hogar/hojas-anexas', {
                templateUrl: 'partials/propuesta-flota/desktop/hojas-anexas-form.html',
                controller: 'HojasAnexasFormCtrl',
                tipo: 'HojasAnexas',
                subtipo:'Propuesta Hogar',
                resolve: resolve
            })

            .when('/propuesta-hogar/hojas-anexas/bcp/:numeroCotizacion', {
                templateUrl: 'partials/propuesta-vehiculo/desktop/propuesta-vehiculo-bcp.html',
                controller: 'PropuestaVehiculoBCPCtrl',
                tipo: 'HojasAnexas',
                subtipo:'Propuesta Hogar',
                resolve: resolve
            })

            .when('/propuesta-hogar/documentos', {
                templateUrl: 'partials/propuesta-flota/desktop/documentos-form.html',
                controller: 'DocumentosFormCtrl',
                tipo: 'Documentos',
                subtipo:'Propuesta Hogar', 
                resolve: resolve
            })

             .when('/propuesta-hogar/documentos/bcp/:numeroCotizacion', {
                templateUrl: 'partials/propuesta-vehiculo/desktop/propuesta-vehiculo-bcp.html',
                controller: 'PropuestaVehiculoBCPCtrl',
                tipo: 'Documentos',
                subtipo:'Propuesta Hogar', 
                resolve: resolve
            })

            /*Flota
             */
            .when('/flota', {
                templateUrl: 'partials/flota/desktop/flota-form.html',
                controller: 'FlotaFormCtrl',
                resolve: resolve
            })
            
            .when('/flota/:numeroCotizacion', {
                templateUrl: 'partials/flota/desktop/flota-form.html',
                controller: 'FlotaFormCtrl',
                resolve: resolve
            })
            .when('/flota-agregar', {
                templateUrl: 'partials/flota/desktop/flota-agregar.html',
                controller: 'FlotaAgregarCtrl',
                resolve: resolve
            })
            .when('/flota/bcp/:numeroCotizacion', {
                templateUrl: 'partials/propuesta-vehiculo/desktop/propuesta-vehiculo-bcp.html',
                controller: 'PropuestaVehiculoBCPCtrl',
                subtipo: 'Vehiculos',
                resolve: resolve
            })

            /*multiriesgos*/
             .when('/cotizacion-multiriesgo', {
                templateUrl: 'partials/cotizacion-multi-riesgos/'+path+'/cotizacion-multiriesgo-form.html',
                controller: path=='desktop'?'CotizacionMultiRiesgosFormCtrl': 'CotizacionMultiRiesgosMobileFormCtrl',
                subtipo: 'Multiriesgos',
                resolve: resolve
            })

            .when('/cotizacion-multiriesgo/:numeroCotizacion', {
                templateUrl: 'partials/cotizacion-multi-riesgos/'+path+'/cotizacion-multiriesgo-form.html',
                controller: path=='desktop'?'CotizacionMultiRiesgosFormCtrl': 'CotizacionMultiRiesgosMobileFormCtrl',
                subtipo: 'Multiriesgos',
                resolve: resolve
            })

            /*propuesta multiriesgo*/
            .when('/propuesta-multiriesgo/propuesta', {
                templateUrl: 'partials/propuesta-multi-riesgos/desktop/propuesta-multiriesgo-form.html',
                controller: 'PropuestaMultiRiesgoFormCtrl',
                subtipo: 'Multiriesgos',
                resolve: resolve
            })

            .when('/propuesta-multiriesgo/propuesta/bcp/:numeroCotizacion', {
                templateUrl: 'partials/propuesta-vehiculo/desktop/propuesta-vehiculo-bcp.html',
                controller: 'PropuestaVehiculoBCPCtrl',
                subtipo: 'Multiriesgos',
                resolve: resolve
            })



            .when('/propuesta-multiriesgo/propuesta/:numeroCotizacion', {
                templateUrl: 'partials/propuesta-multi-riesgos/desktop/propuesta-multiriesgo-form.html',
                controller: 'PropuestaMultiRiesgoFormCtrl',
                subtipo: 'Multiriesgos',
                resolve: resolve
            })
            .when('/propuesta-multiriesgo/multiriesgo', {
                templateUrl: 'partials/propuesta-multi-riesgos-riesgo/desktop/riesgo-form.html',
                 controller: 'RiesgoFormCtrl',
                 subtipo: 'Multiriesgos',
                 resolve: resolve
            })

             .when('/propuesta-multiriesgo/hogar/bcp/:numeroCotizacion', {
                templateUrl: 'partials/propuesta-vehiculo/desktop/propuesta-vehiculo-bcp.html',
                controller: 'PropuestaVehiculoBCPCtrl',
                 subtipo: 'Multiriesgos',
                 resolve: resolve
            })


             .when('/propuesta-multiriesgo/tomador', {
                templateUrl: 'partials/propuesta-flota/desktop/tomador-form.html',
                controller: 'TomadorFormCtrl',
                tipo: 'Tomador',
                subtipo: 'Multiriesgos',
                resolve: resolve
            })
            .when('/propuesta-multiriesgo/tomador/bcp/:numeroCotizacion', {
                templateUrl: 'partials/propuesta-vehiculo/desktop/propuesta-vehiculo-bcp.html',
                controller: 'PropuestaVehiculoBCPCtrl',
                tipo: 'Tomador',
                subtipo: 'Multiriesgos',
                resolve: resolve
            })

             .when('/propuesta-multiriesgo/asegurado', {
                templateUrl: 'partials/propuesta-flota/desktop/tomador-form.html',
                controller: 'TomadorFormCtrl',
                tipo: 'Asegurado',
                subtipo:'Multiriesgos',
                resolve: resolve
            })
            .when('/propuesta-multiriesgo/asegurado/bcp/:numeroCotizacion', {
                templateUrl: 'partials/propuesta-vehiculo/desktop/propuesta-vehiculo-bcp.html',
                controller: 'PropuestaVehiculoBCPCtrl',
                tipo: 'Asegurado',
                subtipo:'Multiriesgos',
                resolve: resolve
            })


             .when('/propuesta-multiriesgo/hojas-anexas', {
                templateUrl: 'partials/propuesta-flota/desktop/hojas-anexas-form.html',
                controller: 'HojasAnexasFormCtrl',
                tipo: 'HojasAnexas',
                subtipo:'Multiriesgos',
                resolve: resolve
            })

            .when('/propuesta-multiriesgo/hojas-anexas/bcp/:numeroCotizacion', {
                templateUrl: 'partials/propuesta-vehiculo/desktop/propuesta-vehiculo-bcp.html',
                controller: 'PropuestaVehiculoBCPCtrl',
                tipo: 'HojasAnexas',
                subtipo:'Multiriesgos',
                resolve: resolve
            })

            .when('/propuesta-multiriesgo/documentos', {
                templateUrl: 'partials/propuesta-flota/desktop/documentos-form.html',
                controller: 'DocumentosFormCtrl',
                tipo: 'Documentos',
                subtipo:'Multiriesgos', 
                resolve: resolve
            })

             .when('/propuesta-multiriesgo/documentos/bcp/:numeroCotizacion', {
                templateUrl: 'partials/propuesta-vehiculo/desktop/propuesta-vehiculo-bcp.html',
                controller: 'PropuestaVehiculoBCPCtrl',
                tipo: 'Documentos',
                subtipo:'Multiriesgos', 
                resolve: resolve
            })





             .when('/login', {
                templateUrl: 'partials/login/login.html',
                controller: 'LoginCtrl',
                resolve: resolve
            })
            /*.when('/acceso-externo/:redirectUri/:token', {
               templateUrl: 'partials/propuesta-vehiculo/'+path+'/propuesta-vehiculo-form.html',
               controller: 'AccesoExternoCtrl'
            })*/
             .when('/acceso-externo/:redirectUri', {
              templateUrl: 'partials/dashboard-partial.html',
              controller: 'AccesoExternoCtrl',
               resolve:publicResolve
             })
              .when('/error403', {
                templateUrl: 'partials/pagina403.html',
               
                resolve: resolve
            })
            /*vehiculo mobile*/
            /*.when('/cotizacion-vehiculo/mobile', {
                templateUrl: 'partials/cotizacion-vehiculo/mobile/cotizacion-vehiculo-form.html',
                controller: 'CotizacionVehiculoMobileFormCtrl',
                resolve: resolve
            })*/
            //finaly
            .otherwise({
                redirectTo: '/dashboard'
            });
            
            // use the HTML5 History API
            $locationProvider.html5Mode({
                enabled:true,
                requireBase:true, //cuando es false no hace falta un base href en el index
                rewriteLinks:true,
                })
                .hashPrefix('!');
            //$locationProvider.baseHref = "/MapCotizador";

    }]);


/**
 * Se configura para que google analytis que trackee las páginas visitadas.
 */
app.run(['$rootScope', '$location', '$window', '$http', function ($rootScope, $location, $window, $http) {
    // initialise google analytics
    //$window.ga('create', 'UA-XXXXXXXX-X', 'auto');
    // track pageview on state change
    $rootScope.version=App.VERSION;
    $rootScope.countRefresh=0;
    $rootScope.$on('$routeChangeStart', function (event) {
        //$window.ga('send', 'pageview', $location.path());
    });
    actualizarToken=function()
    {
        var token= "Bearer " + $window.sessionStorage["token"];
        var header = {headers:  {
                'Authorization': token,
                'Accept': 'application/json',
            }
        };
        return $http.get("autenticador/refresh", header);
    };
    countRefreshToken=function()
    {
        $rootScope.countRefresh=$rootScope.countRefresh+1;
        return  $rootScope.countRefresh;
    };
    resetRefreshToken=function()
    {
        $rootScope.countRefresh=0;
    }
}]);
;/**
 * Se encarga de registrar e inicializar la aplicación y el mecanismo de seguirdad.
 * 
 */
angular.element(document).ready(function ($http) {

    angular.bootstrap(document, [App.MODULE_NAME]);


/*    App.keycloakLauncher = {
        loggedIn: false
    };
    App.keycloakLauncher.keycloak = new Keycloak('./data/keycloak.json');
    App.keycloakLauncher.keycloak.init({
            onLoad: 'check-sso'
        })
        .success(function () {
            App.keycloakLauncher.loggedIn = App.keycloakLauncher.keycloak.authenticated;
            app.factory('keycloakLauncher', function () {
                return App.keycloakLauncher;
            });
            // se registra la aplicación
            angular.bootstrap(document, [App.MODULE_NAME]);

        }).error(function () {
            window.location.reload();
        });*/
});
;/**
 * @namespace 
 * Agrupa los posibles tipos de cuadros de dialogos.
 */
var Message = {
    /**
     * Genera cuadros de dialogo
     * 
     * @param {Object} options Parámetros de message box.
     * @param {Object} options.title Titulo del cuadro de dialog.
     * @param {Object} options.type El tipo de dialogo que construirá.
     * @param {Object} options.body Parámetros de message box.
     */
    box: function (options) {
        var mId = "message-box";
        mId += (new Date()).getTime();
        //se construye el contenedor principal
        var $modal = $("<div class='modal' tabindex='-1' role='dialog'></div>");
        $modal.attr("id", mId);
        //se construye el contendor del dialog
        var $dialog = $("<div class='modal-dialog' role='document'></div>");
        var $content = $("<div class='alert alert-dismissible fade in' role='alert'></div>");
        $content.addClass("alert-" + options.type);

        var $header = $("<h4></h4>");
      /*  $header.text(options.title);*/
        $header.append($("<button type='button' class='close' data-dismiss='modal'><span>&times;</span></button>"));

        var $body = $("<p></p>");
        $body.text(options.body);

        //se añade el dialog al body .
        $modal.append($dialog);
        $dialog.append($content);
        $content.append($header);
        $content.append($body);
        $("body").append($modal);

        /*
         * Se instancia el modal.
         */
        var $messageBox = $("#" + mId).modal();

        //cuando se cierr el dialogo se elimina el dom asociado.
        $messageBox.on("hidden.bs.modal", function (e) {
            e.currentTarget.remove();
        });

    },

    /**
     * Genera un cuadro de dialogo de éxito.
     * @function 
     * @param {object|string} options En caso de ser un string es el mensaje del dialogo. 
     *                                En caso contrario se presume que el json de 
     *                                configuraciones del messagebox.
     */
    ok: function (options) {
        options = typeof options == "string" ? {
            body: options
        } : options;

        options.type = "success";
        options.title = !options.title ? "Éxito!" : options.title;
        this.box(options);
    },

    /**
     * Genera un cuadro de dialogo de error.
     * @function 
     * @param {object|string} options En caso de ser un string es el mensaje del dialogo. 
     *                                En caso contrario se presume que el json de 
     *                                configuraciones del messagebox.
     */
    error: function (options) {
        options = typeof options == "string" ? {
            body: options
        } : options;
        options.type = "danger";
        options.title = !options.title ? "Error!" : options.title;
        this.box(options);
    },

    /**
     * Genera un cuadro de dialogo de aviso.
     * @function 
     * @param {object|string} options En caso de ser un string es el mensaje del dialogo. 
     *                                En caso contrario se presume que el json de 
     *                                configuraciones del messagebox.
     */
    info: function (options) {
        options = typeof options == "string" ? {
            body: options
        } : options;
        options.type = "info";
        options.title = !options.title ? "Aviso!" : options.title;
        this.box(options);
    },

    /**
     * Genera un cuadro de dialogo de atención.
     * @function 
     * @param {object|string} options En caso de ser un string es el mensaje del dialogo. 
     *                                En caso contrario se presume que el json de 
     *                                configuraciones del messagebox.
     */
    warning: function (options) {
        options = typeof options == "string" ? {
            body: options
        } : options;
        options.type = "warning";
        options.title = !options.title ? "Atención!" : options.title;
        this.box(options);
    }
}
;/*
 * @class
 * Directiva que se encarga de dar vida al sidebar de lateral de la aplicación
 */
app.directive('sideNav', [function () {

        /**
         * Se encarga de seleccionar el enlace que corresponde a la página por que se esta
         * viendo actualmente
         * @param {DOM} el elemento donde se renderiza la directiva.
         */
        function selectLink(el) {
            var path = window.location.pathname;
            var hash = window.location.hash;
            /**
             * Se encarga de seleccionar el elemento del sidebar que se
             * esta viendo.
             */
            function select(el, target) {
                $(el).find('li a[href="' + target + '"]').parent()
                .each(function(){
                    $(el).find('li.active').removeClass("active");
                    $(this).addClass("active");
                });
            }

            select(el, path);
            select(el, hash);
        }

        /*
         * Por cada elemento del sidebar seleccionado, se le añade
         * el class active para denotar su selección
         */
        function bindEvents(element){
            $(element).find('li').click(function (e) {
                $(element).find("li.active").removeClass("active");
                $(this).addClass("active");
            });
        }

        return {
            restrict: 'C',
            scope: {
                model: '='
            },
            link: function (scope, element) {
                var $page = $(".page-wrapper");
                var clazz = "compress";



                /*
                 * Si se clickea el boton del sidebar, se colapsa o comprime
                 * los elementos para mostar una versión reducida o extendida del
                 * sidebar.
                 */
                $(element).find(".btn").click(function (e) {
                    if (!$page.hasClass(clazz)) {
                        $page.addClass(clazz);
                        $(element).addClass(clazz);
                        $(this).addClass(clazz);
                    } else {
                        $page.removeClass(clazz);
                        $(element).removeClass(clazz);
                        $(this).removeClass(clazz);
                    }
                });

                /**
                 * Si el usuario realizó colapsó o comprimió el sidebar se recupera
                 * la configuración del storage del browser, para recordar su seleccion.
                 */
               var state = "compress";
                if (state) {
                    $page.addClass(state);
                    $(element).addClass(state);
                    $(element).find(".btn").addClass(state);
                } else {
                    $page.removeClass(clazz);
                    $(element).removeClass(clazz);
                    $(element).find(".btn").removeClass(clazz);
                }


                scope.$watch('model', function () {
                    bindEvents(element)
                    selectLink(element);
                });
            }
        }
    }
]);
;/**

 * @author <a href = "mailto:marcos.peralta@konecta.com.py"> Marcos Peralta</a>
 */

/**
 * directiva Base para las grillas con filtrado
 */
app.directive('listaDirective', function () {
    return {
        restrict: 'E',
        transclude: {
            'breadcrumb': 'breadcrumb',
            'filtros': 'filtros',
            'titulo': 'titulo',
            'descripcion': 'descripcion',
            'tabla': 'tabla'
        },
        replace: true,
        templateUrl: 'partials/templates/list-template.html'
    };
});

/**
 * Directiva Base para los formularios de carga y edición
 */
app.directive('formDirective', function () {
    return {
        restrict: 'E',
        transclude: {
            'titulo': 'titulo',
            'descripcion': 'descripcion',
            'form': 'form'
        },
        replace: true,
        templateUrl: 'partials/templates/form-template.html'
    };
});

/**
 * Directiva Base para los pantallas de visualizacion
 */
app.directive('viewDirective', function () {
    return {
        restrict: 'E',
        transclude: {
            'titulo': 'titulo',
            'descripcion': 'descripcion',
            'view': 'view'
        },
        replace: true,
        templateUrl: '../partials/templates/view-template.html'
    };
});

/**
 * Directiva Base para los pantallas de visualizacion con sub grillas
 */
app.directive('viewCustomDirective', function () {
    return {
        restrict: 'E',
        transclude: {
            'titulo': 'titulo',
            'descripcion': 'descripcion',
            'view': 'view',
            'tabla': 'tabla'
        },
        replace: true,
        templateUrl: 'partials/templates/view-custom-template.html'
    };
});


/**
 * Directiva Base para los pantallas de visualizacion de datos de busqueda
 */
app.directive('searchDirective', function () {
    return {
        restrict: 'E',
        transclude: {
            'titulo': 'titulo',
            'filtros': 'filtros',
            'tabla': 'tabla'
        },
        replace: true,
        templateUrl: 'partials/templates/search-template.html'
    };
});;/*
 * @class
 * Directiva que se encarga de habilitar los tabs.
 * @see http://getbootstrap.com/javascript/#tabs
 */
app.directive('navTabs', [function () {
        return {
            restrict: 'C',
            scope: {},
            link: function (scope, element) {
                $(element).find('a').click(function (e) {
                    e.preventDefault();
                    $(this).tab('show');
                });
                //se fuerza el click.
                $(element).find('a').first().click();
            }
        }
    }
]);
;app.service('BaseService', ['$http', '$location','$rootScope','$mdDialog', '$window', '$sce','$log', function ($http, $location, $rootScope, $mdDialog, $window, $sce, $log) {
    return {
        recurso: '',
        recurso_propuesta: 'propuesta/',
        recurso_control_emision :'control/emisioncampos',

        /**
         * Realiza un get para obtener la lista de paginada de lotes
         * @function
         */
        listar: function (params) {
            return $http.get(App.REST_BASE + this.recurso+"/listar", {
                params: params
            });
        },

        /**
         * Realiza un post para guardar el nuevo lote
         * @function
         */
        crear: function (params) {

            return $http.post(App.REST_BASE + this.recurso+'/insertar', params);
        },

        /**
         * Realiza un post para actualizar la plantilla
         * @function
         */
        actualizar: function (params) {
            return $http.put(App.REST_BASE + this.recurso+'/modificar', params);
        },

        /**
         * Realiza un get para obtener una plantilla específica por su id.
         * @function
         */
        obtener: function (params) {
            var filtros = encodeURIComponent(
                angular.toJson(params));

            return $http.get(App.REST_BASE + this.recurso + "/listar?filtros="+filtros, {
            });
        },

        /**
         * Realiza un delete para borrar un registro específico por su id.
         * @function
         */
        eliminar: function (params) {
            return $http.delete(App.REST_BASE + this.recurso + "/"+params.id);
        },

        /**
         * Realiza un delete para borrar un registro específico por su id.
         * @function
         */
        eliminarCascada: function (url, params) {
            return $http.delete(App.REST_BASE+ this.recurso + "/"+ url + "/"+params.id);
        },

        getDatosUsuario: function (codigoUsuario,idUsuario, idPersona) {
            var params =
                {
                    "codigoUsuario": codigoUsuario,
                    "idUsuario": idUsuario,
                    "idPersona": idPersona
                };
            this.deleteUndefinedValues(params);
            var filtros = encodeURIComponent(
                angular.toJson(params));

            return $http.get(App.REST_BASE + 'usuario-view/vista?filtros='+filtros);
        },
        deleteUndefinedValues : function (object) {
            Object.keys(object).forEach(function (key) {
                if (!object[key]) {
                    delete object[key];
                }
            });
        },

        numberFormater : function (n, c, d, t) {
            var c = isNaN(c = Math.abs(c)) ? 2 : c,
                d = d == undefined ? "," : d,
                t = t == undefined ? "." : t,
                s = n < 0 ? "-" : "",
                i = parseInt(n = Math.abs(+n || 0).toFixed(c)) + "",
                j = (j = i.length) > 3 ? j % 3 : 0;
            return s + (j ? i.substr(0, j) + t : "") + i.substr(j).replace(/(\d{3})(?=\d)/g, "$1" + t) + (c ? d + Math.abs(n - i).toFixed(c).slice(2) : "");
        },

        isUndefined: function (property) {
            return typeof property == "undefined";
        },

        getTabInicial: function () {
            return angular.copy(Tabs);
        },

        getTabs: function (param) {
            //numero cotizacion param.numeroCotizacion
            //var paramsEditables={};
            //paramsEditables.marcaFlota=param.marcaFlota;
            //paramsEditables.numeroCotizacion=angular.isUndefined(param.numeroCotizacion)|| param.numeroCotizacion==null?"":param.numeroCotizacion;
            //paramsEditables.tab=param.tab;
            //this.getCamposEditablesList(paramsEditables);
            var url = App.URL_BASE+'control/campos?numeroCotizacion='+param.numeroCotizacion+'&'+param.pathModule;
            return $http.get(url).then(
                function (succesResults) {
                    for(var index in succesResults.data.dato){
                        $rootScope.tabs[index] = succesResults.data.dato[index];
                    }

                }, function (failResults) {
                    Message.warning("Error al recuperar el porcentaje de completitud de los formularios");
                    $rootScope.tabs = Tabs;
                }
            )

            //llamar a la lista de campos editables

        },
        getCamposEditablesList:function(params)
        {
            if (!angular.isUndefined(params.tab) && params.tab != null && params.tab != '')
            $http.get(App.URL_BASE+'validaciones/propuesta/editables?'+params.pathModule+'&numeroCotizacion='+ params.numeroCotizacion+'&tab='+params.tab ).then(function(response) {
                //console.log("RESPONSE: " + JSON.stringify(response));
                $rootScope.cargando = false;
                if (!response.data.error) {
                    //console.log("LENGTH RESPONSE: " + response.data.dato.length);
                    if (response.data.dato.length > 0) {
                        $rootScope.camposEditablesList = [];
                        var campos = response.data.dato;
                        for (var i = 0; i < campos.length; i++) {
                            $rootScope.camposEditablesList.push(campos[i]);
                        }

                    }

                }
                else
                {
                    Message.error(response.data.mensaje);
                }
			})

        },
         goToPropuestaOrigen : function(modulo){
            $rootScope.camposEditablesList=[];

            Message.warning("Debe seleccionar un número de cotización para continuar");
            //var url = subtipo=='Flota'?'flota/propuesta':'vehiculo/propuesta';
            $location.url(modulo+"/propuesta");
        },
        /**
         * Descarga todos los pdfs de todos los tabs en la seccion de propuesta
         * @function
         */
        descargarPDF : function(accion, subtipo, numeroCotizacion,pathModule) {
            if (subtipo=="Vehiculos") //en propuesta viene como subtipo Vehiculos, y para unificar hacemos vehiculo
            {
                subtipo="Vehiculo";
            }


            //console.log("Es explorer ", this.esExplorer());
            //console.log("Es EDGE ", this.esEDGE());




            var url=this.generarURL(subtipo, accion);
            $rootScope.cargando = true;

            var marcaFlota;
            if (subtipo=="Flota")
            {
                marcaFlota="S";

            }
            else
            {
                marcaFlota="N";
            }
            if (accion=='cartaPropuesta')
            {
                $rootScope.tipoOperacionBCP ={};
                $rootScope.tipoOperacionBCP.valor="imprimir";
                var context=this;
                this.verificarBCP(numeroCotizacion, pathModule).then(function(response)
                {
                    $rootScope.cargando=false;
                    if (!response.error) {
                        $rootScope.camposRequeridosList=[];
                        if (response.dato.length > 0) {
							
							var flagBCP = false;


                            for (var i=0;i<response.dato.length;i++){
                                if (response.dato[i].COD_DIFERENCIA=='02'){
                                   flagBCP = true; 
                                   break;
                                }

                            }

                            if (flagBCP==true){
                                context.abrirBCP(numeroCotizacion);
                            }else {
                                 context.imprimir(url+'?'+pathModule, numeroCotizacion);
                            }  
							
						

                        }

                    }else{
                        Message.error(response.mensaje);

                    }

                });





            }
            else if (accion=='imprimirFormulario'){

                this.imprimir(url+'?'+pathModule, numeroCotizacion);

            }
            else
            {
                this.imprimir(url, numeroCotizacion);

            }

        },
        /**
         * Se encarga de la emision automatica de la propuesta en todos los tabs de la seccion en propuesta
         * @function
         */
        emisionAutomaticaPropuesta : function(numeroCotizacion, nroPropuesta, subtipo,pathModule)
        {

            if (numeroCotizacion==undefined || numeroCotizacion == "" ||
                nroPropuesta==undefined || nroPropuesta == ""){
                Message.warning("Favor verifique si se hizo el pase a propuesta");
                //console.log("Debe especificar un número de cotización y número propuesta.");

            }
            else
            {
                var marcaFlota;
                if (subtipo=="Flota")
                {
                    marcaFlota="S";

                }
                else
                {
                    marcaFlota="N";
                }

                 $rootScope.tipoOperacionBCP={};
                $rootScope.tipoOperacionBCP.valor="emisionAutomaticaPropuesta:"+nroPropuesta;
                
                var context=this;
                this.verificarBCP(numeroCotizacion, pathModule).then(function(response)
                {
                    $rootScope.cargando=false;
                    if (!response.error) {
                        $rootScope.camposRequeridosList=[];
                        if (response.dato.length > 0) {

                            var flagBCP = false;
                            for (var i=0;i<response.dato.length;i++){
                                if (response.dato[i].COD_DIFERENCIA=='02'){
                                   flagBCP = true; 
                                   break;
                                }

                            }

                             if (flagBCP==true){
                                context.abrirBCP(numeroCotizacion);
                            }else {
                                context.generacionAutomaticaPropuesta(numeroCotizacion,nroPropuesta,pathModule);
                            }  

 

                        }

                    }
                    else
                    {
                        Message.error(response.mensaje);

                    }

                });

            }
        },
        /**
         * Emite la validacion, en todos los tabs de la seccion en propuesta
         * @function
         */
        emitirDocumento : function(numeroCotizacion,pathModule)
        {
            //primero validar y luego llamar a emitir
            var marcaFlota="N";

            if (numeroCotizacion==undefined || numeroCotizacion == ""){

                console.log("Debe especificar un número de cotización.");
                Message.warning("Favor especifique un número de cotización");
            }
            else
            {
                $rootScope.tipoOperacionBCP ={};
                $rootScope.tipoOperacionBCP.valor="emitirDocumento";
                var context=this;
                this.verificarBCP(numeroCotizacion, pathModule).then(function(response)
                {
                    $rootScope.cargando=false;
                    if (!response.error) {
                        $rootScope.camposRequeridosList=[];
                        if (response.dato.length > 0) {

                           var flagBCP = false;
                            for (var i=0;i<response.dato.length;i++){
                                if (response.dato[i].COD_DIFERENCIA=='02'){
                                   flagBCP = true; 
                                   break;
                                }

                            }

                             if (flagBCP==true){
                                context.abrirBCP(numeroCotizacion);
                            }else {
                                context.emisionValidacion(numeroCotizacion,pathModule);
                            }  
                            
 

                        }

                    }
                    else
                    {
                        Message.error(response.mensaje);

                    }

                });


            }
        },
        /**
         * Genera el numero de propuesta para todos los tabs en la seccion de propuesta
         * @function
         */
        generar: function(subtipo, numeroCotizacion, pantalla,pathModule)
        {
            $rootScope.cargando=true;
            if(!angular.isUndefined(numeroCotizacion)&& numeroCotizacion!=null && numeroCotizacion !=""){
                var marcaFlota;
                if (subtipo=="Flota")
                {
                    marcaFlota="S";
                }
                else
                {
                    marcaFlota="N"
                }
                 /**/
                $rootScope.tipoOperacionBCP={};
                $rootScope.tipoOperacionBCP.valor="generar";
                var context=this;
                this.verificarBCP(numeroCotizacion, pathModule).then(function(response)
                {
                    $rootScope.cargando=false;
                    if (!response.error) {
                        $rootScope.camposRequeridosList=[];
                        if (response.dato.length > 0) {
                            
                            var flagBCP = false;
                            for (var i=0;i<response.dato.length;i++){
                                if (response.dato[i].COD_DIFERENCIA === '02'){
                                   flagBCP = true; 
                                   break;
                                }

                            }

                             if (flagBCP==true){
                                context.abrirBCP(numeroCotizacion);
                            }else {
                                context.generarPropuesta(numeroCotizacion,pathModule); 
                            }  
                            
 


                        }

                    }
                    else
                    {
                        Message.error(response.mensaje);

                    }

                });

            }
            else
            {
                $rootScope.cargando=false;
                Message.warning("Debe ingresar un número de cotización");
            }
        },
        esExplorer:function()
        {
            var isIE = false || !!document.documentMode; //el documentMode es solo soportado por internet explorer
            return isIE;
        },
        esEDGE:function()
        {
            var isEdge= !this.esExplorer() && !!window.StyleMedia;
            return isEdge;
        },
        trustSrc: function(src) {
            return $sce.trustAsResourceUrl(src);
        },
        imprimir:function(url, numeroCotizacion)
        {
            $rootScope.cargando=true;
            if ($rootScope.changImp)
            {


                window.open(url+"?numeroCotizacion="+ numeroCotizacion);
                $rootScope.cargando = false;


            }
            else
            {
                /*$http.get(url +"?numeroCotizacion="+ numeroCotizacion).then(
                    function (response) {
                        $rootScope.cargando = false;
                        $rootScope.pdf = "data:application/pdf;base64," + response.data;
                        $('#cambioPassModal').modal('show');
                    }).catch(function (response) {
                    $rootScope.cargando = false;
                    Message.error(response.data.mensaje);
                });*/
				$rootScope.cargando = false;
                $('#cambioPassModal').modal('show');
                 if  (url.indexOf("hogar")!==-1){
                     if (url.indexOf("?")>0){
                         $rootScope.pdf =url +"&numeroCotizacion="+ numeroCotizacion;//+"&codigoUsuario="+sessionStorage.getItem("usuarioLogueado")
                     }else{
                         $rootScope.pdf =url +"?numeroCotizacion="+ numeroCotizacion;//+"&codigoUsuario="+sessionStorage.getItem("usuarioLogueado")
                     }
                    
                }
				else if (url.indexOf("vehiculo")!==-1)
                 {
                     if (url.indexOf("?")>0)
                     {
                         if (url.indexOf("cartaoferta")>0 || url.indexOf("propuesta")>0)
                         {
                             $rootScope.pdf =url +"&numeroCotizacion="+ numeroCotizacion+"&token="+encodeURI(sessionStorage.getItem("token"));
                         }
                         else
                         {
                             $rootScope.pdf =url +"&numeroCotizacion="+ numeroCotizacion;
                         }

                     }else
                         {
                         if (url.indexOf("cartaoferta")>0 || url.indexOf("propuesta")>0)
                         {
                             $rootScope.pdf =url +"?numeroCotizacion="+ numeroCotizacion+"&token="+encodeURI(sessionStorage.getItem("token"));
                         }
                         else
                         {
                             $rootScope.pdf =url +"?numeroCotizacion="+ numeroCotizacion;
                         }

                     }
                 }else{
                       if (url.indexOf("?")>0){
                            $rootScope.pdf =url +"&numeroCotizacion="+ numeroCotizacion;
                       }else{
                            $rootScope.pdf =url +"?numeroCotizacion="+ numeroCotizacion;
                       }

                     
                }
            }
        },
        generarURL: function(subtipo,accion)
        {
            var acciones = UrlImpresiones[subtipo];
            var url=acciones[accion];
            var isIE=this.esExplorer();
            var isEdge=this.esEDGE();
            $rootScope.changImp=isIE || isEdge; //se pregunta en que navegador se esta corriendo, estos 2 son los que no funcionan la previsualizacion de pdf
            if ($rootScope.changImp)
            {
                url+="/ie";
            }
            return url;
        },
        verificarBCP: function(numeroCotizacion, pathModule)
        {
            return $http.get(App.URL_BASE +'validar/terceros/bcp?numeroCotizacion='+numeroCotizacion+'&'+pathModule).then(
                function (response)
                {
                    return  response.data;

                });
        },

        abrirBCP: function(numeroCotizacion)
        {
            var path;
            if ($rootScope.rootPathParent.indexOf(':numeroCotizacion') >0)
            {
                path=  $rootScope.rootPathParent.replace('/:numeroCotizacion','' )+"/bcp/" + numeroCotizacion ;
            }
            else
            {
                path =  $rootScope.rootPathParent+"/bcp/" + numeroCotizacion;
            }

            $location.url(path);
        },
        generarPropuesta :function (numeroCotizacion,pathModule){
               
               $http.get(App.URL_BASE+this.recurso_propuesta+'generar?'+pathModule+'&numeroCotizacion='+numeroCotizacion).then(
                    function (response) {
                        if(!response.data.error){
                            $rootScope.nroPropuesta=response.data.dato.numeroPropuesta;
                            $rootScope.cargando=false;
                            $rootScope.camposRequeridosList=[];
                            Message.ok(response.data.mensaje);
                            if($rootScope.redireccionarBCP != null){
                                $location.url($rootScope.redireccionarBCP); 
                            }
                        }
                        else
                        {
                            Message.error(response.data.mensaje);
                            $http.get(App.URL_BASE+'validaciones/propuesta/requeridos?'+pathModule+'&numeroCotizacion='+ numeroCotizacion+'&imprimir=N&generar=S&emitir=N' ).then(function(response){
                            //console.log("RESPONSE: " + JSON.stringify(response));

                                if (!response.data.error)
                                {
                                    $rootScope.cargando=false;
                                    //console.log("LENGTH RESPONSE: " + response.data.dato.length);
                                    if (response.data.dato.length>0)
                                    {
                                        $rootScope.camposRequeridosList=[];
                                        var campos=response.data.dato;
                                        for (var i=0; i< campos.length; i++)
                                        {
                                            $rootScope.camposRequeridosList.push(campos[i]);
                                        }


                                    }

                                }
                                else
                                {
                                    $rootScope.cargando=false;
                                    Message.error(response.data.mensaje);
                                }
                            }).catch(function(response){
                                $rootScope.cargando=false;
                                Message.error("Ocurrió al obtener la lista de campos requeridos");
                            });

                        }

                    }).catch(function(response){
                    $rootScope.cargando=false;
                    Message.error("Ocurrió un error al generar la propuesta");
                });



        },
        generacionAutomaticaPropuesta :function (numeroCotizacion,nroPropuesta,pathModule){
             
             $http.get(App.URL_BASE+this.recurso_control_emision+'?'+pathModule+'&numeroCotizacion='+numeroCotizacion).then(
                    function (response) {
                        if(!response.data.error){


                         localStorage.setItem('numeroCotizacion', numeroCotizacion);
                                            localStorage.setItem('numeroPropuesta', nroPropuesta);
                                           // localStorage.setItem('marcaFlota', marcaFlota);
                                            //$('#emisionvalidacion').modal('show');
                                            $mdDialog.show({
                                                controller: 'EmisionAutomaticaCtrl',
                                                templateUrl: 'partials/ventanas-emergentes/emision-automatica.html',
                                                parent: angular.element(document.body),
                                                clickOutsideToClose:false,
                            });
                           
                        }
                        else
                        {
                            Message.error(response.data.mensaje);
                            $http.get(App.URL_BASE+'validaciones/propuesta/requeridos?'+pathModule+'&numeroCotizacion='+ numeroCotizacion+'&imprimir=N&generar=N&emitir=S' ).then(function(response){
                            //console.log("RESPONSE: " + JSON.stringify(response));

                                if (!response.data.error)
                                {
                                    $rootScope.cargando=false;
                                    //console.log("LENGTH RESPONSE: " + response.data.dato.length);
                                    if (response.data.dato.length>0)
                                    {
                                        $rootScope.camposRequeridosList=[];
                                        var campos=response.data.dato;
                                        for (var i=0; i< campos.length; i++)
                                        {
                                            $rootScope.camposRequeridosList.push(campos[i]);
                                        }


                                    }

                                }
                                else
                                {
                                    $rootScope.cargando=false;
                                    Message.error(response.data.mensaje);
                                }
                            }).catch(function(response){
                                $rootScope.cargando=false;
                                Message.error("Ocurrió al obtener la lista de campos requeridos");
                            });

                        }

                    }).catch(function(response){
                    $rootScope.cargando=false;
                    Message.error("Ocurrió un error al generar la propuesta");
                });






        },


       emisionValidacion :function (numeroCotizacion,pathModule){

                    $http.get(App.URL_BASE+this.recurso_control_emision+'?'+'numeroCotizacion='+numeroCotizacion+'&'+pathModule).then(
                    function (response) {
                        if(!response.data.error){
                                 localStorage.setItem('numeroCotizacion', numeroCotizacion);
                                    //$('#emisionvalidacion').modal('show');
                                    $mdDialog.show({
                                        controller: 'EmisionValidacionCtrl',
                                        templateUrl: 'partials/ventanas-emergentes/emision-validacion.html',
                                        parent: angular.element(document.body),
                                        clickOutsideToClose:false,

                                    });
                           
                        }
                        else
                        {
                            Message.error(response.data.mensaje);
                            $http.get(App.URL_BASE+'validaciones/propuesta/requeridos?'+pathModule+'&numeroCotizacion='+ numeroCotizacion+'&imprimir=N&generar=N&emitir=S' ).then(function(response){
                            //console.log("RESPONSE: " + JSON.stringify(response));

                                if (!response.data.error)
                                {
                                    $rootScope.cargando=false;
                                    //console.log("LENGTH RESPONSE: " + response.data.dato.length);
                                    if (response.data.dato.length>0)
                                    {
                                        $rootScope.camposRequeridosList=[];
                                        var campos=response.data.dato;
                                        for (var i=0; i< campos.length; i++)
                                        {
                                            $rootScope.camposRequeridosList.push(campos[i]);
                                        }


                                    }

                                }
                                else
                                {
                                    $rootScope.cargando=false;
                                    Message.error(response.data.mensaje);
                                }
                            }).catch(function(response){
                                $rootScope.cargando=false;
                                Message.error("Ocurrió al obtener la lista de campos requeridos");
                            });

                        }

                    }).catch(function(response){
                    $rootScope.cargando=false;
                    Message.error("Ocurrió un error al generar la propuesta");
                });
       

       } ,
	mostrarInfo:function(numeroCotizacion,pathModule) {
        $rootScope.cargando=true;
		$rootScope.informacion ={};
        $http.get(App.URL_BASE +'generales/'+'informacion?numeroCotizacion='+numeroCotizacion+'&'+pathModule).then(function(response) {
          if (!response.data.error) {
              if (response.data.dato.length>0)  {
                  $rootScope.cargando=false;
                  console.log("Informacion ", response.data.dato);
                  $rootScope.informacion=response.data.dato[0];
                  $mdDialog.show({
                      //locals:{mobile: $scope.esMobile},
                      controller: 'ModalInformacionCotizacionCtrl',
                      templateUrl: 'partials/ventanas-emergentes/informacion-cotizacion.html',
                      parent: angular.element(document.body),
                      multiple: true,
                      clickOutsideToClose:false,
                      scope:$rootScope,
                       preserveScope: true,
                      fullscreen: $rootScope.customFullscreen // Only for -xs, -sm breakpoints.

                  }).then(function(answer) {



                  }, function() {
                      $rootScope.status = 'You cancelled the dialog.';
                      console.log($scope.status);
                  });
              }
              else{
                  Message.warning("No hay datos de información")
              }

          }else{
              $rootScope.cargando=false;
              Message.error(response.data.mensaje);
          }
      }).catch (function(err){
          $rootScope.cargando=false;
          Message.error("Ocurrio un error intente nuevamente!");
      });
    }




    }
}]);
;/**
 * @class
 * Filter que implementa la traducción de los caracters boleanos.
 *
 * @name ksass.filters#sino
 * @author <a href = "mailto:marcos.peralta@konecta.com.py"> Marcos Peralta</a>
 */
app.filter('sino', function() {
  return function(input) {
    return input ? 'Sí': 'No';
  };
})
;/**
 * @author <a href = "mailto:marcos.peralta@konecta.com.py"> Marcos Peralta</a>
 */
app.controller('BaseFormCtrl', ['$scope', '$routeParams', '$timeout', '$location', 'ConfirmService',
    function ($scope, $routeParams, $timeout, $location, confirmService) {

        $scope.path = "/" +$location.$$path.split("/")[1] + "/";

        /**
         * Variable que se utiliza para desabilitar botones
         */
        $scope.disabledButtonSave = false;

        /**
         * Url base del formulario
         * @field
         * @type {Object}
         */
        //$scope.uri = "";

        /**
         * Service utilizdo para recuperar los datos y realizar las operaciones.
         * @field
         * @type {Object}
         */
        //$scope.service = null;

        /**
         * Objeto que corresponde al recurso sobre se el cual se realizan las operaciones.
         * @field
         * @type {Object}
         */
        $scope.recurso = {};

        /**
         * Determina el modo de la pantalla
         * @returns {Boolean} True si está en modo creación, False en caso contrario.
         */
        $scope.isCrear = function () {
            return typeof $routeParams.id == "undefined";
        };

        /**
         * Se encarga de persistir los datos del modelo.
         */
        $scope.guardar = function () {
            if (this.isCrear()) {
                this.crearRecurso();
            } else {
                this.editarRecurso();
            }
        };

        /**
         * Se encarga de registrar un nuevo recurso.
         * de edición.
         */
        $scope.crearRecurso = function () {
            var confirm = confirmService.showConfirm('¿Está seguro de guardar el recurso?')
                .then(function(answer) {
                    $scope.disabledButtonSave = true;
                    $scope.service.crear($scope.recurso)
                        .then($scope.guardarSuccess
                            , function (data, code) {
                                $scope.disabledButtonSave = false;
                                Message.error("No se pudo realizar la operación");
                            });
                }, function() {
                    return;
                });
        };

        /**
         * Se encarga de actualizar los datos del recurso.
         */
        $scope.editarRecurso = function () {
            var confirm = confirmService.showConfirm('¿Está seguro de modificar el recurso?')
                .then(function(answer) {
                    $scope.disabledButtonSave = true;
                    $scope.disabledButtonSave = true;
                    return $scope.service.actualizar($scope.recurso)
                        .then($scope.guardarSuccess
                            , function (data, code) {
                                $scope.disabledButtonSave = false;
                                Message.error("No se pudo realizar la operación");
                            });
                }, function() {
                    return;
                });
        };

        /**
         * Se encarga de manejar el success de las peticiones
         * @param {object} data la respuesta de la petición
         */
        $scope.guardarSuccess = function (response) {
            $scope.disabledButtonSave = false;
            Message.ok("El recurso se ha registrado exitosamente.");
            console.log($scope.uri + response.data.id + "/ver");
            $location.url($scope.uri + response.data.id + "/ver");
        };

        /**
         * Se encarga de obtener los datos del recurso siempre y cuando la pantalla esté en modo
         * de edición.
         */
        $scope.getRecurso = function () {
            this.service.obtener($routeParams)
                .then(function (response) {
                    $scope.recurso = response.data.lista[0];
                },function (data, code) {
                    Message.error("No se pudo realizar la operación");
                });
        };

        /**
         * Constructor / Entrypoint
         * @constructor
         */
        (function initialize() {
            if (!$scope.isCrear()) {
                $scope.getRecurso();
            }
        })();
    }
]);
;/**
 * @author <a href = "mailto:marcos.peralta@konecta.com.py"> Marcos Peralta</a>
 */
app.controller('BaseListCtrl', ['$scope','$location', 'ConfirmService',
    function ($scope, $location, confirmService) {

        /**
         *
         */
        $scope.path = $location.$$path;

        $scope.loading = true;

        /**
         * Inicializacion de objeto
         */
        $scope.filterBy = {};

        /**
         * @field
         * Parametros de configuración de la grilla
         */
        $scope.init = {
            'count': 20,
            'page': 1,
            'sortBy': "id",
            'sortOrder': 'DESC',
            'filterBase': 1
        };

        /**
         * Se encarga de limpiar los criterios del filtrado.
         * @function
         */
        $scope.limpiar = function () {
            $scope.filterBy = {};
        };

        /**
         * Array que contiene los datos de configuración de la grilla
         * @type Array
         * @field
         */
        $scope.config = {
            "rows": [],
            "pagination": {
                "count": $scope.init.count,
                "page": $scope.init.page,
                "pages": 0,
                "size": 0
            },
            "ssortBy": $scope.init.sortBy,
            "sortOrder": $scope.init.sortOrder
        };

        /**
        * Elimina los elementos del objeto que son nulos
        * @function
        */
        $scope.deleteUndefinedValues = function (object) {
            for (var key in object){
                if (!object[key]) {
                    delete object[key];
                }
            }
        };

        /**
         * Se encarga de eliminar el recurso
         * @function
         */
        $scope.eliminar = function (recurso) {
            var confirm = confirmService.showConfirm('¿Está seguro de eliminar el recurso?')
                .then(function(answer) {
                    $scope.service.eliminar(recurso)
                        .then(function (data) {
                            $scope.limpiar();
                            $location.url($scope.config.recurso);
                            Message.ok("El registro se ha eliminado exitosamente.");
                        }).catch(function (data, code) {
                        Message.error("No se pudo realizar la operación");
                    });
                }, function() {
                    return;
                });
        };

        /**
         * Se encarga de recuperar la lista paginada de los datos.
         * @function
         */
        $scope.getResource = function (params, paramsObj) {
            paramsObj.sortOrder = paramsObj.sortOrder == 'dsc' ? "DESC" : "ASC";
            $scope.loading = true;
            if (paramsObj.filters){
                $scope.deleteUndefinedValues(paramsObj.filters);
            }
            paramsObj.filtros = paramsObj.filters;
            paramsObj.cantidad = paramsObj.count;
            //delete paramsObj.count;
            $scope.config.pagination.count = paramsObj.cantidad;
            delete paramsObj.filters;
            if(paramsObj.page == 1){
                paramsObj.inicio = 0;
            }else
            if(paramsObj.page > 0){
                paramsObj.inicio = (paramsObj.page - 1)*paramsObj.cantidad;
            }
            paramsObj.orderBy = paramsObj.sortBy;
            paramsObj.orderDir = paramsObj.sortOrder;
            return this.service.listar(paramsObj)
                .then(function (response) {
                    $scope.loading = false;
                    $scope.config.rows = response.data.lista;
                    $scope.config.pagination.size = response.data.total;
                    $scope.config.pagination.pages = Math.ceil(response.data.total / $scope.config.pagination.count);
                    return $scope.config;
                }).catch(function(response){
                    console.error(response);
                    $scope.loading = null;
                    $scope.config.rows = [];
                    $scope.config.pagination.size =0;
                    $scope.config.pagination.pages=0;
                    return $scope.config;
                });
        };


        /**
         * Constructor / Entrypoint
         * @constructor
         */

    }
]);
;/**
 * @author <a href = "mailto:marcos.peralta@konecta.com.py"> Marcos Peralta</a>
 */
app.controller('BaseViewCtrl', ['$scope', '$routeParams', '$timeout', '$location',
    function ($scope, $routeParams, $timeout, $location) {

        $scope.path = "/" +$location.$$path.split("/")[1] + "/";    

        /**
         * Service utilizdo para recuperar los datos y realizar las operaciones.
         * @field
         * @type {Object}
         */
        //$scope.service = null;

        /**
         * Objeto que corresponde al recurso sobre se el cual se realizan las operaciones.
         * @field
         * @type {Object}
         */
        $scope.recurso = {};

        /**
         * Se encarga de obtener los datos del recurso siempre y cuando la pantalla esté en modo
         * de edición.
         */
        $scope.getRecurso = function () {
            $scope.service.obtener($routeParams)
            .then(function (response) {
                    $scope.recurso = response.data.lista[0];
                },function (data, code) {
                    Message.error("No se pudo realizar la operación");
                });
        };

        /**
         * Constructor / Entrypoint
         * @constructor
         */
        (function initialize() {
            $scope.getRecurso();
        })();
    }
]);
;/*
 * @Class
 * Definición del service que se encarga de la consulta para confirmar una acción
 *
 */
app.service('ConfirmService', ['$http', '$rootScope', '$mdDialog', function ($http, $rootScope, $mdDialog) {
    return {

        showConfirm: function(data) {
           /* var param = {body:data}
           if(typeof data.header != 'undefined'){
                param = {
                    header: data.header ,  
                    body:data.body
                }

           } */
           return $mdDialog.show({
                controller: 'ConfirmCtrl',
                templateUrl: 'partials/ventanas-emergentes/confirmar-partial.html',
                parent: angular.element(document.body),
                clickOutsideToClose:false,
                locals: {observacion:data},
                fullscreen: false// Only for -xs, -sm breakpoints.
            });
        }
    }
}]);;app.service('BuscadorCotizacionService', ['$http', 'BaseService', function ($http, BaseService) {

    return angular.extend({}, BaseService, {
        recurso_vehiculos: "vehiculos/",

        recurso_buscador: "cotizacion/",
        recurso_multirriesgo:"multirriesgo/",


        getMarcas : function (params) {
            return $http.get(App.URL_BASE +this.recurso_vehiculos+ 'marcas');


        } ,
        getModelos : function (params) {
            return $http.get(App.URL_BASE +this.recurso_vehiculos+'modelos?codigoMarca='+params.codigoMarca+'&esNuevo='+params.esNuevo);


        } ,
        getSubModelos : function (params) {
            return $http.get(App.URL_BASE +this.recurso_vehiculos+'submodelos?codigoMarca='+params.codigoMarca+'&codigoModelo='+params.codigoModelo+'&esNuevo='+params.esNuevo);


        } ,
        getAnhosSubModelos : function (params) {
            return $http.get(App.URL_BASE +this.recurso_vehiculos+'aniosubmodelos?codigoMoneda='+params.codigoMoneda+'&codigoMarca='+params.codigoMarca+'&codigoModelo='+params.codigoModelo+'&codigoSubModelo='+params.codigoSubModelo+'&esNuevo='+params.esNuevo);


        } ,

         getCotizacion:function(params){
            var param=params;
             var param = encodeURIComponent(
                angular.toJson(params));


              return $http.get(App.URL_BASE +this.recurso_buscador+ 'buscador?numeroCotizacion='+params.numeroCotizacion+'&numeroPropuesta='+params.numeroPropuesta+
                '&numeroCotizacionInterno='+params.numeroCotizacionInterno+'&nombreTomador='+params.nombreTomador+'&nombreAsegurado='+params.nombreAsegurado+'&codigoMarca='+params.codigoMarca+'&codigoModelo='+params.codigoModelo+'&codigoSubmodelo='+params.codigoSubmodelo+'&codigoAnioSubmodelo='+params.codigoAnioSubmodelo+'&numeroChasis='+params.numeroChasis+
                '&numeroChapa='+params.numeroChapa+'&tipoDocumentoTomador='+params.tipoDocumentoTomador+'&codigoDocumentoTomador='+params.codigoDocumentoTomador+
                '&tipoDocumentoAseg='+params.tipoDocumentoAseg+'&codigoDocumentoAseg='+params.codigoDocumentoAseg);
          // return $http.get(App.URL_BASE +this.recurso_buscador+ 'buscacotizacion?numeroCotizacion='+encodeFiltros+'1000&numeroPropuesta&numeroCotizacionInterno&nombreTomador&codigoMarca&codigoModelo&codigoSubmodelo&codigoAnioSubmodelo&numeroChasis&numeroChapa&tipoDocumentoTomador&codigoDocumentoTomador&tipoDocumentoAseg&codigoDocumentoAseg');

            
        }, getCotizacionFlota:function(params){

            var param = encodeURIComponent(
                angular.toJson(params));

            //var encodeFiltros = encodeURIComponent(filtrosJson);
            //console.log("App.REST_BASE");

            return $http.get(App.URL_BASE +'flota/buscador?numeroCotizacion='+params.numeroCotizacion+'&numeroPropuesta='+params.numeroPropuesta+
                '&nombre='+params.nombre+'&tipoDocumentoTomador='+params.tipoDocumentoTomador+'&codigoDocumentoTomador='+params.codigoDocumentoTomador+
                '&primerApellido='+params.primerApellido+'&segundoApellido='+params.segundoApellido);
            // return $http.get(App.URL_BASE +this.recurso_buscador+ 'buscacotizacion?numeroCotizacion='+encodeFiltros+'1000&numeroPropuesta&numeroCotizacionInterno&nombreTomador&codigoMarca&codigoModelo&codigoSubmodelo&codigoAnioSubmodelo&numeroChasis&numeroChapa&tipoDocumentoTomador&codigoDocumentoTomador&tipoDocumentoAseg&codigoDocumentoAseg');


        },

        getCotizacionHogar:function(params){
           var param = encodeURIComponent(angular.toJson(params));

             return $http.get(App.URL_BASE +'hogar/cotizador/buscador?numeroCotizacion='+params.numeroCotizacion+'&numeroPropuesta='+params.numeroPropuesta+
               
                '&numeroPoliza='+params.numeroPoliza+'&tipoDocumentoTomador='+params.tipoDocumentoTomador+'&codigoDocumentoTomador='+params.codigoDocumentoTomador+
                '&nombre='+params.nombre+'&primerApellido='+params.primerApellido+'&segundoApellido='+params.segundoApellido);
            


        },

        getCotizacionMultiriesgoAvanzado:function(params){

        var param = encodeURIComponent(angular.toJson(params));
        return $http.get(App.URL_BASE +this.recurso_multirriesgo+ 'cotizador/buscador?numeroCotizacion='+params.numeroCotizacion+
               '&codigoAgente='+params.codigoAgente+'&numeroPropuesta='+params.numeroPropuesta+'&numeroPoliza='+params.numeroPoliza+
               '&tipoDocumentoTomador='+params.tipoDocumentoTomador+'&codigoDocumentoTomador='+params.codigoDocumentoTomador+
               '&nombre='+params.nombre+'&primerApellido='+params.primerApellido+'&segundoApellido='+params.segundoApellido);
        }


    });
}]);


;app.service('CotizacionVehiculoPropuestaService', ['$http', 'BaseService', function ($http, BaseService) {

    return angular.extend({}, BaseService, {
        recurso_generales: "generales/",
        recurso_vehiculos: "vehiculos/",
        recurso_buscador: "cotizacion/",
        recurso_validaciones: "validaciones/propuesta",
        /**
         * Se sobrescribe el método base para invocar a la url del recurso paginado.
         * Esto es debido a que se utiliza un json server para simular una api rest.
         * @function
         */
        //generales
        getAgentes: function (params) {

            return $http.get(App.URL_BASE +this.recurso_generales+ 'agentes?grupoUsuario='+params.grupoUsuario+'&codigoUsuario='+params.codigoUsuario+'&esNuevo='+params.esNuevo);
        },
        getMonedas: function (params) {

            return $http.get(App.URL_BASE +this.recurso_generales+ 'monedas?esNuevo='+params.esNuevo);
        },
        getDescuentosEspeciales: function (params) {

            return $http.get(App.URL_BASE +this.recurso_generales+ 'descuentosespeciales?esNuevo='+params.esNuevo);
        },

        getFraccionamiento: function (params) {

            return $http.get(App.URL_BASE +this.recurso_generales+ 'fraccionamientos?esNuevo='+params.esNuevo);
        },
        getPolizaGrupo: function (params) {

            return $http.get(App.URL_BASE +this.recurso_generales+'polizagrupo?esNuevo='+params.esNuevo+'&'+params.pathModule);
        },
       //vehiculos
        getMarcas : function (params) {
            return $http.get(App.URL_BASE +this.recurso_vehiculos+ 'marcas');


        }  ,

        getModelos: function (params) {


        return $http.get(App.URL_BASE +this.recurso_vehiculos+ 'modelos?codigoMarca='+params.codigoMarca+'&esNuevo='+params.esNuevo);


        },
        getSubModelos: function (params) {

            return $http.get(App.URL_BASE +this.recurso_vehiculos+ 'submodelos?codigoMarca='+params.codigoMarca+'&codigoModelo='+params.codigoModelo+'&esNuevo='+params.esNuevo);
        },
        getAnhoSubModelos: function (params) {

            return $http.get(App.URL_BASE +this.recurso_vehiculos+ 'aniosubmodelos?codigoMarca='+params.codigoMarca+'&codigoModelo='+params.codigoModelo+'&codigoSubModelo='+params.codigoSubModelo+'&esNuevo='+params.esNuevo);
        },
        getProductos: function (params) {

            return $http.get(App.URL_BASE +this.recurso_vehiculos+ 'productos?codigoMarca='+params.codigoMarca+'&codigoModelo='+params.codigoModelo+'&codigoSubModelo='+params.codigoSubModelo+'&anioSubmodelo='+params.anho+'&codigoRamo='+params.codigoRamo+'&esNuevo='+params.esNuevo);
        },

        listarCoberturas: function (params) {

             return $http.get(App.URL_BASE +this.recurso_generales+'coberturas?codigoProducto='+params.codigoProducto+'&codigoMoneda='+params.codigoMoneda+'&SumaAsegurada='+params.SumaAsegurada);

            
        },

        //api/generales/coberturas?codigoProducto=50102&codigoMoneda=1&SumaAsegurada=10000

        


        guardarCotizacionVehiculo: function (params) {
            var param = encodeURIComponent(
                angular.toJson(params));

            return $http.post(App.URL_BASE + this.recurso_buscador+'guardacotizacion', angular.toJson(params));
        },
         
        getPlataforma:function(params){

            var param = encodeURIComponent(
               angular.toJson(params));
            return $http.get(App.URL_BASE +this.recurso_buscador+ 'descripcion?numeroCotizacion='+params.numeroCotizacion+'&'+params.pathModule);



       },
       getCamposEditables: function(subtipo)
       {
           //pasarle el rol
           return $http.get(App.URL_BASE +this.recurso_validaciones + subtipo + '?rol=EMAAUT&pantalla=VEHICULO');
       },
       getCamposRequeridos: function(subtipo)
       {
           //pasarle el rol
           return $http.get(App.URL_BASE +this.recurso_validaciones + subtipo + 'Requerido?rol=EMAAUT&imprimeGenera=IMPRIME&pantalla=VEHICULO');
       }



    });
}]);
;app.service('CotizacionVehiculoService', ['$http', 'BaseService', function ($http, BaseService) {

    return angular.extend({}, BaseService, {
        recurso_generales: "generales/",
        recurso_vehiculos: "vehiculos/",
        recurso_buscador: "cotizacion/",
        recurso_validaciones: "validaciones/",
        recurso_requeridos:"cotizador/requeridos",
        recurso_editables:"validaciones/cotizador/editables",
        /**
         * Se sobrescribe el método base para invocar a la url del recurso paginado.
         * Esto es debido a que se utiliza un json server para simular una api rest.
         * @function
         */
        //generales
        getAgentes: function (params) {

            return $http.get(App.URL_BASE +this.recurso_generales+ 'agentes?grupoUsuario='+params.grupoUsuario+'&codigoUsuario='+params.codigoUsuario+'&esNuevo='+params.esNuevo);
        },
        getMonedas: function (params) {

            return $http.get(App.URL_BASE +this.recurso_generales+ 'monedas?tienePreferencia='+params.preferencia+'&esNuevo='+params.esNuevo);



        },
        getDescuentosEspeciales: function (params) {

            return $http.get(App.URL_BASE +this.recurso_generales+ 'descuentosespeciales?esNuevo='+params.esNuevo+'&numeroCotizacion='+params.numeroCotizacion+'&'+params.pathModule);
        },

        getFraccionamiento: function (params) {

            return $http.get(App.URL_BASE +this.recurso_generales+ 'fraccionamientos?esNuevo='+params.esNuevo+'&tienePreferencia='+params.preferencia+'&codigoGrupoPoliza='+params.codigoGrupoPoliza);
        },
        getPolizaGrupo: function (params) {

            return $http.get(App.URL_BASE +this.recurso_generales+'polizagrupo?esNuevo='+params.esNuevo+'&'+params.pathModule);
        },
       //vehiculos
        getMarcas : function (params) {
            return $http.get(App.URL_BASE +this.recurso_vehiculos+ 'marcas?tienePreferencia='+params.preferencia+'&esNuevo='+params.esNuevo);


        }  ,

        getModelos: function (params) {


        return $http.get(App.URL_BASE +this.recurso_vehiculos+ 'modelos?codigoMarca='+params.codigoMarca+'&esNuevo='+params.esNuevo);


        },
        getSubModelos: function (params) {

            return $http.get(App.URL_BASE +this.recurso_vehiculos+ 'submodelos?codigoMarca='+params.codigoMarca+'&codigoModelo='+params.codigoModelo+'&esNuevo='+params.esNuevo);
        },

        getSumaAsegurada: function (params) {

            return $http.get(App.URL_BASE +this.recurso_vehiculos+ 'sumaasegurada?codigoMoneda='+params.codigoMoneda+'&codigoMarca='+params.codigoMarca+'&codigoModelo='+params.codigoModelo+'&codigoSubmodelo='+params.codigoSubModelo+'&anioSubmodelo='+params.anho+'&numeroCotizacion='+params.numeroCotizacion);
        },

          getAnhoSubModelos: function (params) {

            return $http.get(App.URL_BASE +this.recurso_vehiculos+ 'aniosubmodelos?codigoMoneda='+params.codigoMoneda+'&codigoMarca='+params.codigoMarca+'&codigoModelo='+params.codigoModelo+'&codigoSubModelo='+params.codigoSubModelo+'&esNuevo='+params.esNuevo);
        },


        getProductos: function (params) {

            return $http.get(App.URL_BASE +this.recurso_vehiculos+ 'productos?codigoMarca='+params.codigoMarca+'&codigoModelo='+params.codigoModelo+'&codigoSubModelo='+params.codigoSubModelo+'&anioSubmodelo='+params.anho+'&codigoRamo='+params.codigoRamo+'&esNuevo='+params.esNuevo+'&renovacion='+params.renovacion+'&numeroCotizacion='+params.numeroCotizacion);
        },

        /*listarCoberturas: function (params) {

             return $http.get(App.URL_BASE +this.recurso_generales+'coberturas?codigoProducto='+params.codigoProducto+'&codigoMoneda='+params.codigoMoneda+'&SumaAsegurada='+params.SumaAsegurada);

            
        },*/

        listarCoberturas: function (params) {

             return $http.get(App.URL_BASE +this.recurso_generales+'coberturas?numeroCotizacion='+params.numeroCotizacion);

            
        },

        


        guardarCotizacionVehiculo: function (params) {
            var param = encodeURIComponent(
                angular.toJson(params));

            return $http.post(App.URL_BASE + this.recurso_buscador+'guardacotizacion', angular.toJson(params));
        },
         getCartaOferta:function (params)
         {
            var headers = new Headers();
            headers.append('Content-Type', 'application/pdf');
            //var options = new RequestOptions({ headers: headers });
            /* $http({
                url: App.URL_BASE+'impresion/cartaoferta/vehiculo?numeroCotizacion='+params.numCotizacion,
                dataType: 'json',
                method: 'GET',
                data: '',
                headers: {
                    "Content-Type": "application/pdf; charset=UTF-8"
                }
            
            });*/
            return $http.get(App.URL_BASE+'impresion/cartaoferta/vehiculo?numeroCotizacion='+params.numCotizacion, {responseType: 'arraybuffer'});
         },
         guardadoParcialCabecera:function (params)
         {

            return $http.post(App.URL_BASE + this.recurso_buscador+'guardacabecera', angular.toJson(params));
         },
         getCotizacion:function(params){

            var param = encodeURIComponent(
               angular.toJson(params));
            return $http.get(App.URL_BASE +this.recurso_buscador+ 'buscacotizacion?numeroCotizacion='+params.numeroCotizacion);
       },
        getPlataforma:function(params){
            var param = encodeURIComponent(
               angular.toJson(params));
            return $http.get(App.URL_BASE +this.recurso_buscador+ 'descripcion?numeroCotizacion='+params.numeroCotizacion+"&"+params.pathModule);
        },
        getPdf:function(url){
            return $http.get(url);
        },

        getCamposEditables: function(params)
        {
            //pasarle el rol
            return $http.get(App.URL_BASE +this.recurso_editables + '?numeroCotizacion='+params.numeroCotizacion+'&'+params.pathModule);
        },
       getCamposRequeridos: function(params)
       {
           //pasarle el rol
           return $http.get(App.URL_BASE +this.recurso_validaciones+ this.recurso_requeridos+'?numeroCotizacion='+params.numeroCotizacion+"&"+params.pathModule);
       },
       getAutorizaciones: function(params)
       {
           //pasarle el rol
           return $http.get(App.URL_BASE +this.recurso_validaciones+ 'autorizaciones?'+params.pathModule);
       },
        validarPolizaGrupo:function(params)
        {
            return $http.get(App.URL_BASE +this.recurso_generales+ 'contratoPoliza?numeroPolizaGrupo='+params.numeroPolizaGrupo+'&codigoMoneda='+params.moneda+'&'+params.pathModule);
        },
        getFranquicias: function(params)
        {
            return $http.get(App.URL_BASE + 'franquicia/listafranquicia?codigoMoneda='+params.moneda+'&sumaAsegurada='+params.sumaAsegurada);
        }


    });
}]);
;app.service('FlotaAgregarService', ['$http', 'BaseService', function ($http, BaseService) {
    return angular.extend({}, BaseService, {

 
    recurso_vehiculos: "vehiculos/",
    recurso_flota: "flota/",
    recurso_riesgos: "riesgos/",
    recurso_validaciones: "validaciones/",

    getAutorizaciones: function(params)
       {
           //pasarle el rol
           return $http.get(App.URL_BASE +this.recurso_validaciones+ 'autorizaciones?'+params.pathModule);
       },
 
    getMarcas : function (params) {
        return $http.get(App.URL_BASE +this.recurso_vehiculos+ 'marcas?tienePreferencia='+params.tienePreferencia+'&esNuevo='+params.esNuevo);


    },

    getModelos: function (params) {


         return $http.get(App.URL_BASE +this.recurso_vehiculos+ 'modelos?codigoMarca='+params.codigoMarca+'&esNuevo='+params.esNuevo);


    },
    getSubModelos: function (params) {

        return $http.get(App.URL_BASE +this.recurso_vehiculos+ 'submodelos?codigoMarca='+params.codigoMarca+'&codigoModelo='+params.codigoModelo+'&esNuevo='+params.esNuevo);
    },
    getAnhoSubModelos: function (params) {
        return $http.get(App.URL_BASE +this.recurso_vehiculos+ 'aniosubmodelos?codigoMoneda='+params.codigoMoneda+'&codigoMarca='+params.codigoMarca+'&codigoModelo='+params.codigoModelo+'&codigoSubModelo='+params.codigoSubModelo+'&esNuevo='+params.esNuevo);

    },

    guardarRiesgo: function (params) {
        var param = encodeURIComponent(angular.toJson(params));

        return $http.post(App.URL_BASE + this.recurso_flota+this.recurso_riesgos+'altariesgos', angular.toJson(params));
},
    editarRiesgo: function (params) {
            var param = encodeURIComponent(angular.toJson(params));

            return $http.post(App.URL_BASE + this.recurso_flota+this.recurso_riesgos+'actualizariesgos', angular.toJson(params));
    },
     editarRiesgoGrilla: function (params) {

        return $http.get(App.URL_BASE +this.recurso_flota+this.recurso_riesgos+ 'detalleRiesgos?numeroCotizacion='+params.numeroCotizacion+'&numeroRiesgo='+params.numeroRiesgo);
    },
     getCobertura: function (params) {

        return $http.get(App.URL_BASE +this.recurso_flota+this.recurso_riesgos+ 'coberturariesgos?codigoProducto='+params.codigoProducto+'&SumaAsegurada='+params.sumaAsegurada);
    },
    getSumaAseguradaRiesgo:function(params)
    {
        return $http.get(App.URL_BASE +this.recurso_vehiculos+ 'sumaasegurada/flota?codigoMoneda='+params.codigoMoneda+'&codigoMarca='+params.codigoMarca+'&codigoModelo='+params.codigoModelo+'&codigoSubmodelo='+params.codigoSubModelo+'&anioSubmodelo='+params.anho+'&numeroCotizacion='+params.numeroCotizacion+'&numeroRiesgo='+params.numeroRiesgo);

    }




    });

}]);;app.service('FlotaService', ['$http', 'BaseService', function ($http, BaseService) {
    return angular.extend({}, BaseService, {

         recurso_generales: "generales/",
         recurso_flota: "flota/",
         recurso_riesgo: "riesgos/",
         recurso_buscador: "cotizacion/",
         recurso_validaciones: "validaciones/",
         recurso_editables:"validaciones/cotizador/editables",

    	getMonedas: function (params) {

            return $http.get(App.URL_BASE +this.recurso_generales+ 'monedas?esNuevo='+params.esNuevo+'&tienePreferencia=N');
        },
        getFraccionamiento: function (params) {

            return $http.get(App.URL_BASE +this.recurso_generales+ 'fraccionamientos?esNuevo='+params.esNuevo);
        },

        getProductos: function (params) {

            return $http.get(App.URL_BASE +this.recurso_flota+ 'listaproducto?numeroCotizacion='+params.numeroCotizacion);
        },
        getCoberturas: function (params) {

            return $http.get(App.URL_BASE +this.recurso_flota+ 'listacoberturas?codigoProducto='+params.codigoProducto+'&SumaAsegurada='+params.sumaAsegurada);
        },
        CoberturasFlota: function (params) {
            if (params.codigoProducto==null && angular.isUndefined(params.nroCotizacion))
            {
                return $http.get(App.URL_BASE +this.recurso_flota + 'coberturapoliza?codigoMoneda='+params.codigoMoneda+'&codigoProducto&numeroCotizacion');
            }
            else if (params.codigoProducto == null && !angular.isUndefined(params.nroCotizacion) )
            {
                return $http.get(App.URL_BASE +this.recurso_flota + 'coberturapoliza?codigoMoneda='+params.codigoMoneda+'&codigoProducto&numeroCotizacion='+params.nroCotizacion);
            }
            else
            {
                return $http.get(App.URL_BASE +this.recurso_flota + 'coberturapoliza?codigoMoneda='+params.codigoMoneda+'&codigoProducto='+params.codigoProducto+'&numeroCotizacion='+params.nroCotizacion);
            }
           

           

        },
        getListaRiesgos: function (params) {

            return $http.get(App.URL_BASE +this.recurso_flota+this.recurso_riesgo+ 'listaRiesgosPg?numeroCotizacion='+params.numeroCotizacion+'&numeroPagina='+params.numeroPagina);
        },
         getCotizacion:function(params){

             var param = encodeURIComponent( angular.toJson(params));
             
             return $http.get(App.URL_BASE +this.recurso_flota+ 'buscacotizacion?numeroCotizacion='+params.numeroCotizacion);
      
        },
        agregarCotizacion: function (params) {
            var param = encodeURIComponent(angular.toJson(params));

            return $http.post(App.URL_BASE + this.recurso_flota+'guarda', angular.toJson(params));
        },
        cotizar: function (params) {
            var param = encodeURIComponent(angular.toJson(params));

            return $http.post(App.URL_BASE + this.recurso_flota+'cotiza', angular.toJson(params));
        },
        editarCotizacion: function (params) {
            var param = encodeURIComponent(angular.toJson(params));

            return $http.put(App.URL_BASE + this.recurso_flota+'cotiza', angular.toJson(params));
        },
        getPdf:function(url){
            return $http.get(url);
        }
        ,
       getAutorizaciones: function(params)
       {
           //pasarle el rol
           return $http.get(App.URL_BASE +this.recurso_validaciones+ 'autorizaciones?'+params.pathModule);
       },
        getCamposEditables:function(params)
        {
            return $http.get(App.URL_BASE +this.recurso_editables + '?numeroCotizacion='+params.numeroCotizacion+'&'+params.pathModule+'&numeroRiesgo='+params.numeroRiesgo);

        },
        actualizarTasa: function(dato)
        {
            return $http.post(App.URL_BASE + this.recurso_flota+'actualizartasa', dato);
        }



    });

}]);
;app.service('HojaAnexaService', ['$http', 'BaseService', function ($http, BaseService) {
    return angular.extend({}, BaseService, {
        
        obtenerHojasAnexas: function (numeroCotizacion, path) {
            return $http.get(App.URL_BASE + 'hojasanexas/recuperar?numeroCotizacion='+numeroCotizacion+'&'+path);
        }, 
        
        guardarHojasAnexas: function (params) {
            var param = encodeURIComponent(angular.toJson(params));
            return $http.post(App.URL_BASE + 'hojasanexas/guardar', angular.toJson(params));
        },
        obtenerCabecera: function()
        {
            return $http.get(App.URL_BASE + 'hojasanexas/textofijo');
        }

    });

}]);
;app.service('ModalFlotaService', ['$http', 'BaseService', function ($http, BaseService) {

    return angular.extend({}, BaseService, {
        recurso: "productos",
        nombre: "Productos",
        /**
         * Se sobrescribe el método base para invocar a la url del recurso paginado.
         * Esto es debido a que se utiliza un json server para simular una api rest.
         * @function
         */
        listar: function (params) {
            return $http.get(App.REST_BASE + "producto-view/vista", {
                params: params
            });
        },

        obtenerTipoProductos: function (params) {
            return $http.get(App.REST_BASE + "tipo-productos/listar", {
            });
        },

        obtenerTipoIva: function (params) {
            return $http.get(App.REST_BASE + "iva/listar", {
            });
        },

        obtenerProducto: function (idProducto) {

            var params = {"idProducto": idProducto}
            var filtros = encodeURIComponent(
                angular.toJson(params));

            return $http.get(App.REST_BASE + 'producto-view/vista?filtros='+filtros);
            /*
             return $http.get(App.REST_BASE + "productos/listar-descripcion", {
             params: params
             });*/
        },
        obtenerDetallesProductos: function (params) {
            return $http.get(App.REST_BASE + 'productos-detalles/listar', {
                params: params
            });
        }
    });
}]);

;app.service('CotizacionHogarService', ['$http', 'BaseService', function ($http, BaseService) {
    return angular.extend({}, BaseService, {

         recurso_generales: "generales/",
         recurso_flota: "flota/",
         recurso_riesgo: "riesgos/",
         recurso_buscador: "cotizacion/",
         recurso_validaciones: "validaciones/",
         recurso_editables:"validaciones/cotizador/editables",
         recurso_hogar:"hogar/",
         recurso_requeridos:"cotizador/requeridos",

    	getProductos: function () {

            return $http.get(App.URL_BASE +this.recurso_hogar+ 'lista/producto'); 
        },
        getMonedas: function (param) {

            return $http.get(App.URL_BASE +this.recurso_hogar+ 'lista/moneda?codigoProducto='+param.codigoProducto); 
        },
        getCotizacion:function(params){

            var param = encodeURIComponent(
               angular.toJson(params));
            return $http.get(App.URL_BASE +this.recurso_hogar+ 'cotizador/buscar?numeroCotizacion='+params.numeroCotizacion+'&'+params.pathModule);
       },
       guardarCotizacionHogar: function (params) {
            var param = encodeURIComponent(
                angular.toJson(params));

            return $http.post(App.URL_BASE + this.recurso_hogar+'cotizador/guardar', angular.toJson(params));
        },

        listarCoberturas: function (params) {

             return $http.get(App.URL_BASE +this.recurso_hogar+'lista/coberturas?codigoProducto='+params.codigoProducto+'&montoIncendioEdificio='+params.montoIncendioEdificio+'&codigoMoneda='+params.codigoMoneda);
            
        },
        getCamposRequeridos: function(params)
       {
           //pasarle el rol
           return $http.get(App.URL_BASE +this.recurso_validaciones+ this.recurso_requeridos+'?numeroCotizacion='+params.numeroCotizacion+"&"+params.pathModule);
       },
        getCiudades: function ()
        {
            return $http.get(App.URL_BASE +this.recurso_generales+'lista/ciudad');

        },
        getInformacion: function(params)
        {
            return $http.get(App.URL_BASE +this.recurso_generales+'informacion?numeroCotizacion='+params.numeroCotizacion+'&marcaModulo='+params.marcaModulo);
        },
        getPolizaGrupoHogar: function(params)
        {
            return $http.get(App.URL_BASE +this.recurso_generales+'lista/polizagrupo?esNuevo='+params.esNuevo+'&'+params.pathModule+'&fechaEfectoPoliza='+params.fechaPoliza);
        }
  

    });

}]);
;app.service('PropuestaHogarService', ['$http', 'BaseService', function ($http, BaseService) {
    return angular.extend({}, BaseService,  {
        recurso_lista:"hogar/lista/",
        recurso_hogar :"hogar/ocupacion/",
        getAcreedores:function ()
        {
            return $http.get(App.URL_BASE+this.recurso_lista+ "acreedorHipotecario");
        },
        getTecho:function ()
        {
            return $http.get(App.URL_BASE+this.recurso_lista+ "techo");
        },
        getPiso:function ()
        {
            return $http.get(App.URL_BASE+this.recurso_lista+ "piso");
        },
        getPared:function ()
        {
            return $http.get(App.URL_BASE+this.recurso_lista+ "pared");
        },
        getEntrePiso:function ()
        {
            return $http.get(App.URL_BASE+this.recurso_lista+ "entrepiso");
        },
        getCieloRaso:function ()
        {
            return $http.get(App.URL_BASE+this.recurso_lista+ "cieloraso");
        },
        getOcupacion:function ()
        {
            return $http.get(App.URL_BASE+this.recurso_lista+ "ocupacion");
        },
        guardarOcupacion: function (params) {
            var param = encodeURIComponent(
                angular.toJson(params));

            return $http.post(App.URL_BASE +this.recurso_hogar+'guardar', angular.toJson(params));
        },
        eliminarOcupacion:function(params) {
            
           return $http.post(App.URL_BASE + this.recurso_hogar+'borrar', params);
        },
        recuperarOcupacion:function (params){
            return $http.get(App.URL_BASE+this.recurso_hogar+ "recuperar?numeroCotizacion="+params.numeroCotizacion+'&'+params.pathModule);
        },
        buscarHogar:function (params){
            return $http.get(App.URL_BASE+"propuesta/hogar/recuperar?numeroCotizacion="+params.numeroCotizacion+'&'+params.pathModule);
        },

        guardarHogar: function (params) {
            var param = encodeURIComponent(
                angular.toJson(params));

            return $http.post(App.URL_BASE +'propuesta/hogar/'+'guardar', angular.toJson(params));
        }


    });

}]);
;app.service('ModalAutorizacionService', ['$http', 'BaseService', function ($http, BaseService) {

    return angular.extend({}, BaseService, {
        recurso_autorizaciones: "autorizaciones/",

      

        guardarAutorizacionVehiculo: function (params) {
            return $http.post(App.URL_BASE + this.recurso_autorizaciones+'guardar/vehiculo', angular.toJson(params));
        },
        
        guardarAutorizacionFlota: function (params) {
            return $http.post(App.URL_BASE + this.recurso_autorizaciones+'guardar/flota', angular.toJson(params));
        },

 
        getAnhosSubModelos : function (params) {
            return $http.get(App.URL_BASE +this.recurso_vehiculos+'aniosubmodelos?codigoMarca='+params.codigoMarca+'&codigoModelo='+params.codigoModelo+'&codigoSubModelo='+params.codigoSubModelo+'&esNuevo='+params.esNuevo);


        } ,

        getRecuperarAutorizaciones : function (params, pathModule) {
            return $http.get(App.URL_BASE +this.recurso_autorizaciones+'recuperar?numeroCotizacion='+params.numeroCotizacion+'&'+pathModule);


        } ,
        eliminarAutorizacion: function (params) {
            return $http.post(App.URL_BASE + this.recurso_autorizaciones+'eliminar', angular.toJson(params));
        },
        guardarAutorizacionHogar: function (params) {
            return $http.post(App.URL_BASE + this.recurso_autorizaciones+'guardar/hogar', angular.toJson(params));
        },
        guardarAutorizacionMultiriesgos: function (params) {
            return $http.post(App.URL_BASE + this.recurso_autorizaciones+'guardar/multiriesgo', angular.toJson(params));
        }
         

 


    });
}]);
;app.service('CotizacionMultiRiesgoService', ['$http', 'BaseService', function ($http, BaseService) {
    return angular.extend({}, BaseService, {

    recurso_multirriesgo:"multirriesgo/",
    recurso_validaciones: "validaciones/",
    recurso_requeridos:"cotizador/requeridos",
    recurso_propuesta_multiriesgo:"propuesta/multirriesgo/",


    getCiudades: function () {

            return $http.get(App.URL_BASE +this.recurso_multirriesgo+ 'lista/ciudad'); 
    },
    getOcupacion: function () {

            return $http.get(App.URL_BASE +this.recurso_multirriesgo+ 'lista/ocupacion'); 
    },
    getCoberturas: function (param) {

            return $http.get(App.URL_BASE +this.recurso_multirriesgo+ 'lista/coberturas?codigoMoneda='+param.codigoMoneda); 
    },
    guardarCotizacionMultiriesgo: function (params) {
        var param = encodeURIComponent(angular.toJson(params));

        return $http.post(App.URL_BASE + this.recurso_multirriesgo+'cotizador/guardar', angular.toJson(params));
    },
   
    getCotizacionMultiriesgo:function(params){

        var param = encodeURIComponent(angular.toJson(params));
        return $http.get(App.URL_BASE +this.recurso_multirriesgo+ 'cotizador/buscar?numeroCotizacion='+params.numeroCotizacion+
        	'&'+params.pathModule);
    },
    getCamposRequeridos: function(params){
           //pasarle el rol
           return $http.get(App.URL_BASE +this.recurso_validaciones+ this.recurso_requeridos+'?numeroCotizacion='+params.numeroCotizacion+"&"+params.pathModule);
    },
    getCartaOferta:function (params){
            var headers = new Headers();
        headers.append('Content-Type', 'application/pdf');
          
        return $http.get(App.URL_BASE+'impresion/multirriesgo/cartaoferta/?numeroCotizacion='+params.numCotizacion, {responseType: 'arraybuffer'});
    }
    


 });
}]);
;app.service('PropuestaMultiRiesgoService', ['$http', 'BaseService', function ($http, BaseService) {
    return angular.extend({}, BaseService, {

    recurso_multirriesgo:"multirriesgo/",
    recurso_validaciones: "validaciones/",
    recurso_requeridos:"cotizador/requeridos",
    recurso_propuesta:"propuesta",
    recurso_propuesta_multiriesgo:"propuesta/multirriesgo",


    
    /*propuesta multiriesgo*/
    guardarPropuestaMultiriesgo: function (params) {
        var param = encodeURIComponent(angular.toJson(params));

        return $http.post(App.URL_BASE + this.recurso_propuesta_multiriesgo+'/guardar', angular.toJson(params));
    },
    getPropuestaMultiriesgo:function(params){

        var param = encodeURIComponent(angular.toJson(params));
        return $http.get(App.URL_BASE +this.recurso_propuesta_multiriesgo+ '/recuperar?numeroCotizacion='+params.numeroCotizacion);
    }


 });
}]);
;app.service('OrdenesRemisionService', ['$http', 'BaseService', function ($http, BaseService) {

    return angular.extend({}, BaseService, {
        recurso: "ordenes-remision",
        nombre: "Ordenes de Remisión",
        /**
         * Se sobrescribe el método base para invocar a la url del recurso paginado.
         * Esto es debido a que se utiliza un json server para simular una api rest.
         * @function
         */
        listarOld: function (params) {
            return $http.get(App.REST_BASE + "ordenes-remision/listar", {
                params: params
            });
        },
        listar: function (params) {
            return $http.get(App.REST_BASE + "ordenes-remision-view/vista", {
                params: params
            });
        },

        /**
         * Realiza un get para obtener una plantilla específica por su id.
         * @function
         */
        obtener: function (params) {
            var filtros = encodeURIComponent(
                angular.toJson(params));

            return $http.get(App.REST_BASE + "ordenes-remision-view/vista?filtros="+filtros, {
            });
        },
        obtenerOrdenesRemision: function (id) {
            var params = {"id": id};
            var filtros = encodeURIComponent(
                angular.toJson(params));

            return $http.get(App.REST_BASE + 'ordenes-remision/listar?filtros='+filtros);
        },
        administrarOrdenRemision: function (params) {
            return $http.get(App.REST_BASE + "ordenes-remision-view/administrar", {
                params: params
            });
        },
        crearOrdenRemisionDetalle: function (params) {
            return $http.post(App.REST_BASE + this.recurso+'/insertar-orden-remision-detalles', params);
        },
        eliminarDetalleRemision: function (id) {
            return $http.delete(App.REST_BASE +"ordenes-remision-detalle/"+id);
        },
        obtenerPorOrden: function (params) {
            var filtros = encodeURIComponent(
                angular.toJson(params));

            return $http.get(App.REST_BASE + "ordenes-remision/listar?filtros="+filtros, {
            });
        },
        finalizarOrdenRemision: function (params) {
            return $http.post(App.REST_BASE + this.recurso+'/finalizar-orden-remision', params);
        },
    });
}]);;app.service('PreferenciaService', ['$rootScope','$http', '$window', '$location', function ($rootScope, $http, $window, $location) {
    return {
        recurso: "propuesta",
        recurso_vehiculos:"vehiculos/",
        recurso_concesionarias:"concesionarias",
        recurso_preferencias:"preferencias/",
        recurso_generales: "generales/",
        recurso_cotizador: "preferenciacotizador",
        getGestoresPago: function()
        {
            return $http.get(App.URL_BASE + this.recurso+"/formapago");
        },
        getFormasPago:function()
        {
            return $http.get(App.URL_BASE + this.recurso_preferencias+"/formapago");
        },
        getGestor: function  (params)
        {
            return $http.get(App.URL_BASE + this.recurso+"/gestores?codigoFormaPago="+params.codFormaPago);
        },
        getMarcas : function (params) {
            return $http.get(App.URL_BASE +this.recurso_vehiculos+ 'marcas');


        },
        getConcesionaria: function()
        {
            return $http.get(App.URL_BASE +this.recurso_preferencias+this.recurso_concesionarias);
        },
        getMonedas: function () {

            return $http.get(App.URL_BASE +this.recurso_generales+ 'monedas?esNuevo=S');
        },
        getFraccionamiento: function () {

            return $http.get(App.URL_BASE +this.recurso_generales+ 'fraccionamientos?esNuevo=S');
        },
        guardarPreferencia: function(tipo, params)
        {
            return $http.post(App.URL_BASE+this.recurso_preferencias+'guardapreferencia?codigoCampo='+tipo, JSON.stringify(params));
        },
        guardarLista: function(tipo, params)
        {
            return $http.post(App.URL_BASE+this.recurso_preferencias+'guardarlista?codigoCampo='+tipo, JSON.stringify(params));
        },
        getPreferencias: function(tipo)
        {
            return $http.get(App.URL_BASE +this.recurso_preferencias+this.recurso_cotizador+ '?codigoCampo='+tipo);
        }
    }
    
}]);;app.service('ProductosService', ['$http', 'BaseService', function ($http, BaseService) {

    return angular.extend({}, BaseService, {
        recurso: "productos",
        nombre: "Productos",
        /**
         * Se sobrescribe el método base para invocar a la url del recurso paginado.
         * Esto es debido a que se utiliza un json server para simular una api rest.
         * @function
         */
        listar: function (params) {
            return $http.get(App.REST_BASE + "producto-view/vista", {
                params: params
            });
        },

        obtenerTipoProductos: function (params) {
            return $http.get(App.REST_BASE + "tipo-productos/listar", {
            });
        },

        obtenerTipoIva: function (params) {
            return $http.get(App.REST_BASE + "iva/listar", {
            });
        },

        obtenerProducto: function (idProducto) {

            var params = {"idProducto": idProducto}
            var filtros = encodeURIComponent(
                angular.toJson(params));

            return $http.get(App.REST_BASE + 'producto-view/vista?filtros='+filtros);
            /*
            return $http.get(App.REST_BASE + "productos/listar-descripcion", {
                params: params
            });*/
        },
        obtenerDetallesProductos: function (params) {
            return $http.get(App.REST_BASE + 'productos-detalles/listar', {
                params: params
            });
        },
    });
}]);
;app.service('PropuestaService', ['$http', 'BaseService', function ($http, BaseService) {

    return angular.extend({}, BaseService, {
        recurso: "propuesta/",
        recurso_validaciones: "validaciones/propuesta",
        recurso_emision: "emision/inmediata/",
        recurso_emision_automatica: "emision/automatica/",
        recurso_validar_terceros:"validar/terceros/",
        nombre: "Propuestas",
        recurso_editables:"validaciones/propuesta/editables",
        /**
         * Se sobrescribe el método base para invocar a la url del recurso paginado.
         * Esto es debido a que se utiliza un json server para simular una api rest.
         * @function
         */
        obtenerComision: function (params) {
            return $http.get(App.URL_BASE + "propuesta/comision?codigoAgente=" + params.codigoAgente+'&'+params.pathModule);
        },

        obtenerEjecutivos: function (codigoNivel3) {
            return $http.get(App.URL_BASE + "propuesta/ejecutivo?codigoOficinaComercial="+codigoNivel3);
        },

        obtenerTiposEnvio: function () {
            return $http.get(App.URL_BASE + "propuesta/tipoenvio");
        },

        obtenerOficinas: function (params) {
            return $http.get(App.URL_BASE + "propuesta/oficinacomercial?codigoAgente=" + params);
        },

        obtenerFormasPago: function (preferencia) {
            return $http.get(App.URL_BASE + "propuesta/formapago?tienePreferencia="+preferencia);
        },

        obtenerGestores: function (params) {
            return $http.get(App.URL_BASE + "propuesta/gestores?codigoFormaPago="+params.codigoFormaPago+'&'+params.pathModule);
        },

        obtenerEntidades: function (params) {
            return $http.get(App.URL_BASE + "propuesta/entidad?codigoGestor="+params.codigoGestor);
        },

        obtenerSucursales: function (params) {
            return $http.get(App.URL_BASE + "propuesta/sucursales?codigoEntidad="+params.codigoEntidad);
        },

        obtenerTiposTarjetas: function () {
            return $http.get(App.URL_BASE + "propuesta/tipostarjetas");
        },

        obtenerTarjetas: function (params) {

            return $http.get(App.URL_BASE + "propuesta/tarjetas?codigoAgente="+params.codigoAgente+"&tipoTarjeta="+params.tipotarjeta);
        },

        obtenerAgentes: function () {
            return $http.get(App.URL_BASE + "generales/agentes");
        },

        obtenerConcesionarias: function (params) {

            return $http.get(App.URL_BASE + "vehiculos/concesionarias?codigoAgente="+params.codigoAgente+"&tienePreferencia="+params.preferencia);

        },

        obtenerReferidos: function (codigoAgente, codigoConcesionaria) {
            return $http.get(App.URL_BASE + "vehiculos/referidos?codigoAgente="+codigoAgente+ "&codigoConcesionaria=" + codigoConcesionaria);
        },

        obtenerAcrPrendarios: function () {
            return $http.get(App.URL_BASE + "vehiculos/acreedoresprendarios");
        },

        guardarPropuesta: function (params) {
             
            return $http.post(App.URL_BASE + this.recurso+'guardar', angular.toJson(params));
        },

        getPropuesta:function(params){
            return $http.get(App.URL_BASE +this.recurso+ 'recuperar?numeroCotizacion='+params.numeroCotizacion+'&'+params.pathModule);
      
        },
        getPdf:function(url){
            return $http.get(url);
        },
        getValidarTomadorBCP:function(params){
            return $http.get(App.URL_BASE +this.recurso_validar_terceros+ 'bcp?numeroCotizacion='+params.numeroCotizacion+'&'+params.pathModule);
      
        },
         /*generar: function (params){
            return $http.get(App.URL_BASE+this.recurso+'generar?numeroCotizacion='+params.numeroCotizacion);
        },*/
        getCamposEditables: function(params)
        {
            //pasarle el rol
            return $http.get(App.URL_BASE +this.recurso_editables + '?numeroCotizacion='+params.numeroCotizacion+'&='+params.pathModule+'&pantalla='+params.pantalla);
        },
       getCamposRequeridos: function(params)
       {
           //pasarle el rol
           return $http.get(App.URL_BASE +this.recurso_validaciones + params.subtipo + 'Requerido?imprimeGenera='+params.imprimeGenera+'&pantalla=PROPUESTA&numeroCotizacion='+ params.numeroCotizacion );
       },
       getValidacionEmision: function(numeroCotizacion, pathModule){
            return $http.get(App.URL_BASE +this.recurso_emision + 'validaciones?numeroCotizacion=' + numeroCotizacion+"&"+pathModule);
        },
        getDescripcionEmision: function(numeroCotizacion, pathModule){
            return $http.get(App.URL_BASE +this.recurso_emision + 'descripcion?numeroCotizacion=' + numeroCotizacion+'&'+pathModule);
        },
        emision: function(numeroCotizacion,pathModule){
            return $http.post(App.URL_BASE +this.recurso_emision + 'emitir?numeroCotizacion=' + numeroCotizacion+'&'+pathModule);
        },
        reemplazar :function(params){
            return $http.post(App.URL_BASE +this.recurso_validar_terceros + 'reemplazar' , angular.toJson(params));
        },
        verificar: function(numeroCotizacion, numeroPropuesta, verificado, pathModule){
            return $http.post(App.URL_BASE +this.recurso_emision_automatica + 'verificado?marcaVerificado=' + verificado + '&'+pathModule+'&numeroCotizacion=' + numeroCotizacion + "&numeroPropuesta=" + numeroPropuesta);
        },
        emisionNocturna: function(numeroCotizacion, numeroPropuesta, verificado, pathModule){
            return $http.post(App.URL_BASE +this.recurso_emision_automatica + 'emisnocturna?marcaEmisNocturna='+verificado+'&'+pathModule+'&numeroCotizacion=' + numeroCotizacion + "&numeroPropuesta=" + numeroPropuesta);
        },
        emisionAutomatica :function(numeroCotizacion, numeroPropuesta, pathModule){
            return $http.post(App.URL_BASE +this.recurso_emision_automatica + 'emitir?'+pathModule+'&numeroCotizacion=' + numeroCotizacion + "&numeroPropuesta=" + numeroPropuesta);
        },
        getEmisionAutomatica: function(numeroPropuesta, pathModulo)
        {
            return $http.get(App.URL_BASE +this.recurso_emision_automatica + 'recuperar?numeroPropuesta=' + numeroPropuesta+'&'+pathModulo);
        },
        enviarConstancia: function(datos)
        {
            return $http.post(App.URL_BASE+'constancia/generar',angular.toJson(datos));
        },
        obtenerFechaVigenciaHasta: function(param)
        {
            return $http.get(App.URL_BASE +this.recurso + 'vigenciahasta?fechaEfectoPoliza=' + param.fechaVigencia+'&'+param.pathModule);
        }

    });
}]);
;app.service('AseguradoService', ['$http', 'BaseService', function ($http, BaseService) {
    return angular.extend({}, BaseService, {
        recurso_propuesta:"propuesta/",
        recurso_validaciones: "validaciones/propuesta",
        
        obtenerListaAsegurados:function(param)
        {
            return $http.get(App.URL_BASE+ this.recurso_propuesta+'listaaseguradosPg?numeroCotizacion='+param.numeroCotizacion+'&numeroPagina='+param.numeroPagina);
        },

        obtenerDetallesRiesgo:function(numeroRiesgo)
        {
            return $http.get(App.URL_BASE+ this.recurso_propuesta+'riesgos/detalleRiesgos?numeroCotizacion=123&numeroRiesgo=' + numeroRiesgo);
        },

        guardarAsegurado:function(asegurado) {
           // var param = encodeURIComponent(angular.toJson(asegurado));
           return $http.post(App.URL_BASE + this.recurso_propuesta+'asegurado/guardar', asegurado);
        },
        actualizarAsegurado:function(asegurado) {
          // var param = encodeURIComponent(angular.toJson(asegurado));
           return $http.post(App.URL_BASE + this.recurso_propuesta+'asegurado/actualizar', asegurado);
        },
        eliminarAsegurado:function(asegurado) {
           //var param = encodeURIComponent(angular.toJson(asegurado));
           return $http.post(App.URL_BASE + this.recurso_propuesta+'asegurado/eliminar', asegurado);
        },
        recuperarAsegurado:function(param)
        {
            return $http.get(App.URL_BASE+ this.recurso_propuesta+'asegurado/recuperar?numeroCotizacion='+param.numeroCotizacion+'&tipoDocumento='+param.tipoDocumento+'&codigoDocumento='+param.codigoDocumento+'&'+param.pathModule);
        },
        getCamposEditables: function(subtipo)
       {
           //pasarle el rol
           return $http.get(App.URL_BASE +this.recurso_validaciones + subtipo + '?rol=EMAAUT&imprimeGenera=GENERA&pantalla=ASEGURADO');
       }


});

}]);
;app.service('DocumentosService', ['$http', 'BaseService', '$rootScope', function ($http, BaseService, $rootScope) {
    return angular.extend({}, BaseService, {
        recurso_propuesta:"propuesta/",

         guardarDocumento: function (params) {
            var param = encodeURIComponent(
            angular.toJson(params));

        //    return $http.post(App.URL_BASE + this.recurso_buscador+'guardacotizacion', angular.toJson(params));

             return $http.post(App.URL_BASE+ this.recurso_propuesta+'documentos/guardar', angular.toJson(params.data));

           // api/propuesta/documentos/guardar?documento
        },

        
        obtenerDocumentosCotizacionPropuesta: function (numeroCotizacion, path) {
            return $http.get(App.URL_BASE + 'documentos/propuesta/listadocumento?numeroCotizacion='+numeroCotizacion+'&'+ path);
        }, 
        
        obtenerDocumentosTomadorAsegurado: function (tipoDocumento, codigoDocumento, path) {
            return $http.get(App.URL_BASE + 'documentos/terceros/listadocumento?tipoDocumento='+tipoDocumento+'&codigoDocumento='+codigoDocumento+'&'+ path);
        }, 

        obtenerTomador: function (numeroCotizacion, path) {
            return $http.get(App.URL_BASE + 'propuesta/tomador/recuperar?numeroCotizacion='+numeroCotizacion+'&tipoBeneficiario=0&'+ path);
        }, 
        
        listarTipoDocumentos: function (param) {
            return $http.get(App.URL_BASE + 'documentos/propuesta/tipodocumento?'+param.pathModule);
        }, 
        
        descargarCotProp: function (numeroCotizacion, item, doc, data) {
            //api/documentos/propuesta/documento?numeroCotizacion&numeroItem
            return $http.get(App.URL_BASE + 'documentos/propuesta/documento?numeroCotizacion='+numeroCotizacion+'&numeroItem='+ item).then(function(response){ 
                $rootScope.listaDocumentosCotizacionPropuestaTemp[doc] = data;
                $rootScope.listaDocumentosCotizacionPropuestaTemp[doc].BASE64 =  "data:image/png;base64," +response.data ; 
            }, function(response){
                Message.error("No se pudo desplegar la imagen");
            });;
        }, 
        
        descargarTomador: function (tipoDocumento, codigoDocumento, item, docTom, data) {
            //api/documentos/terceros/documento?tipoDocumento&codigoDocumento&numeroItem 
            //return $http.get(App.URL_BASE + 'documentos/terceros/documento?tipoDocumento='+tipoDocumento+'&codigoDocumento='+codigoDocumento+'&numeroItem='+ item);

            //api/documentos/propuesta/documento?numeroCotizacion&numeroItem
            return $http.get(App.URL_BASE + 'documentos/terceros/documento?tipoDocumento='+tipoDocumento+'&codigoDocumento='+codigoDocumento+'&numeroItem='+ item).then(function(response){ 
                $rootScope.listaDocumentosTomadorAseguradoTemp[docTom] = data;
                $rootScope.listaDocumentosTomadorAseguradoTemp[docTom].BASE64 =  "data:image/png;base64," +response.data ; 
            }, function(response){
                Message.error("No se pudo desplegar la imagen");
            });;
        }, 


       /* getTipoDocumento:function()
        {
            return $http.get(App.URL_BASE+ this.recurso_propuesta+'tipoDocumento');
        },*/
        
});

}]);
;app.service('RiesgoService', ['$http', 'BaseService', function ($http, BaseService) {
    return angular.extend({}, BaseService, {
        recurso_propuesta:"flota",
        
        obtenerRiesgos:function(params)
        {   //221237
            return $http.get(App.URL_BASE+ this.recurso_propuesta+'riesgos/recuperarListaPg?numeroCotizacion='+params.numeroCotizacion+'&numeroPagina='+params.numeroPagina);
        },

        obtenerDetallesRiesgo:function(param)
        {
            return $http.get(App.URL_BASE+ this.recurso_propuesta+'riesgos/detalleRiesgos?numeroCotizacion='+param.numeroCotizacion+'&numeroRiesgo=' + param.numeroRiesgo);
        },

        guardarRiesgo:function(riesgo)
        {
            return $http.post(App.URL_BASE + this.recurso_propuesta+'/riesgos/altariesgos', riesgo);
        },
        actualizarRiesgo:function(riesgo)
        {
            return $http.post(App.URL_BASE + 'propuesta/vehiculo/actualizariesgo', riesgo);
             
        },
        actualizarAsegurado:function(param)
        {
            return $http.post(App.URL_BASE+ this.recurso_propuesta+'riesgos/actualizarAsegurado?numeroCotizacion='+param.numeroCotizacion+'&tipoDocumento=' + param.tipoDocumento+'&codigoDocumento=' + param.codigoDocumento);
        }


});

}]);
;app.service('TomadorService', ['$http', 'BaseService', function ($http, BaseService) {
    return angular.extend({}, BaseService, {
        recurso_propuesta:"propuesta/",
        recurso_validar:"validar/",
        recurso_validaciones: "validaciones/propuesta",
        getTipoDocumento:function()
        {
            return $http.get(App.URL_BASE+ this.recurso_propuesta+'tipoDocumento');
        },
        getEstadoCivil: function()
        {
            return $http.get(App.URL_BASE+this.recurso_propuesta+'estadocivil');
        },
        getNacionalidad: function()
        {
            return $http.get(App.URL_BASE+this.recurso_propuesta+'nacionalidad');
        },
        getProfesion: function()
        {
            return $http.get(App.URL_BASE+this.recurso_propuesta+'profesion');
        },
        getActividades: function()
        {
            return $http.get(App.URL_BASE+this.recurso_propuesta+'actividades');
        },
        getCiudades: function()
        {
            return $http.get(App.URL_BASE+this.recurso_propuesta+'ciudad');
        },
        getBarrios:function(params)
        {
            return $http.get(App.URL_BASE+this.recurso_propuesta+'barrio?codigoProv='+params.codigo);
        },
        getPersona: function (params)
        {
            return $http.get(App.URL_BASE+this.recurso_propuesta+'datostercero?tipoDocumento='+params.tipoDoc+'&codigoDocumento='+params.codigoDoc);
        },
        guardarPropuestaTomadorAsegurado: function (params) {
             
            return $http.post(App.URL_BASE + this.recurso_propuesta+'tomador/guardar', angular.toJson(params));
        },

        getPropuestaTomadorAsegurado:function(params){
            return $http.get(App.URL_BASE +this.recurso_propuesta+ 'tomador/recuperar?numeroCotizacion='+params.numeroCotizacion+'&tipoBeneficiario='+params.tipoBeneficiario+'&'+params.pathModule);
      
        },
        getValidarTomadorBCP:function(params){
            return $http.get(App.URL_BASE +this.recurso_validar+ 'terceros/bcp?tipoDocumento='+params.tipoDocumento+'&codigoDocumento='+params.codigoDocumento+'&codigoNacionalidad='+params.codigoNacionalidad+
                '&nombre='+params.nombre+'&primerApellido='+params.primerApellido+'&segundoApellido='+params.segundoApellido+'&fechaNacimiento='+params.fechaNacimiento+'&marcaFisico='+params.marcaFisico);
      
        },
         getCamposEditables: function(subtipo, tipo)
       {
           //pasarle el rol
           return $http.get(App.URL_BASE +this.recurso_validaciones + subtipo + '?rol=EMAAUT&pantalla='+tipo);
       },
       getCamposRequeridos: function(subtipo, tipo)
       {
           //pasarle el rol
           return $http.get(App.URL_BASE +this.recurso_validaciones + subtipo + 'Requerido?rol=EMAAUT&imprimeGenera=IMPRIME&pantalla='+tipo);
       }


});

}]);
;/*
 * @Class
 * Definición del service que se encarga de la comunicación con la capa de servicios
 * para realizar las operaciones relacionadas con la sessión del usuario.
 *
 * @name cm.service#SessionService
 */
app.service('SessionService', ['$rootScope','$http', '$window', '$location', function ($rootScope, $http, $window, $location) {
    return {    
        /**
         * Realiza un get para obtener los datos de usuario logeado
         * @function
         */
        loadUserInfo: function (codigoUsuario) {
            var params = {"codigoUsuario": codigoUsuario}
            var filtros = encodeURIComponent(
                angular.toJson(params));

            return $http.get(App.REST_BASE + 'usuario-view/vista?filtros='+filtros);
        },

        login: function(username, password){
            return $http.post("autenticador/login",
             //{username:"admin", password: "123456"},
             {username:username, password: password},
             {headers:{'Content-Type': 'application/json', 
                    'Access-Control-Allow-Origin': '*', 
                    'Access-Control-Allow-Methods': 'GET, POST, OPTIONS, PUT, PATCH, DELETE', 
                    'Access-Control-Allow-Headers': 'X-Requested-With,content-type', 
                    'Access-Control-Allow-Credentials': 'true' }
                }
             );
        },

        pruebaToken: function(){
            return $http.get("http://localhost:8888/api/Account/UserInfo");
        },

        permiso: function(token){
            var tokenBearer = "Bearer " + token;
            //var headers: { Authorization: tokenBearer};
            return $http.get("http://localhost:8888/autenticador/sesion?url=1", {headers:{'Authorization':tokenBearer,
                        'Access-Control-Allow-Origin': '*', 
                        'Access-Control-Allow-Methods': 'GET, POST, OPTIONS, PUT, PATCH, DELETE', 
                        'Access-Control-Allow-Headers': 'X-Requested-With,content-type', 
                        'Access-Control-Allow-Credentials': 'true'
            }});
        }
    }
}]);
;/*
 * @Class
 * Definición del service que se encarga de la consulta para confirmar una acción
 *
 */
app.service('DialogService', ['$http', '$rootScope', '$mdDialog', function ($http, $rootScope, $mdDialog) {
    return {

        showDialog: function(data) {
            /* var param = {body:data}
            if(typeof data.header != 'undefined'){
                 param = {
                     header: data.header ,
                     body:data.body
                 }

            } */
            return $mdDialog.show({
                controller: 'DialogCtrl',
                templateUrl: 'partials/ventanas-emergentes/dialog-partial.html',
                parent: angular.element(document.body),
                clickOutsideToClose:false,
                locals: {mensaje:data},
                fullscreen: false// Only for -xs, -sm breakpoints.
            });
        }
    }
}]);
;app.service('SuplementosListServices', ['$http', 'BaseService', function ($http, BaseService) {
    return angular.extend({}, BaseService, {
    
    recurso_detalles: "gestiones",
    recurso_vehiculos:"vehiculos",

    getSuplementosList: function(){
        return $http.get(App.URL_BASE+'/suplementos/lista');
    },
    getDatosVehiculos: function(params){
        return $http.get(App.URL_BASE+'/suplementos/vehiculo?numeroCotizacion='+params);
    },
    getMotivosAnulacion: function(params){
        return $http.get(App.URL_BASE+'/suplementos/motivoAnulacion');
    },
    emitirCambioVehiculo:function(params)
    {
        return $http.post(App.URL_BASE+'suplementos/emitircambio', params);
    },
    emitirAnulacionVehiculo:function(params)
    {
        return $http.post(App.URL_BASE+'suplementos/emitiranulacion', params);
    },
    guardarAnulacion:function(params)
    {
        return $http.post(App.URL_BASE+'suplementos/guardaranulacion', params);
    },
    getDatosTomador: function(params){
        return $http.get(App.URL_BASE+'/suplementos/datotomador?numeroCotizacion='+params);
    },
    imprimirProp: function(param){
        return $http.get(App.URL_BASE+'/impresion/suplemento/propuesta?numeroCotizacion='+param.numeroCotizacion);
    },
    getAnulado: function(param){
        return $http.get(App.URL_BASE+"suplementos/recuperaAnulado?numeroPropuesta=" + param.numeroPropuesta);
    }

    });
    
}]);;app.service('UsuarioService', ['$http', 'BaseService', function ($http, BaseService) {

    return angular.extend({}, BaseService, {
        recurso: "usuario",
        nombre: "Usuario",
        /**
         * Se sobrescribe el método base para invocar a la url del recurso paginado.
         * Esto es debido a que se utiliza un json server para simular una api rest.
         * @function
         */
        listar: function (params) {
            return $http.get(App.REST_BASE + "usuario-view/vista", {
                params: params
            });
        },

        obtenerPersonas: function (params) {
            return $http.get(App.REST_BASE + "personas/listar", {
            });
        },

        obtenerTipoUsuario: function (params) {
            return $http.get(App.REST_BASE + "usuario-tipo/listar", {
            });
        },

        obtenerProducto: function (idProducto) {

            var params = {"idProducto": idProducto}
            var filtros = encodeURIComponent(
                angular.toJson(params));

            return $http.get(App.REST_BASE + 'producto-view/vista?filtros='+filtros);
            /*
            return $http.get(App.REST_BASE + "usuario/listar-descripcion", {
                params: params
            });*/
        },
        obtenerUsuario: function (idUsuario) {
            var params = {"id": idUsuario};
            var filtros = encodeURIComponent(
                angular.toJson(params));

            return $http.get(App.REST_BASE + 'usuario/listar?filtros='+filtros);
        },
        obtenerUsuarioDescripcion: function (idUsuario) {
            var params = {"idUsuario": idUsuario};
            var filtros = encodeURIComponent(
                angular.toJson(params));

            return $http.get(App.REST_BASE + 'usuario-view/vista?filtros='+filtros);
        }
    });
}]);
;app.factory('UtilsService',function UtilsService($rootScope) {
    return {


        verificarCamposForm: function (listaCampos, nombreCampo) {
			if ( !angular.isUndefined(listaCampos) && listaCampos.length>0)
			{
				if (listaCampos.indexOf(nombreCampo)>=0) {

					return true;
				}
				else {

					return false;
				}
			}
			else
			{
				return false;
			}
            


        },
		truncar: function(x) {
			if (isNaN(x)) {
				return NaN;
			}
			if (x > 0) {
				return Math.floor(x);
			}
			return Math.ceil(x);
        },

        retornarPath: function (currentPath) {
			if ( !angular.isUndefined(currentPath) && currentPath.length>0)
			{

				 return 'marcaModulo='+currentPath;
			}
			else
			{
				return "marcaModulo=";
			}
            


        },
		bloquearCamposTercero:function(listaCampos, nombreCampo, valoresCampo)
		{
			if ($rootScope.currentModule.indexOf("propuesta")>0 && ($rootScope.currentModule.indexOf("tomador")>0) || ($rootScope.currentModule.indexOf("asegurado"))) {
				if (!angular.isUndefined(valoresCampo.existeTercero) && valoresCampo.existeTercero !=null)
				{
					/**Si el tercero no existe en la tabla de ellos se deberia de hacer caso a lo que dice los campos editables**/
					if (valoresCampo.existeTercero=="N")
					{
						return !this.verificarCamposForm(listaCampos, nombreCampo);
					}
					else
					{
						/***Aplicar reglas, esto es en caso que el tercero exista en la tabla bcp y madre, las reglas deben mantenerse**/
						if (valoresCampo.tipoDocumento!=null && valoresCampo.tipoDocumento!="" && valoresCampo.codigoDocumento!=null && valoresCampo.codigoDocumento!="") /**esta marca se utiliza para saber si fue llamado el metodo obtenerPersona en el formulario tomador**/
						{

							if (nombreCampo=="personaFisica" || nombreCampo=="nombres" || nombreCampo=="apellido1" || nombreCampo=="apellido2" || nombreCampo=="fechaNacimiento")
							{
								if ( nombreCampo=="fechaNacimiento" && valoresCampo.fechaNacimiento=="")
								{
									return false;
								}
								return true;
							}
							else
							{
								/**aca validar el valor del campo, es distinto de null o vacio, y se debe poder editar, ademas tener perfil de empleado**/
								var grupo=sessionStorage.getItem("grupoUsuario");
								if (grupo!="" && grupo!="11" && grupo!="12") /**si es empleado, puede editar estos campos**/
								{
									if (nombreCampo=="telefono" || nombreCampo=="telefonoLaboral" || nombreCampo=="telefonoMovil" || nombreCampo=="faxLaboral"|| nombreCampo=="fax" || nombreCampo=="emailLaboral" || nombreCampo=="email")
									{
										return false;
									}


								}
								else /**es agente, entonces si en el valor del campo tiene cargado algo entonces no deberia editar**/
								{
									if (nombreCampo=="telefono" && valoresCampo.numeroTelefono!="" && valoresCampo.numeroTelefono!=null) /**no podrá editar**/
									{
										return true;
									}
									else if (nombreCampo=="telefonoLaboral" && valoresCampo.numeroTelefonoCom!="" && valoresCampo.numeroTelefonoCom!=null) /**no podrá editar**/
									{
										return true;
									}

									else if (nombreCampo=="telefonoMovil" && valoresCampo.numeroMovil!="" && valoresCampo.numeroMovil!=null)  /**no podrá editar**/
									{
										return true;
									}

									else if (nombreCampo=="faxLaboral" && valoresCampo.numeroFaxCom!="" && valoresCampo.numeroFaxCom!=null) /**no podrá editar**/
									{
										return true;
									}

									else if (nombreCampo=="fax" && valoresCampo.numeroFax!="" && valoresCampo.numeroFax!=null) /**no podrá editar**/
									{
										return true
									}

									else if (nombreCampo=="emailLaboral" && valoresCampo.emailCom!="" && valoresCampo.emailCom!=null) /**no podrá editar**/
									{
										return true;
									}

									else if (nombreCampo=="email" && valoresCampo.email!="" && valoresCampo.email!=null) /**no podrá editar**/
									{
										return true;
									}
									else
									{
										return false;
									}
								}
								return false;
							}



							/*}*/

						}
						else
						{
							return !this.verificarCamposForm(listaCampos, nombreCampo);
						}


					}

				}
				else
				{
					/**Aplicar reglas esto se da en caso, que se llame desde recuperar persona**/
					if (valoresCampo.tipoDocumento!=null && valoresCampo.tipoDocumento!="" && valoresCampo.codigoDocumento!=null && valoresCampo.codigoDocumento!="") /**esta marca se utiliza para saber si fue llamado el metodo obtenerPersona en el formulario tomador**/
					{

						if (nombreCampo=="personaFisica" || nombreCampo=="nombres" || nombreCampo=="apellido1" || nombreCampo=="apellido2" || nombreCampo=="fechaNacimiento")
						{
							if ( nombreCampo=="fechaNacimiento" && valoresCampo.fechaNacimiento=="")
							{
								return false;
							}
							return true;
						}
						else
						{
							/**aca validar el valor del campo, es distinto de null o vacio, y se debe poder editar, ademas tener perfil de empleado**/
							var grupo=sessionStorage.getItem("grupoUsuario");
							if (grupo!="" && grupo!="11" && grupo!="12") /**si es empleado, puede editar estos campos**/
							{
								if (nombreCampo=="telefono" || nombreCampo=="telefonoLaboral" || nombreCampo=="telefonoMovil" || nombreCampo=="faxLaboral"|| nombreCampo=="fax" || nombreCampo=="emailLaboral" || nombreCampo=="email")
								{
									return false;
								}


							}
							else /**es agente, entonces si en el valor del campo tiene cargado algo entonces no deberia editar**/
							{
								if (nombreCampo=="telefono" && valoresCampo.numeroTelefono!="" && valoresCampo.numeroTelefono!=null) /**no podrá editar**/
								{
									return true;
								}
								else if (nombreCampo=="telefonoLaboral" && valoresCampo.numeroTelefonoCom!="" && valoresCampo.numeroTelefonoCom!=null) /**no podrá editar**/
								{
									return true;
								}

								else if (nombreCampo=="telefonoMovil" && valoresCampo.numeroMovil!="" && valoresCampo.numeroMovil!=null)  /**no podrá editar**/
								{
									return true;
								}

								else if (nombreCampo=="faxLaboral" && valoresCampo.numeroFaxCom!="" && valoresCampo.numeroFaxCom!=null) /**no podrá editar**/
								{
									return true;
								}

								else if (nombreCampo=="fax" && valoresCampo.numeroFax!="" && valoresCampo.numeroFax!=null) /**no podrá editar**/
								{
									return true
								}

								else if (nombreCampo=="emailLaboral" && valoresCampo.emailCom!="" && valoresCampo.emailCom!=null) /**no podrá editar**/
								{
									return true;
								}

								else if (nombreCampo=="email" && valoresCampo.email!="" && valoresCampo.email!=null) /**no podrá editar**/
								{
									return true;
								}
								else
								{
									return false;
								}
							}
							return false;
						}



						/*}*/

					}
					else
					{
						return !this.verificarCamposForm(listaCampos, nombreCampo);
					}
				}

			}
		}

}

});
;app.factory('utils', function Utils() {
    return {
      insertData: function (list, numItems, data) {
        for(var i = 0; i < numItems; i++) {
          list.push({id: i + 1, nombre:data[i].nombre, codigoId: data[i].codigoId});
        }  
      },
      getIndexesFromList: function(list) {
        var newList = [];
        for(var i in list) {
          if(typeof list[i].id === "number" && newList.indexOf(list[i].id) === -1) newList.push(list[i].id)
        }
        return newList;
      },
      getAllSelectedItems: function(list) {
        var newList = [];
        newList = list.filter(function(el) {
              return el.active === true;
        });
        return newList;
      },
      addListIfNoExists: function(list, newListToAppend) {
        var indexes = this.getIndexesFromList(list);
        var newList = [];
        for(var i in newListToAppend) {
          /*if(indexes.indexOf(newListToAppend[i].id) === -1)*/
          list.push(newListToAppend[i])
        }
        return list;
      },

    }
});
;app.service('VehiculoService', ['$http', 'BaseService', function ($http, BaseService) {

    return angular.extend({}, BaseService, {
        recurso: "propuesta/vehiculo/",
        nombre: "Vehiculos",
        documentos:"documentos/",
        /**
         * Se sobrescribe el método base para invocar a la url del recurso paginado.
         * Esto es debido a que se utiliza un json server para simular una api rest.
         * @function
         */
        obtenerColores: function () {
            return $http.get(App.URL_BASE + "vehiculos/colores");
        },

        obtenerUsos: function (param) {
            return $http.get(App.URL_BASE + "vehiculos/usosvehiculos?codigoTipoVehiculo="+param.codTipoVehiculo);
        },
        guardarPropuestaVehiculo: function (params) {
             
            return $http.post(App.URL_BASE + this.recurso+'guardar', angular.toJson(params));
        },
        guardarSuplementoVehiculo: function (params) {
             
            return $http.post(App.URL_BASE + this.recurso+'guardarSuplemento', angular.toJson(params));
        },

        getPropuestaVehiculo:function(params){
            return $http.get(App.URL_BASE +this.recurso+ 'recuperar?numeroCotizacion='+params.numeroCotizacion+'&'+params.pathModule);
      
        },
        listadoImagenes:function(params)
        {
            return $http.get(App.URL_BASE +this.documentos+ 'vehiculo/listaimagenes?numeroInspeccion='+params.inspeccion);
        },
        obtenerImagen:function(params)
        {
            return $http.get(App.URL_BASE +this.documentos+ 'vehiculo/imagen?numeroInspeccion='+params.inspeccion+"&numeroItem="+params.item);
        }

    });
}]);
;/*
 * @class
 * Directiva que se encarga de manejar el doble listado de concesionarias.
 */
app.directive('dualListConcesionarias', [function (utils) {
    function _controller ($scope, utils) {
        $scope.selectAllItem = function(list, checked) {
            list.map(function(item) {
                item.active = checked
                return item;
            });
        };
        $scope.getAllSelectedItems = function(list) {
            return utils.getAllSelectedItems(list);
        }
        $scope.moveItemToRightList = function() {
            var newListToAppend = $scope.list3.filter(function(el) {
                if(el.active === true) {
                    el.active = false;
                    return el;
                }
            });
            if (newListToAppend.length > 0) {
                $scope.list3 = $scope.list3.filter(function (el) {
                    return utils.getIndexesFromList(newListToAppend).indexOf(el.id) === -1;
                });
                $scope.list4 = utils.addListIfNoExists($scope.list4, newListToAppend);
                if($scope.list3.length === 0) $scope.checked1 = false;
            }

        };
        $scope.moveItemToLeftList = function() {
            var newListToAppend = $scope.list4.filter(function(el) {
                if(el.active === true) {
                    el.active = false;
                    return el;
                }
            });
            if (newListToAppend.length > 0) {
                $scope.list4 = $scope.list4.filter(function (el) {
                    return utils.getIndexesFromList(newListToAppend).indexOf(parseInt(el.id)) === -1;
                });
                $scope.list3 = utils.addListIfNoExists($scope.list3, newListToAppend);
                if($scope.list4.length === 0) $scope.checked2 = false;
            }

        };
    }
    return {
        restrict: 'E',
        scope: { list4: "=", list3:"=" },
        controller: _controller,
        templateUrl: "partials/dual-list/dual-concesionarias.html"

    };

}
]);;/*
 * @class
 * Directiva que se encarga de manejar el doble listado.
 */
app.directive('dualListMarcas', [function (utils) {
    function _controller ($scope, utils) {
        $scope.selectAllItem = function(list, checked) {
            list.map(function(item) {
                item.active = checked
                return item;
            });
        };
        $scope.getAllSelectedItems = function(list) {
            return utils.getAllSelectedItems(list);
        }
        $scope.moveItemToRightList = function() {
            var newListToAppend = $scope.list1.filter(function(el) {
                if(el.active === true) {
                    el.active = false;
                    return el;
                }
            });
            if (newListToAppend.length > 0) {
                $scope.list1 = $scope.list1.filter(function (el) {
                    return utils.getIndexesFromList(newListToAppend).indexOf(el.id) === -1;
                });
                $scope.list2 = utils.addListIfNoExists($scope.list2, newListToAppend);
            }

        };
        $scope.moveItemToLeftList = function() {
            var newListToAppend = $scope.list2.filter(function(el) {
                if(el.active === true) {
                    el.active = false;
                    return el;
                }
            });
            if (newListToAppend.length > 0) {
                $scope.list2 = $scope.list2.filter(function (el) {
                    return utils.getIndexesFromList(newListToAppend).indexOf(parseInt(el.id)) === -1;
                });
                $scope.list1 = utils.addListIfNoExists($scope.list1, newListToAppend);

            }

        };

      }
      return {
        restrict: 'E',
        scope: { list2: "=", list1:"=" },
        controller: _controller,
        templateUrl: "partials/dual-list/dual-marcas.html"

      };
      
}
]);;
/*
 * @class
 * Directiva que se encarga de disparar un evento cuando se presiona la tecla ENTER
 *
 */
app.directive('ngEnter', function () { //a directive to 'enter key press' in elements with the "ng-enter" attribute

return function (scope, element, attrs) {

    element.bind("keydown keypress", function (event) {
        if (event.which === 13) {
            scope.$apply(function () {
                scope.$eval(attrs.ngEnter);
            });

            event.preventDefault();
        }
    });
}
});/*
 * @class
 * Directiva que se encarga de mostrar un mensaje cuando no hay 
 * datos para las visualizaciones.
 */
app.directive('loading', [function () {
        return {
            restrict: 'E',
            template: ' <br/><br/><br/><br/><div class="loading"><img src="./images/loader.gif"><br/><p>Cargando...</p></div>',
            scope: {},
            link: function (scope, element) {
                return;
            }
        }
    }
]);
;
app.directive('moneda', function() {
        return {
            require: 'ngModel',
			scope: {
				ngModel: '='
			},
            link: function(scope, element, attrs, modelCtrl) {
                /**
                 * Función encargada de formatear el $viewValue
                 * @return
                 */
                var darFormato = function(input) {
                    if (input == null) {
                        return undefined;
                    }
                    //reemplazo los puntos decimales que llegan por '', para poder
                    //separar correctemente de a tres.
                    //Dependiendo de que si tiene coma o no para poder separar
                    var nuevo = input.toString().replace(/\./g, ',');
                    /*
                    Como el regex para agregar separadores de miles varia dependiendo
                    si el input que representa el monto posee o no separador decimal,
                    se comprueba la presencia de dicho caracter
                    */
                    var existeComa = nuevo.split(',');
                    if(existeComa.length == 1){//La expresión NO posee separador decimal
                        //agrega separadores de miles(.) y retorna el resultado
                        return (nuevo.toString().replace(/(\d)(?=(\d\d\d)+(?!\d))/g, "$1."));
                    }else{//La expresión SI posee separador decimal
                        //agrega separadores de miles(.) y retorna el resultado
						//tomar solo el primer y segundo elemento
					
                        return (nuevo.toString().replace(/(\d)(?=(\d\d\d)+(,))/g, "$1."));
                    }
                    
                };




                darFormato.esFormatNumero = true;

                modelCtrl.$formatters.push(darFormato);
                
                /**
                 * Función encargada de parsear
                 * @return
                 */
                 modelCtrl.$parsers.push(function(input) {
                    if (input == null) {
                        return;
                    };
                    modelCtrl.$setValidity('moneda', true);
                    // Se tiene en cuenta el uso de coma o punto como separador decimal
                    var regExNumReal = /^\-?\d+((\.|\,)\d+)?$/;
                    if(regExNumReal.test(input.toString())){
                        if ((/\,/).test(input.toString())) {
                            // Al final en el modelo, siempre se tiene el punto como
                            // separador decimal
                            //console.log("Tiene coma");
                            return input;
                            //return input.replace(/\,/,'.');
                        }else{
                            //console.log("Tiene una solo punto y es sin coma");
                            var pattern="."
                            var exp= new RegExp(pattern, "g")
                            nuevoValor=input.toString().split(pattern).join("");
                            return nuevoValor;
                        }
                    }else{
                        //console.log("El valor no tiene coma");
                        var nuevoValor=input.toString();
                       // console.log("Cantidad de puntos ");

                        var cantpuntos=input.toString().split(".");
                        console.log(cantpuntos)

                        if (cantpuntos.length>1)
                        {

                            var pattern="."
                            var exp= new RegExp(pattern, "g")
                            nuevoValor=input.toString().split(pattern).join("");

                            //console.log("Valor reemplazado en el modelo es  ", nuevoValor)

                        }
                        else
                        {

                        }
                        modelCtrl.$setValidity('moneda',true);
                        return nuevoValor;

                        //return input;
                    };
                });


                /**
                 * Función encargada de asignar asignar los puntos decimales una vez hecho 
                 * el desenfoque del input
                 * @return
                 */
                    element.bind('blur', function() {
                    //manda a mi función el $viewValue, sobre el cual va a ser el formato
                    var modelValue = modelCtrl.$modelValue;
                    var valorCambiado;
                    /*for (var i in modelCtrl.$formatters) {
                        if (modelCtrl.$formatters[i].esFormatNumero) {
                            valorCambiado = modelCtrl.$formatters[i](modelValue);
                        }
                    }*/
                    valorCambiado = darFormato(modelValue);
                    modelCtrl.$viewValue = valorCambiado;
                    modelCtrl.$render();
                });


                /**
                 * Función encargada de mostrar el valor almacenado en el model sin ningún formateo
                 * cuando el elemento adquiere foco.
                 * @return
                 */
                element.bind('focus', function() {
                    // Se obtiene el $modelValue para asignar dicho valor al $viewValue
                    modelCtrl.$viewValue = modelCtrl.$modelValue;
                    modelCtrl.$render();
                });
				
				
				 element.bind('keypress', function(event) {
					 //console.log("Key press");
					var charCode = event.which || event.keyCode;
					if (charCode !=44){ //cuando no se aprieta coma, se verifica que sean numeros
				      if (charCode < 48 ||charCode > 57 ) { //se verifican que no sean letras las que se esten tipeando
						if (charCode === 8)
						{


							//console.log("Backspace en keydown mozilla, chrome")
							modelCtrl.$viewValue = modelCtrl.$modelValue;
							modelCtrl.$render();

						}
						else
						{
							event.preventDefault();
						}
					 
				      
						}
						else //se verifica sino hay alguna coma, y se valida que no supere 2 digitos
						{


							var valor = modelCtrl.$modelValue;
							//console.log("El valor cuando se aprietan numeros despues de la coma, si es que hay coma ", valor);
							if (typeof valor !== 'undefined' && valor !== null)
							{	
								//valorCambiado = darFormato(valor);

                                    var posCaracter=element.get(0).selectionStart;
                                    var posPunto=valor.toString().indexOf(".");
                                    //verificamos que el caracter insertado este en la parte entera o decimal
                                    //si la posicion del caractere insertado es mayor a la posicion de donde se encuentra el punto entonces, se inserto en la parte decimal

                                    if (posCaracter>posPunto)
                                    {
                                        //validar cantidad de decimales luego de la coma
                                        var idx =valor.toString().split(".");
                                        if (idx.length>1)
                                        {
                                            var cantidad=idx[1];
                                            if (cantidad.length>1)
                                            {

                                                event.preventDefault();
                                            }
                                        }
                                    }
                                    //sino se supera entonces, se procede a insertar normalmente

								
								
							}
						
						
						}
					 
				  }
				  else
				  { //cuando se aprieta la coma, se verifica que haya numeros antes o despues	
					var valor = modelCtrl.$modelValue;
					//console.log("El valor cuando se aprieta la coma ", valor);
					if (typeof valor == 'undefined' || valor == null)
					{
						
						event.preventDefault();
						
					} 
				  }
				 
                  if(charCode === 46) {
                      //console.log("Cuando se borra un elemento");
                   event.preventDefault();
                   }
				   //cuando se quiere borrar un elemento
				   
                 });
				 
            }
        };
    });
;/*
 * @class
 * Directiva que se encarga de mostrar un mensaje cuando no hay 
 * datos para las visualizaciones.
 */
app.directive('noData', [function () {
        return {
            restrict: 'E',
            template: '<div class="no-data"><i class="fa fa-low-vision"></i><br/>No hay datos disponibles</div>',
            scope: {},
            link: function (scope, element) {
                return;
            }
        }
    }
]);
;app.directive('number', function () {
    return  {
        restrict: 'A',
        link: function (scope, elm, attrs, ctrl) {
		     
            elm.on('keydown', function (event) {
			   
                var $input = $(this);  
                var value = $input.val();  
                value = value.replace(/[^0-9]/g, '')  
                $input.val(value);  
                if (event.which == 64 || event.which == 16) {  
                    // to allow numbers  
                    return false;  
                } else if (event.which >= 48 && event.which <= 57) {  
                    // to allow numbers  
                    return true;  
                } else if (event.which >= 96 && event.which <= 105) {  
                    // to allow numpad number  
                    return true;  
                } else if ([8, 13, 27, 37, 38, 39, 40].indexOf(event.which) > -1) {  
                    // to allow backspace, enter, escape, arrows  
                    return true;
                 					
                } else {  
                    event.preventDefault();  
                    // to stop others  
                    //alert("Sorry Only Numbers Allowed");  
                    return false;  
                }
            });
        }
    }
});;app.directive('numberletter', function () {
    return {
        require: 'ngModel',
        link: function(scope, element, attr, ngModelCtrl) {
            function fromUser(text) {
                var transformedInput = text.replace(/[^0-9a-zA-Z]/g, '');
                //console.log(transformedInput);
                if (transformedInput !== text) {
                    ngModelCtrl.$setViewValue(transformedInput);
                    ngModelCtrl.$render();
                }
                return transformedInput;
            }
            ngModelCtrl.$parsers.push(fromUser);
        }
    };
});
;app.directive("preventTypingGreater", function() {
  return {
    link: function(scope, element, attributes) {
      var oldVal = null;
      element.on("keydown keyup", function(e) {
    if (Number(element.val()) > Number(attributes.max) &&
          e.keyCode != 46 // delete
          &&
          e.keyCode != 8 // backspace
        ) {
          e.preventDefault();
          element.val(attributes.max);
        }
        else {
            oldVal = Number(element.val());
        }


      });
    }
  };
});;app.directive("preventTypingLess", function() {
  return {
    link: function(scope, element, attributes) {
      var oldVal = null;
      element.on("keydown keyup", function(e) {
    if (Number(element.val()) < Number(attributes.min) &&
          e.keyCode != 46 // delete
          &&
          e.keyCode != 8 // backspace
        ) {
          e.preventDefault();
          element.val(attributes.min);
        }
        else if (Number(element.val())== Number(attributes.min) && element.val().length==1 && e.keyCode != 46 // delete
        && e.keyCode != 8) // backspace)
        {
            e.preventDefault();


        }
        else {
            oldVal = Number(element.val());
        }

      });
    }
  };
});;/*
 * @class
 * Directiva que se encarga de mostrar un mensaje cuando no hay 
 * datos para las visualizaciones.
 */
app.directive('currencyInput', function($filter, $browser) {
    return {
        require: 'ngModel',
        link: function($scope, $element, $attrs, ngModelCtrl) {
            var listener = function() {
                var value = $element.val().replace(/,/g, '')
                $element.val($filter('number')(value, false))
            }
            
            // This runs when we update the text field
            ngModelCtrl.$parsers.push(function(viewValue) {
                return viewValue.replace(/,/g, '');
            })
            
            // This runs when the model gets updated on the scope directly and keeps our view in sync
            ngModelCtrl.$render = function() {
                $element.val($filter('number')(ngModelCtrl.$viewValue, false))
            }
            
            $element.bind('change', listener)
            $element.bind('keydown', function(event) {
                var key = event.keyCode
                // If the keys include the CTRL, SHIFT, ALT, or META keys, or the arrow keys, do nothing.
                // This lets us support copy and paste too
                if (key == 91 || (15 < key && key < 19) || (37 <= key && key <= 40)) 
                    return 
                $browser.defer(listener) // Have to do this or changes don't get picked up properly
            })
            
            $element.bind('paste cut', function() {
                $browser.defer(listener)  
            })
        }
        
    }
});
;app.directive('uppercase', function() {
        return {
            require: 'ngModel',
            link: function(scope, element, attrs, modelCtrl) {
                modelCtrl.$parsers.push(function(input) {
                    return input ? input.toUpperCase() : "";
                });
                element.css("text-transform","uppercase");
            }
        };
    });;app.directive('validInputNumber', function() {
    return {
        require: 'ngModel',
        link: function(scope, element, attrs, ctrl) {
            ctrl.$parsers.unshift(function (viewValue) {
                var options = scope.$eval(attr.restrictInput);
                options.regex = "^[-+]?[0-9]*(\\.[0-9]+)?$"
                var reg = new RegExp(options.regex);
                if (reg.test(viewValue)) { //if valid view value, return it
                    return viewValue;
                } else { //if not valid view value, use the model value (or empty string if that's also invalid)
                    var overrideValue = (reg.test(ctrl.$modelValue) ? ctrl.$modelValue : '');
                    element.val(overrideValue);
                    return overrideValue;gri
                }
            });
        }
    };
});
;app.directive('verifiedClass', [function(){
    return{
        restrict: 'A',
        link: function(scope, element, attrs, controller){
            scope.$watch(function() {return element.attr('class'); }, function(newValue){

                if (element.hasClass('has-error')) {
                     console.log("Cantidad que entra", 1)

                }
            });
        }
    }
}]);
;app.controller('AccesoExternoCtrl', ['$routeParams', '$location','$rootScope','$window', '$http',
   function ( $routeParams, $location, $rootScope, $window, $http) {

       (function initialize() {            
           if(typeof $routeParams.redirectUri != "undefined"){
               
               //VERIFICAR SI EL TOKEN ESTÁ ACTIVO SERVICIO?
               if(true){
                   $window.sessionStorage["token"] = decodeURIComponent($location.search().token);
                    //console.log("Token ", $location.search().token);
                   //$window.sessionStorage["token"] = decodeURIComponent($routeParams.token);
                   
                   var tokenBearer = "Bearer " + $window.sessionStorage.token;

                   $http.get(App.URL_BASE + 'autorizaciones/usuario', {headers:{'Authorization':tokenBearer,
                   'Access-Control-Allow-Origin': '*', 
                   'Access-Control-Allow-Methods': 'GET, POST, OPTIONS, PUT, PATCH, DELETE', 
                   'Access-Control-Allow-Headers': 'X-Requested-With,content-type', 
                   'Access-Control-Allow-Credentials': 'true'
                   }}).then(function(response){
                       //console.log(response);
                       sessionStorage.setItem("nombreUsuario",angular.isUndefined(response.data.dato.nombreUsuario)?"undefined":response.data.dato.nombreUsuario);
                       sessionStorage.setItem("usuarioLogueado",angular.isUndefined(response.data.dato.codigoUsuario)?"undefined":response.data.dato.codigoUsuario);
                       sessionStorage.setItem("preferencia_marcas",angular.isUndefined(response.data.dato.preferenciaMarca)?"S": response.data.dato.preferenciaMarca);
                       sessionStorage.setItem("preferencia_moneda",angular.isUndefined(response.data.dato.preferenciaMoneda)?"S": response.data.dato.preferenciaMoneda);
                       sessionStorage.setItem("preferencia_fraccionamiento",angular.isUndefined(response.data.dato.preferenciaFraccionamiento)?"S": response.data.dato.preferenciaFraccionamiento);
                       sessionStorage.setItem("preferencia_concesionarias",angular.isUndefined(response.data.dato.preferenciaConcesionarias)?"S": response.data.dato.preferenciaConcesionarias);
                       sessionStorage.setItem("preferencia_forma_pago",angular.isUndefined(response.data.dato.preferenciaFormaPago )?"S": response.data.dato.preferenciaFormaPago);
                    $rootScope.usuarioActual = {
                        usuario: sessionStorage.getItem("usuarioLogueado"),
                        nombre : sessionStorage.getItem("nombreUsuario"),
                    };
                    $rootScope.datosCliente = {
                        usuario: sessionStorage.getItem("usuarioLogueado"),
                        nombre : sessionStorage.getItem("nombreUsuario"),
                    };
                    $rootScope.user = {
                        usuario: sessionStorage.getItem("usuarioLogueado"),
                        nombre : sessionStorage.getItem("nombreUsuario"),
                    };
                       $location.url(decodeURIComponent($routeParams.redirectUri));
                   }, function(response){
                       Message.error("No se pudo obtener los datos del usuario");
                       $window.sessionStorage.clear();
                       $location.url("/login");
                   });


               }else{
                   //SI NO ESTÁ ACTIVO ENVIAR AL LOGIN                    
                   $window.sessionStorage.clear();
                   $location.url("/login");
               }
           }else{
                   //SI NO ESTÁ ACTIVO ENVIAR AL LOGIN                    
                   $window.sessionStorage.clear();
                   $location.url("/login");
               }
           
       })();
           


   }]);
;/**
 * @class
 * Controller que implementa la lógica del header del portal y maneja la interacción 
 * con la sesión
 * 
 * @name mapfre-cotizador-vehiculos#HeaderCtrl
 * @author <a href = "mailto:marcos.peralta@konecta.com.py">Marcos Peralta</a>
 */
app.controller('HeaderCtrl', ['$scope', '$timeout','SessionService', '$rootScope', '$window', '$location','CotizacionVehiculoService',
    function ($scope, $timeout, service, $rootScope, $window, $location, CotizacionVehiculoService) {

    
        /**
         * Contiene la información del usuario logeado en el sistema
         */
       // $rootScope.isAuth = false;
        $rootScope.user = null;

        /**
         * Se encarga de cerrar la sesión del usuario.
         */
        $scope.logout = function () {          
            $window.sessionStorage.clear();
            $rootScope.datosCliente = {
                usuario: null,
                nombre : "",
            };
            $rootScope.user = null;
            $location.url("/");
        }

        /**
         * Se encarga de verificar si el usuario esta logeado.
         * @returns {boolean} true si esta logeado, false en caso contrario.
         */
        $scope.isLoggedIn = function () {
            return true;
        }

        /**
         * Se encarga de invocar al login del keycloak
         */
        $scope.login = function () {
            $scope.cerrarMenu();
            if ($window.sessionStorage["token"]=="" || $window.sessionStorage["token"]==null ){
                //service.login();
            }  
        }

        /**
         * Se recupera los datos del usuario logeado y se injecta en la variable user. 
         */
        function initSession() {
            if (!$scope.isLoggedIn()) {
                return;
            }
            getUserInfo();
        }

        /**
         * Se recupera los datos del usuario logeado y se injecta en la variable user. 
         */
        function getUserInfo() {
            $rootScope.usuarioActual = {
                usuario: sessionStorage.getItem("usuarioLogueado"),
                nombre : sessionStorage.getItem("nombreUsuario"),
            };
            $rootScope.datosCliente = {
                usuario: sessionStorage.getItem("usuarioLogueado"),
                nombre : sessionStorage.getItem("nombreUsuario"),
            };
            $rootScope.user = {
                usuario: sessionStorage.getItem("usuarioLogueado"),
                nombre : sessionStorage.getItem("nombreUsuario"),
            };
        };

        $scope.cerrarMenu = function(){
 
              var menu = $('#menuPrincipal');
              var menuBoton = $('.btn.action');

              menu.addClass('compress');

               menuBoton.addClass('compress');

             
                  
        };
        $scope.cargarMarcas = function() { /*se llama a esta funcion para saber si esta logueado o no**/

            var parametros = {};
            parametros.preferencia="N";
               
            
           
            parametros.esNuevo="S";
            CotizacionVehiculoService.getMarcas(parametros).then(

                function (response) {                  

            },
                function(response){
            });

        };

         $scope.limpiarStorage = function () {
            sessionStorage.removeItem("");
         };
         $scope.$on('get-user', function() {
            /*metodo que es invocado desde el login, una vez que se logea el usuario, refresca los datos en el dashboard*/

            getUserInfo();
            //
        });


          $scope.limpiarCotizacion = function () {
            $rootScope.numeroCotizacionRoot=undefined;
            $rootScope.nroPropuesta=undefined;
            $rootScope.camposRequeridosList=[];
            sessionStorage.removeItem("paginaRiesgoCotizador");
            sessionStorage.removeItem("paginaRiesgoPropuesta");
            sessionStorage.removeItem("paginaAsegurado");
            $scope.cerrarMenu();
        /*    $scope.route = $location.path();
            console.log($scope.route);
       
             $scope.ruta = $scope.route.slice(1, ($scope.route.length)) + "/";
       
            console.log($scope.ruta);*/

          
       
         };
          $scope.esMovil=function()
          {
              var check = false;
              var plataforma ='';
              (function(a){
                  if(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|ipad|iris|kindle|Android|Silk|lge |maemo|midp|mmp|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i.test(navigator.userAgent)
                      || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(navigator.userAgent.substr(0,4)))
                      check = true
              })(navigator.userAgent||navigator.vendor||window.opera);

              return check;
          };


        /**
         * Constructor / Entrypoint
         * @constructor
         */


        (function initialize() {

          
            $rootScope.isAuth = true;

            initSession();
            //$scope.login();
            $scope.$watch('user', function () {
                if (!$scope.isLoggedIn()) {
                    initSession();
                }
            });
            //$scope.cargarMarcas();
            $scope.menuSideBar = Menu;
        })();
}


]);
;app.controller('UtilsCtrl',
    ['$scope', '$mdDateLocale','$filter','$rootScope',
       function ($scope,$mdDateLocale,$filter,$rootScope) {

        
        
        $scope.convertirDate = function(dato){
        
        if(!angular.isUndefined(dato)){
          if(dato!=null && dato !=""){

              var dataSplit= dato.split('/');
               if (dataSplit[2].split(" ").length > 1) {

                          var hora = dataSplit[2].split(" ")[1].split(':');
                          dataSplit[2] = dataSplit[2].split(" ")[0];
                          dateConverted = new Date(dataSplit[2], dataSplit[1]-1, dataSplit[0], hora[0], hora[1]);

                          } else {
                              dateConverted = new Date(dataSplit[2], dataSplit[1] - 1, dataSplit[0]);
                          }
                    return dateConverted;
             }else{
              return null;
             }
        }else{
          return null;
        }
             
  		    
		    };
            
         $scope.aplicarFormato = function(fecha){
         	 $mdDateLocale.formatDate = function(date) { return $filter('date')(fecha,"dd/MM/yyyy"); };
         };

        $scope.limpiarDatePicker = function(){
            $mdDateLocale.formatDate = function(date) { 

            return null; };
         };

        } ]).config(function($mdDateLocaleProvider) {
    // Example of a Spanish localization.
    $mdDateLocaleProvider.months = ['Enero', 'Febrero', 'Marzo', 'Abril', 'Mayo', 'Junio', 
                                    'Julio', 'Agosto', 'Septiembre', 'Octubre', 'Noviembre', 'Diciembre'];
    $mdDateLocaleProvider.shortMonths = ['Ene', 'Feb', 'Mar', 'Abr', 'May', 'Jun', 
                                    'Jul', 'Ago', 'Sep', 'Oct', 'Nov', 'Dic'];
    $mdDateLocaleProvider.days = ['Domingo', 'Lunes', 'Martes', 'Miercoles', 'Jueves', 'Viernes', 'Sábado'];
    $mdDateLocaleProvider.shortDays = ['Do', 'Lu', 'Ma', 'Mi', 'Ju', 'Vi', 'Sá'];
    // Can change week display to start on Monday.
    $mdDateLocaleProvider.firstDayOfWeek = 1;
    $mdDateLocaleProvider.formatDate = function(date) {
    if (angular.isUndefined(date))
    {
    return '';
    }
    else
    {
    var m = moment(date);
    return m.format('DD/MM/YYYY');
    }
    };
    $mdDateLocaleProvider.parseDate = function(dateString) {
    var m = moment(dateString, 'DD/MM/YYYY', true);
    return m.isValid() ? m.toDate() : new Date(NaN);
    };
    // Optional.
    //$mdDateLocaleProvider.dates = [1, 2, 3, 4, 5, 6, 7,8,9,10,11,12,13,14,15,16,17,18,19,
    //                               20,21,22,23,24,25,26,27,28,29,30,31];
    // In addition to date display, date components also need localized messages
    // for aria-labels for screen-reader users.
    $mdDateLocaleProvider.weekNumberFormatter = function(weekNumber) {
      return 'Semana ' + weekNumber;
    };
    $mdDateLocaleProvider.msgCalendar = 'Calendario';
    $mdDateLocaleProvider.msgOpenCalendar = 'Abrir calendario';
  });;app.controller('PropuestaHogarFormCtrl', ['$scope', '$q', '$controller', '$routeParams', '$location', 'SessionService', '$rootScope','$route', '$mdDialog', '$filter', 'ConfirmService', '$window', 'PropuestaService','CotizacionVehiculoPropuestaService','UtilsService','CotizacionVehiculoService','$log','$timeout',
        function ($scope,$q, $controller, $routeParams, $location, sessionService, $rootScope,$route, $mdDialog,  $filter, confirmService, $window, PropuestaService,CotizacionVehiculoPropuestaService, UtilsService ,CotizacionVehiculoService, $log, $timeout) {
            $scope.service = PropuestaService;
            $scope.controlPermisos = true;
            $scope.nombre = $route.current.$$route.subtipo;
            $rootScope.rootPathParent = $route.current.$$route.originalPath;
            $scope.listaComision = [];
            $scope.subtipo = $scope.nombre;
            $scope.agenteSelected = undefined;
            $scope.comisionSelected = undefined;
            $scope.oficinaSelected = undefined;
            $scope.sucursalSelected = undefined;
            $scope.tipoEnvioSelected = undefined;
            $scope.tipoTarjetaSelected = undefined;
           // $scope.referidoSelected = undefined;
            $scope.ejecutivoSelected = undefined;
            $scope.formaPagoSelected = undefined;
            $scope.nroCobroAnt = {};
            $scope.modelo = {};
            $scope.nroInterno = {};
            $scope.nroCuentaCte = {};
            $scope.nroCuentaCte.valor = undefined;
            $scope.nroTarjeta = {};
            $scope.vtotarjeta = {};
            $scope.cargando = false;
            $scope.prop = {};
            $scope.prop.plataforma = null;
            $scope.nroPropuesta = null;
            $scope.gestorSelected = undefined;
            $scope.entidadSelected = undefined;
            $scope.todo_concesionarias = true;
            $scope.submitted = false;
           // $scope.valorConcesionaria = undefined;
            $scope.valorComision = undefined;
            $scope.valorOficina = undefined;
            $scope.valorEjecutivo = undefined;
            $scope.valorAcreedor = undefined;
            $scope.valorTipoGestor = undefined;
            $scope.valorOficina = undefined;
            $scope.valorTipoTarjeta = undefined;
            $scope.valorEnvio = undefined;
            $scope.valorCodTarjeta = undefined;
            $scope.cambiarValores = true;
            $scope.permitirCambio = true;
            $scope.validCarga = false;
            $scope.cambiarGestor = true;
            $scope.tab = "PROPUESTA";
            $scope.sinc = 0;
            /**variable que almcena las promesas resueltas o fracasadas*/
            var cantModeloSinc = 0;
            /**variable que almacena la cantidad de datos que vienen en el buscar, que requieren otras llamadas de promesas**/
            $scope.pagoPreferencia = undefined;
            $scope.cambiarTab = 0; //valor inicial
            $scope.verificarCamposForm = function (listaCampo, campo) {
                return UtilsService.verificarCamposForm(listaCampo, campo);
            };
            var obtenerComision = function (codigoAgente) {
                 var params = {};
                 params.codigoAgente = codigoAgente;
                 params.pathModule=$scope.pathModule;
                PropuestaService.obtenerComision(params).then(function (response) {
                    if (!response.data.error) {
                        $scope.listaComision = response.data.dato;
                        $scope.promesaComision.resolve();
                    } else {
                        Message.error(response.data.error);
                        $scope.promesaComision.resolve();
                    }

                }).catch(function (response) {
                    $scope.promesaComision.reject();
                    Message.error("No se pudo obtener las comisiones");
                    $scope.comisionSelected = $scope.valorComision;
                    $scope.incrementarSincronizador($scope.comisionSelected);
                });
            };


            var obtenerOficina = function (codigoAgente) {
                PropuestaService.obtenerOficinas(codigoAgente).then(function (response) {
                    if (!response.data.error) {
                        $scope.listaOficina = response.data.dato;
                        if ($scope.permitirCambio)
                        {
                            //aca se pregunta si viene un solo elemento de oficinal
                            if ($scope.listaOficina!=null)
                            {
                                if ($scope.listaOficina.length==1) //se setea el que viene alli
                                {
                                    $scope.oficinaSelected=$scope.listaOficina[0].COD_NIVEL3;

                                }
                            }
                        }
                    } else {
                        Message.error(response.data.mensaje);
                    }
                    $scope.promesaOficina.resolve();
                }).catch(function (response) {
                    $scope.promesaOficina.reject();
                    $scope.oficinaSelected = $scope.valorOficina;
                    $scope.incrementarSincronizador($scope.oficinaSelected);
                    Message.error("No se pudo obtener las oficinas");
                });
            };
            /**Funcion que se encarga de incrementar la variable de sincronizacion cuando las promesas se resuelven o tienen error*/
            $scope.incrementarSincronizador = function (campo) {
                if (campo != null) {
                    $scope.sinc++;
                }
            }

            var promesaObtenerFormasPago = $q.defer();
            var obtenerFormasPago = function () {
                var preferencia;
                preferencia = "N";
                PropuestaService.obtenerFormasPago(preferencia).then(function (response) {
                    if (!response.data.error) {
                        $scope.listaFormasPago = response.data.dato;

                        //obtener las que son de preferencia y setear
                        if ($scope.subtipo != "Flota") {

                            preferencia = window.sessionStorage.getItem("preferencia_forma_pago");
                            if (preferencia == "S") {
                                PropuestaService.obtenerFormasPago(preferencia).then(function (response) {
                                    //$scope.formaPagoSelected.valor = response.data.dato[0].TIP_GESTOR;
                                    //$scope.formaPagoSelected = response.data.dato[0].TIP_GESTOR;
                                    if (!response.data.error) {
                                        if (response.data.dato.length > 0) {
                                            $scope.pagoPreferencia = response.data.dato[0].TIP_GESTOR;
                                        }
                                        promesaObtenerFormasPago.resolve();
                                    } else {
                                        promesaObtenerFormasPago.resolve();
                                        Message.error(response.data.error);
                                    }

                                }, function (response) {
                                    promesaObtenerFormasPago.reject();
                                    Message.error("No se pudo obtener las formas de pago de preferencia");

                                });
                            } else {
                                promesaObtenerFormasPago.resolve();
                                //$scope.formaPagoSelected.valor=undefined;
                                $scope.formaPagoSelected = undefined;
                            }

                        }
                        else
                        {
                            promesaObtenerFormasPago.resolve();
                        }

                    } else {
                        promesaObtenerFormasPago.resolve();
                        Message.error(response.data.mensaje);
                    }



                }).catch(function (response) {
                    promesaObtenerFormasPago.reject();
                    $scope.formaPagoSelected = $scope.valorTipoGestor;
                    $scope.incrementarSincronizador($scope.formaPagoSelected);
                    Message.error("No se pudo obtener las formas de pago");
                });


            };


            var obtenerEjecutivos = function (codNivel3) {
                PropuestaService.obtenerEjecutivos(codNivel3).then(function (response) {
                    if (!response.data.error) {
                        $scope.listaEjecutivos = response.data.dato;

                    } else {
                        Message.error(response.data.mensaje);
                    }

                    promesaEjecutivo.resolve();
                }).catch(function (response) {
                    promesaEjecutivo.reject();
                    Message.error("No se pudo obtener los ejecutivos");
                    $scope.ejecutivoSelected = $scope.valorEjecutivo;
                    $scope.incrementarSincronizador($scope.ejecutivoSelected);
                });
            };

            var promesaTipoEnvio = $q.defer();
            var obtenerTiposEnvio = function () {
                PropuestaService.obtenerTiposEnvio().then(function (response) {
                    $scope.listaTiposEnvio = response.data.dato;
                    promesaTipoEnvio.resolve();
                }).catch(function (response) {
                    promesaTipoEnvio.reject();
                    $scope.tipoEnvioSelected = $scope.valorEnvio;
                    $scope.incrementarSincronizador($scope.tipoEnvioSelected);
                    Message.error("No se pudo obtener los tipos de envio");
                });
            };


            var obtenerGestores = function (codigoFormaPago) {
                var param = {};
                param.codigoFormaPago = codigoFormaPago;
                param.pathModule = $scope.pathModule;
                PropuestaService.obtenerGestores(param).then(function (response) {
                    if (!response.data.error) {
                        $scope.listaGestores = response.data.dato;
                    } else {
                        Message.error(response.data.mensaje);
                    }

                    promesaGestores.resolve();

                }).catch(function (response) {
                    promesaGestores.reject();
                    $scope.gestorSelected = $scope.valorCodGestor;
                    $scope.incrementarSincronizador($scope.gestorSelected);
                    Message.error("No se pudo obtener los gestores");

                });
            };


            var obtenerEntidades = function (codigoGestor) {
                var param = {};
                param.codigoGestor = codigoGestor;
                PropuestaService.obtenerEntidades(param).then(function (response) {
                    if (!response.data.error) {
                        $scope.listaEntidades = response.data.dato;
                    } else {
                        Message.error(response.data.mensaje);
                    }
                    $scope.promesaEntidad.resolve();


                }).catch(function (response) {
                    $scope.promesaEntidad.reject();
                    $scope.entidadSelected = $scope.valorEntidad;
                    $scope.incrementarSincronizador($scope.entidadSelected);
                });
            };


            var obtenerSucursales = function (codigoEntidad) {
                var param = {};
                param.codigoEntidad = codigoEntidad;
                PropuestaService.obtenerSucursales(param).then(function (response) {
                    if (!response.data.error) {
                        $scope.listaSucursales = response.data.dato;
                    } else {
                        Message.error(response.data.mensaje);
                    }
                    $scope.promesaSucursal.resolve();
                }).catch(function (response) {
                    $scope.promesaSucursal.reject();
                    $scope.sucursalSelected = $scope.valorSucursal;
                    $scope.incrementarSincronizador($scope.sucursalSelected);
                    Message.error("No se pudo obtener sucursales");
                });
            };

            var promesaTipoTarjeta = $q.defer();
            var obtenerTiposTarjetas = function () {
                PropuestaService.obtenerTiposTarjetas().then(function (response) {
                    if (!response.data.error) {
                        $scope.listaTiposTarjeta = response.data.dato;
                    } else {
                        Message.error(response.data.error);
                    }

                    promesaTipoTarjeta.resolve();
                }).catch(function (response) {
                    promesaTipoTarjeta.reject();
                    $scope.tipoTarjetaSelected = $scope.valorTipoTarjeta;
                    $scope.incrementarSincronizador($scope.tipoTarjetaSelected);
                    Message.error("No se pudo obtener los tipos de tarjetas");
                });
            };

            var promesaCodigoTarjeta = $q.defer();
            var obtenerCodigosTarjetas = function (codigoAgente, tipotarjeta) {
                var param = {};
                if (!angular.isUndefined(codigoAgente)) {
                    param.codigoAgente = codigoAgente;
                } else {
                    param.codigoAgente = undefined;
                }

                param.tipotarjeta = tipotarjeta;
                PropuestaService.obtenerTarjetas(param).then(function (response) {
                    if (response.data.dato != null) {
                        $scope.listaCodigosTarjeta = response.data.dato;
                    } else {
                        $scope.listaCodigosTarjeta = [];
                        $scope.nroTarjeta.valor = undefined;
                    }

                    promesaCodigoTarjeta.resolve();
                }).catch(function (response) {
                    promesaCodigoTarjeta.reject();
                    $scope.codTarjetaSelected = $scope.valorCodTarjeta;
                    $scope.incrementarSincronizador($scope.codTarjetaSelected);
                    Message.error("No se pudo obtener las tarjetas");
                });
            };
            var promesaAgentes = $q.defer();
            var obtenerAgentes = function () {
                PropuestaService.obtenerAgentes().then(function (response) {
                    $scope.listaAgentes = response.data.dato;
                    promesaAgentes.resolve();
                }, function (response) {
                    promesaAgentes.reject();
                    Message.error("No se pudo obtener los agentes");

                });
            };


            // var obtenerConcesionarias = function (codigoAgente) {
            //     var parametros = {};
            //     if (!angular.isUndefined(codigoAgente)) {
            //         if ($scope.subtipo !== "Flota") {
            //             parametros.codigoAgente = codigoAgente;
            //             parametros.preferencia = sessionStorage.getItem("preferencia_concesionarias");
            //             if ($scope.todo_concesionarias == false) {
            //                 parametros.preferencia = "N";
            //             }
            //         } else {
            //             parametros.preferencia = "N";
            //             parametros.codigoAgente = codigoAgente;

            //         }

            //         PropuestaService.obtenerConcesionarias(parametros).then(function (response) {
            //             if (!response.data.error) {
            //                 $scope.listaConcesionarias = response.data.dato;
            //                 //console.log($scope.listaConcesionarias);
            //             } else {
            //                 Message.error(response.data.error);
            //             }
            //             //$scope.promesaConcesionaria.resolve();

            //         }).catch(function (response) {
            //            // $scope.promesaConcesionaria.reject();
            //           //  $scope.concesionariaSelected = $scope.valorConcesionaria;
            //           //  $scope.incrementarSincronizador($scope.concesionariaSelected);


            //             Message.error("No se pudo obtener la lista de Concesionarias");
            //         });

            //     }

            // };

            // var obtenerReferidos = function (codigoAgente, codigoConcesionaria) {
            //     PropuestaService.obtenerReferidos(codigoAgente, codigoConcesionaria).then(function (response) {
            //         if (!response.data.error) {
            //             $scope.listaReferidos = response.data.dato;
            //         } else {
            //             Message.error(response.data.mensaje);
            //         }
            //         $scope.promesaReferido.resolve();
            //     }).catch(function (response) {
            //         $scope.promesaReferido.reject();
            //         //$scope.referidoSelected = $scope.valorReferido;
            //        // $scope.incrementarSincronizador($scope.referidoSelected);
            //         Message.error("No se pudo obtener la lista de Referidos");
            //     });
            // };

            // var promesaAcrePrendario = $q.defer();
            // var obtenerAcrPrendarios = function () {
            //     PropuestaService.obtenerAcrPrendarios().then(function (response) {
            //         if (!response.data.error) {
            //             $scope.listaAcrPrendarios = response.data.dato;
            //         } else {
            //             Message.error(response.data.error);
            //         }

            //         promesaAcrePrendario.resolve();
            //     }).catch(function (response) {
            //         promesaAcrePrendario.reject();
            //         $scope.acrPrendarioSelected = $scope.valorAcreedor;
            //         $scope.incrementarSincronizador($scope.acrPrendarioSelected);
            //         Message.error("No se pudo obtener la lista de Acreedores Prendarios");
            //     });
            // };

            //Al seleccionar agente...
            $scope.promesaOficina = $q.defer();
            $scope.promesaComision = $q.defer();
           // $scope.promesaConcesionaria = $q.defer();
            $scope.$watch('agenteSelected', function (newValue, oldValue) {
                if (!angular.isUndefined(newValue)) {
                   // $scope.concesionariaSelected = undefined;
                  //  $scope.referidoSelected = undefined;
                    $scope.comisionSelected = undefined;
                    $scope.oficinaSelected = undefined;
                   // obtenerConcesionarias(newValue);
                    obtenerComision(newValue);
                    obtenerOficina(newValue);
                } else {
                  //  $scope.concesionariaSelected = undefined;
                  //  $scope.referidoSelected = undefined;
                    $scope.comisionSelected = undefined;
                    //$scope.oficinaSelected = undefined;
                  //  $scope.listaConcesionarias = [];
                    //$scope.listaComision=[];
                    $scope.listaOficina = [];
                  //  $scope.listaReferidos = [];
                }
            }, true);
           // $scope.promesaReferido = $q.defer();
            // $scope.$watch('concesionariaSelected', function (newValue, oldValue) {
            //     if (!angular.isUndefined(newValue)) {
            //         if (newValue !== "todos") {
            //             if (newValue != oldValue) {
            //                 if (newValue != null && newValue != "") {
            //                     if ($scope.cambiarValores) {
            //                         $scope.referidoSelected = undefined;
            //                     }
            //                     obtenerReferidos($scope.agenteSelected, newValue);
            //                 } else {
            //                     $scope.listaReferidos = [];
            //                     $scope.referidoSelected = undefined;
            //                 }

            //             }
            //         } else {
            //             $scope.concesionariaSelected = undefined;
            //             $scope.todo_concesionarias = false;
            //             obtenerConcesionarias($scope.agenteSelected);
            //         }

            //     }

            // }, true);
            var promesaEjecutivo = $q.defer();
            $scope.$watch('oficinaSelected', function (newValue, oldValue) {
                if (!angular.isUndefined(newValue) && newValue != null) {
                    if (newValue != oldValue) {
                        //obtenerEjecutivos(newValue.COD_NIVEL3);
                        obtenerEjecutivos(newValue);
                    }
                } else {
                    $scope.valorEjecutivo = undefined;
                    $scope.ejecutivoSelected = undefined;

                }

            }, true);
            $scope.promesaEntidad = $q.defer();
            $scope.$watch('gestorSelected', function (newValue, oldValue) {
                if (!angular.isUndefined(newValue) && newValue != null) {
                    //$scope.sinc++;
                    if (newValue != oldValue) {
                        if (!angular.isUndefined($scope.gestorSelected)) {

                            obtenerEntidades($scope.gestorSelected);
                        }

                    }
                }

            }, true);
            var promesaGestores = $q.defer();
            $scope.$watch('formaPagoSelected', function (newValue, oldValue) {

                if (!angular.isUndefined(newValue) && newValue != null) {

                    obtenerGestores(newValue)
                    //esta bandera sirve basicamente para no pisar los datos que se setean desde el buscar
                    if ($scope.cambiarGestor == true) //este es el caso en que se haya cambiado desde el HTML, o desde el initialize
                    {
                        $scope.gestorSelected = undefined;
                        $scope.limpiarDatosGestores(newValue);
                        //$scope.gestorSelected.valor=undefined;


                    } else //esto es en caso que sea desde el buscar
                    {
                        $scope.cambiarGestor = true;
                    }


                } else {
                    $scope.gestorSelected = undefined;
                    $scope.listaGestores = [];
                }


            }, true);
            $scope.limpiarDatosGestores = function (newValue) {
                if (newValue == "CO") {
                    if (!angular.isUndefined($scope.entidadSelected)) {
                        //$scope.entidadSelected.valor=undefined;
                        $scope.entidadSelected = undefined;
                    }
                    if (!angular.isUndefined($scope.sucursalSelected)) {
                        //$scope.sucursalSelected.valor=undefined;
                        $scope.sucursalSelected = undefined;
                    }
                    $scope.nroTarjeta.valor = undefined;
                    $scope.vtotarjeta.valor = undefined;
                    $scope.nroCuentaCte.valor = undefined;
                    if (!angular.isUndefined($scope.tipoTarjetaSelected)) {
                        $scope.tipoTarjetaSelected = undefined;
                        //$scope.tipoTarjetaSelected.valor=undefined;

                    }
                    if (!angular.isUndefined($scope.codTarjetaSelected)) {
                        $scope.codTarjetaSelected = undefined;
                        //$scope.codTarjetaSelected.valor=undefined;
                    }

                } else if (newValue == "DB") {
                    $scope.nroTarjeta.valor = undefined;
                    $scope.vtotarjeta.valor = undefined;
                    if (!angular.isUndefined($scope.tipoTarjetaSelected)) {
                        $scope.tipoTarjetaSelected = undefined;
                    }
                    if (!angular.isUndefined($scope.codTarjetaSelected)) {
                        $scope.codTarjetaSelected = undefined;
                    }
                } else if (newValue == "TA") {
                    $scope.nroCuentaCte.valor = undefined;
                    if (!angular.isUndefined($scope.entidadSelected)) {
                        $scope.entidadSelected = undefined;
                    }
                    if (!angular.isUndefined($scope.sucursalSelected)) {
                        $scope.sucursalSelected = undefined;
                    }
                } else {
                    $scope.entidadSelected = undefined;
                    $scope.sucursalSelected = undefined;
                    $scope.nroTarjeta.valor = undefined;
                    $scope.vtotarjeta.valor = undefined;
                    $scope.tipoTarjetaSelected = undefined;
                    $scope.codTarjetaSelected = undefined;
                    $scope.nroCuentaCte.valor = undefined;
                }

            };
            $scope.promesaSucursal = $q.defer();
            $scope.$watch('entidadSelected', function (newValue, oldValue) {
                if (!angular.isUndefined(newValue)) {
                    if (newValue != oldValue) {
                        if (newValue != null) {
                            //$scope.sinc++;
                            obtenerSucursales(newValue);
                        } else {
                            $scope.listaSucursales = [];
                            //$scope.sucursalSelected={};
                            //$scope.sucursalSelected.valor=null;
                            $scope.sucursalSelected = undefined;
                        }

                    }
                }


            }, true);
            $scope.$watch('tipoTarjetaSelected', function (newValue, oldValue) {
                if (!angular.isUndefined(newValue)) {
                    if (newValue != oldValue) {
                        if (newValue != null) {
                            obtenerCodigosTarjetas($scope.agenteSelected, newValue);
                        } else {
                            obtenerCodigosTarjetas($scope.agenteSelected, null);
                        }

                    }
                }
            }, true);

            $scope.save = function (clickButton) {


                $scope.submitted = false;
                $scope.numeroCotizacion = $scope.numeroCotizacionRoot;
                var propuesta = {};
                propuesta.numeroCotizacion = $scope.numeroCotizacion;//218631
                propuesta.codigoAgente = angular.isUndefined($scope.agenteSelected) ? null : $scope.agenteSelected;
                propuesta.cuadroComision = angular.isUndefined($scope.comisionSelected) ? null : $scope.comisionSelected != null ? $scope.comisionSelected : null;
                propuesta.codigoEjecutivo = angular.isUndefined($scope.ejecutivoSelected) ? null : $scope.ejecutivoSelected != null ? $scope.ejecutivoSelected : null;
                propuesta.codigoOficinaComercial = angular.isUndefined($scope.oficinaSelected) ? null : $scope.oficinaSelected != null ? $scope.oficinaSelected : null;
                propuesta.codigoTipoEnvio = angular.isUndefined($scope.tipoEnvioSelected) ? null : $scope.tipoEnvioSelected != null ? $scope.tipoEnvioSelected : null;
                propuesta.codigoTipoGestor = angular.isUndefined($scope.formaPagoSelected) ? null : $scope.formaPagoSelected != null ? $scope.formaPagoSelected : null;
                propuesta.codigoGestor = angular.isUndefined($scope.gestorSelected) ? null : $scope.gestorSelected != null ? $scope.gestorSelected : null;
                propuesta.numeroCobroAnticipado = angular.isUndefined($scope.nroCobroAnt) ? null : $scope.nroCobroAnt.valor;
                propuesta.fechaEfectoRecibo = angular.isUndefined($scope.modelo) ? null : angular.isUndefined($scope.modelo.fechaRecibo) ? null : $scope.modelo.fechaRecibo;
                propuesta.fechaPrimerVencimiento = angular.isUndefined($scope.modelo) ? null : angular.isUndefined($scope.modelo.fechaPrimerVencimiento) ? null : $scope.modelo.fechaPrimerVencimiento;
                propuesta.numeroInternoBanco = angular.isUndefined($scope.nroInterno) ? null : angular.isUndefined($scope.nroInterno.valor) ? null : $scope.nroInterno.valor;
                propuesta.codigoEntidad = angular.isUndefined($scope.entidadSelected) ? null : $scope.entidadSelected != null ? $scope.entidadSelected : null;

                propuesta.codigoSucursal = angular.isUndefined($scope.sucursalSelected) ? null : $scope.sucursalSelected != null ? $scope.sucursalSelected : null;

                propuesta.numeroCuentaCorriente = angular.isUndefined($scope.nroCuentaCte) ? null : $scope.nroCuentaCte.valor;
                propuesta.tipoTarjeta = angular.isUndefined($scope.tipoTarjetaSelected) ? null : $scope.tipoTarjetaSelected != null ? $scope.tipoTarjetaSelected : null;

                propuesta.codigoTarjeta = angular.isUndefined($scope.codTarjetaSelected) ? null : $scope.codTarjetaSelected != null ? $scope.codTarjetaSelected : null;

                propuesta.numeroTarjeta = angular.isUndefined($scope.nroTarjeta) ? null : $scope.nroTarjeta.valor;
                propuesta.fechaVencimientoTarjeta = angular.isUndefined($scope.vtotarjeta) ? null : !angular.isUndefined($scope.vtotarjeta.valor) && $scope.vtotarjeta.valor != null ? moment($scope.vtotarjeta.valor).format("DD/MM/YYYY") : null;
               // propuesta.codigoReferido = angular.isUndefined($scope.referidoSelected) ? null : $scope.referidoSelected != null ? $scope.referidoSelected : null;
                // if (propuesta.codigoReferido != null) {
                //     for (var i = 0; i < $scope.listaReferidos.length; i++) {
                //         if ($scope.listaReferidos[i].DOCUMENTO == propuesta.codigoReferido) {

                //             propuesta.tipoReferido = $scope.listaReferidos[i].REFERIDO;
                //             break;

                //         }
                //     }
                // } else {
                //     propuesta.tipoReferido = null;
                // }
                // propuesta.codigoAcreedor = angular.isUndefined($scope.acrPrendarioSelected) ? null : $scope.acrPrendarioSelected != null ? $scope.acrPrendarioSelected : null;
                // if (propuesta.codigoAcreedor != null) {
                //     for (var i = 0; i < $scope.listaAcrPrendarios.length; i++) {
                //         if ($scope.listaAcrPrendarios[i].DOCUMENTO == propuesta.codigoAcreedor) {

                //             propuesta.tipoAcreedor = $scope.listaAcrPrendarios[i].ACREEDOR;
                //             break;

                //         }
                //     }
                // } else {
                //     propuesta.tipoAcreedor = null;
                // }

               // propuesta.codigoConcesionaria = angular.isUndefined($scope.concesionariaSelected) ? null : $scope.concesionariaSelected != null && $scope.concesionariaSelected != "" ? $scope.concesionariaSelected : null;
                propuesta.marcaModulo=$scope.pathModule.split("marcaModulo=")[1];
                var param = JSON.stringify(propuesta);
                $scope.cargando = true;
                PropuestaService.guardarPropuesta(propuesta).then(
                    //sucess
                    function (response) {

                        if (!response.data.error) {

                            if (clickButton == "S") {
                                var param = {};
                                param.numeroCotizacion = $scope.numeroCotizacion;
                                param.marcaFlota = $scope.subtipo == 'Flota' ? 'S' : 'N';
                                param.tab = $scope.tab;
                                param.pathModule=$scope.pathModule;
                                PropuestaService.getTabs(param);
                            } else {
                                $scope.cambiarTab = 1; //exito
                            }


                            Message.ok(response.data.mensaje);
                        } else {
                            $scope.cambiarTab = 2; //error
                            Message.error(response.data.mensaje);

                        }
                        $scope.cargando = false;
                        //error
                    }).catch(function (response) {
                    $scope.cargando = false;
                    $scope.cambiarTab = 2; //error
                    Message.error(response.data.mensaje);

                });


            };


            $scope.buscar = function () {
                $scope.numeroCotizacion = $scope.numeroCotizacionRoot;
                if (!angular.isUndefined($scope.numeroCotizacion)) {
                    if ($scope.numeroCotizacion != null && $scope.numeroCotizacion != "") {

                        $scope.cargando = true;
                        var param = {};
                        param.numeroCotizacion = $scope.numeroCotizacion;
                        param.marcaFlota = $scope.subtipo == 'Flota' ? 'S' : 'N';
                        param.tab = $scope.tab;
                        param.pathModule=$scope.pathModule;
                        $scope.todo_concesionarias = false;
                        $scope.agenteSelected = undefined;
                        $scope.sinc = 0;
                        cantModeloSinc = 0;
                        $scope.permitirCambio = false;

                        $scope.cambiarGestor = false; //cuando no tiene preferencia se debe de volver a llamar a la lista de gestores
                        $scope.formaPagoSelected = undefined;
                        $scope.limpiarDatosGestores();
                        PropuestaService.getTabs(param);
                        PropuestaService.getCamposEditablesList(param);
                        PropuestaService.getPropuesta(param).then(
                            //sucess
                            function (response) {

                                if (!response.data.error) {
                                    if (response.data.dato != null && response.data.dato.length > 0) {


                                        $scope.bloquearBuscador = true;
                                        $scope.cambiarValores = false;
                                        $scope.cargarPlataforma();
                                        $scope.tieneIva = response.data.dato[0].MCA_IVA == null ? 'S' : response.data.dato[0].MCA_IVA;
                                        $scope.firmaDigital = response.data.dato[0].MCA_FIRMA_ELECTRONICA == null ? 'N' : response.data.dato[0].MCA_FIRMA_ELECTRONICA;
                                        $scope.setearCantidadModelos(response);

                                        $scope.promesaOficina.promise.$$state.status = 0;
                                      //  $scope.promesaConcesionaria.promise.$$state.status = 0;
                                        $scope.promesaComision.promise.$$state.status = 0;
                                        //promesaObtenerFormasPago.promise.$$state.status = 0;
                                        if (response.data.dato[0].COD_AGT == null) {

                                            $scope.agenteSelected = parseInt(sessionStorage.getItem("codigoAgente"));


                                        } else {

                                            $scope.agenteSelected = response.data.dato[0].COD_AGT;

                                        }

                                        $scope.promesaOficina.promise.then(
                                            function () {
                                                $scope.permitirCambio=true;
                                                $scope.oficinaSelected = response.data.dato[0].COD_NIVEL3;
                                                $scope.incrementarSincronizador($scope.oficinaSelected);
                                                if ($scope.oficinaSelected==null) //setear el que trae el agente si es que tiene una sola oficina comercial
                                                {
                                                    if ($scope.listaOficina.length==1)
                                                    {
                                                        $scope.oficinaSelected=$scope.listaOficina[0].COD_NIVEL3;
                                                    }
                                                }

                                                $scope.promesaOficina.promise.$$state.status = 0;
                                            });
                                        promesaEjecutivo.promise.then(
                                            function () {
                                                $scope.ejecutivoSelected = response.data.dato[0].COD_EJECUTIVO;
                                                $scope.incrementarSincronizador($scope.ejecutivoSelected);

                                            });
                                        $scope.promesaComision.promise.then(
                                            function () {
                                                $scope.comisionSelected = response.data.dato[0].COD_CUADRO_COM;
                                                $scope.incrementarSincronizador($scope.comisionSelected);
                                                var encontrado=false;
                                                for (var i=0; i< $scope.listaComision.length;i++)
                                                {
                                                    if ($scope.listaComision[i].COD_CUADRO_COM==parseInt($scope.comisionSelected))
                                                    {
                                                        encontrado=true;
                                                    }
                                                }
                                                if (!encontrado)
                                                {
                                                    $scope.comisionSelected=undefined;
                                                }


                                            });
                                        // $scope.promesaReferido.promise.then(function () {
                                        //     $scope.referidoSelected = response.data.dato[0].COD_REFERIDO;
                                        //     $scope.incrementarSincronizador($scope.referidoSelected);

                                        // });
                                        // $scope.promesaConcesionaria.promise.then(function () {
                                        //     $scope.concesionariaSelected = response.data.dato[0].COD_CONCESIONARIA;
                                        //     $scope.incrementarSincronizador($scope.concesionariaSelected);

                                        // });


                                        // promesaAcrePrendario.promise.then(
                                        //     function () {
                                        //         $scope.acrPrendarioSelected = response.data.dato[0].COD_ACREEDOR;
                                        //         $scope.incrementarSincronizador($scope.acrPrendarioSelected);


                                        //     });


                                        promesaTipoEnvio.promise.then(
                                            function () {

                                                $scope.tipoEnvioSelected = response.data.dato[0].COD_TIP_ENVIO ? response.data.dato[0].COD_TIP_ENVIO.toString() : response.data.dato[0].COD_TIP_ENVIO;
                                                $scope.incrementarSincronizador($scope.tipoEnvioSelected);


                                            });

                                        promesaObtenerFormasPago.promise.then(
                                            function () {
                                                if (response.data.dato[0].TIP_GESTOR == null) {
                                                    $scope.formaPagoSelected = $scope.pagoPreferencia;
                                                } else {
                                                    $scope.formaPagoSelected = response.data.dato[0].TIP_GESTOR;
                                                }

                                                $scope.incrementarSincronizador($scope.formaPagoSelected);


                                            });
                                        $scope.promesaEntidad.promise.then(function () {
                                            $scope.entidadSelected = response.data.dato[0].COD_ENTIDAD;
                                            $scope.incrementarSincronizador($scope.entidadSelected);

                                        });
                                        $scope.nroCobroAnt.valor = response.data.dato[0].NUM_COBRO_ANTICIPADO;
                                        $scope.modelo.fechaRecibo = angular.isUndefined(response.data.dato[0].FEC_EFEC_RECIBO) ? undefined : response.data.dato[0].FEC_EFEC_RECIBO != undefined ? $scope.convertirDate(response.data.dato[0].FEC_EFEC_RECIBO) : undefined;
                                        $rootScope.nroPropuesta = angular.isUndefined(response.data.dato[0].NUM_PROPUESTA) ? null : response.data.dato[0].NUM_PROPUESTA;
                                        $scope.gestorSelected = undefined;


                                        promesaGestores.promise.then(function () {
                                            $scope.gestorSelected = null;
                                            if (response.data.dato[0].TIP_GESTOR != null && response.data.dato[0].TIP_GESTOR != "")
                                            {
                                                $scope.gestorSelected=response.data.dato[0].COD_GESTOR;
                                            }
                                            $scope.incrementarSincronizador($scope.gestorSelected);

                                        })


                                        $scope.modelo.fechaPrimerVencimiento = angular.isUndefined(response.data.dato[0].FEC_PRIMER_VCTO) ? undefined : response.data.dato[0].FEC_PRIMER_VCTO != undefined ? $scope.convertirDate(response.data.dato[0].FEC_PRIMER_VCTO) : undefined;
                                        $scope.nroInterno.valor = response.data.dato[0].NUM_SOLICITUD_EE;

                                        $scope.promesaSucursal.promise.then(
                                            function () {
                                                $scope.sucursalSelected = response.data.dato[0].COD_OFICINA;
                                                $scope.incrementarSincronizador($scope.sucursalSelected);

                                            });

                                        $scope.nroCuentaCte.valor = response.data.dato[0].CTA_CTE;
                                        $scope.tipoTarjetaSelected = response.data.dato[0].COD_TIP_TAR;


                                        promesaCodigoTarjeta.promise.then(
                                            function () {
                                                $scope.codTarjetaSelected = response.data.dato[0].COD_TARJETA;
                                                $scope.incrementarSincronizador($scope.codTarjetaSelected);

                                            });

                                        $scope.nroTarjeta.valor = response.data.dato[0].NUM_TARJETA;
                                        $scope.vtotarjeta.valor = angular.isUndefined(response.data.dato[0].FEC_VCTO_TARJETA) ? undefined : response.data.dato[0].FEC_VCTO_TARJETA != undefined ? $scope.convertirDate(response.data.dato[0].FEC_VCTO_TARJETA) : undefined;

                                        if (response.data.dato[0].MCA_ASEGURADO === 'S') {

                                            $rootScope.llamarAsegurado = false;
                                        } else {
                                            $rootScope.llamarAsegurado = true;
                                        }


                                    } else {
                                        $scope.limpiar();
                                        $rootScope.llamarAsegurado = true;
                                        Message.warning(response.data.mensaje);
                                        $scope.cargando = false;
                                    }


                                } else {
                                    $scope.limpiar();
                                    $rootScope.llamarAsegurado = true;
                                    $scope.cargando = false;
                                    Message.error(response.data.mensaje);
                                }

                                //error
                            }).catch(function (response) {
                             
                            $scope.limpiar();
                            $rootScope.llamarAsegurado = true;
                            $scope.cargando = false;
                            Message.error("Ocurrió un error, intente nuevamente");

                        });

                    }

                }


            };



            /**formato para el datepicker**/
            $scope.formatearFecha = function (fecha) {
                $scope.aplicarFormato(fecha);
            };


            $scope.cargarPlataforma = function () {

                var paramPla = {};
                paramPla.numeroCotizacion = $scope.numeroCotizacion;
                paramPla.marcaFlota = $scope.subtipo == 'Flota' ? 'S' : 'N';
                paramPla.pathModule = $scope.pathModule;
                CotizacionVehiculoPropuestaService.getPlataforma(paramPla).then(
                    function (response) {
                        if (!response.data.error) {
                            if (response.data.dato != null) {

                                $scope.mostrarPlataforma = true;

                                $scope.prop.plataforma = response.data.dato.mensaje;


                            }

                        }


                    }).catch(function (response) {

                    Message.error(response.data.mensaje);

                });
            };


            /**
             * Función creada para el salto de propuesta a cotizacion
             */
            $scope.goToCotizacion = function () {
                var path = $location.$$absUrl;
                var n = path.search("module");
                var url = path.substring(0, n);

                if (typeof $scope.numeroCotizacionRoot != 'undefined' && $scope.numeroCotizacionRoot != null) {
                    var subtipo = 'cotizacion-hogar';
                    
                    location.href = subtipo + '/' + $scope.numeroCotizacionRoot;

                } else {
                    Message.warning("Debe ingresar un número de cotización");
                }
            }


            $scope.limpiar = function () {

                $rootScope.camposRequeridosList = [];
                $rootScope.numeroCotizacionRoot = undefined;
                $rootScope.nroPropuesta = undefined;
                $scope.eliminarPagina();
                if (typeof $routeParams.numeroCotizacion != "undefined") {
                    $location.search('numeroCotizacion', undefined);
                    $rootScope.numeroCotizacionRoot = undefined;
                    if ($scope.subtipo == "Flota") {
                     $location.path('propuesta-flota/propuesta');
                    } else if  ($scope.subtipo == 'Vehiculos') {
                        $location.path('propuesta-vehiculo/propuesta');
                    }else if ($scope.subtipo == 'Propuesta Hogar'){
                         $location.path('propuesta-hogar');
                    }


                } else {
                    $route.reload();
                }

            };
            $scope.recargar = function () {
                $scope.agenteSelected = undefined;
                $scope.bloquearBuscador = false;
                $scope.mostrarPlataforma = false;
                $scope.limpiar();

            };
            $scope.generarConstancia = function () {
                if (!angular.isUndefined($scope.numeroCotizacion) || $scope.numeroCotizacion != null) {
                    $scope.cargando = true;
                    var datos = {};
                    datos.numeroCotizacion = $scope.numeroCotizacion;
                    datos.marcaModulo=$location.path().split("/")[1];
                    PropuestaService.enviarConstancia(datos).then(function (response) {
                        $scope.cargando = false;
                        if (!response.data.error) {
                            Message.ok(response.data.mensaje);
                        } else {
                            Message.error(response.data.mensaje);
                        }
                    }).catch(function (response) {
                        $scope.cargando = false;
                        Message.error("Ocurrió un error, intente nuevamente");

                    });
                } else {
                    Message.warning("Debe ingresar un numero de cotizacion válido!");
                }
            };

            $scope.llamarModal = function (value) {

                if (!angular.isUndefined($rootScope.numeroCotizacionRoot) && $rootScope.numeroCotizacionRoot != null && $rootScope.numeroCotizacionRoot != "") {
                    $rootScope.numCotiza = $rootScope.numeroCotizacionRoot;
                    $rootScope.modalCotizadorVehFlota = value;
                    $rootScope.flagVehiculoFlota = false;
                    $rootScope.flagHogar=true;
                    $mdDialog.show({
                        //locals:{parent: $scope},
                        controller: 'ModalAutorizacionCtrl',
                        templateUrl: 'partials/ventanas-emergentes/modal-autorizacion-partial.html',
                        parent: angular.element(document.body),
                        multiple: true,
                        clickOutsideToClose: false,
                        scope: $scope,
                        preserveScope: true,
                        fullscreen: $scope.customFullscreen // Only for -xs, -sm breakpoints.
                    }).then(function (answer) {
                        $scope.buscar();


                    }, function () {
                        $scope.status = 'You cancelled the dialog.';
                        //console.log($scope.status);
                    });
                }

            };


            $scope.obtenerAutorizaciones = function () {

                $scope.autorizacionesList = [];
                var param = {};
                param.pathModule =$scope.pathModule;
                CotizacionVehiculoService.getAutorizaciones(param).then(function (response) {
                    if (!response.data.error) {
                        if (response.data.dato.length > 0) {
                            var campos = response.data.dato;
                            for (var i = 0; i < campos.length; i++) {
                                $scope.autorizacionesList.push(campos[i]);

                            }
                        }
                        //console.log("Lista Autorizaciones: " + JSON.stringify($scope.autorizacionesList));
                    } else {
                        Message.error(response.data.mensaje);
                    }
                });
            };

            /**Este Watch se dispara cuando las promesas se resuelven o tiene error, y la condicion principal debe ser
             * que el valor del sinc sea mayor a 0, sino ocurre eso es porque hay un error en el buscar o viene vacio el modelo de buscar**/

            $scope.$watch('sinc', function (NewValue, OldValue) {
                
                if (NewValue == cantModeloSinc && NewValue > 0) {
                    $scope.cargando = false;
                    $scope.sinc = 0; //cantidad de modelos seteados una vez obtenida la promesa
                    cantModeloSinc = 0; //cantidad de modelos que necesitan llamadas de servicios
                }


            }, true);
            $scope.setearCantidadModelos = function (response) {
                //preguntar la cantidad de campos a ser seteados
                // if (response.data.dato[0].COD_CONCESIONARIA != null && response.data.dato[0].COD_CONCESIONARIA != "") {
                //     variable auxiliar en caso que ocurra algun error, en la promesa de la concesionaria
                //     $scope.valorConcesionaria = response.data.dato[0].COD_CONCESIONARIA;
                //     cantModeloSinc++;
                // }//1

                if (response.data.dato[0].COD_CUADRO_COM != null && response.data.dato[0].COD_CUADRO_COM != "") {

                    $scope.valorComision = response.data.dato[0].COD_CUADRO_COM;
                    cantModeloSinc++;
                }
                if (response.data.dato[0].COD_NIVEL3 != null && response.data.dato[0].COD_NIVEL3 != "") {
                    $scope.valorOficina = response.data.dato[0].COD_NIVEL3;
                    cantModeloSinc++;
                }


                if (response.data.dato[0].COD_REFERIDO != null && response.data.dato[0].COD_REFERIDO != "" && response.data.dato[0].COD_CONCESIONARIA != null && response.data.dato[0].COD_CONCESIONARIA != "") {
                    $scope.valorReferido = response.data.dato[0].COD_REFERIDO;
                    cantModeloSinc++;
                }
                if (response.data.dato[0].COD_ENTIDAD != null && response.data.dato[0].COD_ENTIDAD != "" && response.data.dato[0].COD_GESTOR != null && response.data.dato[0].COD_GESTOR != "") {
                    $scope.valorEntidad = response.data.dato[0].COD_ENTIDAD;
                    cantModeloSinc++;
                }
                if (response.data.dato[0].COD_ACREEDOR != null && response.data.dato[0].COD_ACREEDOR != "") {
                    $scope.valorAcreedor = response.data.dato[0].COD_ACREEDOR;
                    cantModeloSinc++;
                }
                if (response.data.dato[0].COD_TIP_ENVIO != null && response.data.dato[0].COD_TIP_ENVIO != "") {
                    $scope.valorEnvio = response.data.dato[0].COD_TIP_ENVIO;
                    cantModeloSinc++;
                }
                if (response.data.dato[0].TIP_GESTOR != null && response.data.dato[0].TIP_GESTOR != "" ) {
                    $scope.valorTipoGestor = response.data.dato[0].TIP_GESTOR;
                    cantModeloSinc++;
                }//2
                if (response.data.dato[0].COD_OFICINA != null && response.data.dato[0].COD_OFICINA != "" && response.data.dato[0].COD_ENTIDAD != null && response.data.dato[0].COD_ENTIDAD != "" && response.data.dato[0].COD_GESTOR != null && response.data.dato[0].COD_GESTOR != "") {
                    $scope.valorSucursal = response.data.dato[0].COD_OFICINA;
                    cantModeloSinc++;
                }//3
                if (response.data.dato[0].COD_TIP_TAR != null && response.data.dato[0].COD_TARJETA != null && response.data.dato[0].COD_TIP_TAR != "" && response.data.dato[0].COD_TARJETA != "") {
                    $scope.valorCodTarjeta = response.data.dato[0].COD_TARJETA;
                    cantModeloSinc++;
                }//7
                if (response.data.dato[0].COD_GESTOR != null && response.data.dato[0].COD_GESTOR != "" && response.data.dato[0].TIP_GESTOR != null && response.data.dato[0].TIP_GESTOR != "") {
                    $scope.valorCodGestor = response.data.dato[0].COD_GESTOR;
                    cantModeloSinc++;
                }//8
                if (response.data.dato[0].COD_EJECUTIVO != null && response.data.dato[0].COD_EJECUTIVO != "" && response.data.dato[0].COD_NIVEL3 != null && response.data.dato[0].COD_NIVEL3 != "") {
                    $scope.valorEjecutivo = response.data.dato[0].COD_EJECUTIVO;
                    cantModeloSinc++;
                }//9
                /**Si no hay datos en el modelo que no necesitan promesas entonces se debe de ocultar el cargando*/
                if (cantModeloSinc == 0) {
                    $scope.cargando = false;
                }
            };
            $scope.$watch('cambiarTab', function (newValue, oldValue) {
                if (newValue != 0) {
                    if (newValue == 1) {
                        //hacer el redirect

                        var params={};
                        params.marcaFlota=$scope.subtipo=="Flota"?'S':'N';
                        params.numeroCotizacion=angular.isUndefined($scope.numeroCotizacionRoot)|| $scope.numeroCotizacionRoot==null?"":$scope.numeroCotizacionRoot;
                        params.tab=$rootScope.sigTab;
                        params.pathModule=$scope.pathModule;
                        $scope.service.getCamposEditablesList(params);
                        $timeout($location.url($rootScope.url_destino),1000);
                    } else {
                        newValue = 0; //para que vuelva a cambiar e intentar
                    }
                }

            }, true);
            $scope.eliminarPagina=function()
            {
                sessionStorage.removeItem("paginaAsegurado");
                sessionStorage.removeItem("paginaRiesgoPropuesta");
            };




        (function initialize() {
            $rootScope.currentPage = 'propuestaHogar';
            $rootScope.tabs = PropuestaService.getTabInicial();
            $scope.bloquearBuscador=false;
            $rootScope.llamarAsegurado=true;
            $scope.pathModule = UtilsService.retornarPath($location.path().split("/")[1]);
            $scope.agenteSelected=parseInt(sessionStorage.getItem("codigoAgente"));
            $scope.tieneIva='N';
            $scope.firmaDigital='N';
            $scope.imprimeGenera=undefined;
            $scope.subtipo=='Flota'?$scope.todo_concesionarias=false:$scope.todo_concesionarias=true;
        	obtenerFormasPago();
        	obtenerTiposTarjetas();
        	obtenerAgentes();
           // obtenerAcrPrendarios();
            obtenerTiposEnvio();
            $scope.obtenerAutorizaciones();
           angular.extend(this, $controller('UtilsCtrl', {
                    "$scope": $scope
            }));

            /**
             * Verifica si la ventana fue llamada desde cotizacion
             */
            if(typeof $routeParams.numeroCotizacion != "undefined"){
                
                $rootScope.numeroCotizacionRoot = $routeParams.numeroCotizacion;
                $scope.numeroCotizacion=$rootScope.numeroCotizacionRoot;
                $scope.buscar();
            }
            else if (!angular.isUndefined($scope.numeroCotizacionRoot) && $scope.numeroCotizacionRoot!= null && $scope.numeroCotizacionRoot!=""){

             $scope.buscar();
            }
            else
            {
                var marcaFlota;
                if ($scope.subtipo == "Flota")
                {
                    marcaFlota="S";
                }
                else
                {
                    marcaFlota="N";
                }
                var params={};
                params.marcaFlota=marcaFlota;
                params.numeroCotizacion=angular.isUndefined($scope.numeroCotizacionRoot)|| $scope.numeroCotizacionRoot==null?"":$scope.numeroCotizacionRoot;
                params.tab=$scope.tab;
                params.pathModule=$scope.pathModule;
                $scope.service.getCamposEditablesList(params);
            }



            $scope.eliminarPagina();







            
        })();
            


    }]);
;
app.controller('CotizacionHogarFormCtrl', ['$scope', '$q','CotizacionVehiculoService', '$controller', '$routeParams', '$location', 'SessionService', '$rootScope','$route', '$mdDialog', '$filter', 'ConfirmService', '$window','BuscadorCotizacionService','UtilsService','$locale','PropuestaService','UtilsService','$timeout','$log','DialogService','CotizacionHogarService',
    function ($scope,$q, CotizacionVehiculoService, $controller, $routeParams, $location, sessionService, $rootScope,$route, $mdDialog,  $filter, confirmService, $window,BuscadorCotizacionService, UtilsService, $locale, PropuestaService, UtilsService, $timeout, $log, DialogService,CotizacionHogarService) {

        /**
         * Url del recurso
         * @field
         * @type {Object}
         */
        $rootScope.rootPathParent =$route.current.$$route.originalPath;
        $scope.service=PropuestaService;
        $locale.NUMBER_FORMATS.GROUP_SEP = '.';
        $locale.NUMBER_FORMATS.DECIMAL_SEP=',';
        $scope.controlPermisos = true;

        $scope.nombre = "Cotizacion Hogar";
        $scope.status = '  ';
        $scope.customFullscreen = false;
        $scope.mostrarDocumento = {};


        $scope.listaMarcas =[];
        $scope.datosSubmodelo=[];
        $scope.listaCambio=[];
        var parametros = {};


        // combos vehiculos
        $scope.listaGrupoPoliza = [];

        
        $scope.listaMonedas = [];
        $scope.datosGrupoPoliza=[];
        $scope.datosDescuentoEspecial=[];
        //combo comercial
        $scope.listaProductos = [];
        $scope.listaPolizas = [];
        $scope.listaDesctComercial = [];

        $scope.listaDesctEspc = [];

        $scope.listaFraccion = [];

        /*datos generales*/
        $scope.datosGenerales = {};
        $scope.datosGenerales.nuevo ="N";
        $scope.datosGenerales.numeroPoliza=undefined;
        $scope.datosGenerales.numeroPolizaAnterior =undefined;
        $scope.datosGenerales.numeroCotizacion=null;

        /*vehiculos*/
        $scope.hogar = {};
		$scope.hogar.producto=undefined;
       // $scope.vehiculo.concecionaria=undefined;
       // $scope.vehiculo.acrPrendario=undefined;
        
        $scope.hogar.moneda=undefined;
		$scope.hogar.cotizacion="";
       // $scope.vehiculo.monto="2000";
       // $scope.vehiculo.referido='N';
        
        
       // $scope.vehiculo.nombreMarca=undefined;
        $scope.hogar.numeroSolicitud="";
        $scope.hogar.ciudad=undefined;
        $scope.hogar.fechaVigenciaDesde=undefined;
        $scope.hogar.fechaVigenciaHasta=undefined;
       // $scope.hogar.cerrado="";

        /*comercial*/
        $scope.comercial = {};

        $scope.comercial.desctComercial=undefined;
        $scope.comercial.desctP="1";
        $scope.comercial.desctEspecial=undefined;
        $scope.comercial.desctComercial2=undefined;
        $scope.comercial.recComercial=undefined;
        $scope.comercial.fraccion=undefined;
        $scope.comercial.cuota="S";
        $scope.comercial.poliza=undefined;
        $scope.comercial.polizaDescripcion="";
        $scope.comercial.bono=undefined;
        $scope.comercial.bono2=null;
        //$scope.comercial.malus=null;
        $scope.comercial.inicial=undefined;
        $scope.comercial.primeraCuota=undefined;
        $scope.comercial.polizaPorct=undefined;


        /*cobertura*/
        $scope.cobertura = {};
        $scope.cobertura.rcPersonas="200";
        $scope.cobertura.ovpGtosMdeOcup="200";
        $scope.cobertura.robo="200";
        $scope.cobertura.granizo="200";
        $scope.cobertura.incendioEdificio="200";
        $scope.cobertura.danhosVandalismo="200";
        $scope.cobertura.rcDanhosMateriales="200";
        $scope.cobertura.danhosPropiosTotal="200";
        $scope.cobertura.roboParcialRadio="2011";
        $scope.cobertura.accidentePersonales="200";
        $scope.cobertura.incendioContenidoVivienda="300";
        $scope.cobertura.airbag="200";
        $scope.cobertura.ovpMteOcupante="200000000";
        $scope.cobertura.danhosPropiedad="200";
        $scope.cobertura.roboParcialRadio2="200";
        $scope.cobertura.gtoMedAccPersonales="200";
        $scope.cobertura.sepelio="200";
        $scope.cobertura.cartaVerde=true;
        $scope.cobertura.cartaAzul=false;
        
         
        $scope.cobertura.minMonto=0;
        $scope.cobertura.maxMonto=0;
        $scope.cobertura.franquicia=undefined;

        $scope.debitoAutomatico ={};
        $scope.debitoAutomatico.prima="0";
        $scope.debitoAutomatico.costoTotal ="0";
        $scope.debitoAutomatico.cuota="0";
        $scope.debitoAutomatico.ultimaCuota="0";

        $scope.contado ={};
        $scope.contado.prima="0";
        $scope.contado.costoTotal ="0";

        $scope.chequera ={};
        $scope.chequera.prima="0";
        $scope.chequera.costoTotal ="0";
        $scope.chequera.cuota="0";
        $scope.chequera.ultimaCuota="0";
        $scope.desctComercial=false;
        $scope.recComercial=false;
        $scope.coberturaDatos=[];
        $scope.minDescRec=-100;
        $scope.maxDescRec=100;
        $scope.maxDescEspecial=0;
        $scope.restriccion="^[0-9]+(\,[0-9]{1,2})?$";
        $scope.camposEditablesList=[];
        $scope.submitted=false;
        $scope.emitir=false;
        $scope.todo_marcas=false;
        $scope.preferencia_marcas=$window.sessionStorage.getItem("preferencia_marcas");
        $scope.preferencia_moneda=$window.sessionStorage.getItem("preferencia_moneda");
        $scope.preferencia_fraccionamiento=$window.sessionStorage.getItem("preferencia_fraccionamiento");
        $scope.bloquearCartaVerde=true;
        $scope.bloquearCartaAzul=true;
        $scope.minOcupantes=0;
        $scope.maxOcupantes=0;
        $scope.esBuscar=false;
        $scope.sumaAseguradaBuscar=false;
        $scope.marcaNoPreferencia=false;
        $scope.habilitarPropuesta=false;
        $scope.bloquearBuscador=false;
        $scope.esNuevo="S";
        $scope.promesaSave= $q.defer();
        $scope.editablesDescPoliza=true;
        $scope.monedaPolizaG=true;
        $scope.fraccionPolizaG=true
        $scope.visibleMoneda=true;
        $scope.ciudades=[];
        $scope.informacion=[];
         

       // $scope.mostrarFranquicia=false;
        //$scope.listaFranquicias=[];
        //$scope.codigoFranquicia=undefined;
        $scope.save = function () {
            $scope.cargando=true;
            //obtenemos los campos requeridos
            $scope.camposRequeridosList = [];
            var params = {};
            params.numeroCotizacion = angular.isUndefined($scope.datosGenerales.numeroCotizacion) ? "" : $scope.datosGenerales.numeroCotizacion != null ? $scope.datosGenerales.numeroCotizacion : "";
            params.pathModule =$scope.pathModule;
            CotizacionHogarService.getCamposRequeridos(params).then(function (response) {
                if (!response.data.error) {
                    if (response.data.dato.length > 0) {
                        var campos = response.data.dato;
                        $scope.camposRequeridosList=campos;
                        $timeout(function(){
                            if ($scope.CotizacionForm.$invalid && !angular.isUndefined($scope.CotizacionForm.$error.required)) {
                                $scope.cargando=false;
                                Message.warning("Existen campos que faltan ser completados!");
                                return;
                            }
                            else
                            {
                              //  $log.debug("Valido, llamar a guardar"); //llamar al guardar
                                $scope.camposRequeridosList = [];
                               
                                    var datosSave = {};
                                   
                                    datosSave.numeroPropuesta = angular.isUndefined($scope.datosGenerales.numeroPropuesta)?null:$scope.datosGenerales.numeroPropuesta;
                                    datosSave.numeroCotizacion = angular.isUndefined($scope.datosGenerales.numeroCotizacion)?null:$scope.datosGenerales.numeroCotizacion;
                                    datosSave.esNuevo=$scope.datosGenerales.nuevo;

                                    datosSave.descuentoComercial = angular.isUndefined($scope.comercial.desctComercial2)?null:$scope.comercial.desctComercial2;
                                    datosSave.bonus = $scope.comercial.bono2;
                                    datosSave.codigoPolizaGrupo = angular.isUndefined($scope.comercial.poliza)?null:$scope.comercial.poliza;
                                    datosSave.nombrePolizaGrupo = angular.isUndefined($scope.nombrePolizaGrupo)?"":$scope.nombrePolizaGrupo;
                                    datosSave.porcentajePolizaGrupo = $scope.comercial.polizaPorct;
                                    datosSave.codigoDescEspecial = angular.isUndefined($scope.comercial.desctEspecial)?null:$scope.comercial.desctEspecial;
                                    datosSave.nombreDescEspecial = angular.isUndefined($scope.nombreDescEspecial)?"":$scope.nombreDescEspecial;
                                    datosSave.porcentajeDescEspecial = $scope.comercial.desctEspecialPorct;
                                    datosSave.valorCambio = $scope.hogar.cotizacion;
                                    datosSave.codigoProducto = angular.isUndefined($scope.hogar.producto) ? null : $scope.hogar.producto;
                                    datosSave.codigoMoneda = $scope.hogar.moneda;
                                    datosSave.codigoFraccionamiento = $scope.comercial.fraccion;
                                    datosSave.importeInicial = angular.isUndefined($scope.comercial.inicial)?null:$scope.comercial.inicial;
                                    datosSave.marcaCuotaIgual = $scope.comercial.primeraCuota;
                                    //datosSave.marcaEnvioDigital=$scope.comercial.envioDigital;
                                    datosSave.codigoCiudad=angular.isUndefined($scope.hogar.ciudad)?null:$scope.hogar.ciudad;
                                    datosSave.fechaEfectoPoliza = angular.isUndefined($scope.hogar.fechaVigenciaDesde) ? null : $scope.hogar.fechaVigenciaDesde != null ? moment($scope.hogar.fechaVigenciaDesde).format("DD/MM/YYYY") : null;
                                    datosSave.fechaVencimientoPoliza = angular.isUndefined($scope.hogar.fechaVigenciaHasta) ? null : moment($scope.hogar.fechaVigenciaHasta).format("DD/MM/YYYY");
                                    if ($scope.ciudades.length>0)
                                    {
                                        for (var i=0; i<$scope.ciudades.length;i++)
                                        {
                                            if ($scope.ciudades[i].codigoBarrio==$scope.hogar.ciudad)
                                            {
                                                datosSave.codigoBarrio=$scope.ciudades[i].codigoCiudad;
                                                break;
                                            }
                                        }

                                    }
                                    datosSave.codigoCiudad=datosSave.codigoBarrio;
                                    datosSave.codigoBarrio=angular.isUndefined($scope.hogar.ciudad)?null:$scope.hogar.ciudad;

                                    $scope.coberturaDatos = [];

                                    if ($scope.v1 && $scope.datos) {
                                        for (var i = 0; i < $scope.v1.length; i++) {

                                            var obj = {

                                                numeroCotizacion: datosSave.numeroCotizacion,
                                                codigoCobertura: $scope.v1[i].COD_COB,
                                                etiqueta: $scope.v1[i].ETIQUETA,
                                                capital: $scope.v1[i].CAPITAL,
                                                marcaModificable: $scope.v1[i].MCA_MODIFICABLE
                                            };

                                            $scope.coberturaDatos.push(obj);
                                        }
                                        for (var i = 0; i < $scope.datos.length; i++) {
                                            var obj = {

                                                numeroCotizacion: datosSave.numeroCotizacion,
                                                codigoCobertura: $scope.datos[i].COD_COB,
                                                etiqueta: $scope.datos[i].ETIQUETA,
                                                capital: $scope.datos[i].CAPITAL,
                                                marcaModificable: $scope.datos[i].MCA_MODIFICABLE
                                            };

                                            $scope.coberturaDatos.push(obj);
                                        }
                                        datosSave.coberturasHogar = angular.copy($scope.coberturaDatos);
                                    }
                                    else {
                                        datosSave.coberturasHogar = [];
                                    }
                                    $scope.cargando = true;
                                    CotizacionHogarService.guardarCotizacionHogar(datosSave).then(
                                        function (response) {
                                            if (!response.data.error) {

                                                    $scope.listaFormaPago = [];
                                                   // $scope.listaFormaPago = response.data.dato[0].costoVehiculo ? response.data.dato[0].costoVehiculo : [];
                                                   // $scope.cargarListadoFormaPago();

                                                    $scope.datosGenerales.numeroCotizacion = parseInt(response.data.dato.numeroCotizacion);
                                                   $scope.cargando = false;
                                                   Message.ok(response.data.mensaje);
                                                    $scope.clickButton = false;
                                                    $scope.promesaSave.resolve();
                                                $scope.buscarCotizacion();

                                            } else {
                                                $scope.cargando = false;
                                                Message.error(response.data.mensaje);
                                                //
                                                $scope.promesaSave.reject();

                                            }

                                        }).catch(function (response) {
                                        $scope.cargando = false;
                                        Message.error("Ocurrio un error intente nuevamente!");
                                        $scope.promesaSave.reject();
                                    });
                                  
                                    $scope.cargando = false;
                              

                            }
                        }, 1000);

                    }
                    else
                    {
                        $scope.cargando=false;
                    }


                }
                else {
                    $scope.cargando=false;
                    Message.error(response.data.mensaje);
                }
            }, function(error){
                $scope.cargando=false;
                Message.error("Ocurrio un error al obtener los campos requeridos.");
            });





        };
        $scope.actualizarDatos = function() {
            
            var datosSave={};
            datosSave.numeroPropuesta = angular.isUndefined($scope.datosGenerales.numeroPropuesta)?null:$scope.datosGenerales.numeroPropuesta;
            datosSave.numeroCotizacion = angular.isUndefined($scope.datosGenerales.numeroCotizacion)?null:$scope.datosGenerales.numeroCotizacion;
            datosSave.esNuevo=$scope.datosGenerales.nuevo;

            datosSave.descuentoComercial = angular.isUndefined($scope.comercial.desctComercial2)?null:$scope.comercial.desctComercial2;
            datosSave.bonus = $scope.comercial.bono2;
            datosSave.codigoPolizaGrupo = angular.isUndefined($scope.comercial.poliza)?null:$scope.comercial.poliza;
            datosSave.nombrePolizaGrupo = angular.isUndefined($scope.nombrePolizaGrupo)?"":$scope.nombrePolizaGrupo;
            datosSave.porcentajePolizaGrupo = $scope.comercial.polizaPorct;
            datosSave.codigoDescEspecial = angular.isUndefined($scope.comercial.desctEspecial)?null:$scope.comercial.desctEspecial;
            datosSave.nombreDescEspecial = angular.isUndefined($scope.nombreDescEspecial)?"":$scope.nombreDescEspecial;
            datosSave.porcentajeDescEspecial = $scope.comercial.desctEspecialPorct;
            datosSave.valorCambio = $scope.hogar.cotizacion;
            datosSave.codigoProducto = angular.isUndefined($scope.hogar.producto) ? null : $scope.hogar.producto;
            datosSave.codigoMoneda = $scope.hogar.moneda;
            datosSave.codigoFraccionamiento = $scope.comercial.fraccion;
            datosSave.importeInicial = angular.isUndefined($scope.comercial.inicial)?null:$scope.comercial.inicial;
            datosSave.marcaCuotaIgual = $scope.comercial.primeraCuota;
            //datosSave.marcaEnvioDigital=$scope.comercial.envioDigital;
            datosSave.codigoCiudad=angular.isUndefined($scope.hogar.ciudad)?null:$scope.hogar.ciudad;
            datosSave.fechaEfectoPoliza = angular.isUndefined($scope.hogar.fechaVigenciaDesde) ? null : $scope.hogar.fechaVigenciaDesde != null ? moment($scope.hogar.fechaVigenciaDesde).format("DD/MM/YYYY") : null;
            datosSave.fechaVencimientoPoliza = angular.isUndefined($scope.hogar.fechaVigenciaHasta) ? null : moment($scope.hogar.fechaVigenciaHasta).format("DD/MM/YYYY");
            if ($scope.ciudades.length>0)
            {
                for (var i=0; i<$scope.ciudades.length;i++)
                {
                    if ($scope.ciudades[i].codigoBarrio==$scope.hogar.ciudad)
                    {
                        datosSave.codigoBarrio=$scope.ciudades[i].codigoCiudad;
                        break;
                    }
                }

            }
            datosSave.codigoCiudad=datosSave.codigoBarrio;
            datosSave.codigoBarrio=angular.isUndefined($scope.hogar.ciudad)?null:$scope.hogar.ciudad;

            $scope.coberturaDatos = [];

            if ($scope.v1 && $scope.datos) {
                for (var i = 0; i < $scope.v1.length; i++) {

                    var obj = {

                        numeroCotizacion: datosSave.numeroCotizacion,
                        codigoCobertura: $scope.v1[i].COD_COB,
                        etiqueta: $scope.v1[i].ETIQUETA,
                        capital: $scope.v1[i].CAPITAL,
                        marcaModificable: $scope.v1[i].MCA_MODIFICABLE
                    };

                    $scope.coberturaDatos.push(obj);
                }
                for (var i = 0; i < $scope.datos.length; i++) {
                    var obj = {

                        numeroCotizacion: datosSave.numeroCotizacion,
                        codigoCobertura: $scope.datos[i].COD_COB,
                        etiqueta: $scope.datos[i].ETIQUETA,
                        capital: $scope.datos[i].CAPITAL,
                        marcaModificable: $scope.datos[i].MCA_MODIFICABLE
                    };

                    $scope.coberturaDatos.push(obj);
                }
                datosSave.coberturasHogar = angular.copy($scope.coberturaDatos);
            }
            else {
                datosSave.coberturasHogar = [];
            }
            $scope.cargando=true;
                    CotizacionHogarService.guardarCotizacionHogar(datosSave).then(
                        function (response) {
                          if(!response.data.error){
                              $scope.buscarCotizacion();


                          }else{
                            $scope.cargando=false;
                            Message.error(response.data.mensaje);
                            //

                          }


                           

                        }).catch(function(response){
                            $scope.cargando=false;
                            Message.error("Ocurrio un error intente nuevamente!");
                        });

            

        };
        





        $scope.buscarPoliza = function(evt) {
            if (angular.isUndefined(evt)) {
                //Ejecutado cuando $scope.buscar es invocado sin parametros --NO CREOQ QUE HAGA FALTA ESTE CONTROL

            } else {
                //enter
                if (angular.equals(evt.keyCode, 13)) {
                }
            }

        };

        $scope.resetFilter=function()
        {
            $scope.comercial.inicial = undefined;
        };

       

        var valorGua;
        var valorDol;
        var valorEu;
        $scope.promesaMonedas = $q.defer();  
        $scope.cargarMonedas = function(codigoProducto, valorDefault)
        {
        //primero traemos todas las monedas
            var parametros = {};
            $scope.listaMonedas=[];
            $scope.listaCambio=[];
        
          //  parametros.preferencia="N"; //por defecto no tiene preferencia, luego consultar la variable que almacena
           // parametros.esNuevo=$scope.esNuevo;
           parametros.codigoProducto = codigoProducto ;
            CotizacionHogarService.getMonedas(parametros).then(
                function (response) {
                    if (response.data.error== false)
                    {
                        if(response.data.dato !== null)
                        {
                              
                            for(var i=0; i<response.data.dato.length; i++){
                                var camb ={
                                    id :  response.data.dato[i].codigoMoneda,
                                    cambio : response.data.dato[i].valorCambio
                                };
                                var obj = {
                                    id:response.data.dato[i].codigoMoneda,
                                    moneda:response.data.dato[i].nombreMoneda
                                };
                                $scope.listaMonedas.push(obj);
                                $scope.listaCambio.push(camb);

                                //valorGua= response.data.dato[0].VAL_CAMBIO;
                                //valorDol= response.data.dato[1].VAL_CAMBIO;
                                //valorEu= response.data.dato[2]? response.data.dato[2].VAL_CAMBIO: 0.0;


                            }
                            if ($scope.listaMonedas.length>0 && valorDefault=="S")
                            {
                                $scope.hogar.moneda=$scope.listaMonedas[0].id;
                            }
                            $scope.visibleMoneda=false;
                            $scope.cargando=false;
                            $scope.promesaMonedas.resolve();
                            
                        }

                    }
                    else
                    {
                        $scope.promesaMonedas.reject();
                        Message.error(response.data.mensaje);

                    }
                    

                   
                },
                function(response){
                    $scope.promesaMonedas.reject();
                    Message.error(response.data.mensaje);
                    
                });

        };

        $scope.promesaPoliza= $q.defer();
        $scope.cargarPolizaGrupo = function() {
            var parametros = {};
            parametros.esNuevo=$scope.esNuevo;
            parametros.fechaPoliza=!angular.isUndefined($scope.hogar.fechaVigenciaDesde)?$scope.hogar.fechaVigenciaDesde!=null?moment($scope.hogar.fechaVigenciaDesde).format("DD/MM/YYYY"):null:null;
            parametros.pathModule =$scope.pathModule;
            CotizacionHogarService.getPolizaGrupoHogar(parametros).then(
                function (response) {
                    if (response.data.error==false )
                    {
                        if (response.data.dato != null && response.data.dato.length>0)
                        {
                            for(var i=0; i<response.data.dato.length; i++){
                                var dato = {
                                    id:response.data.dato[i].NUM_POLIZA,
                                    porcentaje:response.data.dato[i].PORC_DESCUENTO
                                };

                                var obj = {
                                    id:response.data.dato[i].NUM_POLIZA,
                                    poliza:response.data.dato[i].NOM_POLIZA
                                };
                                $scope.listaGrupoPoliza.push(obj);
                                $scope.datosGrupoPoliza.push(dato);
                            }
                        }
                        else
                        {
                            $scope.listaGrupoPoliza=[];
                            $scope.datosGrupoPoliza=[];
                        }

                    }
                    else
                    {
                        Message.error(response.data.mensaje);
                    }
                    
                    $scope.promesaPoliza.resolve();
                    
                },
                 function(response){
                    $scope.promesaPoliza.reject();
                    Message.error(response.data.mensaje);
                    
                });

        };

        $scope.cargarDescuentoEspecial = function() {
            var parametros = {};
            parametros.numeroCotizacion= $scope.datosGenerales.numeroCotizacion;
            parametros.esNuevo=$scope.esNuevo;
            parametros.pathModule = $scope.pathModule;
            CotizacionVehiculoService.getDescuentosEspeciales(parametros).then(
                function (response) {
                    if (response.data.error== false)
                    {
                        if (response.data.dato != null)
                        {
                            for(var i=0; i<response.data.dato.length; i++){

                                var objDatos = {
                                    id:response.data.dato[i].COD_VALOR,
                                    desct:response.data.dato[i].PCT_DESCUENTO
                                };

                                var obj = {
                                    id:response.data.dato[i].COD_VALOR,
                                    desct:response.data.dato[i].NOM_VALOR
                                };
                                $scope.listaDesctEspc.push(obj);
                                $scope.datosDescuentoEspecial.push(objDatos);
                            }
                        }

                    }
                    else
                    {
                        Message.error(response.data.mensaje);
                    }
                    
                     
                },
                function(response){
                    Message.error(response.data.mensaje);
                    
                });

        };


        $scope.promesaFraccion =$q.defer();
        $scope.cargarFraccionamiento = function() {
            var parametros = {}; //al inicio traer todas las listas de fraccionamiento
            parametros.preferencia="N";
            parametros.esNuevo=$scope.esNuevo;
            parametros.codigoGrupoPoliza = angular.isUndefined($scope.comercial.poliza)?null:$scope.comercial.poliza;
            CotizacionVehiculoService.getFraccionamiento(parametros).then(
                function (response) {
                    if (response.data.error ==false ) {
                        if (response.data.dato != null)
                        {
                            for (var i = 0; i < response.data.dato.length; i++) {
                                var obj = {
                                    id: response.data.dato[i].COD_FRACC_PAGO,
                                    fraccion: response.data.dato[i].NOM_FRACC_PAGO
                                };
                                $scope.listaFraccion.push(obj);
                            }
                            //si tiene preferencia entonces llamar a la preferencia y seleccionar por defecto
                            if ($scope.preferencia_fraccionamiento == "S") {
                                //llamar al servicio que traiga la preferencia
                                parametros = {};
                                parametros.preferencia = $scope.preferencia_fraccionamiento;
                                parametros.esNuevo = $scope.esNuevo;
                                CotizacionVehiculoService.getFraccionamiento(parametros).then(
                                    function (response) {
                                        if (response.data.error == false && response.data.dato != null) {
                                            //se setea el fraccionamiento por defecto
                                            $scope.comercial.fraccion=parseInt(response.data.dato[0].COD_FORMA_PAGO);

                                        }

                                    })

                            }
                            else
                            {
                                $scope.comercial.fraccion =99100;
                            }
                        }

                    }
                    else
                    {
                        Message.error(response.data.mensaje);
                        //
                    }

                    $scope.promesaFraccion.resolve();
                },
                function(response){
                    $scope.promesaFraccion.reject();
                    Message.error(response.data.mensaje);
                    
                });

        };

 
        
        $scope.$watch('hogar.fechaVigenciaDesde', function (NewValue, OldValue){
            if (!angular.isUndefined(NewValue) && NewValue!=null)
            {
                var dato = moment(NewValue).format("DD/MM/YYYY");
                var param={};
                param.fechaVigencia=dato;
                param.pathModule=$scope.pathModule;
                PropuestaService.obtenerFechaVigenciaHasta(param).then(function(response){
                    if (!response.data.error)
                    {
                        if (response.data.dato!=null)
                        {
                            $scope.hogar.fechaVigenciaHasta=$scope.convertirDate(response.data.dato.fechaVencimientoPoliza);
                        }
                    }
                    else
                    {
                        Message.error(response.data.mensaje);
                    }
                });
                $scope.cargarPolizaGrupo();
            }
            else
            {
                $scope.listaGrupoPoliza=[];
            }

        });

          $scope.$watch('hogar.producto', function(NewValue, OldValue) {

                if(!angular.isUndefined(NewValue) && NewValue !=null){
                     
                        
                        if (!$scope.esBuscar){
                            $scope.v1=[];
                            $scope.v2=[];
                            $scope.datos=[];
                            $scope.montoIncendioEdificio=null;
                            $scope.limpiarFormasPago();

                        }

                    $scope.promesaMonedas.promise.$$state.status=0;
                     $scope.cargarMonedas(NewValue, $scope.esBuscar?"N":"S");

                    if($scope.persistirProducto==true){
                        $scope.flagConfirmacion=false;
                        $scope.promesaSave.promise.$$state.status=0;
                       
                        $scope.cambioProducto=true;
                        var parametros={};
                        parametros.esNuevo=$scope.esNuevo;
                        
                        parametros.codigoMoneda=$scope.hogar.moneda;
                        parametros.codigoRamo=501;
                        parametros.numeroCotizacion=$scope.datosGenerales.numeroCotizacion;
                        $scope.cargando=true;
                        //$scope.cobertura.franquicia=undefined;
                        /**verificar que el producto seleccionado tenga franquicia**/
                        //$scope.verificarFranquicia(NewValue, $scope.hogar.moneda, $scope.datosGenerales.numeroPropuesta);
                      //  $scope.recalcularCotizacion(parametros);  

                    }else{
                         $scope.persistirProducto=true;
                        /**verificar que el producto seleccionado tenga franquicia**/
                       // $scope.verificarFranquicia(NewValue, $scope.hogar.moneda, $scope.datosGenerales.numeroPropuesta);
                    }
                    

            }else{
                    $scope.datosCobertura=[];
                    $scope.listaMonedas=[];
                    $scope.hogar.cotizacion = null;
                    $scope.v1=[];
                    $scope.v2=[];
                    $scope.datos=[];
                   // $scope.mostrarCartas=false;
                   // $scope.mostrarFranquicia=false;
                  //  $scope.setearCobertura($scope.datosCobertura);
                    $scope.limpiarFormasPago();

               /* $scope.hogar.cotizacion=null;*/
            }
              

           

        },true);

            var valorSub=0;
            var valorSubMax;
            var valorSubMin;
            var valorCot;


        $scope.cambiarMoneda=function()
        {
            if(!angular.isUndefined($scope.hogar.moneda))
            {
                var  parametros ={};
                parametros.esNuevo=$scope.esNuevo;
                 
                parametros.codigoMoneda=$scope.hogar.moneda;
                parametros.codigoRamo=501;
                parametros.numeroCotizacion=!angular.isUndefined($scope.datosGenerales.numeroCotizacion)&& $scope.datosGenerales.numeroCotizacion!=null?$scope.datosGenerales.numeroCotizacion:"";
             
              
        
                    for(var i=0; i<$scope.listaCambio.length; i++){
                        if ($scope.listaCambio[i].id==$scope.hogar.moneda){
                            $scope.hogar.cotizacion = $scope.listaCambio[i].cambio;
                            break;
                        }
                    }
                
                
 

                
                        var sumaAsegurada=valorSub*valorCot;
                        var sumaAseguradaMax=valorSubMax*$scope.hogar.cotizacion;
                        var sumaAseguradaMin=valorSubMin*$scope.hogar.cotizacion;
                       $scope.datosGenerales.numeroPropuesta=sumaAsegurada? sumaAsegurada:0;



                if($scope.acti){
                    $scope.acti=false;
                }
                $scope.comercial.inicial=undefined;

        
        }
        else
        {
            $scope.hogar.cotizacion=null;
            $scope.comercial.inicial=undefined;
        }
        };



        
       
        

        $scope.$watch('comercial.poliza', function(NewValue, OldValue) {
            if(!angular.isUndefined(NewValue) && NewValue!=null)
            {
                if ($scope.editablesDescPoliza)
                {

                    var params = {};
                    params.numeroPolizaGrupo = NewValue;
                    params.moneda = $scope.hogar.moneda;
                    params.pathModule = $scope.pathModule;
                    CotizacionVehiculoService.validarPolizaGrupo(params).then(function (response) {
                        if (response.data.error) {
                            $scope.comercial.poliza = undefined;
                            $scope.comercial.polizaPorct="";
                            $scope.comercial.nombrePolizaGrupo="";
                            $scope.monedaPolizaG=true;
                            $scope.fraccionPolizaG=true;
                            DialogService.showDialog(response.data.mensaje);


                        } else {
                            $scope.setearPorcentajeDesc(NewValue);
                            if (response.data.dato!=null)
                            {
                                if (response.data.dato.monedaModificable=="S")
                                {
                                    $scope.monedaPolizaG=true;
                                }
                                else
                                {
                                    $scope.monedaPolizaG=false;
                                }

                                if (response.data.dato.fraccionamientoModificable=="S")
                                {
                                    $scope.fraccionPolizaG=true;
                                }
                                else
                                {
                                    $scope.fraccionPolizaG=false;
                                }

                                if (response.data.dato.codigoFraccionamiento!=null && response.data.dato.codigoFraccionamiento!="")
                                {
                                    var fraccion=parseInt(response.data.dato.codigoFraccionamiento);
                                    var index=$scope.listaFraccion.map(function(e){return e.id;}).indexOf(fraccion);
                                    if (index !==-1)
                                    {
                                        $scope.comercial.fraccion=parseInt(response.data.dato.codigoFraccionamiento);
                                    }

                                }
                            }





                        }



                    }).catch(function(error){
                        $scope.comercial.poliza = undefined;
                        $scope.comercial.polizaPorct="";
                        $scope.comercial.nombrePolizaGrupo="";
                        Message.error("Algo inesperado ha ocurrido, intente nuevamente!");
                    });
                }
                else
                {
                    $scope.editablesDescPoliza = true;
                    /**Calcular lo seteado por el buscar **/
                    $scope.setearPorcentajeDesc(NewValue);
                }







            }else{
                $scope.editablesDescPoliza = true;
                $scope.comercial.polizaPorct="";
                $scope.comercial.nombrePolizaGrupo="";
            }
            
            $scope.cambiarRangoDescuento();

        },true);
        $scope.setearPorcentajeDesc=function(descPoliza)
        {
            for (var i = 0; i < $scope.datosGrupoPoliza.length; i++) {
                if ($scope.datosGrupoPoliza[i].id == descPoliza) {
                    $scope.comercial.polizaPorct = $scope.datosGrupoPoliza[i].porcentaje;
                    break;
                }
            }
            for (var i = 0; i < $scope.listaGrupoPoliza.length; i++) {
                if ($scope.listaGrupoPoliza[i].id == descPoliza) {
                    $scope.nombrePolizaGrupo = $scope.listaGrupoPoliza[i].poliza;
                    break;
                }
            }
        }
        $scope.$watch('comercial.desctEspecial', function(NewValue, OldValue) {

            
            if(!angular.isUndefined(NewValue) && $scope.comercial.desctEspecial !=null ){

                for(var i=0; i<$scope.datosDescuentoEspecial.length; i++){
                    if ($scope.datosDescuentoEspecial[i].id==NewValue){
                        if ($scope.comercial.desctEspecialPorct != null){
                           $scope.maxDescEspecial=$scope.comercial.desctEspecialPorct;
                        }else{
                            $scope.maxDescEspecial=parseInt($scope.datosDescuentoEspecial[i].desct);
                            $scope.comercial.desctEspecialPorct=parseInt($scope.datosDescuentoEspecial[i].desct);
                        }
                        
                        break;
                    }
                }
                for(var i=0; i<$scope.listaDesctEspc.length; i++){
                    if ($scope.listaDesctEspc[i].id==NewValue){
                        $scope.nombreDescEspecial=$scope.listaDesctEspc[i].desct;
                        break;
                    }
                }



            }else{
                $scope.comercial.desctEspecialPorct=null;
            }
        },true);



        $scope.$watch('comercial.fraccion', function(NewValue, OldValue) {

            if(!angular.isUndefined(NewValue)){

                var  parametros ={};



            }else{

            }
        },true);

      
 $scope.$watch('datosGenerales.nuevo', function(NewValue, OldValue) {

             if(!angular.isUndefined(NewValue)){

             }else{
                   
             }


        },true);
 
  $scope.promesaCambioEnMoneda=$q.defer();
  $scope.$watch('hogar.moneda', function(NewValue, OldValue) {

             if(!angular.isUndefined(NewValue) && NewValue != null){
                $scope.datosCobertura=[];
                var params = {};
                params.codigoProducto = $scope.hogar.producto;
                params.codigoMoneda = NewValue;
                
                
                for(var i=0; i<$scope.listaCambio.length; i++){
                        if ($scope.listaCambio[i].id==$scope.hogar.moneda){
                            $scope.hogar.cotizacion = $scope.listaCambio[i].cambio;
                            break;
                        }
                }  
                
                
                params.montoIncendioEdificio = $scope.montoIncendioEdificio ==null ?"":$scope.montoIncendioEdificio;

                CotizacionHogarService.listarCoberturas(params).then(
                function (response) {
                    if (response.data.error ==false ) {
                        if (response.data.dato != null) {
                             $scope.cargando=true;
                            for (var i = 0; i < response.data.dato.length; i++) {
                                $scope.datosCobertura.push({"COD_COB": response.data.dato[i].codigoCobertura,"ETIQUETA":response.data.dato[i].etiqueta,"CAPITAL":Number(response.data.dato[i].capital), "INCREMENTO": Number(response.data.dato[i].incremento),"MCA_MODIFICABLE":response.data.dato[i].marcaModificable, "MINIMO": Number(response.data.dato[i].minimo), "PORCENTAJE": parseFloat(response.data.dato[i].porcentajeCobertura) } );
                                if(response.data.dato[i].maximo!="" ){
                                    $scope.datosCobertura[i].MAXIMO=Number(response.data.dato[i].maximo);
                                }else{
                                    $scope.datosCobertura[i].MAXIMO=-1;
                                }
                            }
                                if ($scope.esBuscar==false){
                                     $scope.setearCobertura($scope.datosCobertura);

                                }else{
                                     $scope.esBuscar = false;
                                }
                             
                                
                            
                           
                             
                            $scope.cargando=false;
                           
                        }

                    } else{
                        // $scope.sindatos= true;
                        Message.error(response.data.mensaje);
                        
                    }

                    
                },
                function(response){
                    
                    Message.error(response.data.mensaje);
                    
                });

                $scope.promesaCambioEnMoneda.resolve();

             }else{
               
                   
             }


        },true);

         $scope.llamarListadoCoberturas = function(monto,moneda,producto) {
                 $scope.cargando=true;
                $scope.datosCobertura=[];
                var params = {};
                params.codigoProducto = producto;
                params.codigoMoneda = moneda;
                params.montoIncendioEdificio = monto;
               // $scope.limpiarFormasPago();

               CotizacionHogarService.listarCoberturas(params).then(
                function (response) {
                    if (response.data.error ==false ) {
                        if (response.data.dato != null) {
                             $scope.cargando=true;
                            for (var i = 0; i < response.data.dato.length; i++) {
                                $scope.datosCobertura.push({"COD_COB": response.data.dato[i].codigoCobertura,"ETIQUETA":response.data.dato[i].etiqueta,"CAPITAL":Number(response.data.dato[i].capital), "INCREMENTO": Number(response.data.dato[i].incremento),"MCA_MODIFICABLE":response.data.dato[i].marcaModificable, "MINIMO": Number(response.data.dato[i].minimo), "PORCENTAJE": parseFloat(response.data.dato[i].porcentajeCobertura) } );
                                if(response.data.dato[i].maximo!="" ){
                                    $scope.datosCobertura[i].MAXIMO=Number(response.data.dato[i].maximo);
                                }else{
                                    $scope.datosCobertura[i].MAXIMO=-1;
                                }
                            }
                                if ($scope.esBuscar==false){
                                     $scope.setearCobertura($scope.datosCobertura);

                                }else{
                                     $scope.esBuscar = false;
                                }
                             
                                
                            
                           
                             
                            $scope.cargando=false;
                           
                        }

                    } else{
                        // $scope.sindatos= true;
                        $scope.cargando=false;
                        Message.error(response.data.mensaje);
                        
                    }

                    
                },
                function(response){
                    $scope.cargando=false;
                    
                    Message.error(response.data.mensaje);
                    
                });


         };



        $scope.showAdvanced = function() {

           $rootScope.codCoti=$scope.datosGenerales.numeroCotizacion;
           $rootScope.monedaAbuscar=$scope.hogar.moneda;
           $rootScope.mostrarBuscadorCotizacion=true;
            $mdDialog.show({
                locals:{parent: $scope},   
                controller: 'BuscadorCotizacionCtrl',
                templateUrl: 'partials/ventanas-emergentes/buscador-cotizacion-partial.html',
                parent: angular.element(document.body),
                clickOutsideToClose:false,
                fullscreen: $scope.customFullscreen // Only for -xs, -sm breakpoints.
            }).then(function(answer) {
                 $scope.cargando=true;
                $scope.status = 'You said the information was "' + answer + '".';
                if (!angular.isUndefined(answer.numeroCotizacion) && answer.numeroCotizacion !="" && answer.numeroCotizacion!= null){
                    $scope.datosGenerales.numeroCotizacion = parseInt(answer.numeroCotizacion);
                }else{
                     Message.error("Numero de cotizacion inexistente");
                     return;
                }
               

                $scope.buscarCotizacion();


            }, function() {
                $scope.status = 'You cancelled the dialog.';
                //console.log($scope.status);
            });

        };
        $scope.guardadoParcialCabecera=function()
        {
            var dataVal={};
             
           // dataVal.cerrado=$scope.hogar.cerrado;
            dataVal.sumaAsegurada=$scope.datosGenerales.numeroPropuesta;
            dataVal.descuentoComercial=$scope.comercial.desctComercial2;
           
            dataVal.bonus=$scope.comercial.bono2;
            
            dataVal.codigoPolizaGrupo=$scope.comercial.poliza;
            dataVal.nombrePolizaGrupo=$scope.nombrePolizaGrupo;
            dataVal.porcentajePolizaGrupo=$scope.comercial.polizaPorct;
            dataVal.codigoDescEspecial=$scope.comercial.desctEspecial;
            dataVal.nombreDescEspecial=$scope.nombreDescEspecial;
            dataVal.porcentajeDescEspecial=$scope.comercial.desctEspecialPorct;
            dataVal.codigoProducto= angular.isUndefined($scope.hogar.producto)?null:$scope.hogar.producto;
            dataVal.referido= $scope.vehiculo.referido;
            dataVal.codigoMoneda=$scope.hogar.moneda;
            dataVal.codigoFraccionamiento=$scope.comercial.fraccion;
            dataVal.importeInicial=$scope.comercial.inicial;
            dataVal.marcaCuotaIgual=$scope.comercial.primeraCuota;
            dataVal.marcaFlota='N';
            dataVal.cambio=$scope.hogar.cotizacion;
            //console.log("Numero de cotizacion ",$scope.datosGenerales.numeroCotizacion);
            dataVal.numeroCotizacion=$scope.datosGenerales.numeroCotizacion;
            return CotizacionVehiculoService.guardadoParcialCabecera(dataVal).then(
                function (response){
                    return response.data;
            });       
        };

     $scope.cargarListadoFormaPago = function() {
         //console.log("Costo vehiculo ",$scope.listaFormaPago);
          
             
        if( $scope.listaFormaPago != null && $scope.listaFormaPago.length>0) {
            //console.log("Entra aca");
            $scope.sindatost=true;
        }
        else
        {
            $scope.sindatost=false;
        }
        //$scope.cargando=false;
       // console.log("sIN DATOS TABLA", $scope.sindatost);
            
     } ;
     $scope.limpiarDatos=function()
     {
         $scope.obtenerCamposEditables();
         $scope.hogar.moneda=undefined;
        // $scope.vehiculo.monto="2000";
        // $scope.vehiculo.referido='N';
          
        // $scope.hogar.cerrado=undefined;
       
       //  $scope.datosSubmodelo=[];
        // $scope.listaSubModelos=[];
         //combo comercial
         $scope.comercial.desctComercial=undefined;
         $scope.comercial.desctP="1";
         $scope.comercial.desctEspecial=undefined;
         $scope.comercial.desctComercial2=undefined;
         $scope.comercial.recComercial=undefined;
         $scope.comercial.fraccion=undefined;
         $scope.comercial.cuota="S";
         $scope.comercial.poliza=undefined;
         $scope.comercial.polizaDescripcion="";
         $scope.comercial.bono=undefined;
         $scope.comercial.bono2=null;
        // $scope.comercial.malus=null;
         $scope.comercial.inicial=undefined;
         $scope.comercial.primeraCuota=undefined;
         $scope.comercial.polizaPorct=undefined;
         $scope.cobertura.cartaVerde=true;
         $scope.cobertura.cartaAzul=false;
         $scope.hogar.producto=undefined;
         $scope.datosGenerales.numeroPropuesta="";
         $scope.cobertura.minMonto=0;
         $scope.cobertura.maxMonto=0;
         $scope.debitoAutomatico ={};
         $scope.debitoAutomatico.prima="0";
         $scope.debitoAutomatico.costoTotal ="0";
         $scope.debitoAutomatico.cuota="0";
         $scope.debitoAutomatico.ultimaCuota="0";

         $scope.contado ={};
         $scope.contado.prima="0";
         $scope.contado.costoTotal ="0";

         $scope.chequera ={};
         $scope.chequera.prima="0";
         $scope.chequera.costoTotal ="0";
         $scope.chequera.cuota="0";
         $scope.chequera.ultimaCuota="0";
         $scope.desctComercial=false;
         $scope.recComercial=false; 
         $scope.coberturaDatos=[];
         $scope.minDescRec=-100;
         $scope.maxDescRec=100;
 
     };
     $scope.actualizarGTOSMED=function(etiqueta,nuevoValor){
         if(etiqueta=="OVP MUERTE"){

            for(var i=0;i<$scope.v1.length;i++){
                if($scope.v1[i].ETIQUETA=="OVP GTOS MED"){
                    $scope.v1[i].MONTO_BASE=Math.ceil(nuevoValor*$scope.v1[i].PORCENTAJE);
                }
            } 
            for(var i=0;i<$scope.datos.length;i++){
                if($scope.datos[i].ETIQUETA=="OVP GTOS MED"){
                    $scope.datos[i].MONTO_BASE=Math.ceil(nuevoValor*$scope.datos[i].PORCENTAJE);
                }
            } 
         }
     };
     $scope.buscarCotizacion = function() {

            //console.log("Buscar");

            if ($scope.datosGenerales.numeroCotizacion!=null)
            {
              

                $scope.cargando=true;
                $scope.esBuscar=true;
              
                var datosBuscador={};
                datosBuscador.numeroCotizacion=$scope.datosGenerales.numeroCotizacion;
                datosBuscador.pathModule = $scope.pathModule;
                $scope.persistirProducto=false;
                $scope.persistir=false;
               
                $scope.esNuevo ="N";
                $scope.limpiarDatos();
              
                $timeout( function(){
                    CotizacionHogarService.getCotizacion(datosBuscador).then(

                        function (response) {

                            if(!response.data.error)
							{

                                $scope.habilitarPropuesta=true;
                                $scope.bloquearBuscador=true;
                                $scope.editablesDescPoliza=false;
                                 

                                if(!angular.isUndefined(response.data.dato) && response.data.dato != null){

                                    //if(response.data.dato.length >0){
                                       // $scope.cargarPlataforma();

                                        $scope.promesaCambioEnMoneda.promise.$$state.status = 0;
                                        $scope.promesaMonedas.promise.$$state.status = 0;
                                       
                                        $scope.promesaProducto.promise.then(
                                            function(){

                                                  if(response.data.dato.codigoProducto != null && response.data.dato.codigoProducto !=""){
                                                    $scope.hogar.producto=response.data.dato.codigoProducto;
                                                }else{
                                                    $scope.hogar.producto=undefined;
                                                   // $scope.persistirProducto=true;
                                                  }


                                                //llamar a un metodo que cargue la cobertura de esta cotizacion
                                                $scope.datosCobertura=[];
                                                if (response.data.dato.coberturasHogar.length>0 && response.data.dato.coberturasHogar!= null)
                                                {
                                                    //$scope.mostrarCartas=true;
                                                    for (var i=0; i< response.data.dato.coberturasHogar.length; i++)
                                                    {
                                                      
                                                        if  (response.data.dato.coberturasHogar[i].etiqueta=='INCENDIO EDIFICIO'){

                                                             $scope.montoIncendioEdificio = response.data.dato.coberturasHogar[i].capital == null?"" :response.data.dato.coberturasHogar[i].capital;
                                                        }
                                                        $scope.datosCobertura.push({"COD_COB": response.data.dato.coberturasHogar[i].codigoCobertura,"ETIQUETA":response.data.dato.coberturasHogar[i].etiqueta,"CAPITAL":Number(response.data.dato.coberturasHogar[i].capital),"MAXIMO":Number(response.data.dato.coberturasHogar[i].maximo), "INCREMENTO": Number(response.data.dato.coberturasHogar[i].incremento),"MCA_MODIFICABLE":response.data.dato.coberturasHogar[i].marcaModificable, "MINIMO": Number(response.data.dato.coberturasHogar[i].minimo),"MCA_REQUERIDO":response.data.dato.coberturasHogar[i].marcaRequerido } );
                                                        if(response.data.dato.coberturasHogar[i].maximo!="" ){
                                                            $scope.datosCobertura[i].MAXIMO=Number(response.data.dato.coberturasHogar[i].maximo);
                                                        }else{
                                                            $scope.datosCobertura[i].MAXIMO=-1;
                                                        }

                                                    }
                                                    $scope.setearCobertura($scope.datosCobertura);
                                                   // $scope.cargando=false;
                                                }
                                                else
                                                {

                                                  //  $scope.mostrarCartas=false;
                                                    $scope.cargando=false;
                                                }
                                            }
                                        );

                                         $scope.promesaMonedas.promise.then(
                                            function () {
                                                 $scope.hogar.moneda = response.data.dato.codigoMoneda;
                                                 
                                            });

                                          $scope.promesaCambioEnMoneda.promise.then(
                                            function () {
                                                 
                                                $scope.hogar.cotizacion =response.data.dato.valorCambio;
                                            });

                                       
                                        $scope.promesaPoliza.promise.then(
                                            function(){
                                                if (response.data.dato.codigoPolizaGrupo!=null && response.data.dato.codigoPolizaGrupo !=""){
                                                    $scope.comercial.poliza=response.data.dato.codigoPolizaGrupo;
                                                }else {
                                                    $scope.comercial.poliza=undefined; 
                                                }
                                                
                                            }
                                        );

                                        $scope.comercial.desctEspecialPorct = null;
                                        if (response.data.dato.porcentajeDescEspecial != null && response.data.dato.porcentajeDescEspecial != ""){
                                            $scope.comercial.desctEspecialPorct = parseInt(response.data.dato.porcentajeDescEspecial);
                                        } 

                                        if (response.data.dato.codigoDescEspecial != null && response.data.dato.codigoDescEspecial != ""){
                                             $scope.comercial.desctEspecial=response.data.dato.codigoDescEspecial;
                                        }else{
                                             $scope.comercial.desctEspecial=undefined;
                                        }
                                       
                                        if (response.data.dato.descuentoComercial != null)
                                        {
                                            $scope.desctComercial=true;
                                        }
                                        $scope.comercial.desctComercial2=response.data.dato.descuentoComercial!=null && response.data.dato.descuentoComercial!=""?parseInt(response.data.dato.descuentoComercial):undefined;
                                        //$scope.comercial.recComercial=response.data.dato[0].recargoComercial;
                                        $scope.promesaFraccion.promise.then(
                                            function(){
                                                if(response.data.dato.codigoFraccionamiento!= ""){
                                                    $scope.comercial.fraccion=parseInt(response.data.dato.codigoFraccionamiento);
                                                }else{
                                                    $scope.comercial.fraccion=null;
                                                }

                                            }
                                        );
                                        $scope.datosGenerales.numeroCotizacion =parseInt(response.data.dato.numeroCotizacion);
                                        $scope.datosGenerales.nuevo=response.data.dato.marcaRenovacion;
                                        $scope.comercial.primeraCuota=response.data.dato.marcaCuotaIgual==null?'N':response.data.dato.marcaCuotaIgual;
                                        $scope.comercial.inicial=response.data.dato.importeInicial;
                                        //$scope.comercial.malus =response.data.dato.malus;
                                        $scope.comercial.bono2=response.data.dato.bonus;
                                        //$scope.comercial.envioDigital=response.data.dato.marcaEnvioDigital
                                        $scope.datosGenerales.numeroPropuesta=response.data.dato.numeroPropuesta!=null && response.data.dato.numeroPropuesta!=""? response.data.dato.numeroPropuesta:"";
                                        $scope.hogar.fechaVigenciaDesde = response.data.dato.fechaEfectoPoliza!=null && response.data.dato.fechaEfectoPoliza!=""?  $scope.convertirDate(response.data.dato.fechaEfectoPoliza): undefined;
                                        $scope.hogar.fechaVigenciaHasta = response.data.dato.fechaVencimientoPoliza!=null && response.data.dato.fechaVencimientoPoliza!=""? $scope.convertirDate(response.data.dato.fechaVencimientoPoliza): undefined;
                                        $scope.comercial.poliza=response.data.dato.porcentajePolizaGrupo!=null?response.data.dato.porcentajePolizaGrupo:undefined;
                                        $scope.listaFormaPago=[];
                                        $scope.listaFormaPago =response.data.dato.costosHogar;
                                        for(var i=0; i<$scope.listaCambio.length; i++){
                                            if ($scope.listaCambio[i].id==$scope.hogar.moneda){
                                                $scope.hogar.cotizacion = $scope.listaCambio[i].cambio;
                                                break;
                                            }
                                        }
                                        $scope.hogar.cotizacion=!angular.isUndefined(response.data.dato.cambio)&& response.data.dato.cambio!=null?parseInt(response.data.dato.cambio):1;
                                        $scope.promesaCiudad.promise.then(function()
                                        {
                                            /*for (var i=0; i< $scope.ciudades.length;i++)
                                            {
                                                if ($scope.ciudades[i].codigoCiudad==response.data.dato.codigoCiudad && $scope.ciudades[i].codigoBarrio==response.data.dato.codigoBarrio)
                                                {
                                                    $scope.hogar.ciudad=response.data.dato.codigoCiudad==null?undefined:response.data.dato.codigoCiudad;
                                                }
                                            }*/

                                            $scope.hogar.ciudad=response.data.dato.codigoBarrio==null?undefined:response.data.dato.codigoBarrio;

                                        })

 
                                        $q.all( [
                                            $scope.promesaProducto.promise.then(),$scope.promesaPoliza.promise.then() , $scope.promesaFraccion.promise.then()
                                        ] ).then(function(sucess){
                                           // $scope.datosGenerales.numeroPropuesta=response.data.dato[0].sumaAsegurada;
                                            $scope.cargarListadoFormaPago();
                                        });



                                   // }

                                }else{
                                    Message.error(response.data.mensaje);
                                    $scope.cargando=false;
                                    
                                }
                            }else{
                                $scope.habilitarPropuesta=false;
                                $scope.recargar();
                                Message.error(response.data.mensaje);
                                $scope.cargando=false;
                               

                            }





                        },
                        function(response){
                            $scope.persistirProducto=true;
                            $scope.persistir=true;
                            Message.error(response.data.mensaje);
                            
                        });

                }, 2000 );


            }
            
            

             
        };

        /**
         * Constructor / Entrypoint
         * @constructor
         */
        $scope.cargarCombos= function() {
          

              $scope.cargarFraccionamiento();
              $scope.cargarDescuentoEspecial();


        };

        $scope.recargar = function()
        {

            if(!angular.isUndefined($routeParams.numeroCotizacion)){
                $location.search('numeroCotizacion', undefined);
                $rootScope.numeroCotizacionRoot = undefined;
                $location.path('cotizacion-hogar');

            }
            else
            {
                $route.reload();
            }


        };

                $scope.filteredText = $filter('number')($scope.datosGenerales.numeroPropuesta);





$scope.actualizarCotizacion=function ()
{
   // console.log("Valor de suma agregada ", $scope.datosGenerales.numeroPropuesta);
    //$scope.validarNumero();
    $scope.cargando=true;
    $scope.cobertura.franquicia=undefined;
    $scope.verificarFranquicia($scope.hogar.producto,$scope.hogar.moneda, $scope.datosGenerales.numeroPropuesta);
    if ($scope.datosGenerales.numeroPropuesta != undefined && $scope.datosGenerales.numeroPropuesta != null)
    {
        var  parametros ={};
        parametros.esNuevo=$scope.esNuevo;
       
        parametros.codigoMoneda=$scope.hogar.moneda;
        parametros.codigoRamo=501;
        parametros.numeroCotizacion=$scope.datosGenerales.numeroCotizacion;
       // $scope.recalcularCotizacion(parametros);
    }
    else
    {
        $scope.cargando=false;
    }


};

$scope.cambiarRangoDescuento=function()
{
    if (!angular.isUndefined($scope.comercial.poliza) && $scope.comercial.poliza!=null)
    {
        $scope.minDescRec=0;
        $scope.maxDescRec=100;

    }
    else
    {
        $scope.minDescRec=-100;
        $scope.maxDescRec=100;
    }
};
$scope.verificarMontoCobertura=function (cobertura)
{
    if(cobertura.MAXIMO!=-1 && cobertura.CAPITAL >0){
    var montoActual=cobertura.CAPITAL
    if (montoActual> cobertura.MAXIMO && cobertura.MAXIMO>0) 
    {
        cobertura.CAPITAL=cobertura.MAXIMO;
    }
    else if (montoActual< cobertura.MINIMO)
    {
        cobertura.CAPITAL=cobertura.MINIMO;
    }

    }
    else {
        if (angular.isUndefined(cobertura.capital))
        {
            cobertura.CAPITAL=0
        }
    }
};
$scope.incrementarCobertura=function (cobertura)
{
    //console.log("La cobertura es ", cobertura);
    var montoActual=cobertura.CAPITAL;
   // console.log("La cobertura es ", montoActual);
    if (montoActual>= cobertura.MAXIMO && cobertura.MAXIMO>0)
    {
        cobertura.CAPITAL=cobertura.MAXIMO;
    }
    else
    {
        cobertura.CAPITAL+=cobertura.INCREMENTO;
    }
    $scope.montoIncendioEdificio=cobertura.CAPITAL;
    $scope.llamarListadoCoberturas($scope.montoIncendioEdificio,$scope.hogar.moneda,$scope.hogar.producto);
};
$scope.decrementarCobertura=function (cobertura)
{
   //console.log("La cobertura es en decremento ", cobertura);
var montoActual = cobertura.CAPITAL;
if (montoActual <= cobertura.MINIMO){
    cobertura.CAPITAL = cobertura.MINIMO;
}
else{
    cobertura.CAPITAL-=cobertura.INCREMENTO;
}
    $scope.montoIncendioEdificio=cobertura.CAPITAL;
    $scope.llamarListadoCoberturas($scope.montoIncendioEdificio,$scope.hogar.moneda,$scope.hogar.producto);

};


$scope.limpiarFormasPago=function()
{
    $scope.listaFormaPago=null;
   

    $scope.sindatost=false;
};
$scope.setearCobertura=function(coberturas)
{   
     $scope.sindatos=false;
    //$scope.cartaVerde=false;
    //$scope.cartaAzul=false;
    $scope.v1=[];
    $scope.v2=[];
    $scope.datosCobertura=[];
    $scope.datos=[];
    //$scope.bloquearCartaVerde=true;
   // $scope.bloquearCartaAzul=true;
    var CV,CA;
    CA=0,CV=0;
    $scope.datosCobertura=angular.copy(coberturas);
    $scope.cartas=[];

    //$scope.datos = angular.copy($scope.datosCobertura);

    
    for(var i=0;i<$scope.datosCobertura.length;i++)
    {

         
            $scope.datos.push($scope.datosCobertura[i]);
         
    }
    $scope.datosCobertura=angular.copy($scope.datos);

    if($scope.datosCobertura.length<=6){
        var i=0;
        while($scope.datos.length>0 && $scope.v1.length<=6){
            $scope.v1.push($scope.datos[i]);
           // i++;
           $scope.datos.splice(0,1);
        };
    }else{
        var x=$scope.datosCobertura.length/2;
        var cant = UtilsService.truncar($scope.datosCobertura.length/2);

        var resto = $scope.datosCobertura.length%2;
        var cantxColum = cant + resto;
        var i=0;
        var temp =[];
        temp=angular.copy($scope.datos);
        while(temp.length>0 && $scope.v1.length< cantxColum){
            $scope.v1.push(temp[i]);
            $scope.datos.splice(0,1);
            i++;
        };
        

    }
        //console.log($scope.v1);
        //console.log($scope.datos);
         $scope.cargarListadoFormaPago();
            $scope.cargando=false;
    
    
};

 



    /**
     * Función creada para el salto de cotización a propuesta
     */
    $scope.goToPropuesta = function() {
        var path = $location.$$absUrl; 
        var n = path.search("module");
        var url =  path.substring(0 , n);
        $scope.cargando=true;
        if(typeof $scope.datosGenerales.numeroCotizacion != 'undefined' && $scope.datosGenerales.numeroCotizacion != null){

            location.href ='propuesta-hogar/propuesta/'+$scope.datosGenerales.numeroCotizacion;

        }else{            
            Message.warning("Debe ingresar un número de cotización");
        }
    }
     /*descargar carta oferta
     };*/
     $scope.verificarCamposForm=function(listaCampo, campo)
        {
            return UtilsService.verificarCamposForm(listaCampo, campo);
        };
     

     $scope.cargarPlataforma = function(){

        var paramPla={};
        paramPla.numeroCotizacion=$scope.datosGenerales.numeroCotizacion;
        paramPla.pathModule=$scope.pathModule;

      CotizacionVehiculoService.getPlataforma(paramPla).then(

                       
                        function (response) {
                          if(!response.data.error){
                             if(response.data.dato!=null  )  {
                                   
                                $scope.mostrarPlataforma=true;
                                 
                                   $scope.datosGenerales.plataforma=response.data.dato.mensaje;

                                
                            }

                          }
                     

                        }).catch(function(response){
                           
                            Message.error("Ocurrio un error intente nuevamente");
                           
                        });
          };
        $scope.obtenerAutorizaciones=function()
        {
             
            $scope.autorizacionesList = [];
            var params={};
            params.pathModule=$scope.pathModule;
            CotizacionVehiculoService.getAutorizaciones(params).then(function(response){
               if (!response.data.error)
               {
                   if (response.data.dato.length>0)
                   {
                       var campos=response.data.dato;
                       for (var i=0; i< campos.length; i++)
                       {
                           $scope.autorizacionesList.push(campos[i]);
                           if (campos[i]==='btnEliminar'){
                              $rootScope.botonEliminar=true;

                           }
                       }
                   }
                  
                   //console.log("Lista Autorizaciones: " + JSON.stringify($scope.autorizacionesList));
               }
               else
                   {
                   Message.error(response.data.mensaje);
               }
            });
        };
        $scope.obtenerCamposEditables=function()
        {

            $scope.camposEditablesList = [];
            
            
            var params={};
            params.pathModule=$scope.pathModule;
                      
            params.numeroCotizacion=angular.isUndefined($scope.datosGenerales.numeroCotizacion)|| $scope.datosGenerales.numeroCotizacion==null?"":$scope.datosGenerales.numeroCotizacion;
            CotizacionVehiculoService.getCamposEditables(params).then(function(response){
               if (!response.data.error)
               {
                   if (response.data.dato.length>0)
                   {
                       var campos=response.data.dato;
                       for (var i=0; i< campos.length; i++)
                       {
                           $scope.camposEditablesList.push(campos[i]);
                       }
                   }
                   }
               else
                   {
                   Message.error(response.data.mensaje);
               }
            });
        };
        $scope.obtenerCamposRequeridos=function()
        {

            $scope.camposRequeridosList = [];
            var params={};
            params.numeroCotizacion=angular.isUndefined($scope.datosGenerales.numeroCotizacion)?"":$scope.datosGenerales.numeroCotizacion!=null?$scope.datosGenerales.numeroCotizacion:"";
            params.pathModule=$scope.pathModule;
            CotizacionHogarService.getCamposRequeridos(params).then(function(response){
               if (!response.data.error)
               {
                   if (response.data.dato.length>0)
                   {
                       var campos=response.data.dato;
                       for (var i=0; i< campos.length; i++)
                       {
                           $scope.camposRequeridosList.push(campos[i]);
                       }
                   }
               }
               else
                   {
                   Message.error(response.data.mensaje);
               }
           }, function(error){
                $scope.cargando=false;
                Message.error("Ocurrio un error al obtener los campos requeridos");
             });
        };
        $scope.emitirDocumento=function()
        {
            $scope.emitir=true;
        };

        $scope.llamarModal = function(value) {

        if(!angular.isUndefined($scope.datosGenerales.numeroCotizacion)&& $scope.datosGenerales.numeroCotizacion!=null && $scope.datosGenerales.numeroCotizacion!=""){ 
            $rootScope.numCotiza = $scope.datosGenerales.numeroCotizacion;
            $rootScope.autEsNuevo=$scope.esNuevo;
            $rootScope.modalCotizadorVehFlota=value;
            $rootScope.flagHogar=true;
            $mdDialog.show({
                //locals:{mobile: $scope.esMobile},
                controller: 'ModalAutorizacionCtrl',
                templateUrl: 'partials/ventanas-emergentes/modal-autorizacion-partial.html',
                parent: angular.element(document.body),
                multiple: true,
                clickOutsideToClose:false,
               /* scope:$scope,
                preserveScope: true,*/
                fullscreen: $scope.customFullscreen // Only for -xs, -sm breakpoints.

            }).then(function(answer) {
                 
                
                
                $scope.buscarCotizacion();


            }, function() {
                $scope.status = 'You cancelled the dialog.';
                console.log($scope.status);
            });
           } 

        };
        $scope.verificarCamposForm=function(listaCampo, campo)
        {
            return UtilsService.verificarCamposForm(listaCampo, campo);
        };
        $scope.franquicia=$q.defer();
        $scope.verificarFranquicia=function(producto, moneda, sumaAsegurada)
        {
            $scope.cargando=true;

            $scope.listaFranquicias=[];
            $scope.mostrarFranquicia=false;
            if (!angular.isUndefined(producto) && producto!=null )
            {
                for (var i=0; i< $scope.listaProductos.length; i++)
                {
                    if ($scope.listaProductos[i].id==producto)
                    {
                        if ($scope.listaProductos[i].mcaFranquicia=="S")
                        {
                            $scope.mostrarFranquicia=true;
                            break;
                        }
                    }
                }
                if ($scope.mostrarFranquicia)
                {
                    var data=null;
                    var params={};
                    params.moneda=moneda;
                    params.sumaAsegurada=angular.isUndefined(sumaAsegurada)?null:sumaAsegurada;
                    CotizacionVehiculoService.getFranquicias(params).then(function(response) {
                        if (!response.data.error)
                        {

                            if (response.data.dato!=null && response.data.dato.length>0)
                            {
                                data=response.data.dato;
                                for (var i=0; i<data.length;i++)
                                {
                                    $scope.listaFranquicias.push(data[i]);
                                }
                                $scope.franquicia.resolve();
                                $scope.cargando=false;


                            }
                            else {
                                $scope.cargando=false;
                                $scope.franquicia.resolve();
                                Message.info("No se encontraron franquicias");
                            }
                        }
                        else {
                            $scope.cargando=false;
                            $scope.franquicia.reject();
                            Message.error(response.data.mensaje);
                        }
                    })
                }
                else
                {
                    $scope.cargando=false;
                }
            }



        };
        $scope.recuperarImporte=function(codigo)
        {
            for (var i=0; i<$scope.listaFranquicias.length;i++) {
                if ($scope.listaFranquicias[i].codigoFranquicia == codigo) {
                    return $scope.listaFranquicias[i].importeFranquicia;
                }
            }
        };
        
        $scope.promesaProducto=$q.defer();
        $scope.obtenerProductos=function(){
              CotizacionHogarService.getProductos().then(
                    function (response) {
                        if (response.data.error ==false )
                        {
                            $scope.listaProductos=[];
                            if (response.data.dato!=null && response.data.dato.length>0)
                            {
                                for(var i=0; i<response.data.dato.length; i++)
                                {
                                    var obj = {
                                        id:response.data.dato[i].codigoProducto,
                                        producto:response.data.dato[i].nombreProducto,
                                        // mcaFranquicia:response.data.dato[i].MCA_FRANQUICIA,
                                    };
                                    $scope.listaProductos.push(obj);
                                }
                                $scope.promesaProducto.resolve();



                            }
                            else {
                                $scope.promesaProducto.resolve();
                            }
                        }
                        else
                        {
                            $scope.cargando=false;
                            $scope.hogar.producto=undefined;
                            $scope.promesaProducto.resolve();
                            Message.error(response.data.mensaje);


                        }



                    },
                    function(response){
                        $scope.promesaProducto.reject();
                        $scope.cargando=false;
                        Message.error(response.data.mensaje);
                        
                        return response.data;
                    });
        };


        $scope.cambiarRangoDescuento=function()
{
    if (!angular.isUndefined($scope.comercial.poliza) && $scope.comercial.poliza!=null)
    {
        var roles=sessionStorage.getItem("roles");
        if (roles !="" && roles.indexOf("TECAUT")>0)
        {
            $scope.minDescRec=-100;
            $scope.maxDescRec=100;
        }
        else
        {
            $scope.minDescRec=0;
            $scope.maxDescRec=100;
        }


    }
    else
    {
        $scope.minDescRec=-100;
        $scope.maxDescRec=100;
    }
};
$scope.promesaCiudad=$q.defer();
  $scope.obtenerCiudades=function()
  {
        CotizacionHogarService.getCiudades().then(function(response)
        {
            if (!response.data.error)
            {
                $scope.ciudades=response.data.dato;
                $scope.promesaCiudad.resolve();
            }
            else
            {
                $scope.promesaCiudad.reject();
                Message.error(response.data.mensaje);
            }
        }).catch(function(err){
            $scope.promesaCiudad.reject();
            Message.error("Ocurrio un error, intente nuevamente!")
            console.log(err);
        })
  };
  
  (function initialize() {

            $scope.sindatos=true;
            $scope.sindatost=false;
            $scope.comercial.primeraCuota='S';
            //$scope.comercial.envioDigital='S';
            $scope.flagConfirmacion=true;
            $scope.persistir= true;
            $scope.esBuscar= false;
            $scope.persistirProducto=true;
            $scope.listaFormaPago=[];
         
            $scope.controlRequerido = false;
           
            $scope.pathModule = UtilsService.retornarPath($location.path().split("/")[1]);
            $scope.hogar.fechaVigenciaDesde=new Date();
            $scope.obtenerCamposEditables();
             
            $scope.obtenerAutorizaciones();
            $scope.obtenerProductos();
            $scope.obtenerCiudades();
           
             $scope.montoIncendioEdificio =""
        

            $scope.hogar.cotizacion=1;
            $scope.botonEliminar = undefined;


             
            $scope.path = "/" +$location.$$path.split("/")[1] + "/";
            $scope.cargarCombos();
            
            if ($window.sessionStorage["rolesAsignados"]!=undefined && $window.sessionStorage["rolesAsignados"]!=null){
                var listaRoles = $window.sessionStorage["rolesAsignados"].split(",");
                $scope.controlPermisos = listaRoles.indexOf("rol_1")>-1? true:false;
            }
            
        




            /**
             * Verifica si la ventana fue llamada desde propuesta
             */
            if(!angular.isUndefined($routeParams.numeroCotizacion )){
                
                $rootScope.numeroCotizacionRoot = $routeParams.numeroCotizacion;
                $scope.datosGenerales.numeroCotizacion=$rootScope.numeroCotizacionRoot;
                $scope.buscarCotizacion();
            }else if(!angular.isUndefined($rootScope.numCotizacionBcp) && $rootScope.numCotizacionBcp!=null){
                //viene del bcp 
                $rootScope.numeroCotizacionRoot =  $rootScope.numCotizacionBcp;
                $scope.datosGenerales.numeroCotizacion=$rootScope.numeroCotizacionRoot;
                $rootScope.numCotizacionBcp=undefined;
                $scope.buscarCotizacion();
            }
            angular.extend(this, $controller('UtilsCtrl', {
                "$scope": $scope
            }));

        })();


    }]);
;app.controller('CotizacionHogarMobileFormCtrl', ['$scope', '$q','CotizacionVehiculoService','$timeout', '$controller', '$routeParams', '$location', 'SessionService', '$rootScope','$route', '$mdDialog', '$filter', 'ConfirmService', '$window','BuscadorCotizacionService', 'UtilsService','PropuestaService','$locale','CotizacionHogarService',
    function ($scope,$q, CotizacionVehiculoService, $timeout, $controller, $routeParams, $location, sessionService, $rootScope,$route, $mdDialog,  $filter, confirmService, $window, BuscadorCotizacionService,UtilsService, PropuestaService,$locale,CotizacionHogarService) {

        $rootScope.rootPathParent = $route.current.$$route.originalPath;
        $scope.service = PropuestaService;
        $locale.NUMBER_FORMATS.GROUP_SEP = '.';
        $locale.NUMBER_FORMATS.DECIMAL_SEP = ',';
        $scope.data = {};
        $scope.data.seccion = undefined;
        $scope.customFullscreen = false;
        $scope.mostrarDocumento = {};

 
        $scope.listaCambio = [];
        var parametros = {};

        // combos vehiculos
        $scope.listaGrupoPoliza = [];

        $scope.years = [];

        $scope.listaMonedas = [];
        $scope.datosGrupoPoliza = [];
        $scope.datosDescuentoEspecial = [];
        //combo comercial
        $scope.listaProductos = [];
        $scope.listaPolizas = [];
        $scope.listaDesctComercial = [];

        $scope.listaDesctEspc = [];

        $scope.listaFraccion = [];
        
        $scope.hogar = {};
        $scope.hogar.producto=undefined;
        $scope.hogar.moneda=undefined;
        $scope.hogar.cotizacion="";
        $scope.hogar.numercoSoliitud="";
        $scope.hogar.ciudad=undefined;
        $scope.hogar.fechaVigenciaDesde=undefined;
        $scope.hogar.fechaVigenciaHasta=undefined;
        
        $scope.datosGenerales = {};
        $scope.datosGenerales.nuevo = "N";
        $scope.datosGenerales.numeroPoliza = undefined;
        $scope.datosGenerales.numeroPolizaAnterior = undefined;
        $scope.datosGenerales.numeroCotizacion = undefined;
		$scope.datosGenerales.numeroPropuesta = undefined;
        

        $scope.comercial = {};
        $scope.comercial.desctComercial = undefined;
        $scope.comercial.desctP = "1";
        $scope.comercial.desctEspecial = undefined;
        $scope.comercial.desctComercial2 = undefined;
        $scope.comercial.recComercial = undefined;
        $scope.comercial.fraccion = undefined;
        $scope.comercial.cuota = "S";
        $scope.comercial.poliza = undefined;
        $scope.comercial.polizaDescripcion = "";
        $scope.comercial.bono = undefined;
        $scope.comercial.bono2 = null;
        $scope.comercial.malus = null;
        $scope.comercial.inicial = undefined;
        $scope.comercial.primeraCuota = undefined;
        $scope.comercial.polizaPorct = undefined;

        $scope.cobertura = {};
        $scope.cobertura.rcPersonas = "200000000";
        $scope.cobertura.ovpGtosMdeOcup = "200000000";
        $scope.cobertura.robo = "200";
        $scope.cobertura.granizo = "200";
        $scope.cobertura.incendioEdificio = "200";
        $scope.cobertura.danhosVandalismo = "200";
        $scope.cobertura.rcDanhosMateriales = "200000000";
        $scope.cobertura.danhosPropiosTotal = "200";
        $scope.cobertura.roboParcialRadio = "2011";
        $scope.cobertura.accidentePersonales = "200";
        $scope.cobertura.incendioContenidoVivienda = "300";
        $scope.cobertura.airbag = "200";
        $scope.cobertura.ovpMteOcupante = "200000000";
        $scope.cobertura.danhosPropiedad = "200";
        $scope.cobertura.roboParcialRadio2 = "200";
        $scope.cobertura.gtoMedAccPersonales = "200";
        $scope.cobertura.sepelio = "200";
        $scope.cobertura.cartaVerde = true;
        $scope.cobertura.cartaAzul = false;
       
        $scope.datosGenerales.numeroPropuesta = "";
        $scope.cobertura.minMonto = 0;
        $scope.cobertura.maxMonto = 0;
        $scope.debitoAutomatico = {};
        $scope.debitoAutomatico.prima = "0";
        $scope.debitoAutomatico.costoTotal = "0";
        $scope.debitoAutomatico.cuota = "0";
        $scope.debitoAutomatico.ultimaCuota = "0";

        $scope.montoIncendioEdificio =null;

        $scope.contado = {};
        $scope.contado.prima = "0";
        $scope.contado.costoTotal = "0";

        // $scope.chequera = {};
        // $scope.chequera.prima = "0";
        // $scope.chequera.costoTotal = "0";
        // $scope.chequera.cuota = "0";
        // $scope.chequera.ultimaCuota = "0";
        $scope.desctComercial = false;
        $scope.recComercial = false;
        $scope.coberturaDatos = [];
        $scope.minDescRec = -100;
        $scope.maxDescRec = 100;
        $scope.maxDescEspecial = 0;
        $scope.restriccion = "^[0-9]+(\,[0-9]{1,2})?$";
        $scope.camposEditablesList = [];
        $scope.submitted = false;
        $scope.emitir = false;
        $scope.todo_marcas = false;
        $scope.preferencia_marcas = $window.sessionStorage.getItem("preferencia_marcas");
        $scope.preferencia_moneda = $window.sessionStorage.getItem("preferencia_moneda");
        $scope.preferencia_fraccionamiento = $window.sessionStorage.getItem("preferencia_fraccionamiento");
        
        $scope.minOcupantes = 0;
        $scope.maxOcupantes = 0;
        $scope.esBuscar = false;
        $scope.sumaAseguradaBuscar = false;
        $scope.marcaNoPreferencia = false;
        $scope.nombrePDF = undefined;
        $scope.autorizacion = false;
        $scope.bloquearBuscador=false;
        $scope.promesaSave = $q.defer();
        $scope.save = function () {
            $scope.cargando=true;
            //obtenemos los campos requeridos
            $scope.camposRequeridosList = [];
            var params = {};
            params.numeroCotizacion = angular.isUndefined($scope.datosGenerales.numeroCotizacion) ? "" : $scope.datosGenerales.numeroCotizacion != null ? $scope.datosGenerales.numeroCotizacion : "";
            params.pathModule =$scope.pathModule;
            CotizacionHogarService.getCamposRequeridos(params).then(function (response) {
                if (!response.data.error) {
                   if (response.data.dato.length > 0) {
                        var campos = response.data.dato;
                        $scope.camposRequeridosList=campos;
                        $timeout(function(){
                            if ($scope.CotizacionMobileForm.$invalid && !angular.isUndefined($scope.CotizacionMobileForm.$error.required)) {
                                $scope.cargando=false;
                                Message.warning("Existen campos que faltan ser completados!");
                                return;
                            }
                            else
                            {
                                //console.log("Valido"); //llamar al guardar
                                $scope.camposRequeridosList = [];
                               // $scope.validarSumaAsegurada();
                                
                                    var datosSave = {};
                                    datosSave.numeroPropuesta = $scope.datosGenerales.numeroPropuesta;
                                    datosSave.numeroCotizacion = $scope.datosGenerales.numeroCotizacion;
                                    datosSave.esNuevo=$scope.datosGenerales.nuevo;
                                    

                                    datosSave.descuentoComercial = $scope.comercial.desctComercial2;
                                    datosSave.bonus = $scope.comercial.bono2;
                                    datosSave.codigoPolizaGrupo = $scope.comercial.poliza;
                                    datosSave.nombrePolizaGrupo = $scope.nombrePolizaGrupo;
                                    datosSave.porcentajePolizaGrupo = $scope.comercial.polizaPorct;
                                    datosSave.codigoDescEspecial = $scope.comercial.desctEspecial;
                                    datosSave.nombreDescEspecial = $scope.nombreDescEspecial;
                                    datosSave.porcentajeDescEspecial = $scope.comercial.desctEspecialPorct;

                                    datosSave.valorCambio = $scope.hogar.cotizacion;

                                    

                                    /*if (angular.isUndefined($scope.hogar.producto)){
                                            $scope.controlRequerido = true;
                                            Message.info("Complete los valores requeridos");
                                            return;
                                        }else{
                                            $scope.controlRequerido = false;
                                        }*/
                                    datosSave.codigoProducto = angular.isUndefined($scope.hogar.producto) ? null : $scope.hogar.producto;
                                    datosSave.codigoMoneda = $scope.hogar.moneda;
                                    datosSave.codigoFraccionamiento = $scope.comercial.fraccion;
                                    datosSave.importeInicial = $scope.comercial.inicial;
                                    datosSave.marcaCuotaIgual = $scope.comercial.primeraCuota;
                                   // datosSave.marcaEnvioDigital=$scope.comercial.envioDigital;
                                    datosSave.codigoCiudad=angular.isUndefined($scope.hogar.ciudad)?null:$scope.hogar.ciudad;
                                    datosSave.fechaEfectoPoliza = angular.isUndefined($scope.hogar.fechaVigenciaDesde) ? null : $scope.hogar.fechaVigenciaDesde != null ? moment($scope.hogar.fechaVigenciaDesde).format("DD/MM/YYYY") : null;
                                    datosSave.fechaVencimientoPoliza = angular.isUndefined($scope.hogar.fechaVigenciaHasta) ? null : moment($scope.hogar.fechaVigenciaHasta).format("DD/MM/YYYY");
                                    if ($scope.ciudades.length>0)
                                    {
                                        for (var i=0; i<$scope.ciudades.length;i++)
                                        {
                                            if ($scope.ciudades[i].codigoBarrio==$scope.hogar.ciudad)
                                            {
                                                datosSave.codigoBarrio=$scope.ciudades[i].codigoCiudad;
                                                break;
                                            }
                                        }

                                    }
                                    datosSave.codigoCiudad=datosSave.codigoBarrio;
                                    datosSave.codigoBarrio=angular.isUndefined($scope.hogar.ciudad)?null:$scope.hogar.ciudad;

                                   

                                    $scope.coberturaDatos = [];
                                    //console.log("El valor de v1 ", $scope.v1);
                                    //console.log("El valor de datos ", $scope.datos);
                                    if ($scope.v1 && $scope.datos) {
                                        for (var i = 0; i < $scope.v1.length; i++) {

                                            var obj = {

                                                numeroCotizacion: datosSave.numeroCotizacion,
                                                codigoCobertura: $scope.v1[i].COD_COB,
                                                etiqueta: $scope.v1[i].ETIQUETA,
                                                capital: $scope.v1[i].CAPITAL,
                                                marcaModificable: $scope.v1[i].MCA_MODIFICABLE
                                            };

                                            $scope.coberturaDatos.push(obj);
                                        }
                                        for (var i = 0; i < $scope.datos.length; i++) {
                                            var obj = {

                                                numeroCotizacion: datosSave.numeroCotizacion,
                                                codigoCobertura: $scope.datos[i].COD_COB,
                                                etiqueta: $scope.datos[i].ETIQUETA,
                                                capital: $scope.datos[i].CAPITAL,
                                                marcaModificable: $scope.datos[i].MCA_MODIFICABLE
                                            };

                                            $scope.coberturaDatos.push(obj);
                                        }
                                       
                                        datosSave.coberturasHogar = angular.copy($scope.coberturaDatos);
                                    }
                                    else {
                                        datosSave.coberturasHogar = [];
                                    }
                                    $scope.cargando = true;
                                    console.log("guardar ",JSON.stringify(datosSave));
                                    CotizacionHogarService.guardarCotizacionHogar(datosSave).then(
                                        function (response) {
                                            if (!response.data.error) {

                                                   // $scope.listaForamaPago = [];
                                                    //$scope.listaForamaPago = response.data.dato[0].costoVehiculo ? response.data.dato[0].costoVehiculo : [];
                                                    $scope.cargarListadoFormaPago();
                                                    $scope.datosGenerales.numeroCotizacion = parseInt(response.data.dato.numeroCotizacion);
                                                    $scope.cargando = false;
                                                    Message.ok(response.data.mensaje);
                                                    $scope.clickButton = false;
                                                    $scope.promesaSave.resolve();

                                                $scope.buscarCotizacion();

                                            } else {
                                                $scope.cargando = false;
                                                Message.error(response.data.mensaje);
                                                
                                                $scope.promesaSave.reject();

                                            }


                                        }).catch(function (response) {
                                        $scope.cargando = false;
                                        Message.error(response.data.mensaje);
                                        
                                        $scope.promesaSave.reject();
                                    });
                                  //  $scope.montoValido = false;

                                                                  

                            }
                        },1000);

                    }else{
                       $scope.cargando=false;
                    }


                }
                else {
                     $scope.cargando=false;
                     Message.error(response.data.mensaje);
                }
            }, function(error){
                $scope.cargando=false;
                Message.error("Ocurrio un error al obtener los campos requeridos.");
            });





        };
        $scope.actualizarDatos = function() {

            var datosSave={};
           
           
           // datosSave.numeroSolicitud=$scope.hogar.numeroSolicitud;
            datosSave.numeroCotizacion=$scope.datosGenerales.numeroCotizacion;
             datosSave.numeroPropuesta=$scope.datosGenerales.numeroPropuesta;
           // datosSave.cerrado=$scope.hogar.cerrado;
          
            datosSave.descuentoComercial=$scope.comercial.desctComercial2;
            datosSave.bonus=$scope.comercial.bono2;
            datosSave.codigoPolizaGrupo=$scope.comercial.poliza;
            datosSave.nombrePolizaGrupo=$scope.nombrePolizaGrupo;
            datosSave.porcentajePolizaGrupo=$scope.comercial.polizaPorct;
            datosSave.codigoDescEspecial=$scope.comercial.desctEspecial;
            datosSave.nombreDescEspecial=$scope.nombreDescEspecial;
            datosSave.porcentajeDescEspecial=$scope.comercial.desctEspecialPorct;
            datosSave.codigoProducto= angular.isUndefined($scope.hogar.producto)?null:$scope.hogar.producto;
          
            datosSave.codigoMoneda=$scope.hogar.moneda;
            datosSave.codigoFraccionamiento=$scope.comercial.fraccion;
            datosSave.importeInicial=$scope.comercial.inicial;
            datosSave.marcaCuotaIgual=$scope.comercial.primeraCuota;
           
            
            datosSave.valorCambio=$scope.hogar.cotizacion;

            datosSave.codigoProducto = angular.isUndefined($scope.hogar.producto) ? null : $scope.hogar.producto;
            datosSave.codigoMoneda = $scope.hogar.moneda;
            datosSave.codigoFraccionamiento = $scope.comercial.fraccion;
            datosSave.importeInicial = angular.isUndefined($scope.comercial.inicial)?null:$scope.comercial.inicial;
            datosSave.marcaCuotaIgual = $scope.comercial.primeraCuota;
            //datosSave.marcaEnvioDigital=$scope.comercial.envioDigital;
            datosSave.codigoCiudad=angular.isUndefined($scope.hogar.ciudad)?null:$scope.hogar.ciudad;
            datosSave.fechaEfectoPoliza = angular.isUndefined($scope.hogar.fechaVigenciaDesde) ? null : $scope.hogar.fechaVigenciaDesde != null ? moment($scope.hogar.fechaVigenciaDesde).format("DD/MM/YYYY") : null;
            datosSave.fechaVencimientoPoliza = angular.isUndefined($scope.hogar.fechaVigenciaHasta) ? null : moment($scope.hogar.fechaVigenciaHasta).format("DD/MM/YYYY");
            if ($scope.ciudades.length>0)
            {
                for (var i=0; i<$scope.ciudades.length;i++)
                {
                    if ($scope.ciudades[i].codigoBarrio==$scope.hogar.ciudad)
                    {
                        datosSave.codigoBarrio=$scope.ciudades[i].codigoCiudad;
                        break;
                    }
                }

            }
            datosSave.codigoCiudad=datosSave.codigoBarrio;
            datosSave.codigoBarrio=angular.isUndefined($scope.hogar.ciudad)?null:$scope.hogar.ciudad;
            $scope.coberturaDatos=[];
            // if ($scope.cartas)
            // {
            //     for (var i=0; i< $scope.cartas.length;i++)
            //     {
            //         var obj = {

            //             numeroCotizacion: datosSave.numeroCotizacion,
            //             codigoCobertura: $scope.cartas[i].COD_COB,
            //             etiqueta: $scope.cartas[i].ETIQUETA,
            //             importeCapital: $scope.cartas[i].MONTO_BASE,
            //             marcaModificable: $scope.cartas[i].MCA_MODIFICABLE
            //         };
            //         $scope.coberturaDatos.push(obj);
            //     }
            // }


            for(var i=0; i<$scope.v1.length; i++){

                var obj = {

                    numeroCotizacion:datosSave.numeroCotizacion,
                    codigoCobertura:$scope.v1[i].COD_COB,
                    etiqueta:$scope.v1[i].ETIQUETA,
                    capital:$scope.v1[i].CAPITAL,
                    marcaModificable:$scope.v1[i].MCA_MODIFICABLE
                };

                $scope.coberturaDatos.push(obj);
            }
            for (var i=0; i< $scope.datos.length;i++)
            {
                var obj = {

                    numeroCotizacion:datosSave.numeroCotizacion,
                    codigoCobertura:$scope.datos[i].COD_COB,
                    etiqueta:$scope.datos[i].ETIQUETA,
                    capital:$scope.datos[i].CAPITAL,
                    marcaModificable:$scope.datos[i].MCA_MODIFICABLE
                };

                $scope.coberturaDatos.push(obj);
            }
          
            datosSave.coberturasVehiculo= angular.copy($scope.coberturaDatos);
            $scope.cargando=true;
            //console.log("Actualizar datos");
            CotizacionHogarService.guardarCotizacionHogar(datosSave).then(
                function (response) {
                    if(!response.data.error){
                        $scope.buscarCotizacion();
                        /*if(response.data.dato.length>0)  {
                            $scope.listaForamaPago=[];
                            $scope.listaForamaPago =response.data.dato[0].costoVehiculo?response.data.dato[0].costoVehiculo:[];
                            $scope.cargarListadoFormaPago();


                            $scope.datosGenerales.numeroCotizacion=parseInt(response.data.dato[0].numeroCotizacion);
                            //$scope.cargarDatosCobertura();


                            //$scope.cargando=false;
                            //Message.ok("El registro se ha registrado exitosamente.");
                            //$scope.sindatost=true;

                            $scope.cargando=true;
                            $scope.buscarCotizacion();

                        }
                        else
                        {
                            $scope.cargando=false;
                        }*/


                    }else{
                        $scope.cargando=false;
                        Message.error(response.data.mensaje);
                        

                    }




                }).catch(function(response){
                $scope.cargando=false;
                Message.error("Ocurrio un error intente nuevamente!");
            });



        };



        $scope.buscarPoliza = function (evt) {
            if (angular.isUndefined(evt)) {
                //Ejecutado cuando $scope.buscar es invocado sin parametros --NO CREOQ QUE HAGA FALTA ESTE CONTROL

            } else {
                //enter
                if (angular.equals(evt.keyCode, 13)) {
                }
            }

        };

        $scope.resetFilter = function () {
            $scope.comercial.inicial = undefined;
        };

        

        var valorGua;
        var valorDol;
        var valorEu;

        $scope.promesaMonedas = $q.defer();  
        $scope.cargarMonedas = function(codigoProducto, valorDefault)
        {
        //primero traemos todas las monedas
            var parametros = {};
            $scope.listaMonedas=[];
            $scope.listaCambio=[];
        
          //  parametros.preferencia="N"; //por defecto no tiene preferencia, luego consultar la variable que almacena
           // parametros.esNuevo=$scope.esNuevo;
           parametros.codigoProducto = codigoProducto ;
            CotizacionHogarService.getMonedas(parametros).then(
                function (response) {
                    if (response.data.error== false)
                    {
                        if(response.data.dato !== null)
                        {
                              
                            for(var i=0; i<response.data.dato.length; i++){
                                var camb ={
                                    id :  response.data.dato[i].codigoMoneda,
                                    cambio : response.data.dato[i].valorCambio
                                };
                                var obj = {
                                    id:response.data.dato[i].codigoMoneda,
                                    moneda:response.data.dato[i].nombreMoneda
                                };
                                $scope.listaMonedas.push(obj);
                                $scope.listaCambio.push(camb);

                                //valorGua= response.data.dato[0].VAL_CAMBIO;
                                //valorDol= response.data.dato[1].VAL_CAMBIO;
                                //valorEu= response.data.dato[2]? response.data.dato[2].VAL_CAMBIO: 0.0;


                            }
                            if ($scope.listaMonedas.length>0 && valorDefault=="S")
                            {
                                $scope.hogar.moneda=$scope.listaMonedas[0].id;
                            }
                            $scope.visibleMoneda=false;
                            $scope.cargando=false;
                            $scope.promesaMonedas.resolve();
                            
                        }

                    }
                    else
                    {
                        $scope.promesaMonedas.reject();
                        Message.error(response.data.mensaje);

                    }
                    

                   
                },
                function(response){
                    $scope.promesaMonedas.reject();
                    Message.error(response.data.mensaje);
                    
                });

        };

        $scope.promesaPoliza = $q.defer();
        $scope.cargarPolizaGrupo = function () {
            var parametros = {};
            parametros.esNuevo = $scope.datosGenerales.nuevo;
            parametros.fechaPoliza=!angular.isUndefined($scope.hogar.fechaVigenciaDesde)?$scope.hogar.fechaVigenciaDesde!=null?moment($scope.hogar.fechaVigenciaDesde).format("DD/MM/YYYY"):null:null;
            parametros.pathModule =$scope.pathModule;
            CotizacionVehiculoService.getPolizaGrupo(parametros).then(
                function (response) {
                    if (response.data.error == false) {
                        if (response.data.dato != null) {
                            for (var i = 0; i < response.data.dato.length; i++) {
                                var dato = {
                                    id: response.data.dato[i].NUM_POLIZA,
                                    porcentaje: response.data.dato[i].PORC_DESCUENTO
                                };

                                var obj = {
                                    id: response.data.dato[i].NUM_POLIZA,
                                    poliza: response.data.dato[i].NOM_POLIZA
                                };
                                $scope.listaGrupoPoliza.push(obj);
                                $scope.datosGrupoPoliza.push(dato);
                            }
                        }

                    }
                    else {
                        Message.error(response.data.mensaje);
                    }

                    $scope.promesaPoliza.resolve();

                },
                function (response) {
                    $scope.promesaPoliza.reject();
                    Message.error(response.data.mensaje);
                    
                });

        };

        $scope.cargarDescuentoEspecial = function () {
            var parametros = {};
            parametros.numeroCotizacion= $scope.datosGenerales.numeroCotizacion;
            parametros.pathModule=$scope.pathModule;
            parametros.esNuevo = $scope.datosGenerales.nuevo;
            CotizacionVehiculoService.getDescuentosEspeciales(parametros).then(
                function (response) {
                    if (response.data.error == false) {
                        if (response.data.dato != null) {
                            for (var i = 0; i < response.data.dato.length; i++) {

                                var objDatos = {
                                    id: response.data.dato[i].COD_VALOR,
                                    desct: response.data.dato[i].PCT_DESCUENTO
                                };

                                var obj = {
                                    id: response.data.dato[i].COD_VALOR,
                                    desct: response.data.dato[i].NOM_VALOR
                                };
                                $scope.listaDesctEspc.push(obj);
                                $scope.datosDescuentoEspecial.push(objDatos);
                            }
                        }

                    }
                    else {
                        Message.error(response.data.mensaje);
                    }


                },
                function (response) {
                    Message.error(response.data.mensaje);
                    
                });

        };


        $scope.promesaFraccion = $q.defer();
        $scope.cargarFraccionamiento = function () {
            var parametros = {}; //al inicio traer todas las listas de fraccionamiento
            parametros.preferencia = "N";
            parametros.esNuevo = $scope.datosGenerales.nuevo;
            CotizacionVehiculoService.getFraccionamiento(parametros).then(
                function (response) {
                    if (response.data.error == false) {
                        if (response.data.dato != null) {
                            for (var i = 0; i < response.data.dato.length; i++) {
                                var obj = {
                                    id: response.data.dato[i].COD_FRACC_PAGO,
                                    fraccion: response.data.dato[i].NOM_FRACC_PAGO
                                };
                                $scope.listaFraccion.push(obj);
                            }
                            //si tiene preferencia entonces llamar a la preferencia y seleccionar por defecto
                            if ($scope.preferencia_fraccionamiento == "S") {
                                //llamar al servicio que traiga la preferencia
                                parametros = {};
                                parametros.preferencia = $scope.preferencia_fraccionamiento;
                                parametros.esNuevo = $scope.datosGenerales.nuevo;
                                CotizacionVehiculoService.getFraccionamiento(parametros).then(
                                    function (response) {
                                        if (response.data.error == false && response.data.dato != null) {
                                            //se setea el fraccionamiento por defecto
                                            $scope.comercial.fraccion = parseInt(response.data.dato[0].COD_FORMA_PAGO);

                                        }

                                    })

                            }
                            else {
                                $scope.comercial.fraccion = 99100;
                            }
                        }

                    }
                    else {
                        Message.error(response.data.mensaje);
                        
                    }

                    $scope.promesaFraccion.resolve();
                },
                function (response) {
                    $scope.promesaFraccion.reject();
                    Message.error(response.data.mensaje);
                    
                });

        };


       
        $scope.$watch('hogar.fechaVigenciaDesde', function (NewValue, OldValue){
            if (!angular.isUndefined(NewValue) && NewValue!=null)
            {
                var dato = moment(NewValue).format("DD/MM/YYYY");
                var param={};
                param.fechaVigencia=dato;
                param.pathModule=$scope.pathModule;
                PropuestaService.obtenerFechaVigenciaHasta(param).then(function(response){
                    if (!response.data.error)
                    {
                        if (response.data.dato!=null)
                        {
                            $scope.hogar.fechaVigenciaHasta=$scope.convertirDate(response.data.dato.fechaVencimientoPoliza);
                        }
                    }
                    else
                    {
                        Message.error(response.data.mensaje);
                    }
                });
                $scope.cargarPolizaGrupo();
            }
            else
            {
                $scope.listaGrupoPoliza=[];
            }

        });
       

       $scope.$watch('hogar.producto', function(NewValue, OldValue) {

                if(!angular.isUndefined(NewValue) && NewValue !=null){
                     
                        
                        if (!$scope.esBuscar){
                            $scope.v1=[];
                            $scope.v2=[];
                            $scope.datos=[];
                            
                            $scope.limpiarFormasPago();

                        }

                    $scope.promesaMonedas.promise.$$state.status=0;
                     $scope.cargarMonedas(NewValue, $scope.esBuscar?"N":"S");

                    if($scope.persistirProducto==true){
                        $scope.flagConfirmacion=false;
                        $scope.promesaSave.promise.$$state.status=0;
                       
                        $scope.cambioProducto=true;
                        var parametros={};
                        parametros.esNuevo=$scope.esNuevo;
                        
                        parametros.codigoMoneda=$scope.hogar.moneda;
                        parametros.codigoRamo=501;
                        parametros.numeroCotizacion=$scope.datosGenerales.numeroCotizacion;
                        $scope.cargando=true;
                        //$scope.cobertura.franquicia=undefined;
                        /**verificar que el producto seleccionado tenga franquicia**/
                        //$scope.verificarFranquicia(NewValue, $scope.hogar.moneda, $scope.datosGenerales.numeroPropuesta);
                      //  $scope.recalcularCotizacion(parametros);  

                    }else{
                         $scope.persistirProducto=true;
                        /**verificar que el producto seleccionado tenga franquicia**/
                       // $scope.verificarFranquicia(NewValue, $scope.hogar.moneda, $scope.datosGenerales.numeroPropuesta);
                    }
                    

            }else{
                    $scope.datosCobertura=[];
                    $scope.listaMonedas=[];
                    $scope.hogar.cotizacion = null;
                    $scope.v1=[];
                    $scope.v2=[];
                    $scope.datos=[];
                   // $scope.mostrarCartas=false;
                   // $scope.mostrarFranquicia=false;
                  //  $scope.setearCobertura($scope.datosCobertura);
                    $scope.limpiarFormasPago();

               /* $scope.hogar.cotizacion=null;*/
            }
              

           

        },true);

        var valorSub = 0;
        var valorSubMax;
        var valorSubMin;
        var valorCot;

$scope.$watch('hogar.moneda', function(NewValue, OldValue) {

             if(!angular.isUndefined(NewValue) && NewValue != null){
                $scope.datosCobertura=[];
                var params = {};
                params.codigoProducto = $scope.hogar.producto;
                params.codigoMoneda = NewValue;
               
                
                for(var i=0; i<$scope.listaCambio.length; i++){
                        if ($scope.listaCambio[i].id==$scope.hogar.moneda){
                            $scope.hogar.cotizacion = $scope.listaCambio[i].cambio;
                            break;
                        }
                }  
                params.montoIncendioEdificio = $scope.montoIncendioEdificio ==null ?"":$scope.montoIncendioEdificio;

                CotizacionHogarService.listarCoberturas(params).then(
                function (response) {
                    if (response.data.error ==false ) {
                        if (response.data.dato != null) {
                             $scope.cargando=true;
                            for (var i = 0; i < response.data.dato.length; i++) {
                                $scope.datosCobertura.push({"COD_COB": response.data.dato[i].codigoCobertura,"ETIQUETA":response.data.dato[i].etiqueta,"CAPITAL":Number(response.data.dato[i].capital), "INCREMENTO": Number(response.data.dato[i].incremento),"MCA_MODIFICABLE":response.data.dato[i].marcaModificable, "MINIMO": Number(response.data.dato[i].minimo), "PORCENTAJE": parseFloat(response.data.dato[i].porcentajeCobertura) } );
                                if(response.data.dato[i].maximo!="" ){
                                    $scope.datosCobertura[i].MAXIMO=Number(response.data.dato[i].maximo);
                                }else{
                                    $scope.datosCobertura[i].MAXIMO=-1;
                                }
                            }
                                if ($scope.esBuscar==false){
                                     $scope.setearCobertura($scope.datosCobertura);

                                }else{
                                     $scope.esBuscar = false;
                                }
                             
                                
                            
                           
                             
                            $scope.cargando=false;
                           
                        }

                    } else{
                        // $scope.sindatos= true;
                        Message.error(response.data.mensaje);
                        
                    }

                    
                },
                function(response){
                    
                    Message.error(response.data.mensaje);
                    
                });


                

             }else{
                   
             }


        },true);



$scope.llamarListadoCoberturas = function(monto,moneda,producto) {
                 $scope.cargando=true;
                $scope.datosCobertura=[];
                var params = {};
                params.codigoProducto = producto;
                params.codigoMoneda = moneda;
                params.montoIncendioEdificio = monto;
                $scope.limpiarFormasPago();

               CotizacionHogarService.listarCoberturas(params).then(
                function (response) {
                    if (response.data.error ==false ) {
                        if (response.data.dato != null) {
                             $scope.cargando=true;
                            for (var i = 0; i < response.data.dato.length; i++) {
                                $scope.datosCobertura.push({"COD_COB": response.data.dato[i].codigoCobertura,"ETIQUETA":response.data.dato[i].etiqueta,"CAPITAL":Number(response.data.dato[i].capital), "INCREMENTO": Number(response.data.dato[i].incremento),"MCA_MODIFICABLE":response.data.dato[i].marcaModificable, "MINIMO": Number(response.data.dato[i].minimo), "PORCENTAJE": parseFloat(response.data.dato[i].porcentajeCobertura) } );
                                if(response.data.dato[i].maximo!="" ){
                                    $scope.datosCobertura[i].MAXIMO=Number(response.data.dato[i].maximo);
                                }else{
                                    $scope.datosCobertura[i].MAXIMO=-1;
                                }
                            }
                                if ($scope.esBuscar==false){
                                     $scope.setearCobertura($scope.datosCobertura);

                                }else{
                                     $scope.esBuscar = false;
                                }
                             
                                
                            
                           
                             
                            $scope.cargando=false;
                           
                        }

                    } else{
                        // $scope.sindatos= true;
                        $scope.cargando=false;
                        Message.error(response.data.mensaje);
                        
                    }

                    
                },
                function(response){
                    $scope.cargando=false;
                    
                    Message.error(response.data.mensaje);
                    
                });


         };


        $scope.cambiarMoneda = function () {
            if (!angular.isUndefined($scope.hogar.moneda)) {
                var parametros = {};
                parametros.esNuevo = $scope.datosGenerales.nuevo;
              
                parametros.codigoMoneda = $scope.hogar.moneda;
                parametros.codigoRamo = 501;
                parametros.numeroCotizacion = !angular.isUndefined($scope.datosGenerales.numeroCotizacion) && $scope.datosGenerales.numeroCotizacion != null ? $scope.datosGenerales.numeroCotizacion : "";
                //   $scope.listaProductos=[];

                /*if ($scope.vehiculo.marca != undefined && $scope.vehiculo.marca != null && $scope.vehiculo.modelo != undefined && $scope.vehiculo.modelo != null
                    && $scope.vehiculo.subModelo != undefined && $scope.vehiculo.subModelo != null && $scope.vehiculo.anho != undefined && $scope.vehiculo.anho != null && $scope.hogar.moneda != undefined && $scope.hogar.moneda != null) {

                    $scope.cargando = true;

                    CotizacionVehiculoService.getSumaAsegurada(parametros).then(
                        function (response) {
                            if (response.data.error == false) {
                                if (response.data.dato != null) {
                                    $scope.datosGenerales.numeroPropuesta=response.data.dato[0].VAL_SUB_MODELO;
                                    $scope.cobertura.minMonto = response.data.dato[0].VAL_SUB_MODELO_MIN;
                                    $scope.cobertura.maxMonto = response.data.dato[0].VAL_SUB_MODELO_MAX;

                                    if ($scope.datosGenerales.numeroPropuesta != undefined && $scope.hogar.producto != undefined) {

                                        parametros.codigoProducto = $scope.hogar.producto;
                                        parametros.SumaAsegurada = $scope.datosGenerales.numeroPropuesta;

                                        parametros.codigoMoneda = $scope.hogar.moneda;

                                        //volver a obtener la cotizacion
                                        for (var i = 0; i < $scope.listaCambio.length; i++) {
                                            if ($scope.listaCambio[i].id == $scope.hogar.moneda) {
                                                $scope.hogar.cotizacion = $scope.listaCambio[i].cambio;
                                                break;
                                            }
                                        }
                                        //llamar al guardado parcial de la cotizacion

                                        $scope.recalcularCotizacion(parametros);
                                    }
                                    else
                                    {
                                        $scope.cargando=false;
                                    }

                                }
                                else {
                                    $scope.cargando = false;
                                }


                            }
                            else {
                                $scope.cargando = false;
                                Message.error(response.data.mensaje);
                            }

                        },
                        function (response) {
                            $scope.cargando = false;
                            Message.error(response.data.mensaje);
                            
                        });


                }*/


                for (var i = 0; i < $scope.listaCambio.length; i++) {
                    if ($scope.listaCambio[i].id == $scope.hogar.moneda) {
                        $scope.hogar.cotizacion = $scope.listaCambio[i].cambio;
                        break;
                    }
                }

 

                var sumaAsegurada = valorSub * valorCot;
                var sumaAseguradaMax = valorSubMax * $scope.hogar.cotizacion;
                var sumaAseguradaMin = valorSubMin * $scope.hogar.cotizacion;
               // $scope.datosGenerales.numeroPropuesta = sumaAsegurada ? sumaAsegurada : 0;


                if ($scope.acti) {
                    $scope.acti == false;
                }
                $scope.comercial.inicial = undefined;


            }
            else {
                $scope.hogar.cotizacion = null;
                $scope.comercial.inicial = undefined;
            }
        };


        $scope.promesaProducto=$q.defer();
        $scope.obtenerProductos=function(){
              CotizacionHogarService.getProductos().then(
                    function (response) {
                        if (response.data.error ==false )
                        {
                            $scope.listaProductos=[];
                            if (response.data.dato!=null && response.data.dato.length>0)
                            {
                                for(var i=0; i<response.data.dato.length; i++)
                                {
                                    var obj = {
                                        id:response.data.dato[i].codigoProducto,
                                        producto:response.data.dato[i].nombreProducto,
                                        // mcaFranquicia:response.data.dato[i].MCA_FRANQUICIA,
                                    };
                                    $scope.listaProductos.push(obj);
                                }
                                $scope.promesaProducto.resolve();



                            }
                            else {
                                $scope.promesaProducto.resolve();
                            }
                        }
                        else
                        {
                            $scope.cargando=false;
                            $scope.hogar.producto=undefined;
                            $scope.promesaProducto.resolve();
                            Message.error(response.data.mensaje);


                        }



                    },
                    function(response){
                        $scope.promesaProducto.reject();
                        $scope.cargando=false;
                        Message.error(response.data.mensaje);
                        
                        return response.data;
                    });
        };


       

        $scope.$watch('comercial.poliza', function (NewValue, OldValue) {

            if (!angular.isUndefined(NewValue) && NewValue != null) {

                for (var i = 0; i < $scope.datosGrupoPoliza.length; i++) {
                    if ($scope.datosGrupoPoliza[i].id == NewValue) {
                        $scope.comercial.polizaPorct = $scope.datosGrupoPoliza[i].porcentaje;
                        break;
                    }
                }
                for (var i = 0; i < $scope.listaGrupoPoliza.length; i++) {
                    if ($scope.listaGrupoPoliza[i].id == NewValue) {
                        $scope.nombrePolizaGrupo = $scope.listaGrupoPoliza[i].poliza;
                        break;
                    }
                }


            } else {
                $scope.comercial.polizaPorct = "";
            }
            $scope.cambiarRangoDescuento();
        }, true);
        $scope.$watch('comercial.desctEspecial', function (NewValue, OldValue) {

            if (!angular.isUndefined(NewValue) && NewValue != null) {

                for (var i = 0; i < $scope.datosDescuentoEspecial.length; i++) {
                    if ($scope.datosDescuentoEspecial[i].id == NewValue) {
                        if ($scope.comercial.desctEspecialPorct != null){
                           $scope.maxDescEspecial=$scope.comercial.desctEspecialPorct;
                        }else{
                            $scope.maxDescEspecial=parseInt($scope.datosDescuentoEspecial[i].desct);
                            $scope.comercial.desctEspecialPorct=parseInt($scope.datosDescuentoEspecial[i].desct);
                        }
                        break;
                    }
                }
                for (var i = 0; i < $scope.listaDesctEspc.length; i++) {
                    if ($scope.listaDesctEspc[i].id == NewValue) {
                        $scope.nombreDescEspecial = $scope.listaDesctEspc[i].desct;
                        break;
                    }
                }


            } else {
                $scope.comercial.desctEspecialPorct = null;
            }
        }, true);


        $scope.$watch('comercial.fraccion', function (NewValue, OldValue) {

            if (!angular.isUndefined(NewValue)) {

                var parametros = {};


            } else {

            }
        }, true);


        $scope.$watch('datosGenerales.nuevo', function (NewValue, OldValue) {

            if (!angular.isUndefined(NewValue)) {

            } else {

            }


        }, true);


        $scope.showAdvanced = function () {

            $rootScope.codCoti = $scope.datosGenerales.numeroCotizacion;
            $rootScope.monedaAbuscar = $scope.hogar.moneda;
            $rootScope.mostrarBuscadorCotizacion = true;
            $mdDialog.show({
                locals: {parent: $scope},
                controller: 'BuscadorCotizacionCtrl',
                templateUrl: 'partials/ventanas-emergentes/buscador-cotizacion-partial.html',
                parent: angular.element(document.body),
                clickOutsideToClose: false,
                fullscreen: $scope.customFullscreen // Only for -xs, -sm breakpoints.
            }).then(function (answer) {
                $scope.cargando = true;
                $scope.status = 'You said the information was "' + answer + '".';
                if (!angular.isUndefined(answer.numeroCotizacion) && answer.numeroCotizacion != "" && answer.numeroCotizacion != null) {
                    $scope.datosGenerales.numeroCotizacion = parseInt(answer.numeroCotizacion);
                } else {
                    Message.error("Numero de cotizacion inexistente");
                    return;
                }


                $scope.buscarCotizacion();


            }, function () {
                $scope.status = 'You cancelled the dialog.';
                console.log($scope.status);
            });

        };
        $scope.guardadoParcialCabecera = function () {
            var dataVal = {};
           
            dataVal.numeroSolicitud = $scope.hogar.numeroSolicitud;
           // dataVal.cerrado = $scope.hogar.cerrado;
         
            dataVal.descuentoComercial = $scope.comercial.desctComercial2;
           
            dataVal.bonus = $scope.comercial.bono2;
            
            dataVal.codigoPolizaGrupo = $scope.comercial.poliza;
            dataVal.nombrePolizaGrupo = $scope.nombrePolizaGrupo;
            dataVal.porcentajePolizaGrupo = $scope.comercial.polizaPorct;
            dataVal.codigoDescEspecial = $scope.comercial.desctEspecial;
            dataVal.nombreDescEspecial = $scope.nombreDescEspecial;
            dataVal.porcentajeDescEspecial = $scope.comercial.desctEspecialPorct;
            dataVal.codigoProducto = angular.isUndefined($scope.hogar.producto) ? null : $scope.hogar.producto;
           // dataVal.referido = $scope.vehiculo.referido;
            dataVal.codigoMoneda = $scope.hogar.moneda;
            dataVal.codigoFraccionamiento = $scope.comercial.fraccion;
            dataVal.importeInicial = $scope.comercial.inicial;
            dataVal.marcaCuotaIgual = $scope.comercial.primeraCuota;
            dataVal.marcaFlota = 'N';
            dataVal.cambio = $scope.hogar.cotizacion;
            //console.log("Numero de cotizacion ",$scope.datosGenerales.numeroCotizacion);
            dataVal.numeroCotizacion = $scope.datosGenerales.numeroCotizacion;
            return CotizacionVehiculoService.guardadoParcialCabecera(dataVal).then(
                function (response) {
                    return response.data;
                });
        };

        $scope.cargarListadoFormaPago = function () {
            //console.log("Costo vehiculo ",$scope.listaForamaPago);
            if ($scope.listaForamaPago != null && $scope.listaForamaPago.length > 0) {
                //console.log("Entra aca");
                $scope.sindatost = true;
                 
            }
            else {
                $scope.sindatost = false;
            }
            //$scope.cargando = false;
            // console.log("sIN DATOS TABLA", $scope.sindatost);

        };
        $scope.limpiarDatos = function () {
            $scope.obtenerCamposEditables();
            $scope.hogar.moneda = undefined;
         //   $scope.vehiculo.monto = "2000";
         
          //  $scope.hogar.cerrado = undefined;
            $scope.hogar.numeroSolicitud = undefined;
            // $scope.datosSubmodelo = [];
            // $scope.listaSubModelos = [];
            //combo comercial
            $scope.comercial.desctComercial = undefined;
            $scope.comercial.desctP = "1";
            $scope.comercial.desctEspecial = undefined;
            $scope.comercial.desctComercial2 = undefined;
            $scope.comercial.recComercial = undefined;
            $scope.comercial.fraccion = undefined;
            $scope.comercial.cuota = "S";
            $scope.comercial.poliza = undefined;
            $scope.comercial.polizaDescripcion = "";
            $scope.comercial.bono = undefined;
            $scope.comercial.bono2 = null;
            //$scope.comercial.malus=null;
            $scope.comercial.inicial = undefined;
            $scope.comercial.primeraCuota = undefined;
            $scope.comercial.polizaPorct = undefined;
            $scope.cobertura.cartaVerde = true;
            $scope.cobertura.cartaAzul = false;
            $scope.hogar.producto = undefined;
            $scope.datosGenerales.numeroPropuesta = "";
            $scope.cobertura.minMonto = 0;
            $scope.cobertura.maxMonto = 0;
            $scope.debitoAutomatico = {};
            $scope.debitoAutomatico.prima = "0";
            $scope.debitoAutomatico.costoTotal = "0";
            $scope.debitoAutomatico.cuota = "0";
            $scope.debitoAutomatico.ultimaCuota = "0";

            $scope.contado = {};
            $scope.contado.prima = "0";
            $scope.contado.costoTotal = "0";

            // $scope.chequera = {};
            // $scope.chequera.prima = "0";
            // $scope.chequera.costoTotal = "0";
            // $scope.chequera.cuota = "0";
            // $scope.chequera.ultimaCuota = "0";
            $scope.desctComercial = false;
            $scope.recComercial = false;
            $scope.coberturaDatos = [];
            $scope.minDescRec = -100;
            $scope.maxDescRec = 100;

        };
        $scope.actualizarGTOSMED=function(etiqueta,nuevoValor){
            if(etiqueta=="OVP MUERTE"){

                for(var i=0;i<$scope.v1.length;i++){
                    if($scope.v1[i].ETIQUETA=="OVP GTOS MED"){
                        $scope.v1[i].MONTO_BASE=Math.ceil(nuevoValor*$scope.v1[i].PORCENTAJE);
                    }
                }
                for(var i=0;i<$scope.datos.length;i++){
                    if($scope.datos[i].ETIQUETA=="OVP GTOS MED"){
                        $scope.datos[i].MONTO_BASE=Math.ceil(nuevoValor*$scope.datos[i].PORCENTAJE);
                    }
                }
            }
        };
        $scope.buscarCotizacion = function () {

            //console.log("Buscar");

            if ($scope.datosGenerales.numeroCotizacion != null) {
                $scope.cargando = true;
                $scope.esBuscar = true;
                $scope.marcaNoPreferencia = true;
                var datosBuscador = {};
                datosBuscador.numeroCotizacion = $scope.datosGenerales.numeroCotizacion;
                datosBuscador.pathModule = $scope.pathModule;
                $scope.persistirProducto = false;
                $scope.persistir = false;
                //$scope.sumaAseguradaBuscar = true;
                $scope.limpiarDatos();
                //$scope.cargarMarcas();
                $timeout( function(){
                    $scope.cargando = true;
                    CotizacionHogarService.getCotizacion(datosBuscador).then(
                        function (response) {
                            if (!response.data.error) {
                                $scope.bloquearBuscador=true;
                                if (!angular.isUndefined(response.data.dato) && response.data.dato != null) {

                                    if (response.data.dato != null ) {
                                        $scope.cargarPlataforma();

                                         

                                        $scope.promesaProducto.promise.then(
                                            function () {

                                                 if (response.data.dato.codigoProducto != null && response.data.dato.codigoProducto != "") {
                                                    $scope.hogar.producto = response.data.dato.codigoProducto;
                                                } else {
                                                    $scope.hogar.producto = undefined;
                                                    $scope.persistirProducto = true;
                                                }
                                               


                                                //llamar a un metodo que cargue la cobertura de esta cotizacion
                                                $scope.datosCobertura = [];
                                                if (response.data.dato.coberturasHogar.length > 0 && response.data.dato.coberturasHogar.length != null) {
                                                   // $scope.mostrarCartas = true;
                                                    for (var i=0; i< response.data.dato.coberturasHogar.length; i++)
                                                    {
                                                      
                                                        if  (response.data.dato.coberturasHogar[i].etiqueta=='INCENDIO EDIFICIO'){

                                                             $scope.montoIncendioEdificio = response.data.dato.coberturasHogar[i].capital == null?"" :response.data.dato.coberturasHogar[i].capital;
                                                        }
                                                        $scope.datosCobertura.push({"COD_COB": response.data.dato.coberturasHogar[i].codigoCobertura,"ETIQUETA":response.data.dato.coberturasHogar[i].etiqueta,"CAPITAL":Number(response.data.dato.coberturasHogar[i].capital),"MAXIMO":Number(response.data.dato.coberturasHogar[i].maximo), "INCREMENTO": Number(response.data.dato.coberturasHogar[i].incremento),"MCA_MODIFICABLE":response.data.dato.coberturasHogar[i].marcaModificable, "MINIMO": Number(response.data.dato.coberturasHogar[i].minimo),"MCA_REQUERIDO":response.data.dato.coberturasHogar[i].marcaRequerido } );
                                                        if(response.data.dato.coberturasHogar[i].maximo!="" ){
                                                            $scope.datosCobertura[i].MAXIMO=Number(response.data.dato.coberturasHogar[i].maximo);
                                                        }else{
                                                            $scope.datosCobertura[i].MAXIMO=-1;
                                                        }

                                                    }
                                                    $scope.setearCobertura($scope.datosCobertura);
                                                  //  $scope.cargando=false;
                                                }
                                                else {

                                                   // $scope.mostrarCartas = false;
                                                    $scope.cargando = false;
                                                }
                                            }
                                        );

                                          $scope.promesaMonedas.promise.then(
                                            function () {
                                                 $scope.hogar.moneda = response.data.dato.codigoMoneda;
                                                   
                                            });


                                    //    $scope.vehiculo.referido = response.data.dato[0].referido;
                                        $scope.promesaPoliza.promise.then(
                                            function () {
                                                if (response.data.dato.codigoPolizaGrupo!=null && response.data.dato.codigoPolizaGrupo !=""){
                                                    $scope.comercial.poliza=response.data.dato.codigoPolizaGrupo;
                                                }else {
                                                    $scope.comercial.poliza=undefined; 
                                                }
                                            }
                                        );

                                        $scope.comercial.desctEspecialPorct = null;
                                        if (response.data.dato.porcentajeDescEspecial != null && response.data.dato.porcentajeDescEspecial != ""){
                                            $scope.comercial.desctEspecialPorct = parseInt(response.data.dato.porcentajeDescEspecial);
                                        }

                                         if (response.data.dato.codigoDescEspecial != null && response.data.dato.codigoDescEspecial != ""){
                                             $scope.comercial.desctEspecial=response.data.dato.codigoDescEspecial;
                                        }else{
                                             $scope.comercial.desctEspecial=undefined;
                                        }

                                        if (response.data.dato.descuentoComercial != null) {
                                            $scope.desctComercial = true;
                                        }
                                        $scope.comercial.desctComercial2 = response.data.dato.descuentoComercial != null && response.data.dato.descuentoComercial != "" ? parseInt(response.data.dato.descuentoComercial) : undefined;
                                        //$scope.comercial.recComercial=response.data.dato[0].recargoComercial;
                                        $scope.promesaFraccion.promise.then(
                                            function () {
                                                if (response.data.dato.codigoFraccionamiento != "") {
                                                    $scope.comercial.fraccion = parseInt(response.data.dato.codigoFraccionamiento);
                                                } else {
                                                    $scope.comercial.fraccion = null;
                                                }

                                            }
                                        );
                                        $scope.datosGenerales.numeroCotizacion = parseInt(response.data.dato.numeroCotizacion);
                                        $scope.datosGenerales.nuevo = response.data.dato.marcaRenovacion;
                                        $scope.comercial.primeraCuota = response.data.dato.marcaCuotaIgual == null ? 'N' : response.data.dato.marcaCuotaIgual;
                                        $scope.comercial.inicial = response.data.dato.importeInicial;
                                        //$scope.comercial.malus =response.data.dato[0].malus;
                                        $scope.comercial.bono2 = response.data.dato.bonus;
                                       
                                       // $scope.hogar.cerrado = response.data.dato.cerrado;
                                        $scope.datosGenerales.numeroPropuesta=response.data.dato.numeroPropuesta!=null && response.data.dato.numeroPropuesta!=""? response.data.dato.numeroPropuesta:""
                                       // $scope.comercial.envioDigital=response.data.dato.marcaEnvioDigital
                                       $scope.hogar.fechaVigenciaDesde = response.data.dato.fechaEfectoPoliza!=null && response.data.dato.fechaEfectoPoliza!=""?  $scope.convertirDate(response.data.dato.fechaEfectoPoliza): undefined;
                                       $scope.hogar.fechaVigenciaHasta = response.data.dato.fechaVencimientoPoliza!=null && response.data.dato.fechaVencimientoPoliza!=""? $scope.convertirDate(response.data.dato.fechaVencimientoPoliza): undefined;
                                       $scope.comercial.poliza=response.data.dato.porcentajePolizaGrupo!=null?response.data.dato.porcentajePolizaGrupo:undefined;

                                        $scope.listaForamaPago = [];
                                       $scope.listaForamaPago = response.data.dato.costosHogar;
                                        for (var i = 0; i < $scope.listaCambio.length; i++) {
                                            if ($scope.listaCambio[i].id == $scope.hogar.moneda) {
                                                $scope.hogar.cotizacion = $scope.listaCambio[i].cambio;
                                                break;
                                            }
                                        }
                                        $scope.hogar.cotizacion = !angular.isUndefined(response.data.dato.cambio) && response.data.dato.cambio != null ? parseInt(response.data.dato.cambio) : 1;
                                         $scope.promesaCiudad.promise.then(function()
                                        {
                                             

                                            $scope.hogar.ciudad=response.data.dato.codigoBarrio==null?undefined:response.data.dato.codigoBarrio;

                                        })

                                        
                                        $q.all( [
                                            $scope.promesaProducto.promise.then(),$scope.promesaPoliza.promise.then() , $scope.promesaFraccion.promise.then()
                                        ] ).then(function(sucess){
                                           // $scope.datosGenerales.numeroPropuesta=response.data.dato[0].sumaAsegurada;
                                            $scope.cargarListadoFormaPago();
                                        });


                                    }

                                } else {
                                    Message.error(response.data.mensaje);
                                    $scope.cargando = false;
                                    
                                }
                            } else {
                                $scope.recargar();
                                Message.error(response.data.mensaje);
                                $scope.cargando = false;
                                

                            }


                        },
                        function (response) {
                            $scope.persistirProducto = true;
                            $scope.persistir = true;
                            Message.error(response.data.mensaje);
                            
                        });
                }, 2000 );
            }


        };
        


        /**
         * Constructor / Entrypoint
         * @constructor
         */
        $scope.cargarCombos = function () {
            $scope.cargarFraccionamiento();

           // $scope.cargarMonedas();
           // $scope.cargarMarcas();


            $scope.cargarDescuentoEspecial();
            $scope.cargarPolizaGrupo()
            $scope.obtenerProductos();


        };

        $scope.recargar = function () {

            if (typeof $routeParams.numeroCotizacion != "undefined") {
                $location.search('numeroCotizacion', undefined);
                $rootScope.numeroCotizacionRoot = undefined;
                $location.path('cotizacion-vehiculo')

            }
            else {
                $route.reload();
            }


        };


        /*    $scope.$watch('datosGenerales.numeroPropuesta', function(NewValue, OldValue) {

         $scope.tags = $filter('number')($scope.tags);
              $scope.datosGenerales.numeroPropuesta = $filter('number')(NewValue);

       });*/

       // $scope.filteredText = $filter('number')($scope.datosGenerales.numeroPropuesta);


        function numberFormat(numero) {
            // Variable que contendra el resultado final
            var resultado = "";
            var nuevoNumero = numero;
            // Si tiene decimales, se los quitamos al numero
            if (numero.indexOf(".") >= 0)
                nuevoNumero = numero.substring(0, numero.indexOf("."));

            // Ponemos un punto cada 3 caracteres
            for (j, i = nuevoNumero.length - 1, j = 0; i >= 0; i-- , j++)
                resultado = nuevoNumero.charAt(i) + ((j > 0) && (j % 3 == 0) ? "." : "") + resultado;

            // Si tiene decimales, se lo añadimos al numero una vez forateado con
            // los separadores de miles
            if (numero.indexOf(".") >= 0)
                resultado += "," + numero.substring(numero.indexOf(".") + 1);

            if (numero[0] == "-") {
                // Devolvemos el valor añadiendo al inicio el signo negativo
                return "-" + resultado;
            } else {
                return resultado;
            }
        }


        /*************cargacobertura******************/

        $scope.cargarDatosCobertura = function(){
            //console.log("Cargar datos cobertura");
            if(!angular.isUndefined($scope.datosGenerales.numeroCotizacion)){
                var  parametros ={};
                parametros.numeroCotizacion= parseInt($scope.datosGenerales.numeroCotizacion);
                $scope.v1=[];
                $scope.v2=[];
                $scope.datosCobertura=[];
                $scope.datos=[];
                $scope.cargando=true;
                CotizacionVehiculoService.listarCoberturas(parametros).then(
                    function (response) {
                        //console.log(response.data.dato);
                        if (!response.data.error)
                        {
                            if (response.data.dato != null)
                            {
                                if(response.data.dato.length>0)
                                {
                                    var datosResponse=[];
                                    datosResponse=response.data.dato;
                                    //console.log(datosResponse);
                                    $scope.datosCobertura=[];
                                    for (var i=0; i< datosResponse.length; i++)
                                    {
                                        $scope.datosCobertura.push({"COD_COB": datosResponse[i].COD_COB,"ETIQUETA":datosResponse[i].ETIQUETA,"CAPITAL":datosResponse[i].CAPITAL,"MAXIMO":datosResponse[i].MAXIMO, "INCREMENTO": datosResponse[i].INCREMENTO,"MCA_MODIFICABLE":datosResponse[i].MCA_MODIFICABLE, "MONTO_BASE": datosResponse[i].minimo } );


                                    }
                                    //$scope.datosCobertura=response.data.dato;
                                    /*   $scope.hogar.producto=undefined;
                                       $scope.datosGenerales.numeroPropuesta=undefined;*/
                                    //$scope.sindatost=true;
                                    $scope.setearCobertura($scope.datosCobertura);
                                    //$scope.cargando=false;
                                }
                                else
                                {
                                    $scope.cargando=false;
                                }


                            }
                            else
                            {
                                $scope.sindatos=true;
                                $scope.cargando=false;
                            }
                        }
                        else
                        {
                            $scope.cargando=false;
                            $scope.sindatos=true;
                        }

                    },
                    function(response){
                        // promesaAnho.reject();
                        Message.error(response.data.mensaje);
                        
                    });

            }else{
                $scope.hogar.cotizacion=null;
            }
            $scope.cargando=false;

        };
        $scope.actualizarCotizacion = function () {
            // console.log("Valor de suma agregada ", $scope.datosGenerales.numeroPropuesta);
            //$scope.validarNumero();
            $scope.cargando=true;
          //  if ($scope.datosGenerales.numeroPropuesta != undefined && $scope.datosGenerales.numeroPropuesta != null) {
                var parametros = {};
                parametros.esNuevo = $scope.datosGenerales.nuevo;
               
                parametros.codigoMoneda = $scope.hogar.moneda;
                parametros.codigoRamo = 501;
                parametros.numeroCotizacion = $scope.datosGenerales.numeroCotizacion;
                //$scope.recalcularCotizacion(parametros);
           // }
           // else
           // {
                $scope.cargando=false;
           // }


        };
        $scope.validarNumero = function () {
            console.log($scope.restriccion.match($scope.datosGenerales.numeroPropuesta));
        };
        // $scope.recalcularCotizacion=function(parametros)
        // {
        //    // $scope.validarSumaAsegurada();
        //     if ($scope.montoValido)
        //     {

        //         $scope.v1=[];
        //         $scope.datosCobertura=[];
        //         $scope.datos=[];
        //         $scope.cartas=[];
        //         var guardadoParcial=$scope.guardadoParcialCabecera();
        //         guardadoParcial.then(function (result)
        //         {
        //             if (result.error==false)
        //             {
        //                 if (result.dato != null)
        //                 {
        //                     $scope.datosGenerales.numeroCotizacion=parseInt(result.dato.numeroCotizacion);
        //                     $scope.habilitarPropuesta=true;
        //                     /*parametros.numeroCotizacion=$scope.datosGenerales.numeroCotizacion;
        //                     // console.log("Hace el guardado parcial");
        //                     CotizacionVehiculoService.listarCoberturas(parametros).then(

        //                         function (response2) {
        //                             if(response2.data.dato != null && response2.data.dato.length>0)
        //                             {
        //                                 $scope.datosCobertura=[];
        //                                 $scope.mostrarCartas=true;
        //                                 // $scope.datosCobertura=response2.data.dato;

        //                                 for (var i=0; i< response2.data.dato.length; i++)
        //                                 {
        //                                     $scope.datosCobertura.push({"COD_COB": response2.data.dato[i].COD_COB,"ETIQUETA":response2.data.dato[i].ETIQUETA,"CAPITAL":response2.data.dato[i].CAPITAL,"MAXIMO":response2.data.dato[i].MAXIMO, "INCREMENTO": response2.data.dato[i].INCREMENTO,"MCA_MODIFICABLE":response2.data.dato[i].MCA_MODIFICABLE, "MONTO_BASE": response2.data.dato[i].CAPITAL } );


        //                                 }
        //                                 //$scope.datosCobertura=response.data.dato;
        //                                 /*   $scope.hogar.producto=undefined;
        //                                    $scope.datosGenerales.numeroPropuesta=undefined;*/
        //                                 //$scope.sindatost=true;
        //                                 $scope.setearCobertura($scope.datosCobertura);
        //                                 //$scope.cargando=false;
        //                                 $scope.sindatos=false;

        //                                 $scope.cobertura.codigoCobertura=response2.data.dato.COD_COB;
        //                                 $scope.cobertura.etiqueta=response2.data.dato.ETIQUETA;
        //                                 $scope.cobertura.capital=response2.data.dato.CAPITAL;


        //                                 /*$scope.cobertura.rcPersonas="200";
        //                                 $scope.cobertura.ovpGtosMdeOcup="200";
        //                                 $scope.cobertura.robo="200";
        //                                 $scope.cobertura.granizo="200";
        //                                 $scope.cobertura.incendioEdificio="200";
        //                                 $scope.cobertura.danhosVandalismo="200";
        //                                 $scope.cobertura.rcDanhosMateriales="200";
        //                                 $scope.cobertura.danhosPropiosTotal="200";
        //                                 $scope.cobertura.roboParcialRadio="2011";
        //                                 $scope.cobertura.accidentePersonales="200";
        //                                 $scope.cobertura.incendioContenidoVivienda="300";
        //                                 $scope.cobertura.airbag="200";
        //                                 $scope.cobertura.ovpMteOcupante="200000000";
        //                                 $scope.cobertura.danhosPropiedad="200";
        //                                 $scope.cobertura.roboParcialRadio2="200";
        //                                 $scope.cobertura.gtoMedAccPersonales="200";
        //                                 $scope.cobertura.sepelio="200";
        //                                 $scope.cobertura.cartaVerde=true;
        //                                 $scope.cobertura.cartaAzul=false;
        //                                 //$scope.cargando=false;
        //                                 /*$scope.cargarPlataforma();*/
        //                                 $scope.actualizarDatos();


        //                                 /*   $scope.hogar.producto=undefined;
        //                                    $scope.datosGenerales.numeroPropuesta=undefined;*/

        //                 }
        //                 else
        //                 {
        //                     $scope.cargando=false;
        //                     //Message.error(result.data.mensaje);
        //                 }



        //             }
        //             else
        //             {
        //                 $scope.cargando=false;
        //                 Message.error(result.data.mensaje);
        //             }
        //         }).catch(function(response) {
        //             $scope.cargando=false;
        //             Message.error("Ocurrio un error, intente nuevamente!")
        //         })
        //     }
        //     else
        //     {
        //         $scope.cargando=false;
        //     }
        // };
         $scope.cambiarRangoDescuento = function () {
            if (!angular.isUndefined($scope.comercial.poliza) && $scope.comercial.poliza != null) {
                var roles=sessionStorage.getItem("roles");
                if (roles !="" && roles.indexOf("TECAUT")>0)
                {
                    $scope.minDescRec=-100;
                    $scope.maxDescRec=100;
                }
                else
                {
                    $scope.minDescRec=0;
                    $scope.maxDescRec=100;
                }

            }
            else {
                $scope.minDescRec = -100;
                $scope.maxDescRec = 100;
            }
        };
        $scope.verificarMontoCobertura = function (cobertura) {
           if(cobertura.MAXIMO!=-1 && cobertura.CAPITAL >0){
                var montoActual=cobertura.CAPITAL
                if (montoActual> cobertura.MAXIMO && cobertura.MAXIMO>0) 
                {
                    cobertura.CAPITAL=cobertura.MAXIMO;
                }
                else if (montoActual< cobertura.MINIMO)
                {
                    cobertura.CAPITAL=cobertura.MINIMO;
                }

                }
                else {
                    if (angular.isUndefined(cobertura.capital))
                    {
                        cobertura.CAPITAL=0
                    }
                }
        };
       $scope.incrementarCobertura=function (cobertura){
    //console.log("La cobertura es ", cobertura);
        var montoActual=cobertura.CAPITAL;
       // console.log("La cobertura es ", montoActual);
        if (montoActual>= cobertura.MAXIMO && cobertura.MAXIMO>0)
        {
            cobertura.CAPITAL=cobertura.MAXIMO;
        }
        else
        {
            cobertura.CAPITAL+=cobertura.INCREMENTO;
        }
        $scope.montoIncendioEdificio=cobertura.CAPITAL;
        $scope.llamarListadoCoberturas($scope.montoIncendioEdificio,$scope.hogar.moneda,$scope.hogar.producto);
};
$scope.decrementarCobertura=function (cobertura)
{
   var montoActual = cobertura.CAPITAL;
    if (montoActual <= cobertura.MINIMO){
        cobertura.CAPITAL = cobertura.MINIMO;
    }
    else{
        cobertura.CAPITAL-=cobertura.INCREMENTO;
    }
        $scope.montoIncendioEdificio=cobertura.CAPITAL;
        $scope.llamarListadoCoberturas($scope.montoIncendioEdificio,$scope.hogar.moneda,$scope.hogar.producto);


};

        $scope.limpiarFormasPago = function () {
            
            $scope.listaFormaPago=null;
            // $scope.debitoAutomatico = {};
            // $scope.debitoAutomatico.prima = "0";
            // $scope.debitoAutomatico.costoTotal = "0";
            // $scope.debitoAutomatico.cuota = "0";
            // $scope.debitoAutomatico.ultimaCuota = "0";

            // $scope.contado = {};
            // $scope.contado.prima = "0";
            // $scope.contado.costoTotal = "0";

            // $scope.chequera = {};
            // $scope.chequera.prima = "0";
            // $scope.chequera.costoTotal = "0";
            // $scope.chequera.cuota = "0";
            // $scope.chequera.ultimaCuota = "0";

             $scope.sindatost=false;
        };
        $scope.setearCobertura=function(coberturas)
        {
            $scope.sindatos=false;
            
            $scope.v1=[];
            $scope.v2=[];
            $scope.datosCobertura=[];
            $scope.datos=[];
          
            var CV,CA;
            CA=0,CV=0;
            $scope.datosCobertura=angular.copy(coberturas);
           // $scope.cartas=[];

         //   $scope.datos = angular.copy($scope.datosCobertura);

            for(var i=0;i<$scope.datosCobertura.length;i++)
            {
 
                    $scope.datos.push($scope.datosCobertura[i]);
                
            }
            $scope.datosCobertura=angular.copy($scope.datos);

            if($scope.datosCobertura.length<=6){
                var i=0;
                while($scope.datos.length>0 && $scope.v1.length<=6){
                    $scope.v1.push($scope.datos[i]);
                    // i++;
                    $scope.datos.splice(0,1);
                };
            }else{
                var cant = Math.trunc($scope.datosCobertura.length/2);
                var resto = $scope.datosCobertura.length%2;
                var cantxColum = cant + resto;
                var i=0;
                var temp =[];
                temp=angular.copy($scope.datos);
                while(temp.length>0 && $scope.v1.length< cantxColum){
                    $scope.v1.push(temp[i]);
                    $scope.datos.splice(0,1);
                    i++;
                };


            }

             $scope.cargarListadoFormaPago();
            $scope.cargando=false;


        };
        


        /**
         * Función creada para el salto de cotización a propuesta
         */
        $scope.goToPropuesta = function () {
            var path = $location.$$absUrl;
            var n = path.search("module");
            var url = path.substring(0, n);

            if (typeof $scope.datosGenerales.numeroCotizacion != 'undefined' && $scope.datosGenerales.numeroCotizacion != null) {
                location.href = 'propuesta-vehiculo/propuesta/' + $scope.datosGenerales.numeroCotizacion;
            } else {
                Message.warning("Debe ingresar un número de cotización");
            }

            /*descargar carta oferta*/
        };
        /*descargar carta oferta*/
        $scope.descargarCartaOferta = function () {

            //window.open(App.URL_BASE+'impresion/cartaoferta/vehiculo?numeroCotizacion='+$scope.datosGenerales.numeroCotizacion);
            var url = App.URL_BASE + 'impresion/hogar/cartaoferta?numeroCotizacion=' + $scope.datosGenerales.numeroCotizacion;
            $scope.mostrarPDF(url, "carta_oferta");
        };
        $scope.descargarCartaVerde = function () {

            var url = App.URL_BASE + 'impresion/cartaverde?numeroCotizacion=' + $scope.datosGenerales.numeroCotizacion;
            //window.open("data:application/pdf,"+url);
            $scope.mostrarPDF(url, "carta_verde");
        };


        $scope.descargarCartaPropuesta = function () {
            //window.open(App.URL_BASE+'impresion/propuesta?numeroCotizacion='+$scope.datosGenerales.numeroCotizacion);
            var url = App.URL_BASE + 'impresion/propuesta?numeroCotizacion=' + $scope.datosGenerales.numeroCotizacion;
            $scope.mostrarPDF(url, "carta_propuesta");
        };

        $scope.descargarCartaCobertura = function () {
            //window.open(App.URL_BASE+'impresion/certificadocobertura?numeroCotizacion='+$scope.datosGenerales.numeroCotizacion);
            var url = App.URL_BASE + 'impresion/certificadocobertura?numeroCotizacion=' + $scope.datosGenerales.numeroCotizacion;
            $scope.mostrarPDF(url, "carta_cobertura");
        };

        $scope.verificarCamposForm = function (listaCampo, campo) {
            return UtilsService.verificarCamposForm(listaCampo, campo);
        };

        $scope.mostrarPDF = function (url, nombre) {
            $scope.cargando = true;
            CotizacionVehiculoService.getPdf(url).then(
                function (response) {
                    $scope.cargando = false;
                    $scope.nombrePDF = nombre + ".pdf";
                   // var data =  btoa(unescape(encodeURIComponent(response.data)));
                    var pdf = 'data:application/octet-stream;base64,' + response.data ;
                    var dlnk = document.getElementById('downloadPDF');
                    dlnk.download = $scope.nombrePDF;
                    dlnk.href = pdf;
                    dlnk.click();

                }).catch(function (response) {
                $scope.cargando = false;
                Message.error(response.data.mensaje);
            });
        };

        $scope.cargarPlataforma = function () {

            var paramPla = {};
            paramPla.numeroCotizacion = $scope.datosGenerales.numeroCotizacion;

            CotizacionVehiculoService.getPlataforma(paramPla).then(
                function (response) {
                    if (!response.data.error) {
                        if (response.data.dato != null) {

                            $scope.mostrarPlataforma = true;

                            $scope.datosGenerales.plataforma = response.data.dato.mensaje;


                        }

                    }


                }).catch(function (response) {

                Message.error(response.data.mensaje);

            });
        };
        $scope.obtenerAutorizaciones = function () {

            $scope.autorizacionesList = [];
            var param={};
            param.pathModule=UtilsService.retornarPath($location.path().split("/")[1]);
            CotizacionVehiculoService.getAutorizaciones(param).then(function (response) {
                if (!response.data.error) {
                    if (response.data.dato.length > 0) {
                        var campos = response.data.dato;
                        for (var i = 0; i < campos.length; i++) {
                            $scope.autorizacionesList.push(campos[i]);
                            if (campos[i] === 'btnEliminar') {
                                $rootScope.botonEliminar = true;

                            }
                        }
                    }

                    //console.log("Lista Autorizaciones: " + JSON.stringify($scope.autorizacionesList));
                }
                else {
                    Message.error(response.data.mensaje);
                }
            });
        };
        $scope.obtenerCamposEditables = function () {
            $scope.camposEditablesList = [];
            var params = {};
            params.marcaFlota = "N";

            params.numeroCotizacion = angular.isUndefined($scope.datosGenerales.numeroCotizacion) || $scope.datosGenerales.numeroCotizacion == null ? "" : $scope.datosGenerales.numeroCotizacion;
            params.pathModule =$scope.pathModule;
            CotizacionVehiculoService.getCamposEditables(params).then(function (response) {
                if (!response.data.error) {
                    if (response.data.dato.length > 0) {
                        var campos = response.data.dato;
                        for (var i = 0; i < campos.length; i++) {
                            $scope.camposEditablesList.push(campos[i]);
                        }
                    }
                    //console.log("Campos editables ", $scope.camposEditablesList);
                }
                else {
                    Message.error(response.data.mensaje);
                }
            });
        };

        $scope.emitirDocumento = function () {
            $scope.emitir = true;
        };

        $scope.llamarModal = function (value) {

            if (!angular.isUndefined($scope.datosGenerales.numeroCotizacion) && $scope.datosGenerales.numeroCotizacion != null && $scope.datosGenerales.numeroCotizacion != "") {
                $rootScope.numCotiza = $scope.datosGenerales.numeroCotizacion;
                $rootScope.autEsNuevo = $scope.datosGenerales.nuevo;
                $rootScope.modalCotizadorVehFlota = value;
                $rootScope.flagVehiculoFlota = true;
                $scope.autorizacion = true;
                $rootScope.mostrarMovil = true;
                $mdDialog.show({
                    //locals:{mobile: $scope.esMobile},

                    controller: 'ModalAutorizacionCtrl',
                    templateUrl: 'partials/ventanas-emergentes/modal-autorizacion-partial.html',
                    parent: angular.element(document.querySelector('#autorizacion_div')),
                    multiple: true,
                    clickOutsideToClose: false,
                    /* scope:$scope,
                     preserveScope: true,*/
                    fullscreen: $scope.customFullscreen // Only for -xs, -sm breakpoints.

                }).then(function (answer) {

                    /* $scope.cargando=true;
                     console.log("Entra aca ");
                    $scope.status = 'You said the information was "' + answer + '".';
                    if (!angular.isUndefined(answer.numeroCotizacion) && answer.numeroCotizacion !="" && answer.numeroCotizacion!= null){
                        $scope.datosGenerales.numeroCotizacion = parseInt(answer.numeroCotizacion);
                    }else{
                         Message.error("Numero de cotizacion inexistente");
                         return;

                    }*/


                    $scope.buscarCotizacion();


                }, function () {
                    $scope.status = 'You cancelled the dialog.';
                    console.log($scope.status);
                });
            }

        };
        $scope.atrasSiguiente = function () {


            $scope.data.seccion = parseInt($scope.data.seccion) + 1;


            console.log($scope.data.seccion);
        };
        $scope.siguienteAtras = function () {

            $scope.data.seccion = parseInt($scope.data.seccion) - 1;


            console.log($scope.data.seccion);
        };


        $scope.promesaCiudad=$q.defer();
        $scope.obtenerCiudades=function()
          {
                CotizacionHogarService.getCiudades().then(function(response)
                {
                    if (!response.data.error)
                    {
                        $scope.ciudades=response.data.dato;
                        $scope.promesaCiudad.resolve();
                    }
                    else
                    {
                        $scope.promesaCiudad.reject();
                        Message.error(response.data.mensaje);
                    }
                }).catch(function(err){
                    $scope.promesaCiudad.reject();
                    Message.error("Ocurrio un error, intente nuevamente!")
                    console.log(err);
                })
        };


        (function initialize() {

            $scope.sindatos=true;
            $scope.sindatost=false;
            $scope.comercial.primeraCuota='S';
            //$scope.comercial.envioDigital='S';
            $scope.flagConfirmacion=true;
            $scope.persistir= true;
            $scope.esBuscar= false;
            $scope.persistirProducto=true;
            $scope.listaForamaPago=[];
            $scope.mostrarCartas=false;
            $scope.controlRequerido = false;
            $scope.listaFormaPago=[];
            $scope.pathModule = UtilsService.retornarPath($location.path().split("/")[1]);
            $scope.menus= [
                {id: '1', name: 'Datos Generales'},
                {id: '2', name: 'Hogar'},
                {id: '3', name: 'Descuentos/Recargo en %'},
                {id: '4', name: 'Cobertura'},
                {id: '5', name: 'Formas de Pago'}
            ];
            $scope.hogar.fechaVigenciaDesde=new Date();
            $scope.obtenerCamposEditables();
            //$scope.obtenerCamposRequeridos();
            $scope.obtenerAutorizaciones();
             $scope.obtenerCiudades();
       
            //    $scope.datosGenerales.nuevo=false;
            $scope.data.seccion='1';
            $scope.hogar.cotizacion=1;
            $scope.botonEliminar = undefined;
            $scope.montoIncendioEdificio =null;



            //console.log($rootScope.usuarioActual);
            $scope.pathModule = UtilsService.retornarPath($location.path().split("/")[1]);
            $scope.cargarCombos();

            //sessionStorage.setItem("hola","hola");
            //if ($scope.controlPermisos != undefined ){


            //}

            angular.extend(this, $controller('UtilsCtrl', {
                "$scope": $scope
            }));



            /**
             * Verifica si la ventana fue llamada desde propuesta
             */
            if(typeof $routeParams.numeroCotizacion != "undefined"){

                $rootScope.numeroCotizacionRoot = $routeParams.numeroCotizacion;
                $scope.datosGenerales.numeroCotizacion=$rootScope.numeroCotizacionRoot;
                $scope.buscarCotizacion();
            }

        })();


    }]);
;
app.controller('CotizacionMultiRiesgosFormCtrl', ['$scope', '$q','CotizacionVehiculoService', '$controller', '$routeParams', '$location', 'SessionService', '$rootScope','$route', '$mdDialog', '$filter', 'ConfirmService', '$window','PropuestaHogarService','UtilsService','$locale','PropuestaService','UtilsService','$timeout','$log','DialogService','CotizacionHogarService','CotizacionMultiRiesgoService',
    function ($scope,$q, CotizacionVehiculoService, $controller, $routeParams, $location, sessionService, $rootScope,$route, $mdDialog,  $filter, confirmService, $window,PropuestaHogarService, UtilsService, $locale, PropuestaService, UtilsService, $timeout, $log, DialogService,CotizacionHogarService,CotizacionMultiRiesgoService) {

        /**
         * Url del recurso
         * @field
         * @type {Object}
         */
        $rootScope.rootPathParent =$route.current.$$route.originalPath;
        $scope.service=PropuestaService;
        $locale.NUMBER_FORMATS.GROUP_SEP = '.';
        $locale.NUMBER_FORMATS.DECIMAL_SEP=',';
        $scope.controlPermisos = true;

        $scope.nombre = "Cotizacion Multiriesgos";
        $scope.status = '  ';
        $scope.customFullscreen = false;
        $scope.mostrarDocumento = {};


        $scope.listaMarcas =[];
        $scope.datosSubmodelo=[];
        $scope.listaCambio=[];
        var parametros = {};


        // combos vehiculos
        $scope.listaGrupoPoliza = [];

        
        $scope.listaMonedas = [];
        $scope.datosGrupoPoliza=[];
        $scope.datosDescuentoEspecial=[];
        //combo comercial
        $scope.listaProductos = [];
        $scope.listaPolizas = [];
        $scope.listaDesctComercial = [];

        $scope.listaDesctEspc = [];

        $scope.listaFraccion = [];

        /*datos generales*/
        $scope.datosGenerales = {};
        $scope.datosGenerales.nuevo ="N";
        $scope.datosGenerales.numeroPoliza=undefined;
        $scope.datosGenerales.numeroPolizaAnterior =undefined;
        $scope.datosGenerales.numeroCotizacion=null;
        $scope.fechaVigenciaDesde = undefined;

        /*vehiculos*/
        $scope.multiriesgo = {};
       // $scope.multiriesgo.producto=undefined;
     
        
        $scope.multiriesgo.moneda=undefined;
        $scope.multiriesgo.cotizacion=undefined;
      
        $scope.multiriesgo.numeroSolicitud="";
        $scope.multiriesgo.ocupacion = undefined;
        /*comercial*/
        $scope.comercial = {};

        $scope.comercial.desctComercial=undefined;
        $scope.comercial.desctP="1";
        $scope.comercial.desctEspecial=undefined;
        $scope.comercial.desctComercial2=null;
        $scope.comercial.recComercial=undefined;
        $scope.comercial.fraccion=undefined;
        $scope.comercial.cuota="S";
        $scope.comercial.poliza=undefined;
        $scope.comercial.polizaDescripcion="";
        $scope.comercial.bono=undefined;
        $scope.comercial.bono2=null;
       
        $scope.comercial.inicial=undefined;
        $scope.comercial.primeraCuota=undefined;
        $scope.comercial.polizaPorct=undefined;


        /*cobertura*/
        $scope.cobertura = {};
        $scope.cobertura.rcPersonas="200";
        $scope.cobertura.ovpGtosMdeOcup="200";
        $scope.cobertura.robo="200";
        $scope.cobertura.granizo="200";
        $scope.cobertura.incendioEdificio="200";
        $scope.cobertura.danhosVandalismo="200";
        $scope.cobertura.rcDanhosMateriales="200";
        $scope.cobertura.danhosPropiosTotal="200";
        $scope.cobertura.roboParcialRadio="2011";
        $scope.cobertura.accidentePersonales="200";
        $scope.cobertura.incendioContenidoVivienda="300";
        $scope.cobertura.airbag="200";
        $scope.cobertura.ovpMteOcupante="200000000";
        $scope.cobertura.danhosPropiedad="200";
        $scope.cobertura.roboParcialRadio2="200";
        $scope.cobertura.gtoMedAccPersonales="200";
        $scope.cobertura.sepelio="200";
        $scope.cobertura.cartaVerde=true;
        $scope.cobertura.cartaAzul=false;
        
         
        $scope.cobertura.minMonto=0;
        $scope.cobertura.maxMonto=0;
        $scope.cobertura.franquicia=undefined;

        $scope.debitoAutomatico ={};
        $scope.debitoAutomatico.prima="0";
        $scope.debitoAutomatico.costoTotal ="0";
        $scope.debitoAutomatico.cuota="0";
        $scope.debitoAutomatico.ultimaCuota="0";

        $scope.contado ={};
        $scope.contado.prima="0";
        $scope.contado.costoTotal ="0";

        $scope.chequera ={};
        $scope.chequera.prima="0";
        $scope.chequera.costoTotal ="0";
        $scope.chequera.cuota="0";
        $scope.chequera.ultimaCuota="0";
        $scope.desctComercial=false;
        $scope.recComercial=false;
        $scope.coberturaDatos=[];
        $scope.minDescRec=-100;
        $scope.maxDescRec=100;
        $scope.maxDescEspecial=0;
        $scope.restriccion="^[0-9]+(\,[0-9]{1,2})?$";
        $scope.camposEditablesList=[];
        $scope.submitted=false;
        $scope.emitir=false;
        $scope.todo_marcas=false;
        $scope.preferencia_marcas=$window.sessionStorage.getItem("preferencia_marcas");
        $scope.preferencia_moneda=$window.sessionStorage.getItem("preferencia_moneda");
        $scope.preferencia_fraccionamiento=$window.sessionStorage.getItem("preferencia_fraccionamiento");
        $scope.bloquearCartaVerde=true;
        $scope.bloquearCartaAzul=true;
        $scope.minOcupantes=0;
        $scope.maxOcupantes=0;
        $scope.esBuscar=false;
        $scope.sumaAseguradaBuscar=false;
        $scope.marcaNoPreferencia=false;
        $scope.habilitarPropuesta=false;
        $scope.bloquearBuscador=false;
        $scope.esNuevo="S";
        $scope.promesaSave= $q.defer();
        $scope.editablesDescPoliza=true;
        $scope.monedaPolizaG=true;
        $scope.fraccionPolizaG=true
        $scope.visibleMoneda=true;


         $scope.seguridad ={};
         $scope.seguridad.extintores='N';
         $scope.seguridad.rociadores='N';
         $scope.seguridad.bocaIncendio='N';
         $scope.seguridad.sensorHumo='N';
         $scope.seguridad.redHidrantes='N';
         $scope.seguridad.guardias='N';
         $scope.seguridad.empresaRespaldo='N';
         $scope.seguridad.alarmaSonora='N';
         $scope.seguridad.circuitoCerrado='N';
         $scope.seguridad.sensorMovimiento='N';
         $scope.seguridad.funcionanDispositivos='N';
         $scope.seguridad.otros='N';

         $scope.ciudades=[];
         $scope.listaOcupacion=[];


            $scope.save = function () {
            $scope.cargando=true;
            //obtenemos los campos requeridos
            $scope.camposRequeridosList = [];
            var params = {};
            params.numeroCotizacion = angular.isUndefined($scope.datosGenerales.numeroCotizacion) ? "" : $scope.datosGenerales.numeroCotizacion != null ? $scope.datosGenerales.numeroCotizacion : "";
            params.pathModule =$scope.pathModule;
            CotizacionHogarService.getCamposRequeridos(params).then(function (response) {
                if (!response.data.error) {
                    if (response.data.dato.length > 0) {
                        var campos = response.data.dato;
                        $scope.camposRequeridosList=campos;
                        $timeout(function(){
                            if ($scope.CotizacionMultiriesgoForm.$invalid && !angular.isUndefined($scope.CotizacionMultiriesgoForm.$error.required)) {
                                $scope.cargando=false;
                                Message.warning("Existen campos que faltan ser completados!");
                                return;
                            }
                            else
                            {
                              //  $log.debug("Valido, llamar a guardar"); //llamar al guardar
                                  $scope.camposRequeridosList = [];
                               
                                    var datosSave = {};
                                   
                                    datosSave.numeroCotizacion = $scope.datosGenerales.numeroCotizacion;
                                    datosSave.codigoMoneda = $scope.multiriesgo.moneda;
                                    datosSave.valorCambio = $scope.multiriesgo.cotizacion;
                                    datosSave.codigoCiudad = angular.isUndefined($scope.multiriesgo.codigoCiudad)?"":$scope.multiriesgo.codigoCiudad;
                                    datosSave.codigoBarrio=angular.isUndefined($scope.multiriesgo.barrio)?"":$scope.multiriesgo.barrio;
                                    datosSave.codigoOcupacion=angular.isUndefined($scope.multiriesgo.ocupacion)?"":$scope.multiriesgo.ocupacion;
                                    datosSave.codigoFraccionamiento = $scope.comercial.fraccion;
                                    datosSave.importeInicial = $scope.comercial.inicial;
                                    datosSave.marcaCuotaIgual = $scope.comercial.primeraCuota;
                                    datosSave.codigoPolizaGrupo = $scope.comercial.poliza;
                                    datosSave.porcentajePolizaGrupo = $scope.comercial.polizaPorct;
                                    datosSave.codigoDescEspecial = $scope.comercial.desctEspecial;
                                    datosSave.porcentajeDescEspecial = $scope.comercial.desctEspecialPorct;
                                    datosSave.descuentoComercial = $scope.comercial.desctComercial2;
                                   // codigoAgente??
                                    datosSave.codigoUsuario=sessionStorage.getItem("usuarioLogueado");
                                    datosSave.marcaModulo=$scope.pathModule.split("marcaModulo=")[1];

                                    datosSave.numeroPropuesta = $scope.datosGenerales.numeroPropuesta;
                                   
                                    datosSave.esNuevo=$scope.datosGenerales.nuevo;

                                    
                                    datosSave.bonus = $scope.comercial.bono2;
                                    
                                    datosSave.nombrePolizaGrupo = $scope.nombrePolizaGrupo;
                                    
                                    
                                    datosSave.nombreDescEspecial = $scope.nombreDescEspecial;
                                    

                                    datosSave.fechaEfectoPoliza = angular.isUndefined($scope.fechaVigenciaDesde) ? null : $scope.fechaVigenciaDesde != null ? moment($scope.fechaVigenciaDesde).format("DD/MM/YYYY") : null;
                                    datosSave.fechaVencimientoPoliza = angular.isUndefined($scope.fechaVigenciaHasta) ? null : moment($scope.fechaVigenciaHasta).format("DD/MM/YYYY");

                                   datosSave.seguridad= [ {
                                    "campo": "extintores",
                                    "check": $scope.seguridad.extintores
                                   },
                                    {
                                        "campo": "rociadores",
                                        "check": $scope.seguridad.rociadores
                                    },
                                    {
                                        "campo": "bocaIncendio",
                                        "check": $scope.seguridad.bocaIncendio
                                    },
                                    {
                                        "campo": "sensorHumo",
                                        "check": $scope.seguridad.sensorHumo
                                    },
                                    {
                                        "campo": "redHidrantes",
                                        "check": $scope.seguridad.redHidrantes
                                    },
                                    {
                                        "campo": "guardias",
                                        "check": $scope.seguridad.guardias
                                    },
                                    {
                                        "campo": "empresaRespaldo",
                                        "check": $scope.seguridad.empresaRespaldo
                                    },
                                    {
                                        "campo": "alarmaSonora",
                                        "check": $scope.seguridad.alarmaSonora
                                    },
                                    {
                                        "campo": "circuitoCerrado",
                                        "check": $scope.seguridad.circuitoCerrado
                                    },
                                    {
                                        "campo": "sensorMovimiento",
                                        "check": $scope.seguridad.sensorHumo
                                    },
                                    {
                                        "campo": "funcionanDispositivos",
                                        "check": $scope.seguridad.funcionanDispositivos
                                    },
                                    {
                                        "campo": "otros",
                                        "check": $scope.seguridad.otros
                                    }  ]
                                  

                                    $scope.coberturaDatos = [];
                                   
                                    if ($scope.v1 && $scope.datos) {
                                        for (var i = 0; i < $scope.v1.length; i++) {

                                            var obj = {

                                                numeroCotizacion: datosSave.numeroCotizacion,
                                                codigoCobertura: $scope.v1[i].COD_COB,
                                                etiqueta: $scope.v1[i].ETIQUETA,
                                                capital: $scope.v1[i].CAPITAL,
                                                marcaModificable: $scope.v1[i].MCA_MODIFICABLE
                                            };

                                            $scope.coberturaDatos.push(obj);
                                        }
                                        for (var i = 0; i < $scope.datos.length; i++) {
                                            var obj = {

                                                numeroCotizacion: datosSave.numeroCotizacion,
                                                codigoCobertura: $scope.datos[i].COD_COB,
                                                etiqueta: $scope.datos[i].ETIQUETA,
                                                capital: $scope.datos[i].CAPITAL,
                                                marcaModificable: $scope.datos[i].MCA_MODIFICABLE
                                            };

                                            $scope.coberturaDatos.push(obj);
                                        }
                                        datosSave.coberturasMultirriesgo = angular.copy($scope.coberturaDatos);
                                    }
                                    else {
                                        datosSave.coberturasMultirriesgo = [];
                                    }
                                    $scope.cargando = true;
                                    var objeto = JSON.stringify(datosSave);
                                    CotizacionMultiRiesgoService.guardarCotizacionMultiriesgo(datosSave).then(
                                        function (response) {
                                            if (!response.data.error) {

                                                    $scope.listaFormaPago = [];
                                                   
                                                    $scope.datosGenerales.numeroCotizacion = parseInt(response.data.dato.numeroCotizacion);
                                                   $scope.cargando = false;
                                                   Message.ok(response.data.mensaje);
                                                    $scope.clickButton = false;
                                                    $scope.promesaSave.resolve();
                                                $scope.buscarCotizacion();

                                            } else {
                                                $scope.cargando = false;
                                                Message.error(response.data.mensaje);
                                                //
                                                $scope.promesaSave.reject();

                                            }

                                        }).catch(function (response) {
                                        $scope.cargando = false;
                                        Message.error("Ocurrio un error intente nuevamente!");
                                        $scope.promesaSave.reject();
                                    });
                                  
                                    $scope.cargando = false;
                              

                            }
                        }, 1000);

                    }
                    else
                    {
                        $scope.cargando=false;
                    }


                }
                else {
                    $scope.cargando=false;
                    Message.error(response.data.mensaje);
                }
            }, function(error){
                $scope.cargando=false;
                Message.error("Ocurrio un error al obtene los campos requeridos.");
            });





        };
        $scope.actualizarDatos = function() {
            
            var datosSave={};
            datosSave.numeroCotizacion=$scope.datosGenerales.numeroCotizacion;
            datosSave.numeroPropuesta=$scope.datosGenerales.numeroPropuesta;
            datosSave.cerrado=$scope.multiriesgo.cerrado;
             
            datosSave.descuentoComercial=$scope.comercial.desctComercial2;
            datosSave.bonus=$scope.comercial.bono2;
            datosSave.codigoPolizaGrupo=$scope.comercial.poliza;
            datosSave.nombrePolizaGrupo=$scope.nombrePolizaGrupo;
            datosSave.porcentajePolizaGrupo=$scope.comercial.polizaPorct;
            datosSave.codigoDescEspecial=$scope.comercial.desctEspecial;
            datosSave.nombreDescEspecial=$scope.nombreDescEspecial;
            datosSave.porcentajeDescEspecial=$scope.comercial.desctEspecialPorct;
           // datosSave.codigoProducto= angular.isUndefined($scope.multiriesgo.producto)?null:$scope.multiriesgo.producto;
           
            datosSave.codigoMoneda=$scope.multiriesgo.moneda;
            datosSave.codigoFraccionamiento=$scope.comercial.fraccion;
            datosSave.importeInicial=$scope.comercial.inicial;
            datosSave.marcaCuotaIgual=$scope.comercial.primeraCuota;
         
            datosSave.valorCambio=$scope.multiriesgo.cotizacion;
           
            $scope.coberturaDatos=[];

          
            for(var i=0; i<$scope.v1.length; i++){
                       
                var obj = {      
                    
                    numeroCotizacion:datosSave.numeroCotizacion,
                    codigoCobertura:$scope.v1[i].COD_COB,
                    etiqueta:$scope.v1[i].ETIQUETA,
                    capital:$scope.v1[i].CAPITAL,
                    marcaModificable:$scope.v1[i].MCA_MODIFICABLE
                };

                 $scope.coberturaDatos.push(obj);
            }
            for (var i=0; i< $scope.datos.length;i++)
            {
                var obj = {      
                    
                    numeroCotizacion:datosSave.numeroCotizacion,
                    codigoCobertura:$scope.datos[i].COD_COB,
                    etiqueta:$scope.datos[i].ETIQUETA,
                    capital:$scope.datos[i].CAPITAL,
                    marcaModificable:$scope.datos[i].MCA_MODIFICABLE
                };

                 $scope.coberturaDatos.push(obj);
            }

            datosSave.coberturasMultirriesgo= angular.copy($scope.coberturaDatos);
            $scope.cargando=true;
                    CotizacionMultiRiesgoService.guardarCotizacionMultiriesgo(datosSave).then(
                        function (response) {
                          if(!response.data.error){
                              $scope.buscarCotizacion();
                             


                          }else{
                            $scope.cargando=false;
                            Message.error(response.data.mensaje);
                            //

                          }


                           

                        }).catch(function(response){
                            $scope.cargando=false;
                            Message.error("Ocurrio un error intente nuevamente!");
                        });

            

        };
        





        $scope.buscarPoliza = function(evt) {
            if (angular.isUndefined(evt)) {
                //Ejecutado cuando $scope.buscar es invocado sin parametros --NO CREOQ QUE HAGA FALTA ESTE CONTROL

            } else {
                //enter
                if (angular.equals(evt.keyCode, 13)) {
                }
            }

        };

        $scope.resetFilter=function()
        {
            $scope.comercial.inicial = undefined;
        };

       

        var valorGua;
        var valorDol;
        var valorEu;
        $scope.promesaMonedas = $q.defer();  
        $scope.cargarMonedas = function()
        {
        //primero traemos todas las monedas
            var parametros = {};
            $scope.listaMonedas=[];
            $scope.listaCambio=[];
        
            parametros.preferencia="N"; //por defecto no tiene preferencia, luego consultar la variable que almacena
            parametros.esNuevo=$scope.esNuevo;
          // parametros.codigoProducto = codigoProducto ;
            CotizacionVehiculoService.getMonedas(parametros).then(
                function (response) {
                    if (response.data.error== false)
                    {
                        if(response.data.dato !== null)
                        {
                              
                            for(var i=0; i<response.data.dato.length; i++){
                                var camb ={
                                    id :  response.data.dato[i].COD_MON,
                                    cambio : response.data.dato[i].VAL_CAMBIO
                                };
                                var obj = {
                                    id:response.data.dato[i].COD_MON,
                                    moneda:response.data.dato[i].NOM_MON
                                };
                                $scope.listaMonedas.push(obj);
                                $scope.listaCambio.push(camb);

                            }

                            $scope.multiriesgo.moneda = 1;
 
                            $scope.visibleMoneda=false;
                            $scope.cargando=false;
                            $scope.promesaMonedas.resolve();
                            $scope.llamarListadoCoberturas($scope.multiriesgo.moneda);
                            
                        }

                    }
                    else
                    {
                        $scope.promesaMonedas.reject();
                        Message.error(response.data.mensaje);

                    }
                    

                   
                },
                function(response){
                    $scope.promesaMonedas.reject();
                    Message.error(response.data.mensaje);
                    
                });

        };

        $scope.promesaPoliza= $q.defer();
        $scope.cargarPolizaGrupo = function() {
            var parametros = {};
            parametros.esNuevo=$scope.esNuevo;
            parametros.pathModule =$scope.pathModule;
            CotizacionVehiculoService.getPolizaGrupo(parametros).then(
                function (response) {
                    if (response.data.error==false )
                    {
                        if (response.data.dato != null)
                        {
                            for(var i=0; i<response.data.dato.length; i++){
                                var dato = {
                                    id:response.data.dato[i].NUM_POLIZA,
                                    porcentaje:response.data.dato[i].PORC_DESCUENTO
                                };

                                var obj = {
                                    id:response.data.dato[i].NUM_POLIZA,
                                    poliza:response.data.dato[i].NOM_POLIZA
                                };
                                $scope.listaGrupoPoliza.push(obj);
                                $scope.datosGrupoPoliza.push(dato);
                            }
                        }

                    }
                    else
                    {
                        Message.error(response.data.mensaje);
                    }
                    
                    $scope.promesaPoliza.resolve();
                    
                },
                 function(response){
                    $scope.promesaPoliza.reject();
                    Message.error(response.data.mensaje);
                    
                });

        };

        $scope.cargarDescuentoEspecial = function() {
            var parametros = {};
            parametros.esNuevo=$scope.esNuevo;
            parametros.pathModule = $scope.pathModule;
            CotizacionVehiculoService.getDescuentosEspeciales(parametros).then(
                function (response) {
                    if (response.data.error== false)
                    {
                        if (response.data.dato != null)
                        {
                            for(var i=0; i<response.data.dato.length; i++){

                                var objDatos = {
                                    id:response.data.dato[i].COD_VALOR,
                                    desct:response.data.dato[i].PCT_DESCUENTO
                                };

                                var obj = {
                                    id:response.data.dato[i].COD_VALOR,
                                    desct:response.data.dato[i].NOM_VALOR
                                };
                                $scope.listaDesctEspc.push(obj);
                                $scope.datosDescuentoEspecial.push(objDatos);
                            }
                        }

                    }
                    else
                    {
                        Message.error(response.data.mensaje);
                    }
                    
                     
                },
                function(response){
                    Message.error(response.data.mensaje);
                    
                });

        };


        $scope.promesaFraccion =$q.defer();
        $scope.cargarFraccionamiento = function() {
            var parametros = {}; //al inicio traer todas las listas de fraccionamiento
            parametros.preferencia="N";
            parametros.esNuevo=$scope.esNuevo;
            parametros.codigoGrupoPoliza = $scope.comercial.poliza;
            CotizacionVehiculoService.getFraccionamiento(parametros).then(
                function (response) {
                    if (response.data.error ==false ) {
                        if (response.data.dato != null)
                        {
                            for (var i = 0; i < response.data.dato.length; i++) {
                                var obj = {
                                    id: response.data.dato[i].COD_FRACC_PAGO,
                                    fraccion: response.data.dato[i].NOM_FRACC_PAGO
                                };
                                $scope.listaFraccion.push(obj);
                            }
                            //si tiene preferencia entonces llamar a la preferencia y seleccionar por defecto
                            if ($scope.preferencia_fraccionamiento == "S") {
                                //llamar al servicio que traiga la preferencia
                                parametros = {};
                                parametros.preferencia = $scope.preferencia_fraccionamiento;
                                parametros.esNuevo = $scope.esNuevo;
                                CotizacionVehiculoService.getFraccionamiento(parametros).then(
                                    function (response) {
                                        if (response.data.error == false && response.data.dato != null) {
                                            //se setea el fraccionamiento por defecto
                                            $scope.comercial.fraccion=parseInt(response.data.dato[0].COD_FORMA_PAGO);

                                        }

                                    })

                            }
                            else
                            {
                                $scope.comercial.fraccion =99100;
                            }
                        }

                    }
                    else
                    {
                        Message.error(response.data.mensaje);
                        //
                    }

                    $scope.promesaFraccion.resolve();
                },
                function(response){
                    $scope.promesaFraccion.reject();
                    Message.error(response.data.mensaje);
                    
                });

        };

 

            var valorSub=0;
            var valorSubMax;
            var valorSubMin;
            var valorCot;


        $scope.cambiarMoneda=function()
        {
            if(!angular.isUndefined($scope.multiriesgo.moneda))
            {
                var  parametros ={};
                parametros.esNuevo=$scope.esNuevo;
                 
                parametros.codigoMoneda=$scope.multiriesgo.moneda;
                parametros.codigoRamo=501;
                parametros.numeroCotizacion=!angular.isUndefined($scope.datosGenerales.numeroCotizacion)&& $scope.datosGenerales.numeroCotizacion!=null?$scope.datosGenerales.numeroCotizacion:"";
             
              
        
                    for(var i=0; i<$scope.listaCambio.length; i++){
                        if ($scope.listaCambio[i].id==$scope.multiriesgo.moneda){
                            $scope.multiriesgo.cotizacion = $scope.listaCambio[i].cambio;
                            break;
                        }
                    }
                
                 



                if($scope.acti){
                    $scope.acti=false;
                }
                $scope.comercial.inicial=undefined;
                $scope.llamarListadoCoberturas($scope.multiriesgo.moneda);

        
        }
        else
        {
            $scope.multiriesgo.cotizacion=null;
            $scope.comercial.inicial=undefined;
        }
        };



        
       
        

        $scope.$watch('comercial.poliza', function(NewValue, OldValue) {
            if(!angular.isUndefined(NewValue) && NewValue!=null)
            {
                if ($scope.editablesDescPoliza)
                {

                    var params = {};
                    params.numeroPolizaGrupo = NewValue;
                    params.moneda = $scope.multiriesgo.moneda;
                    params.pathModule = $scope.pathModule;
                    CotizacionVehiculoService.validarPolizaGrupo(params).then(function (response) {
                        if (response.data.error) {
                            $scope.comercial.poliza = undefined;
                            $scope.comercial.polizaPorct="";
                            $scope.comercial.nombrePolizaGrupo="";
                            $scope.monedaPolizaG=true;
                            $scope.fraccionPolizaG=true;
                            DialogService.showDialog(response.data.mensaje);


                        } else {
                            $scope.setearPorcentajeDesc(NewValue);
                            if (response.data.dato!=null)
                            {
                                if (response.data.dato.monedaModificable=="S")
                                {
                                    $scope.monedaPolizaG=true;
                                }
                                else
                                {
                                    $scope.monedaPolizaG=false;
                                }

                                if (response.data.dato.fraccionamientoModificable=="S")
                                {
                                    $scope.fraccionPolizaG=true;
                                }
                                else
                                {
                                    $scope.fraccionPolizaG=false;
                                }

                                if (response.data.dato.codigoFraccionamiento!=null && response.data.dato.codigoFraccionamiento!="")
                                {
                                    var fraccion=parseInt(response.data.dato.codigoFraccionamiento);
                                    var index=$scope.listaFraccion.map(function(e){return e.id;}).indexOf(fraccion);
                                    if (index !==-1)
                                    {
                                        $scope.comercial.fraccion=parseInt(response.data.dato.codigoFraccionamiento);
                                    }

                                }
                            }





                        }



                    }).catch(function(error){
                        $scope.comercial.poliza = undefined;
                        $scope.comercial.polizaPorct="";
                        $scope.comercial.nombrePolizaGrupo="";
                        Message.error("Algo inesperado ha ocurrido, intente nuevamente!");
                    });
                }
                else
                {
                    $scope.editablesDescPoliza = true;
                    /**Calcular lo seteado por el buscar **/
                    $scope.setearPorcentajeDesc(NewValue);
                }







            }else{
                $scope.editablesDescPoliza = true;
                $scope.comercial.polizaPorct="";
                $scope.comercial.nombrePolizaGrupo="";
            }
            
            $scope.cambiarRangoDescuento();

        },true);
        $scope.setearPorcentajeDesc=function(descPoliza)
        {
            for (var i = 0; i < $scope.datosGrupoPoliza.length; i++) {
                if ($scope.datosGrupoPoliza[i].id == descPoliza) {
                    $scope.comercial.polizaPorct = $scope.datosGrupoPoliza[i].porcentaje;
                    break;
                }
            }
            for (var i = 0; i < $scope.listaGrupoPoliza.length; i++) {
                if ($scope.listaGrupoPoliza[i].id == descPoliza) {
                    $scope.nombrePolizaGrupo = $scope.listaGrupoPoliza[i].poliza;
                    break;
                }
            }
        }
        $scope.$watch('comercial.desctEspecial', function(NewValue, OldValue) {

            
            if(!angular.isUndefined(NewValue) && $scope.comercial.desctEspecial !=null ){

                for(var i=0; i<$scope.datosDescuentoEspecial.length; i++){
                    if ($scope.datosDescuentoEspecial[i].id==NewValue){
                        $scope.maxDescEspecial=parseInt($scope.datosDescuentoEspecial[i].desct);
                        $scope.comercial.desctEspecialPorct=parseInt($scope.datosDescuentoEspecial[i].desct);
                        break;
                    }
                }
                for(var i=0; i<$scope.listaDesctEspc.length; i++){
                    if ($scope.listaDesctEspc[i].id==NewValue){
                        $scope.nombreDescEspecial=$scope.listaDesctEspc[i].desct;
                        break;
                    }
                }



            }else{
                $scope.comercial.desctEspecialPorct=null;
            }
        },true);



        $scope.$watch('comercial.fraccion', function(NewValue, OldValue) {

            if(!angular.isUndefined(NewValue)){

                var  parametros ={};



            }else{

            }
        },true);

      
 $scope.$watch('datosGenerales.nuevo', function(NewValue, OldValue) {

             if(!angular.isUndefined(NewValue)){

             }else{
                   
             }


        },true);


  $scope.$watch('multiriesgo.ciudadId', function(NewValue, OldValue,scope) {

            
            if(!angular.isUndefined(NewValue) && $scope.multiriesgo.ciudadId !=null ){

                for(var i=0; i<$scope.ciudades.length; i++){
                    if ($scope.ciudades[i].id==NewValue){
                        $scope.multiriesgo.codigoCiudad = $scope.ciudades[i].codigoCiudad;
                        $scope.multiriesgo.barrio= $scope.ciudades[i].codigoBarrio;
                        
                        break;
                    }
                }
                


            }
        },true);
           

         $scope.llamarListadoCoberturas = function(moneda) {
                 $scope.cargando=true;
                $scope.datosCobertura=[];
                var params = {};
               
                params.codigoMoneda = moneda;
               
                $scope.limpiarFormasPago();

               CotizacionMultiRiesgoService.getCoberturas(params).then(
                function (response) {
                    if (response.data.error ==false ) {
                        if (response.data.dato != null) {
                             $scope.cargando=true;
                            for (var i = 0; i < response.data.dato.length; i++) {
                                $scope.datosCobertura.push({"COD_COB": response.data.dato[i].codigoCobertura,"ETIQUETA":response.data.dato[i].etiqueta,"CAPITAL":Number(response.data.dato[i].capital), "INCREMENTO": Number(response.data.dato[i].incremento),"MCA_MODIFICABLE":response.data.dato[i].marcaModificable, "MINIMO": Number(response.data.dato[i].minimo), "PORCENTAJE": parseFloat(response.data.dato[i].porcentajeCobertura) } );
                                if(response.data.dato[i].maximo!="" ){
                                    $scope.datosCobertura[i].MAXIMO=Number(response.data.dato[i].maximo);
                                }else{
                                    $scope.datosCobertura[i].MAXIMO=-1;
                                }
                            }
                                if ($scope.esBuscar==false){
                                     $scope.setearCobertura($scope.datosCobertura);

                                }else{
                                     $scope.esBuscar = false;
                                }
                             
                                
                            
                           
                             
                            $scope.cargando=false;
                           
                        }

                    } else{
                        // $scope.sindatos= true;
                        $scope.cargando=false;
                        Message.error(response.data.mensaje);
                        
                    }

                    
                },
                function(response){
                    $scope.cargando=false;
                    
                    Message.error(response.data.mensaje);
                    
                });


         };



        $scope.showAdvanced = function() {

           $rootScope.codCoti=$scope.datosGenerales.numeroCotizacion;
           $rootScope.monedaAbuscar=$scope.multiriesgo.moneda;
           $rootScope.mostrarBuscadorCotizacion=true;
            $mdDialog.show({
                locals:{parent: $scope},   
                controller: 'BuscadorCotizacionCtrl',
                templateUrl: 'partials/ventanas-emergentes/buscador-cotizacion-partial.html',
                parent: angular.element(document.body),
                clickOutsideToClose:false,
                fullscreen: $scope.customFullscreen // Only for -xs, -sm breakpoints.
            }).then(function(answer) {
                 $scope.cargando=true;
                $scope.status = 'You said the information was "' + answer + '".';
                if (!angular.isUndefined(answer.numeroCotizacion) && answer.numeroCotizacion !="" && answer.numeroCotizacion!= null){
                    $scope.datosGenerales.numeroCotizacion = parseInt(answer.numeroCotizacion);
                }else{
                     Message.error("Numero de cotizacion inexistente");
                     return;
                }
               

                $scope.buscarCotizacion();


            }, function() {
                $scope.status = 'You cancelled the dialog.';
                //console.log($scope.status);
            });

        };
        

     $scope.cargarListadoFormaPago = function() {
         //console.log("Costo vehiculo ",$scope.listaFormaPago);
          
             
        if( $scope.listaFormaPago != null && $scope.listaFormaPago.length>0) {
            //console.log("Entra aca");
            $scope.sindatost=true;
        }
        else
        {
            $scope.sindatost=false;
        }
     
            
     } ;
     $scope.limpiarDatos=function()
     {
         $scope.obtenerCamposEditables();
         $scope.multiriesgo.moneda=undefined;
        $scope.multiriesgo.ocupacion = undefined;
         //combo comercial
         $scope.comercial.desctComercial=undefined;
         $scope.comercial.desctP="1";
         $scope.comercial.desctEspecial=undefined;
         $scope.comercial.desctComercial2=undefined;
         $scope.comercial.recComercial=undefined;
         $scope.comercial.fraccion=undefined;
         $scope.comercial.cuota="S";
         $scope.comercial.poliza=undefined;
         $scope.comercial.polizaDescripcion="";
         $scope.comercial.bono=undefined;
         $scope.comercial.bono2=null;
       
         $scope.comercial.inicial=undefined;
         $scope.comercial.primeraCuota=undefined;
         $scope.comercial.polizaPorct=undefined;
         $scope.cobertura.cartaVerde=true;
         $scope.cobertura.cartaAzul=false;
         //$scope.multiriesgo.producto=undefined;
         $scope.datosGenerales.numeroPropuesta="";
         $scope.cobertura.minMonto=0;
         $scope.cobertura.maxMonto=0;
         $scope.debitoAutomatico ={};
         $scope.debitoAutomatico.prima="0";
         $scope.debitoAutomatico.costoTotal ="0";
         $scope.debitoAutomatico.cuota="0";
         $scope.debitoAutomatico.ultimaCuota="0";

         $scope.contado ={};
         $scope.contado.prima="0";
         $scope.contado.costoTotal ="0";

         $scope.chequera ={};
         $scope.chequera.prima="0";
         $scope.chequera.costoTotal ="0";
         $scope.chequera.cuota="0";
         $scope.chequera.ultimaCuota="0";
         $scope.desctComercial=false;
         $scope.recComercial=false; 
         $scope.coberturaDatos=[];
         $scope.minDescRec=-100;
         $scope.maxDescRec=100;
 
     };
     $scope.actualizarGTOSMED=function(etiqueta,nuevoValor){
         if(etiqueta=="OVP MUERTE"){

            for(var i=0;i<$scope.v1.length;i++){
                if($scope.v1[i].ETIQUETA=="OVP GTOS MED"){
                    $scope.v1[i].MONTO_BASE=Math.ceil(nuevoValor*$scope.v1[i].PORCENTAJE);
                }
            } 
            for(var i=0;i<$scope.datos.length;i++){
                if($scope.datos[i].ETIQUETA=="OVP GTOS MED"){
                    $scope.datos[i].MONTO_BASE=Math.ceil(nuevoValor*$scope.datos[i].PORCENTAJE);
                }
            } 
         }
     };
     $scope.buscarCotizacion = function() {

            //console.log("Buscar");

            if ($scope.datosGenerales.numeroCotizacion!=null)
            {
              

                $scope.cargando=true;
                $scope.esBuscar=true;
              
                var datosBuscador={};
                datosBuscador.numeroCotizacion=$scope.datosGenerales.numeroCotizacion;
                datosBuscador.pathModule = $scope.pathModule;
                // datosBuscador.codigoAgente = null;
                // datosBuscador.codigoRol = null;
                // datosBuscador.codigoRamo = null;
              
                $scope.persistirProducto=false;
                $scope.persistir=false;

               
                $scope.esNuevo ="N";
                $scope.limpiarDatos();
              
                $timeout( function(){
                    CotizacionMultiRiesgoService.getCotizacionMultiriesgo(datosBuscador).then(

                        function (response) {

                            if(!response.data.error)
                            {

                                $scope.habilitarPropuesta=true;
                                $scope.bloquearBuscador=true;
                                $scope.editablesDescPoliza=false;

                                if(!angular.isUndefined(response.data.dato) && response.data.dato != null){


                                        //$scope.cargarPlataforma();


                                         if (response.data.dato.seguridad.length>0)
                                        {
                                            var seguridadSelect=response.data.dato.seguridad;
                                            for (var i=0; i<seguridadSelect.length;i++)
                                            {

                                                if (seguridadSelect[i].campo=="extintores")
                                                {
                                                    $scope.seguridad.extintores=seguridadSelect[i].check;

                                                }
                                                else if (seguridadSelect[i].campo=="bocaIncendio")
                                                {
                                                    $scope.seguridad.bocaIncendio=seguridadSelect[i].check

                                                }
                                                else if (seguridadSelect[i].campo=="redHidrantes")
                                                {
                                                    $scope.seguridad.redHidrantes=seguridadSelect[i].check

                                                }
                                                else if (seguridadSelect[i].campo=="alarmaSonora")
                                                {
                                                    $scope.seguridad.alarmaSonora=seguridadSelect[i].check
                                                }
                                                else if (seguridadSelect[i].campo=="empresaRespaldo")
                                                {
                                                    $scope.seguridad.empresaRespaldo=seguridadSelect[i].check
                                                }
                                                else if (seguridadSelect[i].campo=="sensorHumo")
                                                {
                                                    $scope.seguridad.sensorHumo=seguridadSelect[i].check
                                                }
                                                else if (seguridadSelect[i].campo=="guardias")
                                                {
                                                    $scope.seguridad.guardias=seguridadSelect[i].check
                                                }
                                                else if (seguridadSelect[i].campo=="rociadores")
                                                {
                                                    $scope.seguridad.rociadores=seguridadSelect[i].check
                                                }
                                                else if (seguridadSelect[i].campo=="circuitoCerrado")
                                                {
                                                    $scope.seguridad.circuitoCerrado=seguridadSelect[i].check
                                                }
                                                else if (seguridadSelect[i].campo=="sensorMovimiento")
                                                {
                                                    $scope.seguridad.sensorMovimiento=seguridadSelect[i].check
                                                }
                                                else if (seguridadSelect[i].campo=="funcionanDispositivos")
                                                {
                                                    $scope.seguridad.funcionanDispositivos=seguridadSelect[i].check
                                                }
                                                else if (seguridadSelect[i].campo=="otros")
                                                {
                                                    $scope.seguridad.otros=seguridadSelect[i].check
                                                }
                                                else  {
                                                    $log.debug("Este check no esta previsto ", seguridadSelect[i])
                                                }

                                            }

                                            //seguridadSelect.extintores=
                                        }
                                         $scope.fechaVigenciaDesde = angular.isUndefined(response.data.dato.fechaEfectoPoliza) ? undefined : response.data.dato.fechaEfectoPoliza != undefined ? $scope.convertirDate(response.data.dato.fechaEfectoPoliza) : undefined;
                                         $scope.fechaVigenciaHasta = angular.isUndefined(response.data.dato.fechaVencimientoPoliza) ? undefined : response.data.dato.fechaVencimientoPoliza != undefined ? $scope.convertirDate(response.data.dato.fechaVencimientoPoliza) : undefined;

                                         // $scope.promesaMonedas.promise.then(
                                         //    function () {
                                                
                                                 
                                         //    });
                                        
                                        $scope.multiriesgo.moneda = parseInt(response.data.dato.codigoMoneda);
                                        $scope.multiriesgo.cotizacion =parseInt(response.data.dato.valorCambio);
                                         for (var i=0;i<  $scope.listaOcupacion.length;i++){
                                              if ($scope.listaOcupacion[i].idOcupacion == response.data.dato.codigoOcupacion){
                                                  $scope.multiriesgo.ocupacion = $scope.listaOcupacion[i].idOcupacion;
                                                  break;
                                              }

                                         }
                                        $scope.multiriesgo.ciudadId = response.data.dato.codigoCiudad+'-'+response.data.dato.codigoBarrio;
                                          

                                       
                                        $scope.promesaPoliza.promise.then(
                                            function(){
                                                if (response.data.dato.codigoPolizaGrupo!=null && response.data.dato.codigoPolizaGrupo !=""){
                                                    $scope.comercial.poliza=response.data.dato.codigoPolizaGrupo;
                                                }else {
                                                    $scope.comercial.poliza=undefined; 
                                                }
                                                
                                            }
                                        );

                                        if (response.data.dato.codigoDescEspecial != null && response.data.dato.codigoDescEspecial != ""){
                                             $scope.comercial.desctEspecial=response.data.dato.codigoDescEspecial;
                                        }else{
                                             $scope.comercial.desctEspecial=undefined;
                                        }
                                       
                                        if (response.data.dato.descuentoComercial != null)
                                        {
                                            $scope.desctComercial=true;
                                        }
                                        $scope.comercial.desctComercial2=response.data.dato.descuentoComercial!=null && response.data.dato.descuentoComercial!=""?parseInt(response.data.dato.descuentoComercial):undefined;
                                        //$scope.comercial.recComercial=response.data.dato[0].recargoComercial;
                                        $scope.promesaFraccion.promise.then(
                                            function(){
                                                if(response.data.dato.codigoFraccionamiento!= ""){
                                                    $scope.comercial.fraccion=parseInt(response.data.dato.codigoFraccionamiento);
                                                }else{
                                                    $scope.comercial.fraccion=null;
                                                }

                                            }
                                        );
                                        $scope.datosGenerales.numeroCotizacion =parseInt(response.data.dato.numeroCotizacion);
                                        $scope.datosGenerales.nuevo=response.data.dato.marcaRenovacion;
                                        $scope.comercial.primeraCuota=response.data.dato.marcaCuotaIgual==null?'N':response.data.dato.marcaCuotaIgual;
                                        $scope.comercial.inicial=response.data.dato.importeInicial;
                                        //$scope.comercial.malus =response.data.dato.malus;
                                        $scope.comercial.bono2=response.data.dato.bonus;
                                       // $scope.comercial.envioDigital=response.data.dato.marcaEnvioDigital
                                        $scope.datosGenerales.numeroPropuesta=response.data.dato.numeroPropuesta!=null && response.data.dato.numeroPropuesta!=""? response.data.dato.numeroPropuesta:"";
                                        
                                        //$scope.multiriesgo.cerrado = response.data.dato.cerrado;


                                        $scope.listaFormaPago=[];
                                        $scope.listaFormaPago =response.data.dato.costosMultirriesgos;

                                        for(var i=0; i<$scope.listaCambio.length; i++){
                                            if ($scope.listaCambio[i].id==$scope.multiriesgo.moneda){
                                                $scope.multiriesgo.cotizacion = $scope.listaCambio[i].cambio;
                                                break;
                                            }
                                        }
                                       // $scope.multiriesgo.cotizacion=!angular.isUndefined(response.data.dato.cambio)&& response.data.dato.cambio!=null?parseInt(response.data.dato.cambio):1;

                                         //llamar a un metodo que cargue la cobertura de esta cotizacion
                                        $scope.datosCobertura=[];
                                        if (response.data.dato.coberturasMultirriesgo.length>0 && response.data.dato.coberturasMultirriesgo!= null)
                                                {
                                                    //$scope.mostrarCartas=true;
                                                for (var i=0; i< response.data.dato.coberturasMultirriesgo.length; i++)
                                                {
                                                      
                                                    if  (response.data.dato.coberturasMultirriesgo[i].etiqueta=='INCENDIO EDIFICIO'){

                                                         $scope.montoIncendioEdificio = response.data.dato.coberturasMultirriesgo[i].capital == null?"" :response.data.dato.coberturasMultirriesgo[i].capital;
                                                    }
                                                    $scope.datosCobertura.push({"COD_COB": response.data.dato.coberturasMultirriesgo[i].codigoCobertura,"ETIQUETA":response.data.dato.coberturasMultirriesgo[i].etiqueta,"CAPITAL":Number(response.data.dato.coberturasMultirriesgo[i].capital),"MAXIMO":Number(response.data.dato.coberturasMultirriesgo[i].maximo), "INCREMENTO": Number(response.data.dato.coberturasMultirriesgo[i].incremento),"MCA_MODIFICABLE":response.data.dato.coberturasMultirriesgo[i].marcaModificable, "MINIMO": Number(response.data.dato.coberturasMultirriesgo[i].minimo),"MCA_REQUERIDO":response.data.dato.coberturasMultirriesgo[i].marcaRequerido } );
                                                    if(response.data.dato.coberturasMultirriesgo[i].maximo!="" ){
                                                        $scope.datosCobertura[i].MAXIMO=Number(response.data.dato.coberturasMultirriesgo[i].maximo);
                                                    }else{
                                                        $scope.datosCobertura[i].MAXIMO=-1;
                                                    }

                                                }
                                                $scope.setearCobertura($scope.datosCobertura);
                                                    
                                            }
                                            else
                                            {

                                                $scope.cargando=false;
                                        }
 
                                        $q.all( [
                                           $scope.promesaPoliza.promise.then() , $scope.promesaFraccion.promise.then()
                                        ] ).then(function(sucess){
                                           // $scope.datosGenerales.numeroPropuesta=response.data.dato[0].sumaAsegurada;
                                            $scope.cargarListadoFormaPago();
                                        });



                                   // }

                                }else{
                                    Message.error(response.data.mensaje);
                                    $scope.cargando=false;
                                    
                                }
                            }else{
                                $scope.habilitarPropuesta=false;
                                $scope.recargar();
                                Message.error(response.data.mensaje);
                                $scope.cargando=false;
                               

                            }





                        },
                        function(response){
                            $scope.persistirProducto=true;
                            $scope.persistir=true;
                            Message.error(response.data.mensaje);
                            
                        });

                }, 2000 );


            }
            
            

             
        };
         $scope.promesaTipoOcupacion = $q.defer();
         $scope.cargarTipoOcupacion = function () {

            CotizacionMultiRiesgoService.getOcupacion().then(function (response) {
                    if (!response.data.error) {
                        if (response.data.dato.length > 0) {
                           $scope.listaOcupacion=[];
                           for (var i = 0; i < response.data.dato.length; i++) {
                                var objTipoOcupacion = {
                                    idOcupacion: response.data.dato[i].codigoOcupacion,
                                    descripcionOcupacion: response.data.dato[i].nombreOcupacion
                                };
                                $scope.listaOcupacion.push(objTipoOcupacion);
                           }
                           $scope.promesaTipoOcupacion.resolve();
                        }

                   }else{
                       $scope.promesaTipoOcupacion.resolve();
                       Message.error(response.data.mensaje);
                   }


                    
            }).catch(function (response) {
                    $scope.promesaTipoOcupacion.reject();
                     
                    
                    Message.error("No se pudo obtener lista de ocupacion.");
             });

        };

         $scope.$watch('fechaVigenciaDesde', function (NewValue, OldValue) {
                if (!angular.isUndefined(NewValue) && NewValue != null) {
                    // if (NewValue != OldValue) {
                        var dato = moment(NewValue).format("DD/MM/YYYY");
                        var param={};
                        param.fechaVigencia=dato;
                        param.pathModule=$scope.pathModule;
                        PropuestaService.obtenerFechaVigenciaHasta(param).then(function(response){
                            if (!response.data.error)
                            {
                                if (response.data.dato!=null)
                                {
                                    $scope.fechaVigenciaHasta=$scope.convertirDate(response.data.dato.fechaVencimientoPoliza);
                                }
                            }
                            else
                            {
                                Message.error(response.data.mensaje);
                            }
                        });
                      

                } else if (NewValue == null) {
                    $scope.fechaVigenciaHasta = undefined;

                }

            }, true);
        $scope.cargarCombos= function() {
              
              $scope.cargarTipoOcupacion();
              $scope.cargarPolizaGrupo()
              $scope.cargarFraccionamiento();
              $scope.cargarDescuentoEspecial();
              $scope.cargarMonedas();
              $scope.obtenerCiudades();


        };

        $scope.recargar = function()
        {

            if(!angular.isUndefined($routeParams.numeroCotizacion)){
                $location.search('numeroCotizacion', undefined);
                $rootScope.numeroCotizacionRoot = undefined;
                $location.path('cotizacion-hogar');

            }
            else
            {
                $route.reload();
            }


        };

                $scope.filteredText = $filter('number')($scope.datosGenerales.numeroPropuesta);





$scope.actualizarCotizacion=function ()
{
   // console.log("Valor de suma agregada ", $scope.datosGenerales.numeroPropuesta);
    //$scope.validarNumero();
    $scope.cargando=true;
    $scope.cobertura.franquicia=undefined;
    $scope.verificarFranquicia($scope.multiriesgo.producto,$scope.multiriesgo.moneda, $scope.datosGenerales.numeroPropuesta);
    if ($scope.datosGenerales.numeroPropuesta != undefined && $scope.datosGenerales.numeroPropuesta != null)
    {
        var  parametros ={};
        parametros.esNuevo=$scope.esNuevo;
       
        parametros.codigoMoneda=$scope.multiriesgo.moneda;
        parametros.codigoRamo=501;
        parametros.numeroCotizacion=$scope.datosGenerales.numeroCotizacion;
       // $scope.recalcularCotizacion(parametros);
    }
    else
    {
        $scope.cargando=false;
    }


};

$scope.cambiarRangoDescuento=function()
{
    if (!angular.isUndefined($scope.comercial.poliza) && $scope.comercial.poliza!=null)
    {
        $scope.minDescRec=0;
        $scope.maxDescRec=100;

    }
    else
    {
        $scope.minDescRec=-100;
        $scope.maxDescRec=100;
    }
};
$scope.verificarMontoCobertura=function (cobertura)
{
    if(cobertura.MAXIMO!=-1 && cobertura.CAPITAL >0){
    var montoActual=cobertura.CAPITAL
    if (montoActual> cobertura.MAXIMO && cobertura.MAXIMO>0) 
    {
        cobertura.CAPITAL=cobertura.MAXIMO;
    }
    else if (montoActual< cobertura.MINIMO)
    {
        cobertura.CAPITAL=cobertura.MINIMO;
    }

    }
    else {
        if (angular.isUndefined(cobertura.capital))
        {
            cobertura.CAPITAL=0
        }
    }
};
$scope.incrementarCobertura=function (cobertura)
{
    //console.log("La cobertura es ", cobertura);
    var montoActual=cobertura.CAPITAL;
   // console.log("La cobertura es ", montoActual);
    if (montoActual>= cobertura.MAXIMO && cobertura.MAXIMO>0)
    {
        cobertura.CAPITAL=cobertura.MAXIMO;
    }
    else
    {
        cobertura.CAPITAL+=cobertura.INCREMENTO;
    }
    $scope.montoIncendioEdificio=cobertura.CAPITAL;
    $scope.llamarListadoCoberturas($scope.multiriesgo.moneda);
};
$scope.decrementarCobertura=function (cobertura)
{
   //console.log("La cobertura es en decremento ", cobertura);
var montoActual = cobertura.CAPITAL;
if (montoActual <= cobertura.MINIMO){
    cobertura.CAPITAL = cobertura.MINIMO;
}
else{
    cobertura.CAPITAL-=cobertura.INCREMENTO;
}
    $scope.montoIncendioEdificio=cobertura.CAPITAL;
    $scope.llamarListadoCoberturas($scope.multiriesgo.moneda);

};


$scope.limpiarFormasPago=function()
{
    $scope.listaFormaPago=null;
   

    $scope.sindatost=false;
};
$scope.setearCobertura=function(coberturas)
{   
     $scope.sindatos=false;
    
    $scope.v1=[];
    $scope.v2=[];
    $scope.datosCobertura=[];
    $scope.datos=[];
 
    var CV,CA;
    CA=0,CV=0;
    $scope.datosCobertura=angular.copy(coberturas);
    $scope.cartas=[];

    
    for(var i=0;i<$scope.datosCobertura.length;i++)
    {

         
            $scope.datos.push($scope.datosCobertura[i]);
         
    }
    $scope.datosCobertura=angular.copy($scope.datos);

    if($scope.datosCobertura.length<=6){
        var i=0;
        while($scope.datos.length>0 && $scope.v1.length<=6){
            $scope.v1.push($scope.datos[i]);
           // i++;
           $scope.datos.splice(0,1);
        };
    }else{
        var x=$scope.datosCobertura.length/2;
        var cant = UtilsService.truncar($scope.datosCobertura.length/2);

        var resto = $scope.datosCobertura.length%2;
        var cantxColum = cant + resto;
        var i=0;
        var temp =[];
        temp=angular.copy($scope.datos);
        while(temp.length>0 && $scope.v1.length< cantxColum){
            $scope.v1.push(temp[i]);
            $scope.datos.splice(0,1);
            i++;
        };
        

    }
        //console.log($scope.v1);
        //console.log($scope.datos);
         $scope.cargarListadoFormaPago();
            $scope.cargando=false;
    
    
};

 



    /**
     * Función creada para el salto de cotización a propuesta
     */
    $scope.goToPropuesta = function() {
        var path = $location.$$absUrl; 
        var n = path.search("module");
        var url =  path.substring(0 , n);
        $scope.cargando=true;
        if(typeof $scope.datosGenerales.numeroCotizacion != 'undefined' && $scope.datosGenerales.numeroCotizacion != null){

            location.href ='propuesta-hogar/propuesta/'+$scope.datosGenerales.numeroCotizacion;

        }else{            
            Message.warning("Debe ingresar un número de cotización");
        }
    }
     /*descargar carta oferta
     };*/
     $scope.verificarCamposForm=function(listaCampo, campo)
        {
            return UtilsService.verificarCamposForm(listaCampo, campo);
        };
     

     $scope.cargarPlataforma = function(){

        var paramPla={};
        paramPla.numeroCotizacion=$scope.datosGenerales.numeroCotizacion;
        paramPla.pathModule=$scope.pathModule;

      CotizacionVehiculoService.getPlataforma(paramPla).then(

                       
                        function (response) {
                          if(!response.data.error){
                             if(response.data.dato!=null  )  {
                                   
                                $scope.mostrarPlataforma=true;
                                 
                                   $scope.datosGenerales.plataforma=response.data.dato.mensaje;

                                
                            }

                          }
                     

                        }).catch(function(response){
                           
                            Message.error("Ocurrio un error intente nuevamente");
                           
                        });
          };
        $scope.obtenerAutorizaciones=function()
        {
             
            $scope.autorizacionesList = [];
            var params={};
            params.pathModule=$scope.pathModule;
            CotizacionVehiculoService.getAutorizaciones(params).then(function(response){
               if (!response.data.error)
               {
                   if (response.data.dato.length>0)
                   {
                       var campos=response.data.dato;
                       for (var i=0; i< campos.length; i++)
                       {
                           $scope.autorizacionesList.push(campos[i]);
                           if (campos[i]==='btnEliminar'){
                              $rootScope.botonEliminar=true;

                           }
                       }
                   }
                  
                   //console.log("Lista Autorizaciones: " + JSON.stringify($scope.autorizacionesList));
               }
               else
                   {
                   Message.error(response.data.mensaje);
               }
            });
        };
        $scope.obtenerCamposEditables=function()
        {

            $scope.camposEditablesList = [];
            
            
            var params={};
            params.pathModule=$scope.pathModule;
                      
            params.numeroCotizacion=angular.isUndefined($scope.datosGenerales.numeroCotizacion)|| $scope.datosGenerales.numeroCotizacion==null?"":$scope.datosGenerales.numeroCotizacion;
            CotizacionVehiculoService.getCamposEditables(params).then(function(response){
               if (!response.data.error)
               {
                   if (response.data.dato.length>0)
                   {
                       var campos=response.data.dato;
                       for (var i=0; i< campos.length; i++)
                       {
                           $scope.camposEditablesList.push(campos[i]);
                       }
                   }
                   }
               else
                   {
                   Message.error(response.data.mensaje);
               }
            });
        };
        $scope.obtenerCamposRequeridos=function()
        {

            $scope.camposRequeridosList = [];
            var params={};
            params.numeroCotizacion=angular.isUndefined($scope.datosGenerales.numeroCotizacion)?"":$scope.datosGenerales.numeroCotizacion!=null?$scope.datosGenerales.numeroCotizacion:"";
            params.pathModule=$scope.pathModule;
            CotizacionHogarService.getCamposRequeridos(params).then(function(response){
               if (!response.data.error)
               {
                   if (response.data.dato.length>0)
                   {
                       var campos=response.data.dato;
                       for (var i=0; i< campos.length; i++)
                       {
                           $scope.camposRequeridosList.push(campos[i]);
                       }
                   }
               }
               else
                   {
                   Message.error(response.data.mensaje);
               }
           }, function(error){
                $scope.cargando=false;
                Message.error("Ocurrio un error al obtener los campos requeridos");
             });
        };
        $scope.emitirDocumento=function()
        {
            $scope.emitir=true;
        };

        $scope.llamarModal = function(value) {

        if(!angular.isUndefined($scope.datosGenerales.numeroCotizacion)&& $scope.datosGenerales.numeroCotizacion!=null && $scope.datosGenerales.numeroCotizacion!=""){ 
            $rootScope.numCotiza = $scope.datosGenerales.numeroCotizacion;
            $rootScope.autEsNuevo=$scope.esNuevo;
            $rootScope.modalCotizadorVehFlota=value;
           // $rootScope.flagHogar=true;
            $mdDialog.show({
                //locals:{mobile: $scope.esMobile},
                controller: 'ModalAutorizacionCtrl',
                templateUrl: 'partials/ventanas-emergentes/modal-autorizacion-partial.html',
                parent: angular.element(document.body),
                multiple: true,
                clickOutsideToClose:false,
               /* scope:$scope,
                preserveScope: true,*/
                fullscreen: $scope.customFullscreen // Only for -xs, -sm breakpoints.

            }).then(function(answer) {
                 
                
                
                $scope.buscarCotizacion();


            }, function() {
                $scope.status = 'You cancelled the dialog.';
                console.log($scope.status);
            });
           } 

        };
        $scope.verificarCamposForm=function(listaCampo, campo)
        {
            return UtilsService.verificarCamposForm(listaCampo, campo);
        };
        $scope.franquicia=$q.defer();
        $scope.verificarFranquicia=function(producto, moneda, sumaAsegurada)
        {
            $scope.cargando=true;

            $scope.listaFranquicias=[];
            $scope.mostrarFranquicia=false;
            if (!angular.isUndefined(producto) && producto!=null )
            {
                for (var i=0; i< $scope.listaProductos.length; i++)
                {
                    if ($scope.listaProductos[i].id==producto)
                    {
                        if ($scope.listaProductos[i].mcaFranquicia=="S")
                        {
                            $scope.mostrarFranquicia=true;
                            break;
                        }
                    }
                }
                if ($scope.mostrarFranquicia)
                {
                    var data=null;
                    var params={};
                    params.moneda=moneda;
                    params.sumaAsegurada=angular.isUndefined(sumaAsegurada)?null:sumaAsegurada;
                    CotizacionVehiculoService.getFranquicias(params).then(function(response) {
                        if (!response.data.error)
                        {

                            if (response.data.dato!=null && response.data.dato.length>0)
                            {
                                data=response.data.dato;
                                for (var i=0; i<data.length;i++)
                                {
                                    $scope.listaFranquicias.push(data[i]);
                                }
                                $scope.franquicia.resolve();
                                $scope.cargando=false;


                            }
                            else {
                                $scope.cargando=false;
                                $scope.franquicia.resolve();
                                Message.info("No se encontraron franquicias");
                            }
                        }
                        else {
                            $scope.cargando=false;
                            $scope.franquicia.reject();
                            Message.error(response.data.mensaje);
                        }
                    })
                }
                else
                {
                    $scope.cargando=false;
                }
            }



        };
        $scope.recuperarImporte=function(codigo)
        {
            for (var i=0; i<$scope.listaFranquicias.length;i++) {
                if ($scope.listaFranquicias[i].codigoFranquicia == codigo) {
                    return $scope.listaFranquicias[i].importeFranquicia;
                }
            }
        };
        
    $scope.obtenerCiudades=function()
    {   
        CotizacionMultiRiesgoService.getCiudades().then(function (response){
            if (response.data.dato.length>0)
            {
                var data=response.data.dato;
                for (var i=0; i<data.length;i++)
                {   
                 var obj = {
                     id :  data[i].codigoCiudad +'-'+data[i].codigoBarrio,
                     codigoCiudad : data[i].codigoCiudad,
                     codigoBarrio : data[i].codigoBarrio,
                     nombreCiudad : data[i].nombreCiudad
                    };
                    $scope.ciudades.push(obj);
                     
                }

                 
               
            }
            
        });

    };
        $scope.cambiarRangoDescuento=function()
{
    if (!angular.isUndefined($scope.comercial.poliza) && $scope.comercial.poliza!=null)
    {
        var roles=sessionStorage.getItem("roles");
        if (roles !="" && roles.indexOf("TECAUT")>0)
        {
            $scope.minDescRec=-100;
            $scope.maxDescRec=100;
        }
        else
        {
            $scope.minDescRec=0;
            $scope.maxDescRec=100;
        }


    }
    else
    {
        $scope.minDescRec=-100;
        $scope.maxDescRec=100;
    }
};





        (function initialize() {

            $scope.sindatos=true;
            $scope.sindatost=false;
            $scope.comercial.primeraCuota='S';
         
            $scope.flagConfirmacion=true;
            $scope.persistir= true;
            $scope.esBuscar= false;
            $scope.persistirProducto=true;
            $scope.listaFormaPago=[];
         
            $scope.controlRequerido = false;
           
            $scope.pathModule = UtilsService.retornarPath($location.path().split("/")[1]);
            $scope.obtenerCamposEditables();
             
            $scope.obtenerAutorizaciones();
            
           
            $scope.montoIncendioEdificio =null;
            $scope.fechaVigenciaDesde = new Date();

            $scope.multiriesgo.cotizacion=1;
            $scope.botonEliminar = undefined;
            angular.extend(this, $controller('UtilsCtrl', {
                    "$scope": $scope
            }));

             
            $scope.path = "/" +$location.$$path.split("/")[1] + "/";
            $scope.cargarCombos();
            
            if ($window.sessionStorage["rolesAsignados"]!=undefined && $window.sessionStorage["rolesAsignados"]!=null){
                var listaRoles = $window.sessionStorage["rolesAsignados"].split(",");
                $scope.controlPermisos = listaRoles.indexOf("rol_1")>-1? true:false;
            }
            
        
            /**
             * Verifica si la ventana fue llamada desde propuesta
             */
            if(!angular.isUndefined($routeParams.numeroCotizacion )){
                
                $rootScope.numeroCotizacionRoot = $routeParams.numeroCotizacion;
                $scope.datosGenerales.numeroCotizacion=$rootScope.numeroCotizacionRoot;
                $scope.buscarCotizacion();
            }else if(!angular.isUndefined($rootScope.numCotizacionBcp) && $rootScope.numCotizacionBcp!=null){
                //viene del bcp 
                $rootScope.numeroCotizacionRoot =  $rootScope.numCotizacionBcp;
                $scope.datosGenerales.numeroCotizacion=$rootScope.numeroCotizacionRoot;
                $rootScope.numCotizacionBcp=undefined;
                $scope.buscarCotizacion();
            }

        })();


    }]);
;app.controller('CotizacionMultiRiesgosMobileFormCtrl', ['$scope', '$q','CotizacionVehiculoService','$timeout', '$controller', '$routeParams', '$location', 'SessionService', '$rootScope','$route', '$mdDialog', '$filter', 'ConfirmService', '$window','BuscadorCotizacionService', 'UtilsService','PropuestaService','$locale','CotizacionHogarService','CotizacionMultiRiesgoService',
    function ($scope,$q, CotizacionVehiculoService, $timeout, $controller, $routeParams, $location, sessionService, $rootScope,$route, $mdDialog,  $filter, confirmService, $window, BuscadorCotizacionService,UtilsService, PropuestaService,$locale,CotizacionHogarService,CotizacionMultiRiesgoService) {

        $rootScope.rootPathParent = $route.current.$$route.originalPath;
        $scope.service = PropuestaService;
        $locale.NUMBER_FORMATS.GROUP_SEP = '.';
        $locale.NUMBER_FORMATS.DECIMAL_SEP = ',';
        $scope.data = {};
        $scope.data.seccion = undefined;
        $scope.customFullscreen = false;
        $scope.mostrarDocumento = {};

 
        $scope.listaCambio = [];
        var parametros = {};

        // combos vehiculos
        $scope.listaGrupoPoliza = [];

        $scope.years = [];

        $scope.listaMonedas = [];
        $scope.datosGrupoPoliza = [];
        $scope.datosDescuentoEspecial = [];
        //combo comercial
        $scope.listaProductos = [];
        $scope.listaPolizas = [];
        $scope.listaDesctComercial = [];

        $scope.listaDesctEspc = [];

        $scope.listaFraccion = [];
        $scope.multiriesgo = {};
        $scope.multiriesgo.cerrado = undefined;
        $scope.multiriesgo.numeroSolicitud = undefined;
         
		$scope.multiriesgo.moneda = undefined;
		$scope.multiriesgo.cotizacion = undefined;
        
        $scope.datosGenerales = {};
        $scope.datosGenerales.nuevo = "N";
        $scope.datosGenerales.numeroPoliza = undefined;
        $scope.datosGenerales.numeroPolizaAnterior = undefined;
        $scope.datosGenerales.numeroCotizacion = undefined;
		$scope.datosGenerales.numeroPropuesta = undefined;
        

        $scope.comercial = {};
        $scope.comercial.desctComercial = undefined;
        $scope.comercial.desctP = "1";
        $scope.comercial.desctEspecial = undefined;
        $scope.comercial.desctComercial2 = undefined;
        $scope.comercial.recComercial = undefined;
        $scope.comercial.fraccion = undefined;
        $scope.comercial.cuota = "S";
        $scope.comercial.poliza = undefined;
        $scope.comercial.polizaDescripcion = "";
        $scope.comercial.bono = undefined;
        $scope.comercial.bono2 = null;
        $scope.comercial.malus = null;
        $scope.comercial.inicial = undefined;
        $scope.comercial.primeraCuota = undefined;
        $scope.comercial.polizaPorct = undefined;

        $scope.cobertura = {};
        $scope.cobertura.rcPersonas = "200000000";
        $scope.cobertura.ovpGtosMdeOcup = "200000000";
        $scope.cobertura.robo = "200";
        $scope.cobertura.granizo = "200";
        $scope.cobertura.incendioEdificio = "200";
        $scope.cobertura.danhosVandalismo = "200";
        $scope.cobertura.rcDanhosMateriales = "200000000";
        $scope.cobertura.danhosPropiosTotal = "200";
        $scope.cobertura.roboParcialRadio = "2011";
        $scope.cobertura.accidentePersonales = "200";
        $scope.cobertura.incendioContenidoVivienda = "300";
        $scope.cobertura.airbag = "200";
        $scope.cobertura.ovpMteOcupante = "200000000";
        $scope.cobertura.danhosPropiedad = "200";
        $scope.cobertura.roboParcialRadio2 = "200";
        $scope.cobertura.gtoMedAccPersonales = "200";
        $scope.cobertura.sepelio = "200";
        $scope.cobertura.cartaVerde = true;
        $scope.cobertura.cartaAzul = false;
       
        $scope.datosGenerales.numeroPropuesta = "";
        $scope.cobertura.minMonto = 0;
        $scope.cobertura.maxMonto = 0;
        $scope.debitoAutomatico = {};
        $scope.debitoAutomatico.prima = "0";
        $scope.debitoAutomatico.costoTotal = "0";
        $scope.debitoAutomatico.cuota = "0";
        $scope.debitoAutomatico.ultimaCuota = "0";

        $scope.montoIncendioEdificio =null;

        $scope.contado = {};
        $scope.contado.prima = "0";
        $scope.contado.costoTotal = "0";
 
        $scope.desctComercial = false;
        $scope.recComercial = false;
        $scope.coberturaDatos = [];
        $scope.minDescRec = -100;
        $scope.maxDescRec = 100;
        $scope.maxDescEspecial = 0;
        $scope.restriccion = "^[0-9]+(\,[0-9]{1,2})?$";
        $scope.camposEditablesList = [];
        $scope.submitted = false;
        $scope.emitir = false;
        $scope.todo_marcas = false;
       // $scope.preferencia_marcas = $window.sessionStorage.getItem("preferencia_marcas");
        $scope.preferencia_moneda = $window.sessionStorage.getItem("preferencia_moneda");
        $scope.preferencia_fraccionamiento = $window.sessionStorage.getItem("preferencia_fraccionamiento");
        $scope.visibleMoneda=true;
        
        $scope.minOcupantes = 0;
        $scope.maxOcupantes = 0;
        $scope.esBuscar = false;
        $scope.sumaAseguradaBuscar = false;
        $scope.marcaNoPreferencia = false;
        $scope.nombrePDF = undefined;
        $scope.autorizacion = false;
        $scope.bloquearBuscador=false;
        $scope.promesaSave = $q.defer();

         $scope.seguridad ={};
         $scope.seguridad.extintores='N';
         $scope.seguridad.rociadores='N';
         $scope.seguridad.bocaIncendio='N';
         $scope.seguridad.sensorHumo='N';
         $scope.seguridad.redHidrantes='N';
         $scope.seguridad.guardias='N';
         $scope.seguridad.empresaRespaldo='N';
         $scope.seguridad.alarmaSonora='N';
         $scope.seguridad.circuitoCerrado='N';
         $scope.seguridad.sensorMovimiento='N';
         $scope.seguridad.funcionanDispositivos='N';
         $scope.seguridad.otros='N';


        $scope.ciudades=[];
        $scope.listaOcupacion=[];

        $scope.save = function () {
            $scope.cargando=true;
            //obtenemos los campos requeridos
            $scope.camposRequeridosList = [];
            var params = {};
            params.numeroCotizacion = angular.isUndefined($scope.datosGenerales.numeroCotizacion) ? "" : $scope.datosGenerales.numeroCotizacion != null ? $scope.datosGenerales.numeroCotizacion : "";
            params.pathModule =$scope.pathModule;
            CotizacionHogarService.getCamposRequeridos(params).then(function (response) {
                if (!response.data.error) {
                    if (response.data.dato.length > 0) {
                        var campos = response.data.dato;
                        $scope.camposRequeridosList=campos;
                        $timeout(function(){
                            if ($scope.CotizacionMobileForm.$invalid && !angular.isUndefined($scope.CotizacionMobileForm.$error.required)) {
                                $scope.cargando=false;
                                Message.warning("Existen campos que faltan ser completados!");
                                return;
                            }
                            else
                            {
                              //  $log.debug("Valido, llamar a guardar"); //llamar al guardar
                                  $scope.camposRequeridosList = [];
                               
                                    var datosSave = {};

                                datosSave.numeroCotizacion = $scope.datosGenerales.numeroCotizacion;
                                datosSave.codigoMoneda = $scope.multiriesgo.moneda;
                                datosSave.valorCambio = $scope.multiriesgo.cotizacion;
                                datosSave.codigoCiudad = angular.isUndefined($scope.multiriesgo.codigoCiudad)?"":$scope.multiriesgo.codigoCiudad;
                                datosSave.codigoBarrio=angular.isUndefined($scope.multiriesgo.barrio)?"":$scope.multiriesgo.barrio;
                                datosSave.codigoOcupacion=angular.isUndefined($scope.multiriesgo.ocupacion)?"":$scope.multiriesgo.ocupacion;
                                datosSave.codigoFraccionamiento = $scope.comercial.fraccion;
                                datosSave.importeInicial = $scope.comercial.inicial;
                                datosSave.marcaCuotaIgual = $scope.comercial.primeraCuota;
                                datosSave.codigoPolizaGrupo = $scope.comercial.poliza;
                                datosSave.porcentajePolizaGrupo = $scope.comercial.polizaPorct;
                                datosSave.codigoDescEspecial = $scope.comercial.desctEspecial;
                                datosSave.porcentajeDescEspecial = $scope.comercial.desctEspecialPorct;
                                datosSave.descuentoComercial = $scope.comercial.desctComercial2;
                                // codigoAgente??
                                datosSave.codigoUsuario=sessionStorage.getItem("usuarioLogueado");
                                datosSave.marcaModulo=$scope.pathModule.split("marcaModulo=")[1];

                                datosSave.numeroPropuesta = $scope.datosGenerales.numeroPropuesta;

                                datosSave.esNuevo=$scope.datosGenerales.nuevo;


                                datosSave.bonus = $scope.comercial.bono2;

                                datosSave.nombrePolizaGrupo = $scope.nombrePolizaGrupo;


                                datosSave.nombreDescEspecial = $scope.nombreDescEspecial;


                                datosSave.fechaEfectoPoliza = angular.isUndefined($scope.fechaVigenciaDesde) ? null : $scope.fechaVigenciaDesde != null ? moment($scope.fechaVigenciaDesde).format("DD/MM/YYYY") : null;
                                datosSave.fechaVencimientoPoliza = angular.isUndefined($scope.fechaVigenciaHasta) ? null : moment($scope.fechaVigenciaHasta).format("DD/MM/YYYY");

                                datosSave.seguridad= [ {
                                    "campo": "extintores",
                                    "check": $scope.seguridad.extintores
                                },
                                    {
                                        "campo": "rociadores",
                                        "check": $scope.seguridad.rociadores
                                    },
                                    {
                                        "campo": "bocaIncendio",
                                        "check": $scope.seguridad.bocaIncendio
                                    },
                                    {
                                        "campo": "sensorHumo",
                                        "check": $scope.seguridad.sensorHumo
                                    },
                                    {
                                        "campo": "redHidrantes",
                                        "check": $scope.seguridad.redHidrantes
                                    },
                                    {
                                        "campo": "guardias",
                                        "check": $scope.seguridad.guardias
                                    },
                                    {
                                        "campo": "empresaRespaldo",
                                        "check": $scope.seguridad.empresaRespaldo
                                    },
                                    {
                                        "campo": "alarmaSonora",
                                        "check": $scope.seguridad.alarmaSonora
                                    },
                                    {
                                        "campo": "circuitoCerrado",
                                        "check": $scope.seguridad.circuitoCerrado
                                    },
                                    {
                                        "campo": "sensorMovimiento",
                                        "check": $scope.seguridad.sensorHumo
                                    },
                                    {
                                        "campo": "funcionanDispositivos",
                                        "check": $scope.seguridad.funcionanDispositivos
                                    },
                                    {
                                        "campo": "otros",
                                        "check": $scope.seguridad.otros
                                    }
                                    ]


                                $scope.coberturaDatos = [];

                                if ($scope.v1 && $scope.datos) {
                                    for (var i = 0; i < $scope.v1.length; i++) {

                                        var obj = {

                                            numeroCotizacion: datosSave.numeroCotizacion,
                                            codigoCobertura: $scope.v1[i].COD_COB,
                                            etiqueta: $scope.v1[i].ETIQUETA,
                                            capital: $scope.v1[i].CAPITAL,
                                            marcaModificable: $scope.v1[i].MCA_MODIFICABLE
                                        };

                                        $scope.coberturaDatos.push(obj);
                                    }
                                    for (var i = 0; i < $scope.datos.length; i++) {
                                        var obj = {

                                            numeroCotizacion: datosSave.numeroCotizacion,
                                            codigoCobertura: $scope.datos[i].COD_COB,
                                            etiqueta: $scope.datos[i].ETIQUETA,
                                            capital: $scope.datos[i].CAPITAL,
                                            marcaModificable: $scope.datos[i].MCA_MODIFICABLE
                                        };

                                        $scope.coberturaDatos.push(obj);
                                    }
                                    datosSave.coberturasMultirriesgo = angular.copy($scope.coberturaDatos);
                                }
                                else {
                                    datosSave.coberturasMultirriesgo = [];
                                }
                                    $scope.cargando = true;
                                    var objeto = JSON.stringify(datosSave);
                                    CotizacionMultiRiesgoService.guardarCotizacionMultiriesgo(datosSave).then(
                                        function (response) {
                                            if (!response.data.error) {

                                                    $scope.listaFormaPago = [];
                                                   
                                                    $scope.datosGenerales.numeroCotizacion = parseInt(response.data.dato.numeroCotizacion);
                                                   $scope.cargando = false;
                                                   Message.ok(response.data.mensaje);
                                                    $scope.clickButton = false;
                                                    $scope.promesaSave.resolve();
                                                $scope.buscarCotizacion();

                                            } else {
                                                $scope.cargando = false;
                                                Message.error(response.data.mensaje);
                                                //
                                                $scope.promesaSave.reject();

                                            }

                                        }).catch(function (response) {
                                        $scope.cargando = false;
                                        Message.error("Ocurrio un error intente nuevamente!");
                                        $scope.promesaSave.reject();
                                    });
                                  
                                    $scope.cargando = false;
                              

                            }
                        }, 1000);

                    }
                    else
                    {
                        $scope.cargando=false;
                    }


                }
                else {
                    $scope.cargando=false;
                    Message.error(response.data.mensaje);
                }
            }, function(error){
                $scope.cargando=false;
                Message.error("Ocurrio un error al obtener los campos requeridos.");
            });





        };
        $scope.actualizarDatos = function() {

            var datosSave={};
            datosSave.numeroCotizacion=$scope.datosGenerales.numeroCotizacion;
            datosSave.numeroPropuesta=$scope.datosGenerales.numeroPropuesta;
            datosSave.cerrado=$scope.multiriesgo.cerrado;

            datosSave.descuentoComercial=$scope.comercial.desctComercial2;
            datosSave.bonus=$scope.comercial.bono2;
            datosSave.codigoPolizaGrupo=$scope.comercial.poliza;
            datosSave.nombrePolizaGrupo=$scope.nombrePolizaGrupo;
            datosSave.porcentajePolizaGrupo=$scope.comercial.polizaPorct;
            datosSave.codigoDescEspecial=$scope.comercial.desctEspecial;
            datosSave.nombreDescEspecial=$scope.nombreDescEspecial;
            datosSave.porcentajeDescEspecial=$scope.comercial.desctEspecialPorct;
            // datosSave.codigoProducto= angular.isUndefined($scope.multiriesgo.producto)?null:$scope.multiriesgo.producto;

            datosSave.codigoMoneda=$scope.multiriesgo.moneda;
            datosSave.codigoFraccionamiento=$scope.comercial.fraccion;
            datosSave.importeInicial=$scope.comercial.inicial;
            datosSave.marcaCuotaIgual=$scope.comercial.primeraCuota;

            datosSave.valorCambio=$scope.multiriesgo.cotizacion;

            $scope.coberturaDatos=[];


            for(var i=0; i<$scope.v1.length; i++){

                var obj = {

                    numeroCotizacion:datosSave.numeroCotizacion,
                    codigoCobertura:$scope.v1[i].COD_COB,
                    etiqueta:$scope.v1[i].ETIQUETA,
                    capital:$scope.v1[i].CAPITAL,
                    marcaModificable:$scope.v1[i].MCA_MODIFICABLE
                };

                $scope.coberturaDatos.push(obj);
            }
            for (var i=0; i< $scope.datos.length;i++)
            {
                var obj = {

                    numeroCotizacion:datosSave.numeroCotizacion,
                    codigoCobertura:$scope.datos[i].COD_COB,
                    etiqueta:$scope.datos[i].ETIQUETA,
                    capital:$scope.datos[i].CAPITAL,
                    marcaModificable:$scope.datos[i].MCA_MODIFICABLE
                };

                $scope.coberturaDatos.push(obj);
            }

            datosSave.coberturasMultirriesgo= angular.copy($scope.coberturaDatos);
            $scope.cargando=true;
                    CotizacionMultiRiesgoService.guardarCotizacionMultiriesgo(datosSave).then(
                        function (response) {
                          if(!response.data.error){
                              $scope.buscarCotizacion();
                             


                          }else{
                            $scope.cargando=false;
                            Message.error(response.data.mensaje);
                            //

                          }


                           

                        }).catch(function(response){
                            $scope.cargando=false;
                            Message.error("Ocurrio un error intente nuevamente!");
                        });

            

        };



        $scope.buscarPoliza = function (evt) {
            if (angular.isUndefined(evt)) {
                //Ejecutado cuando $scope.buscar es invocado sin parametros --NO CREOQ QUE HAGA FALTA ESTE CONTROL

            } else {
                //enter
                if (angular.equals(evt.keyCode, 13)) {
                }
            }

        };

        $scope.resetFilter = function () {
            $scope.comercial.inicial = undefined;
        };

        

        var valorGua;
        var valorDol;
        var valorEu;

$scope.promesaMonedas = $q.defer();      
$scope.cargarMonedas = function()
        {
        //primero traemos todas las monedas
        $scope.listaMonedas=[];
        $scope.listaCambio=[];
            var parametros = {};
            parametros.preferencia="N"; //por defecto no tiene preferencia, luego consultar la variable que almacena
            parametros.esNuevo=$scope.esNuevo;
          // parametros.codigoProducto = codigoProducto ;
            CotizacionVehiculoService.getMonedas(parametros).then(
                function (response) {
                    if (response.data.error== false)
                    {
                        if(response.data.dato !== null)
                        {
                             
                            for(var i=0; i<response.data.dato.length; i++){
                                var camb ={
                                    id :  response.data.dato[i].COD_MON,
                                    cambio : response.data.dato[i].VAL_CAMBIO
                                };
                                var obj = {
                                    id:response.data.dato[i].COD_MON,
                                    moneda:response.data.dato[i].NOM_MON
                                };
                                $scope.listaMonedas.push(obj);
                                $scope.listaCambio.push(camb);

                               

                            }
                            $scope.multiriesgo.moneda = 1;
                            $scope.visibleMoneda=false;
                            $scope.promesaMonedas.resolve();
                            $scope.cargando=false;
                            $scope.llamarListadoCoberturas($scope.multiriesgo.moneda);
                            
                        }

                    }
                    else
                    {
                        $scope.promesaMonedas.reject();
                        Message.error(response.data.mensaje);

                    }
                    

                   
                },
                function(response){
                    Message.error(response.data.mensaje);
                    
                });

        };

        $scope.promesaPoliza = $q.defer();
        $scope.cargarPolizaGrupo = function () {
            var parametros = {};
            parametros.esNuevo = $scope.datosGenerales.nuevo;
            parametros.pathModule =$scope.pathModule;
            CotizacionVehiculoService.getPolizaGrupo(parametros).then(
                function (response) {
                    if (response.data.error == false) {
                        if (response.data.dato != null) {
                            for (var i = 0; i < response.data.dato.length; i++) {
                                var dato = {
                                    id: response.data.dato[i].NUM_POLIZA,
                                    porcentaje: response.data.dato[i].PORC_DESCUENTO
                                };

                                var obj = {
                                    id: response.data.dato[i].NUM_POLIZA,
                                    poliza: response.data.dato[i].NOM_POLIZA
                                };
                                $scope.listaGrupoPoliza.push(obj);
                                $scope.datosGrupoPoliza.push(dato);
                            }
                        }

                    }
                    else {
                        Message.error(response.data.mensaje);
                    }

                    $scope.promesaPoliza.resolve();

                },
                function (response) {
                    $scope.promesaPoliza.reject();
                    Message.error(response.data.mensaje);
                    
                });

        };

        $scope.cargarDescuentoEspecial = function () {
            var parametros = {};
            parametros.esNuevo = $scope.datosGenerales.nuevo;
            parametros.pathModule = $scope.pathModule;
            CotizacionVehiculoService.getDescuentosEspeciales(parametros).then(
                function (response) {
                    if (response.data.error == false) {
                        if (response.data.dato != null) {
                            for (var i = 0; i < response.data.dato.length; i++) {

                                var objDatos = {
                                    id: response.data.dato[i].COD_VALOR,
                                    desct: response.data.dato[i].PCT_DESCUENTO
                                };

                                var obj = {
                                    id: response.data.dato[i].COD_VALOR,
                                    desct: response.data.dato[i].NOM_VALOR
                                };
                                $scope.listaDesctEspc.push(obj);
                                $scope.datosDescuentoEspecial.push(objDatos);
                            }
                        }

                    }
                    else {
                        Message.error(response.data.mensaje);
                    }


                },
                function (response) {
                    Message.error(response.data.mensaje);
                    
                });

        };


        $scope.promesaFraccion = $q.defer();
        $scope.cargarFraccionamiento = function () {
            var parametros = {}; //al inicio traer todas las listas de fraccionamiento
            parametros.preferencia = "N";
            parametros.esNuevo = $scope.datosGenerales.nuevo;
            CotizacionVehiculoService.getFraccionamiento(parametros).then(
                function (response) {
                    if (response.data.error == false) {
                        if (response.data.dato != null) {
                            for (var i = 0; i < response.data.dato.length; i++) {
                                var obj = {
                                    id: response.data.dato[i].COD_FRACC_PAGO,
                                    fraccion: response.data.dato[i].NOM_FRACC_PAGO
                                };
                                $scope.listaFraccion.push(obj);
                            }
                            //si tiene preferencia entonces llamar a la preferencia y seleccionar por defecto
                            if ($scope.preferencia_fraccionamiento == "S") {
                                //llamar al servicio que traiga la preferencia
                                parametros = {};
                                parametros.preferencia = $scope.preferencia_fraccionamiento;
                                parametros.esNuevo = $scope.datosGenerales.nuevo;
                                CotizacionVehiculoService.getFraccionamiento(parametros).then(
                                    function (response) {
                                        if (response.data.error == false && response.data.dato != null) {
                                            //se setea el fraccionamiento por defecto
                                            $scope.comercial.fraccion = parseInt(response.data.dato[0].COD_FORMA_PAGO);

                                        }

                                    })

                            }
                            else {
                                $scope.comercial.fraccion = 99100;
                            }
                        }

                    }
                    else {
                        Message.error(response.data.mensaje);
                        
                    }

                    $scope.promesaFraccion.resolve();
                },
                function (response) {
                    $scope.promesaFraccion.reject();
                    Message.error(response.data.mensaje);
                    
                });

        };


       


        var valorSub = 0;
        var valorSubMax;
        var valorSubMin;
        var valorCot;




$scope.llamarListadoCoberturas = function(moneda) {
                 $scope.cargando=true;
                $scope.datosCobertura=[];
                var params = {};
                params.codigoMoneda = moneda;
                
                $scope.limpiarFormasPago();

               CotizacionMultiRiesgoService.getCoberturas(params).then(
                function (response) {
                    if (response.data.error ==false ) {
                        if (response.data.dato != null) {
                             $scope.cargando=true;
                            for (var i = 0; i < response.data.dato.length; i++) {
                                $scope.datosCobertura.push({"COD_COB": response.data.dato[i].codigoCobertura,"ETIQUETA":response.data.dato[i].etiqueta,"CAPITAL":Number(response.data.dato[i].capital), "INCREMENTO": Number(response.data.dato[i].incremento),"MCA_MODIFICABLE":response.data.dato[i].marcaModificable, "MONTO_BASE": Number(response.data.dato[i].minimo), "PORCENTAJE": parseFloat(response.data.dato[i].porcentajeCobertura) } );
                                if(response.data.dato[i].maximo!="" ){
                                    $scope.datosCobertura[i].MAXIMO=Number(response.data.dato[i].maximo);
                                }else{
                                    $scope.datosCobertura[i].MAXIMO=-1;
                                }
                            }
                                if ($scope.esBuscar==false){
                                     $scope.setearCobertura($scope.datosCobertura);

                                }else{
                                     $scope.esBuscar = false;
                                }
                             
                                
                            
                           
                             
                            $scope.cargando=false;
                           
                        }

                    } else{
                        // $scope.sindatos= true;
                        $scope.cargando=false;
                        Message.error(response.data.mensaje);
                        
                    }

                    
                },
                function(response){
                    $scope.cargando=false;
                    
                    Message.error(response.data.mensaje);
                    
                });


         };


        $scope.cambiarMoneda=function()
        {
            if(!angular.isUndefined($scope.multiriesgo.moneda))
            {
                var  parametros ={};
                parametros.esNuevo=$scope.esNuevo;
                 
                parametros.codigoMoneda=$scope.multiriesgo.moneda;
                parametros.codigoRamo=501;
                parametros.numeroCotizacion=!angular.isUndefined($scope.datosGenerales.numeroCotizacion)&& $scope.datosGenerales.numeroCotizacion!=null?$scope.datosGenerales.numeroCotizacion:"";
             
              
        
                    for(var i=0; i<$scope.listaCambio.length; i++){
                        if ($scope.listaCambio[i].id==$scope.multiriesgo.moneda){
                            $scope.multiriesgo.cotizacion = $scope.listaCambio[i].cambio;
                            break;
                        }
                    }
                
                
 



                if($scope.acti){
                    $scope.acti=false;
                }
                $scope.comercial.inicial=undefined;
                $scope.llamarListadoCoberturas($scope.multiriesgo.moneda);

        
        }
        else
        {
            $scope.multiriesgo.cotizacion=null;
            $scope.comercial.inicial=undefined;
        }
        };


     


       

        $scope.$watch('comercial.poliza', function (NewValue, OldValue) {

            if (!angular.isUndefined(NewValue) && NewValue != null) {

                for (var i = 0; i < $scope.datosGrupoPoliza.length; i++) {
                    if ($scope.datosGrupoPoliza[i].id == NewValue) {
                        $scope.comercial.polizaPorct = $scope.datosGrupoPoliza[i].porcentaje;
                        break;
                    }
                }
                for (var i = 0; i < $scope.listaGrupoPoliza.length; i++) {
                    if ($scope.listaGrupoPoliza[i].id == NewValue) {
                        $scope.nombrePolizaGrupo = $scope.listaGrupoPoliza[i].poliza;
                        break;
                    }
                }


            } else {
                $scope.comercial.polizaPorct = "";
            }
            $scope.cambiarRangoDescuento();
        }, true);
        $scope.$watch('comercial.desctEspecial', function (NewValue, OldValue) {

            if (!angular.isUndefined(NewValue) && NewValue != null) {

                for (var i = 0; i < $scope.datosDescuentoEspecial.length; i++) {
                    if ($scope.datosDescuentoEspecial[i].id == NewValue) {
                        $scope.maxDescEspecial = parseInt($scope.datosDescuentoEspecial[i].desct);
                        $scope.comercial.desctEspecialPorct = parseInt($scope.datosDescuentoEspecial[i].desct);
                        break;
                    }
                }
                for (var i = 0; i < $scope.listaDesctEspc.length; i++) {
                    if ($scope.listaDesctEspc[i].id == NewValue) {
                        $scope.nombreDescEspecial = $scope.listaDesctEspc[i].desct;
                        break;
                    }
                }


            } else {
                $scope.comercial.desctEspecialPorct = null;
            }
        }, true);


        $scope.$watch('comercial.fraccion', function (NewValue, OldValue) {

            if (!angular.isUndefined(NewValue)) {

                var parametros = {};


            } else {

            }
        }, true);


        $scope.$watch('datosGenerales.nuevo', function (NewValue, OldValue) {

            if (!angular.isUndefined(NewValue)) {

            } else {

            }


        }, true);


        $scope.showAdvanced = function () {

            $rootScope.codCoti = $scope.datosGenerales.numeroCotizacion;
            $rootScope.monedaAbuscar = $scope.multiriesgo.moneda;
            $rootScope.mostrarBuscadorCotizacion = true;
            $mdDialog.show({
                locals: {parent: $scope},
                controller: 'BuscadorCotizacionCtrl',
                templateUrl: 'partials/ventanas-emergentes/buscador-cotizacion-partial.html',
                parent: angular.element(document.body),
                clickOutsideToClose: false,
                fullscreen: $scope.customFullscreen // Only for -xs, -sm breakpoints.
            }).then(function (answer) {
                $scope.cargando = true;
                $scope.status = 'You said the information was "' + answer + '".';
                if (!angular.isUndefined(answer.numeroCotizacion) && answer.numeroCotizacion != "" && answer.numeroCotizacion != null) {
                    $scope.datosGenerales.numeroCotizacion = parseInt(answer.numeroCotizacion);
                } else {
                    Message.error("Numero de cotizacion inexistente");
                    return;
                }


                $scope.buscarCotizacion();


            }, function () {
                $scope.status = 'You cancelled the dialog.';
                console.log($scope.status);
            });

        };
        $scope.guardadoParcialCabecera = function () {
            var dataVal = {};
           
            dataVal.numeroSolicitud = $scope.multiriesgo.numeroSolicitud;
            dataVal.cerrado = $scope.multiriesgo.cerrado;
         
            dataVal.descuentoComercial = $scope.comercial.desctComercial2;
           
            dataVal.bonus = $scope.comercial.bono2;
            
            dataVal.codigoPolizaGrupo = $scope.comercial.poliza;
            dataVal.nombrePolizaGrupo = $scope.nombrePolizaGrupo;
            dataVal.porcentajePolizaGrupo = $scope.comercial.polizaPorct;
            dataVal.codigoDescEspecial = $scope.comercial.desctEspecial;
            dataVal.nombreDescEspecial = $scope.nombreDescEspecial;
            dataVal.porcentajeDescEspecial = $scope.comercial.desctEspecialPorct;
           // dataVal.codigoProducto = angular.isUndefined($scope.multiriesgo.producto) ? null : $scope.multiriesgo.producto;
           // dataVal.referido = $scope.vehiculo.referido;
            dataVal.codigoMoneda = $scope.multiriesgo.moneda;
            dataVal.codigoFraccionamiento = $scope.comercial.fraccion;
            dataVal.importeInicial = $scope.comercial.inicial;
            dataVal.marcaCuotaIgual = $scope.comercial.primeraCuota;
            dataVal.marcaFlota = 'N';
            dataVal.cambio = $scope.multiriesgo.cotizacion;
            //console.log("Numero de cotizacion ",$scope.datosGenerales.numeroCotizacion);
            dataVal.numeroCotizacion = $scope.datosGenerales.numeroCotizacion;
            return CotizacionVehiculoService.guardadoParcialCabecera(dataVal).then(
                function (response) {
                    return response.data;
                });
        };

        $scope.cargarListadoFormaPago = function () {
            //console.log("Costo vehiculo ",$scope.listaForamaPago);
            if ($scope.listaFormaPago != null && $scope.listaFormaPago.length > 0) {
                //console.log("Entra aca");
                $scope.sindatost = true;
                 
            }
            else {
                $scope.sindatost = false;
            }
            //$scope.cargando = false;
            // console.log("sIN DATOS TABLA", $scope.sindatost);

        };
        $scope.limpiarDatos = function () {
            $scope.obtenerCamposEditables();
            $scope.multiriesgo.moneda = undefined;
         //   $scope.vehiculo.monto = "2000";
         
            $scope.multiriesgo.cerrado = undefined;
            $scope.multiriesgo.numeroSolicitud = undefined;
            // $scope.datosSubmodelo = [];
            // $scope.listaSubModelos = [];
            //combo comercial
            $scope.comercial.desctComercial = undefined;
            $scope.comercial.desctP = "1";
            $scope.comercial.desctEspecial = undefined;
            $scope.comercial.desctComercial2 = undefined;
            $scope.comercial.recComercial = undefined;
            $scope.comercial.fraccion = undefined;
            $scope.comercial.cuota = "S";
            $scope.comercial.poliza = undefined;
            $scope.comercial.polizaDescripcion = "";
            $scope.comercial.bono = undefined;
            $scope.comercial.bono2 = null;
            //$scope.comercial.malus=null;
            $scope.comercial.inicial = undefined;
            $scope.comercial.primeraCuota = undefined;
            $scope.comercial.polizaPorct = undefined;
            $scope.cobertura.cartaVerde = true;
            $scope.cobertura.cartaAzul = false;
           // $scope.multiriesgo.producto = undefined;
            $scope.datosGenerales.numeroPropuesta = "";
            $scope.cobertura.minMonto = 0;
            $scope.cobertura.maxMonto = 0;
            $scope.debitoAutomatico = {};
            $scope.debitoAutomatico.prima = "0";
            $scope.debitoAutomatico.costoTotal = "0";
            $scope.debitoAutomatico.cuota = "0";
            $scope.debitoAutomatico.ultimaCuota = "0";

            $scope.contado = {};
            $scope.contado.prima = "0";
            $scope.contado.costoTotal = "0";

            // $scope.chequera = {};
            // $scope.chequera.prima = "0";
            // $scope.chequera.costoTotal = "0";
            // $scope.chequera.cuota = "0";
            // $scope.chequera.ultimaCuota = "0";
            $scope.desctComercial = false;
            $scope.recComercial = false;
            $scope.coberturaDatos = [];
            $scope.minDescRec = -100;
            $scope.maxDescRec = 100;

        };
        $scope.actualizarGTOSMED=function(etiqueta,nuevoValor){
            if(etiqueta=="OVP MUERTE"){

                for(var i=0;i<$scope.v1.length;i++){
                    if($scope.v1[i].ETIQUETA=="OVP GTOS MED"){
                        $scope.v1[i].MONTO_BASE=Math.ceil(nuevoValor*$scope.v1[i].PORCENTAJE);
                    }
                }
                for(var i=0;i<$scope.datos.length;i++){
                    if($scope.datos[i].ETIQUETA=="OVP GTOS MED"){
                        $scope.datos[i].MONTO_BASE=Math.ceil(nuevoValor*$scope.datos[i].PORCENTAJE);
                    }
                }
            }
        };
        $scope.buscarCotizacion = function() {

            //console.log("Buscar");

            if ($scope.datosGenerales.numeroCotizacion!=null)
            {
              

                $scope.cargando=true;
                $scope.esBuscar=true;
              
                var datosBuscador={};
                datosBuscador.numeroCotizacion=$scope.datosGenerales.numeroCotizacion;
                datosBuscador.pathModule = $scope.pathModule;
                datosBuscador.codigoAgente = null;
                datosBuscador.codigoRol = null;
                datosBuscador.codigoRamo = null;
              
                $scope.persistirProducto=false;
                $scope.persistir=false;

               
                $scope.esNuevo ="N";
                $scope.limpiarDatos();
              
                $timeout( function(){
                    CotizacionMultiRiesgoService.getCotizacionMultiriesgo(datosBuscador).then(

                        function (response) {

                            if(!response.data.error)
                            {

                                $scope.habilitarPropuesta=true;
                                $scope.bloquearBuscador=true;
                                $scope.editablesDescPoliza=false;

                                if(!angular.isUndefined(response.data.dato) && response.data.dato != null){

                                    //if(response.data.dato.length >0){
                                        //$scope.cargarPlataforma();

                                       // $scope.promesaCambioEnMoneda.promise.$$state.status = 0;
                                       // $scope.promesaMonedas.promise.$$state.status = 0;
                                       
                                      


                                         if (response.data.dato.seguridad.length>0)
                                        {
                                            var seguridadSelect=response.data.dato.seguridad;
                                            for (var i=0; i<seguridadSelect.length;i++)
                                            {
                                                if (seguridadSelect[i].campo=="extintores")
                                                {
                                                    $scope.seguridad.extintores=seguridadSelect[i].check;

                                                }
                                                else if (seguridadSelect[i].campo=="bocaIncendio")
                                                {
                                                    $scope.seguridad.bocaIncendio=seguridadSelect[i].check

                                                }
                                                else if (seguridadSelect[i].campo=="redHidrantes")
                                                {
                                                    $scope.seguridad.redHidrantes=seguridadSelect[i].check

                                                }
                                                else if (seguridadSelect[i].campo=="alarmaSonora")
                                                {
                                                    $scope.seguridad.alarmaSonora=seguridadSelect[i].check
                                                }
                                                else if (seguridadSelect[i].campo=="empresaRespaldo")
                                                {
                                                    $scope.seguridad.empresaRespaldo=seguridadSelect[i].check
                                                }
                                                else if (seguridadSelect[i].campo=="sensorHumo")
                                                {
                                                    $scope.seguridad.sensorHumo=seguridadSelect[i].check
                                                }
                                                else if (seguridadSelect[i].campo=="guardias")
                                                {
                                                    $scope.seguridad.guardias=seguridadSelect[i].check
                                                }
                                                else if (seguridadSelect[i].campo=="rociadores")
                                                {
                                                    $scope.seguridad.rociadores=seguridadSelect[i].check
                                                }
                                                else if (seguridadSelect[i].campo=="circuitoCerrado")
                                                {
                                                    $scope.seguridad.circuitoCerrado=seguridadSelect[i].check
                                                }
                                                else if (seguridadSelect[i].campo=="sensorMovimiento")
                                                {
                                                    $scope.seguridad.sensorMovimiento=seguridadSelect[i].check
                                                }
                                                else if (seguridadSelect[i].campo=="funcionanDispositivos")
                                                {
                                                    $scope.seguridad.funcionanDispositivos=seguridadSelect[i].check
                                                }
                                                else if (seguridadSelect[i].campo=="otros")
                                                {
                                                    $scope.seguridad.otros=seguridadSelect[i].check
                                                }
                                                else  {
                                                    $log.debug("Este check no esta previsto ", seguridadSelect[i])
                                                }

                                            }

                                            //seguridadSelect.extintores=
                                        }
                                         $scope.fechaVigenciaDesde = angular.isUndefined(response.data.dato.fechaEfectoPoliza) ? undefined : response.data.dato.fechaEfectoPoliza != undefined ? $scope.convertirDate(response.data.dato.fechaEfectoPoliza) : undefined;
                                         $scope.fechaVigenciaHasta = angular.isUndefined(response.data.dato.fechaVencimientoPoliza) ? undefined : response.data.dato.fechaVencimientoPoliza != undefined ? $scope.convertirDate(response.data.dato.fechaVencimientoPoliza) : undefined;

                                         // $scope.promesaMonedas.promise.then(
                                         //    function () {
                                                
                                                 
                                         //    });
                                        
                                        $scope.multiriesgo.moneda = parseInt(response.data.dato.codigoMoneda);
                                        $scope.multiriesgo.cotizacion =parseInt(response.data.dato.valorCambio);
                                         
                                         ;
                                         for (var i=0;i<  $scope.listaOcupacion.length;i++){
                                              if ($scope.listaOcupacion[i].idOcupacion == response.data.dato.codigoOcupacion){
                                                  $scope.multiriesgo.ocupacion = $scope.listaOcupacion[i].idOcupacion;
                                                  break;
                                              }

                                         }
                                         $scope.multiriesgo.ciudadId = response.data.dato.codigoCiudad+'-'+response.data.dato.codigoBarrio;
                                          

                                       
                                        $scope.promesaPoliza.promise.then(
                                            function(){
                                                if (response.data.dato.codigoPolizaGrupo!=null && response.data.dato.codigoPolizaGrupo !=""){
                                                    $scope.comercial.poliza=response.data.dato.codigoPolizaGrupo;
                                                }else {
                                                    $scope.comercial.poliza=undefined; 
                                                }
                                                
                                            }
                                        );

                                        if (response.data.dato.codigoDescEspecial != null && response.data.dato.codigoDescEspecial != ""){
                                             $scope.comercial.desctEspecial=response.data.dato.codigoDescEspecial;
                                        }else{
                                             $scope.comercial.desctEspecial=undefined;
                                        }
                                       
                                        if (response.data.dato.descuentoComercial != null)
                                        {
                                            $scope.desctComercial=true;
                                        }
                                        $scope.comercial.desctComercial2=response.data.dato.descuentoComercial!=null && response.data.dato.descuentoComercial!=""?parseInt(response.data.dato.descuentoComercial):undefined;
                                        //$scope.comercial.recComercial=response.data.dato[0].recargoComercial;
                                        $scope.promesaFraccion.promise.then(
                                            function(){
                                                if(response.data.dato.codigoFraccionamiento!= ""){
                                                    $scope.comercial.fraccion=parseInt(response.data.dato.codigoFraccionamiento);
                                                }else{
                                                    $scope.comercial.fraccion=null;
                                                }

                                            }
                                        );
                                        $scope.datosGenerales.numeroCotizacion =parseInt(response.data.dato.numeroCotizacion);
                                        $scope.datosGenerales.nuevo=response.data.dato.marcaRenovacion;
                                        $scope.comercial.primeraCuota=response.data.dato.marcaCuotaIgual==null?'N':response.data.dato.marcaCuotaIgual;
                                        $scope.comercial.inicial=response.data.dato.importeInicial;
                                        //$scope.comercial.malus =response.data.dato.malus;
                                        $scope.comercial.bono2=response.data.dato.bonus;
                                       // $scope.comercial.envioDigital=response.data.dato.marcaEnvioDigital
                                        $scope.datosGenerales.numeroPropuesta=response.data.dato.numeroPropuesta!=null && response.data.dato.numeroPropuesta!=""? response.data.dato.numeroPropuesta:"";
                                        
                                        //$scope.multiriesgo.cerrado = response.data.dato.cerrado;


                                        $scope.listaFormaPago=[];
                                        $scope.listaFormaPago =response.data.dato.costosMultirriesgos;


                                        for(var i=0; i<$scope.listaCambio.length; i++){
                                            if ($scope.listaCambio[i].id==$scope.multiriesgo.moneda){
                                                $scope.multiriesgo.cotizacion = $scope.listaCambio[i].cambio;
                                                break;
                                            }
                                        }
                                       // $scope.multiriesgo.cotizacion=!angular.isUndefined(response.data.dato.cambio)&& response.data.dato.cambio!=null?parseInt(response.data.dato.cambio):1;

                                         //llamar a un metodo que cargue la cobertura de esta cotizacion
                                        $scope.datosCobertura=[];
                                        if (response.data.dato.coberturasMultirriesgo.length>0 && response.data.dato.coberturasMultirriesgo!= null)
                                                {
                                                    //$scope.mostrarCartas=true;
                                                for (var i=0; i< response.data.dato.coberturasMultirriesgo.length; i++)
                                                {
                                                      
                                                    if  (response.data.dato.coberturasMultirriesgo[i].etiqueta=='INCENDIO EDIFICIO'){

                                                         $scope.montoIncendioEdificio = response.data.dato.coberturasMultirriesgo[i].capital == null?"" :response.data.dato.coberturasMultirriesgo[i].capital;
                                                    }
                                                    $scope.datosCobertura.push({"COD_COB": response.data.dato.coberturasMultirriesgo[i].codigoCobertura,"ETIQUETA":response.data.dato.coberturasMultirriesgo[i].etiqueta,"CAPITAL":Number(response.data.dato.coberturasMultirriesgo[i].capital),"MAXIMO":Number(response.data.dato.coberturasMultirriesgo[i].maximo), "INCREMENTO": Number(response.data.dato.coberturasMultirriesgo[i].incremento),"MCA_MODIFICABLE":response.data.dato.coberturasMultirriesgo[i].marcaModificable, "MINIMO": Number(response.data.dato.coberturasMultirriesgo[i].minimo),"MCA_REQUERIDO":response.data.dato.coberturasMultirriesgo[i].marcaRequerido } );
                                                    if(response.data.dato.coberturasMultirriesgo[i].maximo!="" ){
                                                        $scope.datosCobertura[i].MAXIMO=Number(response.data.dato.coberturasMultirriesgo[i].maximo);
                                                    }else{
                                                        $scope.datosCobertura[i].MAXIMO=-1;
                                                    }

                                                }
                                                $scope.setearCobertura($scope.datosCobertura);
                                                    
                                            }
                                            else
                                            {

                                                $scope.cargando=false;
                                        }
 
                                        $q.all( [
                                           $scope.promesaPoliza.promise.then() , $scope.promesaFraccion.promise.then()
                                        ] ).then(function(sucess){
                                           // $scope.datosGenerales.numeroPropuesta=response.data.dato[0].sumaAsegurada;
                                            $scope.cargarListadoFormaPago();
                                        });



                                   // }

                                }else{
                                    Message.error(response.data.mensaje);
                                    $scope.cargando=false;
                                    
                                }
                            }else{
                                $scope.habilitarPropuesta=false;
                                $scope.recargar();
                                Message.error(response.data.mensaje);
                                $scope.cargando=false;
                               

                            }





                        },
                        function(response){
                            $scope.persistirProducto=true;
                            $scope.persistir=true;
                            Message.error(response.data.mensaje);
                            
                        });

                }, 2000 );


            }
            
            

             
        };



         $scope.promesaTipoOcupacion = $q.defer();
         $scope.cargarTipoOcupacion = function () {

            CotizacionMultiRiesgoService.getOcupacion().then(function (response) {
                    if (!response.data.error) {
                        if (response.data.dato.length > 0) {
                           $scope.listaOcupacion=[];
                           for (var i = 0; i < response.data.dato.length; i++) {
                                var objTipoOcupacion = {
                                    idOcupacion: response.data.dato[i].codigoOcupacion,
                                    descripcionOcupacion: response.data.dato[i].nombreOcupacion
                                };
                                $scope.listaOcupacion.push(objTipoOcupacion);
                           }
                           $scope.promesaTipoOcupacion.resolve();
                        }

                   }else{
                       $scope.promesaTipoOcupacion.resolve();
                       Message.error(response.data.mensaje);
                   }


                    
            }).catch(function (response) {
                    $scope.promesaTipoOcupacion.reject();
                     
                    
                    Message.error("No se pudo obtener lista de ocupacion.");
             });

        };

    $scope.obtenerCiudades=function(){   
        CotizacionMultiRiesgoService.getCiudades().then(function (response){
            if (response.data.dato.length>0)
            {
                var data=response.data.dato;
                for (var i=0; i<data.length;i++)
                {
                   var obj = {
                     id :  data[i].codigoCiudad +'-'+data[i].codigoBarrio,
                     codigoCiudad : data[i].codigoCiudad,
                     codigoBarrio : data[i].codigoBarrio,
                     nombreCiudad : data[i].nombreCiudad
                    };
                    $scope.ciudades.push(obj);
                     
                }

                 
               
            }
            
        });

    };
        


        /**
         * Constructor / Entrypoint
         * @constructor
         */
        $scope.cargarCombos = function () {
            $scope.cargarTipoOcupacion();
            $scope.cargarPolizaGrupo();
            $scope.cargarFraccionamiento();
            $scope.cargarDescuentoEspecial();
            $scope.cargarMonedas();
            $scope.obtenerCiudades();
          


        };

        $scope.recargar = function () {

            if (typeof $routeParams.numeroCotizacion != "undefined") {
                $location.search('numeroCotizacion', undefined);
                $rootScope.numeroCotizacionRoot = undefined;
                $location.path('cotizacion-vehiculo')

            }
            else {
                $route.reload();
            }


        };


        

        function numberFormat(numero) {
            // Variable que contendra el resultado final
            var resultado = "";
            var nuevoNumero = numero;
            // Si tiene decimales, se los quitamos al numero
            if (numero.indexOf(".") >= 0)
                nuevoNumero = numero.substring(0, numero.indexOf("."));

            // Ponemos un punto cada 3 caracteres
            for (j, i = nuevoNumero.length - 1, j = 0; i >= 0; i-- , j++)
                resultado = nuevoNumero.charAt(i) + ((j > 0) && (j % 3 == 0) ? "." : "") + resultado;

            // Si tiene decimales, se lo añadimos al numero una vez forateado con
            // los separadores de miles
            if (numero.indexOf(".") >= 0)
                resultado += "," + numero.substring(numero.indexOf(".") + 1);

            if (numero[0] == "-") {
                // Devolvemos el valor añadiendo al inicio el signo negativo
                return "-" + resultado;
            } else {
                return resultado;
            }
        }


        $scope.actualizarCotizacion = function () {
            // console.log("Valor de suma agregada ", $scope.datosGenerales.numeroPropuesta);
            //$scope.validarNumero();
            $scope.cargando=true;
          //  if ($scope.datosGenerales.numeroPropuesta != undefined && $scope.datosGenerales.numeroPropuesta != null) {
                var parametros = {};
                parametros.esNuevo = $scope.datosGenerales.nuevo;
               
                parametros.codigoMoneda = $scope.multiriesgo.moneda;
                parametros.codigoRamo = 501;
                parametros.numeroCotizacion = $scope.datosGenerales.numeroCotizacion;
                //$scope.recalcularCotizacion(parametros);
           // }
           // else
           // {
                $scope.cargando=false;
           // }


        };
        $scope.validarNumero = function () {
            console.log($scope.restriccion.match($scope.datosGenerales.numeroPropuesta));
        };
       
         $scope.cambiarRangoDescuento = function () {
            if (!angular.isUndefined($scope.comercial.poliza) && $scope.comercial.poliza != null) {
                var roles=sessionStorage.getItem("roles");
                if (roles !="" && roles.indexOf("TECAUT")>0)
                {
                    $scope.minDescRec=-100;
                    $scope.maxDescRec=100;
                }
                else
                {
                    $scope.minDescRec=0;
                    $scope.maxDescRec=100;
                }

            }
            else {
                $scope.minDescRec = -100;
                $scope.maxDescRec = 100;
            }
        };
        $scope.verificarMontoCobertura = function (cobertura) {
            //console.log("Los datos de cobertura son ", cobertura);
            var montoActual = cobertura.MONTO_BASE
            if (montoActual > cobertura.MAXIMO && cobertura.MAXIMO > 0) {
                cobertura.MONTO_BASE = cobertura.MAXIMO;
            }
            else if (montoActual < cobertura.CAPITAL) {
                cobertura.MONTO_BASE = cobertura.CAPITAL;
            }
            else {
                cobertura.MONTO_BASE = montoActual;
            }
        };
       $scope.incrementarCobertura=function (cobertura){
    //console.log("La cobertura es ", cobertura);
        var montoActual=cobertura.CAPITAL;
       // console.log("La cobertura es ", montoActual);
        if (montoActual>= cobertura.MAXIMO && cobertura.MAXIMO>0)
        {
            cobertura.CAPITAL=cobertura.MAXIMO;
        }
        else
        {
            cobertura.CAPITAL+=cobertura.INCREMENTO;
        }
        $scope.montoIncendioEdificio=cobertura.CAPITAL;
        $scope.llamarListadoCoberturas($scope.multiriesgo.moneda);
};
$scope.decrementarCobertura=function (cobertura)
{
   //console.log("La cobertura es en decremento ", cobertura);
    var montoActual = cobertura.CAPITAL;
    if (montoActual <= cobertura.MONTO_BASE){
        cobertura.MONTO_BASE = cobertura.CAPITAL;
    }
    else{
        cobertura.CAPITAL-=cobertura.INCREMENTO;
    }
        $scope.montoIncendioEdificio=cobertura.CAPITAL;
        $scope.llamarListadoCoberturas($scope.multiriesgo.moneda);

};

        $scope.limpiarFormasPago = function () {
            
            $scope.listaFormaPago=null;
            // $scope.debitoAutomatico = {};
            // $scope.debitoAutomatico.prima = "0";
            // $scope.debitoAutomatico.costoTotal = "0";
            // $scope.debitoAutomatico.cuota = "0";
            // $scope.debitoAutomatico.ultimaCuota = "0";

            // $scope.contado = {};
            // $scope.contado.prima = "0";
            // $scope.contado.costoTotal = "0";

            // $scope.chequera = {};
            // $scope.chequera.prima = "0";
            // $scope.chequera.costoTotal = "0";
            // $scope.chequera.cuota = "0";
            // $scope.chequera.ultimaCuota = "0";

             $scope.sindatost=false;
        };
        $scope.setearCobertura=function(coberturas)
        {
            $scope.sindatos=false;
            
            $scope.v1=[];
            $scope.v2=[];
            $scope.datosCobertura=[];
            $scope.datos=[];
          
            var CV,CA;
            CA=0,CV=0;
            $scope.datosCobertura=angular.copy(coberturas);
           // $scope.cartas=[];

         //   $scope.datos = angular.copy($scope.datosCobertura);

            for(var i=0;i<$scope.datosCobertura.length;i++)
            {
 
                    $scope.datos.push($scope.datosCobertura[i]);
                
            }
            $scope.datosCobertura=angular.copy($scope.datos);

            if($scope.datosCobertura.length<=6){
                var i=0;
                while($scope.datos.length>0 && $scope.v1.length<=6){
                    $scope.v1.push($scope.datos[i]);
                    // i++;
                    $scope.datos.splice(0,1);
                };
            }else{
                var cant = Math.trunc($scope.datosCobertura.length/2);
                var resto = $scope.datosCobertura.length%2;
                var cantxColum = cant + resto;
                var i=0;
                var temp =[];
                temp=angular.copy($scope.datos);
                while(temp.length>0 && $scope.v1.length< cantxColum){
                    $scope.v1.push(temp[i]);
                    $scope.datos.splice(0,1);
                    i++;
                };


            }

             $scope.cargarListadoFormaPago();
            $scope.cargando=false;


        };
        


        /**
         * Función creada para el salto de cotización a propuesta
         */
        $scope.goToPropuesta = function () {
            var path = $location.$$absUrl;
            var n = path.search("module");
            var url = path.substring(0, n);

            if (typeof $scope.datosGenerales.numeroCotizacion != 'undefined' && $scope.datosGenerales.numeroCotizacion != null) {
               // location.href = 'propuesta-vehiculo/propuesta/' + $scope.datosGenerales.numeroCotizacion;
            } else {
                Message.warning("Debe ingresar un número de cotización");
            }

            /*descargar carta oferta*/
        };
        /*descargar carta oferta*/
        $scope.descargarCartaOferta = function () {

           
            var url = App.URL_BASE + 'impresion/multirriesgo/cartaoferta/ie?numeroCotizacion=' + $scope.datosGenerales.numeroCotizacion;
            //$scope.mostrarPDF(url, "carta_oferta");
            window.open(url);
        };
        $scope.descargarCartaVerde = function () {

            var url = App.URL_BASE + 'impresion/cartaverde/ie?numeroCotizacion=' + $scope.datosGenerales.numeroCotizacion;
            window.open(url);
            //$scope.mostrarPDF(url, "carta_verde");
        };


        $scope.descargarCartaPropuesta = function () {
            //window.open(App.URL_BASE+'impresion/propuesta?numeroCotizacion='+$scope.datosGenerales.numeroCotizacion);
            var url = App.URL_BASE + 'impresion/propuesta/ie?numeroCotizacion=' + $scope.datosGenerales.numeroCotizacion;
            //$scope.mostrarPDF(url, "carta_propuesta");
            window.open(url);
        };

        $scope.descargarCartaCobertura = function () {
            //window.open(App.URL_BASE+'impresion/certificadocobertura?numeroCotizacion='+$scope.datosGenerales.numeroCotizacion);
            var url = App.URL_BASE + 'impresion/certificadocobertura/ie?numeroCotizacion=' + $scope.datosGenerales.numeroCotizacion;
          //  $scope.mostrarPDF(url, "carta_cobertura");
            window.open(url);
        };

        $scope.verificarCamposForm = function (listaCampo, campo) {
            return UtilsService.verificarCamposForm(listaCampo, campo);
        };

        $scope.mostrarPDF = function (url, nombre) {
            $scope.cargando = true;
            CotizacionVehiculoService.getPdf(url).then(
                function (response) {
                    $scope.cargando = false;
                    $scope.nombrePDF = nombre + ".pdf";
                   // var data =  btoa(unescape(encodeURIComponent(response.data)));
                    var pdf = 'data:application/octet-stream;base64,' + response.data ;
                    var dlnk = document.getElementById('downloadPDF');
                    dlnk.download = $scope.nombrePDF;
                    dlnk.href = pdf;
                    dlnk.click();

                }).catch(function (response) {
                $scope.cargando = false;
                Message.error(response.data.mensaje);
            });
        };

        $scope.cargarPlataforma = function () {

            var paramPla = {};
            paramPla.numeroCotizacion = $scope.datosGenerales.numeroCotizacion;

            CotizacionVehiculoService.getPlataforma(paramPla).then(
                function (response) {
                    if (!response.data.error) {
                        if (response.data.dato != null) {

                            $scope.mostrarPlataforma = true;

                            $scope.datosGenerales.plataforma = response.data.dato.mensaje;


                        }

                    }


                }).catch(function (response) {

                Message.error(response.data.mensaje);

            });
        };
        $scope.obtenerAutorizaciones = function () {

            $scope.autorizacionesList = [];
            var param={};
            param.pathModule=UtilsService.retornarPath($location.path().split("/")[1]);
            CotizacionVehiculoService.getAutorizaciones(param).then(function (response) {
                if (!response.data.error) {
                    if (response.data.dato.length > 0) {
                        var campos = response.data.dato;
                        for (var i = 0; i < campos.length; i++) {
                            $scope.autorizacionesList.push(campos[i]);
                            if (campos[i] === 'btnEliminar') {
                                $rootScope.botonEliminar = true;

                            }
                        }
                    }

                    //console.log("Lista Autorizaciones: " + JSON.stringify($scope.autorizacionesList));
                }
                else {
                    Message.error(response.data.mensaje);
                }
            });
        };
        $scope.obtenerCamposEditables = function () {
            $scope.camposEditablesList = [];
            var params = {};
            params.marcaFlota = "N";

            params.numeroCotizacion = angular.isUndefined($scope.datosGenerales.numeroCotizacion) || $scope.datosGenerales.numeroCotizacion == null ? "" : $scope.datosGenerales.numeroCotizacion;
            params.pathModule =$scope.pathModule;
            CotizacionVehiculoService.getCamposEditables(params).then(function (response) {
                if (!response.data.error) {
                    if (response.data.dato.length > 0) {
                        var campos = response.data.dato;
                        for (var i = 0; i < campos.length; i++) {
                            $scope.camposEditablesList.push(campos[i]);
                        }
                    }
                    //console.log("Campos editables ", $scope.camposEditablesList);
                }
                else {
                    Message.error(response.data.mensaje);
                }
            });
        };

        $scope.emitirDocumento = function () {
            $scope.emitir = true;
        };

        $scope.$watch('multiriesgo.ciudadId', function(NewValue, OldValue,scope) {

            
            if(!angular.isUndefined(NewValue) && $scope.multiriesgo.ciudadId !=null ){

                for(var i=0; i<$scope.ciudades.length; i++){
                    if ($scope.ciudades[i].id==NewValue){
                        $scope.multiriesgo.codigoCiudad = $scope.ciudades[i].codigoCiudad;
                        $scope.multiriesgo.barrio= $scope.ciudades[i].codigoBarrio;
                        
                        break;
                    }
                }
                


            }
        },true);

          $scope.$watch('fechaVigenciaDesde', function (NewValue, OldValue) {
                if (!angular.isUndefined(NewValue) && NewValue != null) {
                    // if (NewValue != OldValue) {
                        var dato = moment(NewValue).format("DD/MM/YYYY");
                        var param={};
                        param.fechaVigencia=dato;
                        param.pathModule=$scope.pathModule;
                        PropuestaService.obtenerFechaVigenciaHasta(param).then(function(response){
                            if (!response.data.error)
                            {
                                if (response.data.dato!=null)
                                {
                                    $scope.fechaVigenciaHasta=$scope.convertirDate(response.data.dato.fechaVencimientoPoliza);
                                }
                            }
                            else
                            {
                                Message.error(response.data.mensaje);
                            }
                        });
                      

                } else if (NewValue == null) {
                    $scope.fechaVigenciaHasta = undefined;

                }

            }, true);

        $scope.llamarModal = function (value) {

            if (!angular.isUndefined($scope.datosGenerales.numeroCotizacion) && $scope.datosGenerales.numeroCotizacion != null && $scope.datosGenerales.numeroCotizacion != "") {
                $rootScope.numCotiza = $scope.datosGenerales.numeroCotizacion;
                $rootScope.autEsNuevo = $scope.datosGenerales.nuevo;
                $rootScope.modalCotizadorVehFlota = value;
                $rootScope.flagVehiculoFlota = true;
                $scope.autorizacion = true;
                $rootScope.mostrarMovil = true;
                $mdDialog.show({
                    //locals:{mobile: $scope.esMobile},

                    controller: 'ModalAutorizacionCtrl',
                    templateUrl: 'partials/ventanas-emergentes/modal-autorizacion-partial.html',
                    parent: angular.element(document.querySelector('#autorizacion_div')),
                    multiple: true,
                    clickOutsideToClose: false,
                    /* scope:$scope,
                     preserveScope: true,*/
                    fullscreen: $scope.customFullscreen // Only for -xs, -sm breakpoints.

                }).then(function (answer) {

                    /* $scope.cargando=true;
                     console.log("Entra aca ");
                    $scope.status = 'You said the information was "' + answer + '".';
                    if (!angular.isUndefined(answer.numeroCotizacion) && answer.numeroCotizacion !="" && answer.numeroCotizacion!= null){
                        $scope.datosGenerales.numeroCotizacion = parseInt(answer.numeroCotizacion);
                    }else{
                         Message.error("Numero de cotizacion inexistente");
                         return;

                    }*/


                    $scope.buscarCotizacion();


                }, function () {
                    $scope.status = 'You cancelled the dialog.';
                    console.log($scope.status);
                });
            }

        };
        $scope.atrasSiguiente = function () {


            $scope.data.seccion = parseInt($scope.data.seccion) + 1;


            console.log($scope.data.seccion);
        };
        $scope.siguienteAtras = function () {

            $scope.data.seccion = parseInt($scope.data.seccion) - 1;


            console.log($scope.data.seccion);
        };


        (function initialize() {

            $scope.sindatos=true;
            $scope.sindatost=false;
            $scope.comercial.primeraCuota='S';
            $scope.comercial.envioDigital='S';
            $scope.flagConfirmacion=true;
            $scope.persistir= true;
            $scope.esBuscar= false;
            $scope.persistirProducto=true;
            $scope.listaForamaPago=[];
            $scope.mostrarCartas=false;
            $scope.controlRequerido = false;
            $scope.listaFormaPago=[];
            $scope.pathModule = UtilsService.retornarPath($location.path().split("/")[1]);
            $scope.menus= [
                {id: '1', name: 'Datos Generales'},
                {id: '2', name: 'Multiriesgo'},
                {id: '3', name: 'Sistemas de Seguridad'},
                {id: '4', name: 'Descuentos/Recargo en %'},
                {id: '5', name: 'Cobertura'},
                {id: '6', name: 'Formas de Pago'}
            ];
            angular.extend(this, $controller('UtilsCtrl', {
                    "$scope": $scope
            }));
            $scope.obtenerCamposEditables();
            
            $scope.obtenerAutorizaciones();
            $scope.fechaVigenciaDesde = new Date();
       
           
            $scope.data.seccion='1';
            $scope.multiriesgo.cotizacion=null;
            $scope.botonEliminar = undefined;
            $scope.montoIncendioEdificio =null;

            $scope.pathModule = UtilsService.retornarPath($location.path().split("/")[1]);
            $scope.cargarCombos();

           

            /**
             * Verifica si la ventana fue llamada desde propuesta
             */
            if(typeof $routeParams.numeroCotizacion != "undefined"){

                $rootScope.numeroCotizacionRoot = $routeParams.numeroCotizacion;
                $scope.datosGenerales.numeroCotizacion=$rootScope.numeroCotizacionRoot;
                $scope.buscarCotizacion();
            }

        })();


    }]);



;
app.controller('CotizacionVehiculoFormCtrl', ['$scope', '$q','CotizacionVehiculoService', '$controller', '$routeParams', '$location', 'SessionService', '$rootScope','$route', '$mdDialog', '$filter', 'ConfirmService', '$window','BuscadorCotizacionService','UtilsService','$locale','PropuestaService','UtilsService','$timeout','$log','DialogService',
    function ($scope,$q, CotizacionVehiculoService, $controller, $routeParams, $location, sessionService, $rootScope,$route, $mdDialog,  $filter, confirmService, $window,BuscadorCotizacionService, UtilsService, $locale, PropuestaService, UtilsService, $timeout, $log, DialogService) {

        /**
         * Url del recurso
         * @field
         * @type {Object}
         */
        $rootScope.rootPathParent =$route.current.$$route.originalPath;
        $scope.service=PropuestaService;
        $locale.NUMBER_FORMATS.GROUP_SEP = '.';
        $locale.NUMBER_FORMATS.DECIMAL_SEP=',';
        $scope.controlPermisos = true;

        $scope.nombre = "Cotizacion Vehiculos";
        $scope.status = '  ';
        $scope.customFullscreen = false;
        $scope.mostrarDocumento = {};


        $scope.listaMarcas =[];
        $scope.datosSubmodelo=[];
        $scope.listaCambio=[];
        var parametros = {};

        // combos vehiculos
        $scope.listaGrupoPoliza = [];

        $scope.years = [];

        $scope.listaMonedas = [];
        $scope.datosGrupoPoliza=[];
        $scope.datosDescuentoEspecial=[];
        //combo comercial
        $scope.listaProductos = [];
        $scope.listaPolizas = [];
        $scope.listaDesctComercial = [];

        $scope.listaDesctEspc = [];

        $scope.listaFraccion = [];

        /*datos generales*/
        $scope.datosGenerales = {};
        $scope.datosGenerales.nuevo ="N";
        $scope.datosGenerales.numeroPoliza=undefined;
        $scope.datosGenerales.numeroPolizaAnterior =undefined;
        $scope.datosGenerales.numeroCotizacion=null;

        /*vehiculos*/
        $scope.vehiculo = {};
        $scope.vehiculo.concecionaria=undefined;
        $scope.vehiculo.acrPrendario=undefined;
        $scope.vehiculo.marca=undefined;
        $scope.vehiculo.subModelo=undefined;
        $scope.vehiculo.ocupantes=undefined;
        $scope.vehiculo.moneda=undefined;
        $scope.vehiculo.monto="2000";
        $scope.vehiculo.referido='N';
        $scope.vehiculo.modelo=undefined;
        $scope.vehiculo.anho=undefined;
        $scope.vehiculo.tipo=undefined;
        $scope.vehiculo.cotizacion="";
        $scope.vehiculo.nombreMarca=undefined;

        /*comercial*/
        $scope.comercial = {};

        $scope.comercial.desctComercial=undefined;
        $scope.comercial.desctP="1";
        $scope.comercial.desctEspecial=undefined;
        $scope.comercial.desctComercial2=undefined;
        $scope.comercial.recComercial=undefined;
        $scope.comercial.fraccion=undefined;
        $scope.comercial.cuota="S";
        $scope.comercial.poliza=undefined;
        $scope.comercial.polizaDescripcion="";
        $scope.comercial.bono=undefined;
        $scope.comercial.bono2=null;
        //$scope.comercial.malus=null;
        $scope.comercial.inicial=undefined;
        $scope.comercial.primeraCuota=undefined;
        $scope.comercial.polizaPorct=undefined;


        /*cobertura*/
        $scope.cobertura = {};
        $scope.cobertura.rcPersonas="200";
        $scope.cobertura.ovpGtosMdeOcup="200";
        $scope.cobertura.robo="200";
        $scope.cobertura.granizo="200";
        $scope.cobertura.incendioEdificio="200";
        $scope.cobertura.danhosVandalismo="200";
        $scope.cobertura.rcDanhosMateriales="200";
        $scope.cobertura.danhosPropiosTotal="200";
        $scope.cobertura.roboParcialRadio="2011";
        $scope.cobertura.accidentePersonales="200";
        $scope.cobertura.incendioContenidoVivienda="300";
        $scope.cobertura.airbag="200";
        $scope.cobertura.ovpMteOcupante="200000000";
        $scope.cobertura.danhosPropiedad="200";
        $scope.cobertura.roboParcialRadio2="200";
        $scope.cobertura.gtoMedAccPersonales="200";
        $scope.cobertura.sepelio="200";
        $scope.cobertura.cartaVerde=true;
        $scope.cobertura.cartaAzul=false;
        $scope.cobertura.producto=undefined;
        $scope.cobertura.sumaAsegurada=0;
        $scope.cobertura.minMonto=0;
        $scope.cobertura.maxMonto=0;
        $scope.cobertura.franquicia=undefined;

        $scope.debitoAutomatico ={};
        $scope.debitoAutomatico.prima="0";
        $scope.debitoAutomatico.costoTotal ="0";
        $scope.debitoAutomatico.cuota="0";
        $scope.debitoAutomatico.ultimaCuota="0";

        $scope.contado ={};
        $scope.contado.prima="0";
        $scope.contado.costoTotal ="0";

        $scope.chequera ={};
        $scope.chequera.prima="0";
        $scope.chequera.costoTotal ="0";
        $scope.chequera.cuota="0";
        $scope.chequera.ultimaCuota="0";
        $scope.desctComercial=false;
        $scope.recComercial=false;
        $scope.coberturaDatos=[];
        $scope.minDescRec=-100;
        $scope.maxDescRec=100;
        $scope.maxDescEspecial=0;
        $scope.restriccion="^[0-9]+(\,[0-9]{1,2})?$";
        $scope.camposEditablesList=[];
        $scope.submitted=false;
        $scope.emitir=false;
        $scope.todo_marcas=false;
        $scope.preferencia_marcas=$window.sessionStorage.getItem("preferencia_marcas");
        $scope.preferencia_moneda=$window.sessionStorage.getItem("preferencia_moneda");
        $scope.preferencia_fraccionamiento=$window.sessionStorage.getItem("preferencia_fraccionamiento");
        $scope.bloquearCartaVerde=true;
        $scope.bloquearCartaAzul=true;
        $scope.minOcupantes=0;
        $scope.maxOcupantes=0;
        $scope.esBuscar=false;
        $scope.sumaAseguradaBuscar=false;
        $scope.marcaNoPreferencia=false;
        $scope.habilitarPropuesta=false;
        $scope.bloquearBuscador=false;
        $scope.esNuevo="S";
        $scope.promesaSave= $q.defer();
        $scope.editablesDescPoliza=true;
        $scope.monedaPolizaG=true;
        $scope.fraccionPolizaG=true;
        $scope.mostrarFranquicia=false;
        $scope.listaFranquicias=[];
        $scope.codigoFranquicia=undefined;
        $scope.cambiarFraccion=true;

        $scope.save = function () {
            $scope.cargando=true;
            //obtenemos los campos requeridos
            $scope.camposRequeridosList = [];
            var params = {};
            params.numeroCotizacion = angular.isUndefined($scope.datosGenerales.numeroCotizacion) ? "" : $scope.datosGenerales.numeroCotizacion != null ? $scope.datosGenerales.numeroCotizacion : "";
            params.pathModule =$scope.pathModule;
            CotizacionVehiculoService.getCamposRequeridos(params).then(function (response) {
                if (!response.data.error) {
                    if (response.data.dato.length > 0) {
                        var campos = response.data.dato;
                        $scope.camposRequeridosList=campos;
                        $timeout(function(){
                            if ($scope.CotizacionForm.$invalid && !angular.isUndefined($scope.CotizacionForm.$error.required)) {
                                $scope.cargando=false;
                                Message.warning("Existe campos requeridos sin completar");
                                return;
                            }
                            else
                            {
                                $log.debug("Valido, llamar a guardar"); //llamar al guardar
                                $scope.camposRequeridosList = [];
                                $scope.validarSumaAsegurada();
                                if ($scope.montoValido) {
                                    var datosSave = {};
                                    datosSave.codigoMarca = $scope.vehiculo.marca;
                                    datosSave.nombreMarca = $scope.vehiculo.nombreMarca;
                                    datosSave.codigoModelo = $scope.vehiculo.modelo;
                                    datosSave.nombreModelo = $scope.nombreModelo;
                                    datosSave.codigoSubmodelo = $scope.vehiculo.subModelo;
                                    datosSave.nombreSubmodelo = $scope.nomSubModelo;
                                    datosSave.anioSubmodelo = $scope.vehiculo.anho;
                                    datosSave.codigoTipoVehiculo = $scope.vehiculo.codigoTipo;
                                    datosSave.nombreTipoVehiculo = $scope.vehiculo.tipo;
                                    datosSave.numeroPlazas = $scope.vehiculo.ocupantes;
                                    datosSave.sumaAsegurada = $scope.cobertura.sumaAsegurada;
                                    // console.log("Descuento comercial ", $scope.comercial.desctComercial2);
                                    datosSave.descuentoComercial = $scope.comercial.desctComercial2;
                                    //datosSave.recargoComercial=$scope.comercial.recComercial;
                                    datosSave.bonus = $scope.comercial.bono2;
                                    //datosSave.malus=$scope.comercial.malus;
                                    datosSave.codigoPolizaGrupo = $scope.comercial.poliza;
                                    datosSave.nombrePolizaGrupo = $scope.nombrePolizaGrupo;
                                    datosSave.porcentajePolizaGrupo = $scope.comercial.polizaPorct;
                                    datosSave.codigoDescEspecial = $scope.comercial.desctEspecial;
                                    datosSave.nombreDescEspecial = $scope.nombreDescEspecial;
                                    datosSave.porcentajeDescEspecial = $scope.comercial.desctEspecialPorct;
                                    datosSave.cambio = $scope.vehiculo.cotizacion;

                                    /*if (angular.isUndefined($scope.cobertura.producto)){
                                            $scope.controlRequerido = true;
                                            Message.info("Complete los valores requeridos");
                                            return;
                                        }else{
                                            $scope.controlRequerido = false;
                                        }*/
                                    datosSave.codigoProducto = angular.isUndefined($scope.cobertura.producto) ? null : $scope.cobertura.producto;
                                    datosSave.referido = $scope.vehiculo.referido;
                                    datosSave.codigoMoneda = $scope.vehiculo.moneda;
                                    datosSave.codigoFraccionamiento = $scope.comercial.fraccion;
                                    datosSave.importeInicial = $scope.comercial.inicial;
                                    datosSave.marcaCuotaIgual = $scope.comercial.primeraCuota;
                                    datosSave.marcaFlota = 'N';

                                    datosSave.numeroCotizacion = $scope.datosGenerales.numeroCotizacion;
                                    if (!angular.isUndefined($scope.cobertura.franquicia))
                                    {
                                        datosSave.codigoFranquicia=$scope.cobertura.franquicia;
                                        datosSave.importeFranquicia=$scope.recuperarImporte(datosSave.codigoFranquicia);
                                    }
                                    else
                                    {
                                        datosSave.codigoFranquicia=null;
                                        datosSave.importeFranquicia=null;
                                    }

                                    $scope.coberturaDatos = [];
                                    if ($scope.cartas)
                                    {
                                        for (var i=0; i< $scope.cartas.length;i++)
                                        {
                                            var obj = {

                                                numeroCotizacion: datosSave.numeroCotizacion,
                                                codigoCobertura: $scope.cartas[i].COD_COB,
                                                etiqueta: $scope.cartas[i].ETIQUETA,
                                                importeCapital: $scope.cartas[i].MONTO_BASE,
                                                marcaModificable: $scope.cartas[i].MCA_MODIFICABLE
                                            };
                                            $scope.coberturaDatos.push(obj);
                                        }
                                    }
                                    if ($scope.v1 && $scope.datos) {
                                        for (var i = 0; i < $scope.v1.length; i++) {

                                            var obj = {

                                                numeroCotizacion: datosSave.numeroCotizacion,
                                                codigoCobertura: $scope.v1[i].COD_COB,
                                                etiqueta: $scope.v1[i].ETIQUETA,
                                                importeCapital: $scope.v1[i].MONTO_BASE,
                                                marcaModificable: $scope.v1[i].MCA_MODIFICABLE
                                            };

                                            $scope.coberturaDatos.push(obj);
                                        }
                                        for (var i = 0; i < $scope.datos.length; i++) {
                                            var obj = {

                                                numeroCotizacion: datosSave.numeroCotizacion,
                                                codigoCobertura: $scope.datos[i].COD_COB,
                                                etiqueta: $scope.datos[i].ETIQUETA,
                                                importeCapital: $scope.datos[i].MONTO_BASE,
                                                marcaModificable: $scope.datos[i].MCA_MODIFICABLE
                                            };

                                            $scope.coberturaDatos.push(obj);
                                        }
                                        datosSave.coberturasVehiculo = angular.copy($scope.coberturaDatos);
                                    }
                                    else {
                                        datosSave.coberturasVehiculo = [];
                                    }
                                    $scope.cargando = true;
                                    CotizacionVehiculoService.guardarCotizacionVehiculo(datosSave).then(
                                        function (response) {
                                            if (!response.data.error) {
                                                if (response.data.dato.length > 0) {
                                                    $scope.listaCostoVehiculos = [];
                                                    $scope.listaCostoVehiculos = response.data.dato[0].costoVehiculo ? response.data.dato[0].costoVehiculo : [];
                                                    $scope.cargarListadoCostoVehiculo();


                                                    $scope.datosGenerales.numeroCotizacion = parseInt(response.data.dato[0].numeroCotizacion);


                                                    $scope.cargando = false;

                                                    Message.ok(response.data.mensaje);

                                                    $scope.clickButton = false;

                                                    $scope.promesaSave.resolve();


                                                }
                                                else
                                                {
                                                    $scope.cargando=false;
                                                }
                                                $scope.buscarCotizacion();

                                            } else {
                                                $scope.cargando = false;
                                                Message.error(response.data.mensaje);
                                                //
                                                $scope.promesaSave.reject();

                                            }


                                        }).catch(function (response) {
                                        $scope.cargando = false;
                                        Message.error("Ocurrio un error intente nuevamente!");
                                        $scope.promesaSave.reject();
                                    });
                                    $scope.montoValido = false;

                                }
                                else {
                                    $scope.cargando = false;
                                }

                            }
                        }, 1000);

                    }
                    else
                    {
                        $scope.cargando=false;
                    }


                }
                else {
                    $scope.cargando=false;
                    Message.error(response.data.mensaje);
                }
            });





        };
        $scope.actualizarDatos = function() {
            
            var datosSave={};
            datosSave.codigoMarca=$scope.vehiculo.marca;
            datosSave.nombreMarca=$scope.vehiculo.nombreMarca;
            datosSave.codigoModelo=$scope.vehiculo.modelo;
            datosSave.nombreModelo= $scope.nombreModelo;
            datosSave.codigoSubmodelo=$scope.vehiculo.subModelo;
            datosSave.nombreSubmodelo=$scope.nomSubModelo;
            datosSave.anioSubmodelo=$scope.vehiculo.anho;
            datosSave.codigoTipoVehiculo=$scope.vehiculo.codigoTipo;
            datosSave.nombreTipoVehiculo=$scope.vehiculo.tipo;
            datosSave.numeroPlazas=$scope.vehiculo.ocupantes;
            datosSave.sumaAsegurada=$scope.cobertura.sumaAsegurada;
            //console.log("Descuento comercial ", $scope.comercial.desctComercial2);
            datosSave.descuentoComercial=$scope.comercial.desctComercial2;
            //datosSave.recargoComercial=$scope.comercial.recComercial;
            datosSave.bonus=$scope.comercial.bono2;
            //datosSave.malus=$scope.comercial.malus;
            datosSave.codigoPolizaGrupo=$scope.comercial.poliza;
            datosSave.nombrePolizaGrupo=$scope.nombrePolizaGrupo;
            datosSave.porcentajePolizaGrupo=$scope.comercial.polizaPorct;
            datosSave.codigoDescEspecial=$scope.comercial.desctEspecial;
            datosSave.nombreDescEspecial=$scope.nombreDescEspecial;
            datosSave.porcentajeDescEspecial=$scope.comercial.desctEspecialPorct;
            datosSave.codigoProducto= angular.isUndefined($scope.cobertura.producto)?null:$scope.cobertura.producto;
            datosSave.referido= $scope.vehiculo.referido;
            datosSave.codigoMoneda=$scope.vehiculo.moneda;
            datosSave.codigoFraccionamiento=$scope.comercial.fraccion;
            datosSave.importeInicial=$scope.comercial.inicial;
            datosSave.marcaCuotaIgual=$scope.comercial.primeraCuota;
            datosSave.marcaFlota='N';

            datosSave.numeroCotizacion=$scope.datosGenerales.numeroCotizacion;
            datosSave.cambio=$scope.vehiculo.cotizacion;
            if (!angular.isUndefined($scope.cobertura.franquicia))
            {
                datosSave.codigoFranquicia=$scope.cobertura.franquicia.codigoFranquicia;
                datosSave.importeFranquicia=$scope.recuperarImporte(datosSave.codigoFranquicia);
            }
            else
            {
                datosSave.codigoFranquicia=null;
                datosSave.importeFranquicia=null;
            }
            $scope.coberturaDatos=[];

            if ($scope.cartas)
            {
                for (var i=0; i< $scope.cartas.length;i++)
                {
                    var obj = {

                        numeroCotizacion: datosSave.numeroCotizacion,
                        codigoCobertura: $scope.cartas[i].COD_COB,
                        etiqueta: $scope.cartas[i].ETIQUETA,
                        importeCapital: $scope.cartas[i].MONTO_BASE,
                        marcaModificable: $scope.cartas[i].MCA_MODIFICABLE
                    };
                    $scope.coberturaDatos.push(obj);
                }
            }
            for(var i=0; i<$scope.v1.length; i++){
                       
                var obj = {      
                    
                    numeroCotizacion:datosSave.numeroCotizacion,
                    codigoCobertura:$scope.v1[i].COD_COB,
                    etiqueta:$scope.v1[i].ETIQUETA,
                    importeCapital:$scope.v1[i].MONTO_BASE,
                    marcaModificable:$scope.v1[i].MCA_MODIFICABLE
                };

                 $scope.coberturaDatos.push(obj);
            }
            for (var i=0; i< $scope.datos.length;i++)
            {
                var obj = {      
                    
                    numeroCotizacion:datosSave.numeroCotizacion,
                    codigoCobertura:$scope.datos[i].COD_COB,
                    etiqueta:$scope.datos[i].ETIQUETA,
                    importeCapital:$scope.datos[i].MONTO_BASE,
                    marcaModificable:$scope.datos[i].MCA_MODIFICABLE
                };

                 $scope.coberturaDatos.push(obj);
            }

            datosSave.coberturasVehiculo= angular.copy($scope.coberturaDatos);
            $scope.cargando=true;
                    CotizacionVehiculoService.guardarCotizacionVehiculo(datosSave).then(
                        function (response) {
                          if(!response.data.error){
                              $scope.buscarCotizacion();
                             /*if(response.data.dato.length>0)  {
                                    $scope.listaCostoVehiculos=[];
                                    $scope.listaCostoVehiculos =response.data.dato[0].costoVehiculo?response.data.dato[0].costoVehiculo:[];
                                    $scope.cargarListadoCostoVehiculo();
                         
                                 
                                    $scope.datosGenerales.numeroCotizacion=parseInt(response.data.dato[0].numeroCotizacion);


                                 $scope.cargando=true;
                                 $scope.buscarCotizacion();
                                
                            }
                            else
                             {
                                 $scope.cargando=false;
                             }*/


                          }else{
                            $scope.cargando=false;
                            Message.error(response.data.mensaje);
                            //

                          }


                           

                        }).catch(function(response){
                            $scope.cargando=false;
                            Message.error("Ocurrio un error intente nuevamente!");
                        });

            

        };
        $scope.validarSumaAsegurada=function ()
        {

            if ($scope.cobertura.sumaAsegurada !=null && $scope.cobertura.sumaAsegurada!=0 && !angular.isUndefined($scope.cobertura.sumaAsegurada)) {
                if (Number($scope.cobertura.sumaAsegurada) < Number($scope.cobertura.minMonto) || Number($scope.cobertura.sumaAsegurada) > Number($scope.cobertura.maxMonto))
                {
                    if ($scope.verificarCamposForm($scope.camposEditablesList, 'sumaAsegurada'))
                    {
                        Message.error("El monto asegurado ingresado no cumple con el rango requerido, el monto debe ser como mínimo " + $scope.cobertura.minMonto + " y como máximo " + $scope.cobertura.maxMonto + ", verifique el monto e intente nuevamente.");
                        $scope.montoValido = false;

                    }
                    else
                    {
                        $scope.montoValido=true;
                    }

                }
                else {
                    $scope.montoValido = true;
                }
            }
            else
            {
                $scope.montoValido=false;
                Message.error("El monto asegurado ingresado no es correcto, verifique el monto e intente nuevamente.");

            }
        };





        $scope.buscarPoliza = function(evt) {
            if (angular.isUndefined(evt)) {
                //Ejecutado cuando $scope.buscar es invocado sin parametros --NO CREOQ QUE HAGA FALTA ESTE CONTROL

            } else {
                //enter
                if (angular.equals(evt.keyCode, 13)) {
                }
            }

        };

        $scope.resetFilter=function()
        {
            $scope.comercial.inicial = undefined;
        };

        $scope.promesaMarcas = $q.defer();
        $scope.cargarMarcas = function() {

            var parametros = {};
            if ($scope.marcaNoPreferencia)
            {
                $scope.esBuscar=false;
                parametros.preferencia="N";
                $scope.marcaNoPreferencia=false;
                $scope.todo_marcas=false;

            }
            else {
                if ($scope.preferencia_marcas=="S")
                {
                    parametros.preferencia="S";
                    $scope.todo_marcas=true;
                }
                else
                {
                    parametros.preferencia="N";
                    $scope.todo_marcas=false;
                }
            }

            parametros.esNuevo=$scope.esNuevo;
            CotizacionVehiculoService.getMarcas(parametros).then(

                function (response) {
                    if (response.data.error == false )
                    {
                        if (response.data.dato != null)
                        {
                            $scope.listaMarcas=[];
                            for(var i=0; i<response.data.dato.length; i++){
                                var obj = {
                                    id:response.data.dato[i].COD_MARCA,
                                    marca:response.data.dato[i].NOM_MARCA
                                };
                                $scope.listaMarcas.push(obj);

                            }

                        }
                        $scope.promesaMarcas.resolve();


                    }
                    else
                    {
                        $scope.promesaMarcas.resolve();
                        Message.error(response.data.mensaje);
                    }

                   
                  

            },
                function(response){
                $scope.promesaMarcas.reject();
                Message.error(response.data.mensaje);
                
            });

        };

        var valorGua;
        var valorDol;
        var valorEu;

        $scope.cargarMonedas = function()
        {
        //primero traemos todas las monedas
            var parametros = {};
            parametros.preferencia="N"; //por defecto no tiene preferencia, luego consultar la variable que almacena
            parametros.esNuevo=$scope.esNuevo;
            CotizacionVehiculoService.getMonedas(parametros).then(
                function (response) {
                    if (response.data.error== false)
                    {
                        if(response.data.dato !== null)
                        {
                            for(var i=0; i<response.data.dato.length; i++){
                                var camb ={
                                    id :  response.data.dato[i].COD_MON,
                                    cambio : response.data.dato[i].VAL_CAMBIO
                                };
                                var obj = {
                                    id:response.data.dato[i].COD_MON,
                                    moneda:response.data.dato[i].NOM_MON
                                };
                                $scope.listaMonedas.push(obj);
                                $scope.listaCambio.push(camb);

                                //valorGua= response.data.dato[0].VAL_CAMBIO;
                                //valorDol= response.data.dato[1].VAL_CAMBIO;
                                //valorEu= response.data.dato[2]? response.data.dato[2].VAL_CAMBIO: 0.0;


                            }
                            //aca procedemos a llamar si tiene preferencia o no
                            if ($scope.preferencia_moneda=="S") {
                                parametros = {};
                                parametros.esNuevo = $scope.esNuevo;
                                parametros.preferencia = $scope.preferencia_moneda;
                                //pasamos con el parametro que tiene preferencia
                                CotizacionVehiculoService.getMonedas(parametros).then(
                                    function (response) {
                                        if (response.data.error == false && response.data.dato.length>0)
                                        {
                                            $scope.acti=false;
                                            $scope.vehiculo.moneda=parseInt(response.data.dato[0].COD_MON);
                                            /*if($scope.vehiculo.moneda==1){

                                                $scope.vehiculo.cotizacion=valorGua;
                                            }else if($scope.vehiculo.moneda==2){

                                                $scope.vehiculo.cotizacion=valorDol;
                                            }else{

                                                $scope.vehiculo.cotizacion=valorEu;
                                            };*/
                                            if ($scope.listaMonedas.length>0)
                                            {
                                                for (var i=0; i<$scope.listaCambio.length;i++)
                                                {
                                                    if ($scope.listaCambio[i].id==$scope.vehiculo.moneda)
                                                    {
                                                        $scope.vehiculo.cotizacion=$scope.listaCambio[i].cambio;

                                                        break;
                                                    }
                                                }

                                            }
                                        }
                                    });
                            }
                            else
                            {
                                //$scope.activar=true;
                                if ($scope.listaMonedas.length>0)
                                {
                                    $scope.vehiculo.moneda=$scope.listaMonedas[0].id;
                                    $scope.vehiculo.cotizacion=$scope.listaCambio[0].cambio;
                                    //$scope.vehiculo.moneda=1;
                                }

                            }
                        }

                    }
                    else
                    {
                        Message.error(response.data.mensaje);

                    }
                    

                   
                },
                function(response){
                    Message.error(response.data.mensaje);
                    
                });

        };

        $scope.promesaPoliza= $q.defer();
        $scope.cargarPolizaGrupo = function() {
            var parametros = {};
            parametros.esNuevo=$scope.esNuevo;
            parametros.pathModule = $scope.pathModule;
            CotizacionVehiculoService.getPolizaGrupo(parametros).then(
                function (response) {
                    if (response.data.error==false )
                    {
                        if (response.data.dato != null)
                        {
                            for(var i=0; i<response.data.dato.length; i++){
                                var dato = {
                                    id:response.data.dato[i].NUM_POLIZA,
                                    porcentaje:response.data.dato[i].PORC_DESCUENTO
                                };

                                var obj = {
                                    id:response.data.dato[i].NUM_POLIZA,
                                    poliza:response.data.dato[i].NOM_POLIZA
                                };
                                $scope.listaGrupoPoliza.push(obj);
                                $scope.datosGrupoPoliza.push(dato);
                            }
                        }

                    }
                    else
                    {
                        Message.error(response.data.mensaje);
                    }
                    
                    $scope.promesaPoliza.resolve();
                    
                },
                 function(response){
                    $scope.promesaPoliza.reject();
                    Message.error(response.data.mensaje);
                    
                });

        };

        $scope.cargarDescuentoEspecial = function() {
            $scope.listaDesctEspc=[];
            $scope.datosDescuentoEspecial=[];
            var parametros = {};
            parametros.esNuevo=$scope.esNuevo;
            parametros.pathModule = $scope.pathModule;
            parametros.numeroCotizacion=$scope.datosGenerales.numeroCotizacion==null?"":$scope.datosGenerales.numeroCotizacion;
            CotizacionVehiculoService.getDescuentosEspeciales(parametros).then(
                function (response) {
                    if (response.data.error== false)
                    {
                        if (response.data.dato != null)
                        {
                            for(var i=0; i<response.data.dato.length; i++){

                                var objDatos = {
                                    id:response.data.dato[i].COD_VALOR,
                                    desct:response.data.dato[i].PCT_DESCUENTO
                                };

                                var obj = {
                                    id:response.data.dato[i].COD_VALOR,
                                    desct:response.data.dato[i].NOM_VALOR
                                };
                                $scope.listaDesctEspc.push(obj);
                                $scope.datosDescuentoEspecial.push(objDatos);
                            }
                        }

                    }
                    else
                    {
                        Message.error(response.data.mensaje);
                    }
                    
                     
                },
                function(response){
                    Message.error(response.data.mensaje);
                    
                });

        };


        $scope.promesaFraccion =$q.defer();
        $scope.cargarFraccionamiento = function(preferencia) {
            var parametros = {}; //al inicio traer todas las listas de fraccionamiento
            parametros.preferencia="N";
            parametros.esNuevo=$scope.esNuevo;
            parametros.codigoGrupoPoliza= !angular.isUndefined($scope.comercial.poliza)?$scope.comercial.poliza!=null?$scope.comercial.poliza:"":"";
            $scope.listaFraccion=[];
            CotizacionVehiculoService.getFraccionamiento(parametros).then(
                function (response) {
                    if (response.data.error ==false ) {
                        if (response.data.dato != null)
                        {
                            for (var i = 0; i < response.data.dato.length; i++) {
                                var obj = {
                                    id: response.data.dato[i].COD_FRACC_PAGO,
                                    fraccion: response.data.dato[i].NOM_FRACC_PAGO
                                };
                                $scope.listaFraccion.push(obj);
                            }
                            //si tiene preferencia entonces llamar a la preferencia y seleccionar por defecto
                            if ($scope.preferencia_fraccionamiento == "S") {
                                if ( preferencia=="S")
                                {
                                    //llamar al servicio que traiga la preferencia
                                    parametros = {};
                                    parametros.preferencia = $scope.preferencia_fraccionamiento;
                                    parametros.esNuevo = $scope.esNuevo;
                                    parametros.codigoGrupoPoliza= !angular.isUndefined($scope.comercial.poliza)?$scope.comercial.poliza!=null?$scope.comercial.poliza:"":"";
                                    CotizacionVehiculoService.getFraccionamiento(parametros).then(
                                        function (response) {
                                            if (response.data.error == false && response.data.dato != null && response.data.dato.length>0) {
                                                //se setea el fraccionamiento por defecto
                                                $scope.comercial.fraccion=parseInt(response.data.dato[0].COD_FORMA_PAGO);

                                            }

                                        })
                                }


                            }
                            else
                            {
                                if (preferencia=="N")
                                {
                                    $scope.comercial.fraccion =99100;
                                }

                            }
                        }

                    }
                    else
                    {
                        Message.error(response.data.mensaje);
                        //
                    }

                    $scope.promesaFraccion.resolve();
                },
                function(response){
                    $scope.promesaFraccion.reject();
                    Message.error(response.data.mensaje);
                    
                });

        };

 
        //cuando cambia el combo marca
         $scope.promesaModelo = $q.defer();
        $scope.$watch('vehiculo.marca', function(NewValue, OldValue) {

             if(!angular.isUndefined(NewValue) && NewValue!=null){
                 if (NewValue=="todos")
                 {
                     $scope.vehiculo.marca=undefined;
                     //aca llamar a marcas con tiene Preferencia de Marcas "N"
                     $scope.todo_marcas=false;
                     $scope.preferencia_marcas="N";
                     $scope.cargarMarcas();


                 }
                 else 
                 {
                     var parametros = {};

                     parametros.preferencia=0;
                     parametros.esNuevo=$scope.esNuevo;
                     parametros.codigoMarca=$scope.vehiculo.marca;

                     for(var i=0; i<$scope.listaMarcas.length; i++){
                         if ($scope.listaMarcas[i].id==NewValue){
                             $scope.vehiculo.nombreMarca= $scope.listaMarcas[i].marca;
                             break;
                         }
                     }

                     //SE LIMPIAN LOS COMBOS DEPENDIENTES
                     $scope.listaModelos =[];
                     $scope.listaSubModelos =[];
                     $scope.years =[];
                     $scope.datosSubmodelo=[];

                     CotizacionVehiculoService.getModelos(parametros).then(

                         function (response) {
                             if (response.data.error ==false )
                             {
                                 if (response.data.dato!=null)
                                 {
                                     for(var i=0; i<response.data.dato.length; i++){
                                         var obj = {
                                             id:response.data.dato[i].COD_MODELO,
                                             modelo:response.data.dato[i].NOM_MODELO
                                         };
                                         $scope.listaModelos.push(obj);
                                     }
                                 }

                             }
                             else
                             {
                                 Message.error(response.data.mensaje);
                             }

                             $scope.promesaModelo.resolve();

                         },
                         function(response){
                             $scope.promesaModelo.reject(response);
                             Message.error(response.data.mensaje);
                             
                         });
                 }

                 

             }else{
                 $scope.listaModelos =[];
                 $scope.listaSubModelos =[];
                 $scope.years =[];
                 $scope.datosSubmodelo=[];
                 $scope.vehiculo.tipo=null;
                 $scope.vehiculo.ocupantes=null;
                 $scope.listaProductos = [];
             }


        },true);

        //
        $scope.promesaSubModelo= $q.defer();
        $scope.$watch('vehiculo.modelo', function(NewValue, OldValue) {
            if(!angular.isUndefined(NewValue) && NewValue!=null){

                var  parametros ={};
                $scope.listaSubModelos =[];
                $scope.datosSubmodelo=[];
                if (!$scope.sumaAseguradaBuscar)
                {
                    $scope.cobertura.sumaAsegurada=0;
                }
                $scope.cobertura.minMonto=0;
                $scope.cobertura.maxMonto=0;
                parametros.esNuevo=$scope.esNuevo;
                parametros.codigoMarca=$scope.vehiculo.marca;
                parametros.codigoModelo=$scope.vehiculo.modelo;
               for(var i=0; i<$scope.listaModelos.length; i++){
                     if ($scope.listaModelos[i].id==NewValue){
                         $scope.nombreModelo= $scope.listaModelos[i].modelo;
                         break;
                     }
                 }


                CotizacionVehiculoService.getSubModelos(parametros).then(

                    function (response) {

                        for(var i=0; i<response.data.dato.length; i++){

                            var datos ={
                                id:response.data.dato[i].COD_SUB_MODELO,
                                tipo:response.data.dato[i].NOM_TIP_VEHI,
                                 codTipo:response.data.dato[i].COD_TIP_VEHI,
                                cantOcup:response.data.dato[i].NUM_PLAZAS,
                                cantMinOcup:response.data.dato[i].NUM_PLAZAS_MIN,

                            }

                            var obj = {
                                id:response.data.dato[i].COD_SUB_MODELO,
                                subModelo:response.data.dato[i].NOM_SUB_MODELO
                            };
                            $scope.listaSubModelos.push(obj);
                            $scope.datosSubmodelo.push(datos);
                        }

                        $scope.promesaSubModelo.resolve();
                        //setear el submodelo
                        $scope.setearDatosSubModelo();



                    },
                    function(response){
                        $scope.promesaSubModelo.reject();
                        Message.error(response.data.mensaje);
                        
                    });



            }else{
                $scope.listaSubModelos =[];
                $scope.years =[];
                $scope.datosSubmodelo=[];
                $scope.vehiculo.tipo=null;
                $scope.vehiculo.ocupantes=null;
                $scope.cobertura.sumaAsegurada=0;
                //$scope.cobertura.sumaAsegurada=0;
                $scope.cobertura.minMonto=0;
                $scope.cobertura.maxMonto=0;
            }

        },true);
        
        $scope.promesaAnho=$q.defer();
        $scope.$watch('vehiculo.subModelo', function(NewValue, OldValue) {

            if(!angular.isUndefined(NewValue) && NewValue!=null){
                $scope.submodel=NewValue;

                   $scope.years=[]
                    if (!$scope.sumaAseguradaBuscar)
                    {
                        $scope.cobertura.sumaAsegurada=0;
                    }
                   //$scope.cobertura.sumaAsegurada=0;

                   //$scope.cobertura.sumaAsegurada=0;
                   $scope.cobertura.minMonto=0;
                   $scope.cobertura.maxMonto=0; 


                var  parametros ={};
                parametros.esNuevo=$scope.esNuevo;
                parametros.codigoMarca=$scope.vehiculo.marca;
                parametros.codigoModelo=$scope.vehiculo.modelo;
                parametros.codigoSubModelo=$scope.vehiculo.subModelo;
                parametros.codigoMoneda=$scope.vehiculo.moneda;
                 $scope.setearDatosSubModelo();

                    
                 $scope.yearsVehiculo =[];

                CotizacionVehiculoService.getAnhoSubModelos(parametros).then(

                    function (response) {
                        if (!response.data.error)
                        {
                            if (response.data.dato!=null && response.data.dato.length>0) {
                                $scope.yearsVehiculo = response.data.dato;
                                for (var i = 0; i < response.data.dato.length; i++) {
                                    var obj = {
                                        id: response.data.dato[i].ANIO_SUB_MODELO,
                                        value: response.data.dato[i].ANIO_SUB_MODELO
                                    };

                                    $scope.years.push(obj);
                                }
                            }
                        }
                        else
                        {
                            Message.error(response.data.mensaje);
                        }
                        $scope.promesaAnho.resolve();
                    },
                    function(response){
                        $scope.promesaAnho.reject();
                        Message.error(response.data.mensaje);
                        
                    });

            }else{
                $scope.years =[];
                $scope.vehiculo.tipo=null;
                $scope.vehiculo.ocupantes=null;
            }

        },true);

        $scope.datosCobertura=[];

          $scope.$watch('cobertura.producto', function(NewValue, OldValue) {

                if(!angular.isUndefined(NewValue) && NewValue !=null){

                    if($scope.persistirProducto==true){
                        $scope.flagConfirmacion=false;
                        $scope.promesaSave.promise.$$state.status=0;
                       
                        $scope.cambioProducto=true;
                        var parametros={};
                        parametros.esNuevo=$scope.esNuevo;
                        parametros.codigoMarca=$scope.vehiculo.marca;
                        parametros.codigoModelo=$scope.vehiculo.modelo;
                        parametros.codigoSubModelo=$scope.vehiculo.subModelo;
                        parametros.anho=$scope.vehiculo.anho;
                        parametros.codigoMoneda=$scope.vehiculo.moneda;
                        parametros.codigoRamo=501;
                        parametros.numeroCotizacion=$scope.datosGenerales.numeroCotizacion;
                        $scope.cargando=true;
                        $scope.cobertura.franquicia=undefined;
                        /**verificar que el producto seleccionado tenga franquicia**/
                        $scope.verificarFranquicia(NewValue, $scope.vehiculo.moneda, $scope.cobertura.sumaAsegurada);
                        $scope.recalcularCotizacion(parametros);  
                    }else{
                         $scope.persistirProducto=true;
                        /**verificar que el producto seleccionado tenga franquicia**/
                        $scope.verificarFranquicia(NewValue, $scope.vehiculo.moneda, $scope.cobertura.sumaAsegurada);
                    }
                    

            }else{
                    $scope.datosCobertura=[];
                    $scope.mostrarCartas=false;
                    $scope.mostrarFranquicia=false;
                    $scope.setearCobertura($scope.datosCobertura);
                    $scope.limpiarFormasPago();

               /* $scope.vehiculo.cotizacion=null;*/
            }
              

           

        },true);

            var valorSub=0;
            var valorSubMax;
            var valorSubMin;
            var valorCot;


        $scope.cambiarMoneda=function()
        {
            if(!angular.isUndefined($scope.vehiculo.moneda))
            {
                var  parametros ={};
                parametros.esNuevo=$scope.esNuevo;
                parametros.codigoMarca=$scope.vehiculo.marca;
                parametros.codigoModelo=$scope.vehiculo.modelo;
                parametros.codigoSubModelo=$scope.vehiculo.subModelo;
                parametros.anho=$scope.vehiculo.anho;
                parametros.codigoMoneda=$scope.vehiculo.moneda;
                parametros.codigoRamo=501;
                parametros.numeroCotizacion=!angular.isUndefined($scope.datosGenerales.numeroCotizacion)&& $scope.datosGenerales.numeroCotizacion!=null?$scope.datosGenerales.numeroCotizacion:"";
             //   $scope.listaProductos=[];

                if($scope.vehiculo.marca!=undefined && $scope.vehiculo.marca!=null && $scope.vehiculo.modelo!=undefined && $scope.vehiculo.modelo!=null
                    && $scope.vehiculo.subModelo!=undefined && $scope.vehiculo.subModelo!=null && $scope.vehiculo.anho!=undefined && $scope.vehiculo.anho!=null  && $scope.vehiculo.moneda!=undefined && $scope.vehiculo.moneda!=null )
                    {

                        $scope.cargando=true;

                    CotizacionVehiculoService.getSumaAsegurada(parametros).then(
                    function (response) 
                    {
                        if (response.data.error==false)
                        {
                            if (response.data.dato !=null)
                            {
                                $scope.cobertura.sumaAsegurada=response.data.dato[0].VAL_SUB_MODELO;
                                $scope.cobertura.minMonto=response.data.dato[0].VAL_SUB_MODELO_MIN;
                                $scope.cobertura.maxMonto=response.data.dato[0].VAL_SUB_MODELO_MAX;

                                if($scope.cobertura.sumaAsegurada!=undefined  &&  $scope.cobertura.producto!=undefined){

                                    parametros.codigoProducto=$scope.cobertura.producto;
                                    parametros.SumaAsegurada= $scope.cobertura.sumaAsegurada;

                                    parametros.codigoMoneda=$scope.vehiculo.moneda;

                                    //volver a obtener la cotizacion
                                    for(var i=0; i<$scope.listaCambio.length; i++){
                                        if ($scope.listaCambio[i].id==$scope.vehiculo.moneda){
                                            $scope.vehiculo.cotizacion = $scope.listaCambio[i].cambio;
                                            break;
                                        }
                                    }
                                    //llamar al guardado parcial de la cotizacion
                                    $scope.cobertura.franquicia=undefined;
                                    $scope.codigoFranquicia=undefined;
                                    $scope.verificarFranquicia($scope.cobertura.producto, $scope.vehiculo.moneda, $scope.cobertura.sumaAsegurada);
                                    $scope.recalcularCotizacion(parametros);
                                    }
                                    else

                                    {
                                        $scope.cobertura.franquicia=undefined;
                                        $scope.codigoFranquicia=undefined;
                                        $scope.verificarFranquicia($scope.cobertura.producto, $scope.vehiculo.moneda, $scope.cobertura.sumaAsegurada);
                                        $scope.cargando=false;
                                    }

                            }
                            else {
                                $scope.cobertura.franquicia=undefined;
                                $scope.codigoFranquicia=undefined;
                                $scope.verificarFranquicia($scope.cobertura.producto, $scope.vehiculo.moneda, $scope.cobertura.sumaAsegurada);
                                $scope.cargando=false;
                            }
                        
                        
                        }
                        else
                        {
                            $scope.cargando=false;
                            Message.error(response.data.mensaje);
                        }
                    
                    },
                    function(response){
                    $scope.cargando=false;
                    Message.error(response.data.mensaje);
                    
                });
               
                
                }
              
              
        
                    for(var i=0; i<$scope.listaCambio.length; i++){
                        if ($scope.listaCambio[i].id==$scope.vehiculo.moneda){
                            $scope.vehiculo.cotizacion = $scope.listaCambio[i].cambio;
                            break;
                        }
                    }
                
                

                /*if($scope.vehiculo.moneda==1){

                             valorCot=valorDol;
                        }else if($scope.vehiculo.moneda==2){

                             valorCot=valorGua;
                        }else{

                             valorCot=valorEu;
                        };*/

                
                        var sumaAsegurada=valorSub*valorCot;
                        var sumaAseguradaMax=valorSubMax*$scope.vehiculo.cotizacion;
                        var sumaAseguradaMin=valorSubMin*$scope.vehiculo.cotizacion;
                       $scope.cobertura.sumaAsegurada=sumaAsegurada? sumaAsegurada:0;



                if($scope.acti){
                    $scope.acti==false;
                }
                $scope.comercial.inicial=undefined;

        
        }
        else
        {
            $scope.vehiculo.cotizacion=null;
            $scope.comercial.inicial=undefined;
        }
        };



        $scope.promesaProducto=$q.defer();
        $scope.promesaSumaAsegurada=$q.defer();
        $scope.$watch('vehiculo.anho', function(NewValue, OldValue) {
            if(!angular.isUndefined(NewValue) && NewValue!=null){

                       if($scope.vehiculo.moneda==1){

                             valorCot=valorDol;
                        }else if($scope.vehiculo.moneda==2){

                             valorCot=valorGua;
                        }else{

                             valorCot=valorEu;
                        };


                for(var i=0; i<$scope.yearsVehiculo.length; i++){
                        if($scope.yearsVehiculo[i].ANIO_SUB_MODELO==NewValue){
                             valorSub=$scope.yearsVehiculo[i].VAL_SUB_MODELO;
                             valorSubMax=$scope.yearsVehiculo[i].VAL_SUB_MODELO_MAX;
                             valorSubMin=$scope.yearsVehiculo[i].VAL_SUB_MODELO_MIN;

                        var sumaAsegurada=valorSub*valorCot;
                        var sumaAseguradaMax=valorSubMax*$scope.vehiculo.cotizacion;
                        var sumaAseguradaMin=valorSubMin*$scope.vehiculo.cotizacion;
                   
                         break;

                        }


                }
                var  parametros ={};
                parametros.esNuevo=$scope.esNuevo;
                parametros.codigoMarca=$scope.vehiculo.marca;
                parametros.codigoModelo=$scope.vehiculo.modelo;
                parametros.codigoSubModelo=$scope.vehiculo.subModelo;
                parametros.anho=$scope.vehiculo.anho;
                parametros.codigoMoneda=$scope.vehiculo.moneda;
                parametros.codigoRamo=501;
                parametros.numeroCotizacion=!angular.isUndefined($scope.datosGenerales.numeroCotizacion)&& $scope.datosGenerales.numeroCotizacion!=null?$scope.datosGenerales.numeroCotizacion:"";
                parametros.renovacion=$scope.datosGenerales.nuevo;
                $scope.cargando=true;
                    var promesaSuma=CotizacionVehiculoService.getSumaAsegurada(parametros).then(
                        function (response) {
                            if (response.data.error==false)
                            {
                                if (response.data.dato !=null)
                                {
                                    if (!$scope.sumaAseguradaBuscar)
                                    {
                                        $scope.cobertura.sumaAsegurada=response.data.dato[0].VAL_SUB_MODELO;
                                        $scope.cobertura.franquicia=undefined;
                                        $scope.verificarFranquicia($scope.cobertura.producto,$scope.vehiculo.moneda, $scope.cobertura.sumaAsegurada);
                                    }
                                    else
                                    {
                                        $scope.sumaAseguradaBuscar=false;


                                    }
                                    $scope.cobertura.minMonto=response.data.dato[0].VAL_SUB_MODELO_MIN;
                                    $scope.cobertura.maxMonto=response.data.dato[0].VAL_SUB_MODELO_MAX;

                                    //$scope.promesaSumaAsegurada.resolve();
                                }



                            }
                            else
                            {
                                $scope.cobertura.sumaAsegurada=sumaAsegurada? sumaAsegurada:0;
                                $scope.cobertura.minMonto=sumaAseguradaMin;
                                $scope.cobertura.maxMonto=sumaAseguradaMax;
                                $scope.cobertura.franquicia=undefined;
                                $scope.verificarFranquicia($scope.cobertura.producto,$scope.vehiculo.moneda, $scope.cobertura.sumaAsegurada);
                                //$scope.promesaSumaAsegurada.resolve();
                                Message.error(response.data.mensaje);
                            }


                        },
                        function(response){
                            // $scope.promesaSumaAsegurada.reject();
                            $scope.cargando=false;
                            $scope.sumaAseguradaBuscar=false;
                            Message.error(response.data.mensaje);
                            
                        });

                



              

                CotizacionVehiculoService.getProductos(parametros).then(
                    function (response) {
                        if (response.data.error ==false )
                        {
                            $scope.listaProductos=[];
                            if (response.data.dato!=null && response.data.dato.length>0)
                            {
                                for(var i=0; i<response.data.dato.length; i++)
                                {
                                    var obj = {
                                        id:response.data.dato[i].COD_MODALIDAD,
                                        producto:response.data.dato[i].NOM_MODALIDAD,
                                        mcaFranquicia:response.data.dato[i].MCA_FRANQUICIA,
                                    };
                                    $scope.listaProductos.push(obj);
                                }
                                $scope.promesaProducto.resolve();



                            }
                            else {
                                $scope.promesaProducto.resolve();
                            }
                        }
                        else
                        {
                            $scope.cargando=false;
                            $scope.cobertura.producto=undefined;
                            $scope.promesaProducto.resolve();
                            Message.error(response.data.mensaje);


                        }



                    },
                    function(response){
                        $scope.promesaProducto.reject();
                        $scope.cargando=false;
                        Message.error(response.data.mensaje);
                        
                        return response.data;
                    });

                
                    $q.all( [promesaSuma,$scope.promesaProducto.promise.then()
                             ] ).then(
                            function(response){
                                //console.log("persistir", $scope.persistir);
                                if($scope.persistir==true){
                                    $scope.flagConfirmacion=false;

                                    $scope.recalcularCotizacion(parametros);
                                 }else{
                                    $scope.persistir=true;
                                    $scope.cargando=false;
                                     
                                 }
                              
                            },
                            function(response){
                                
                            }
                        );
                  

            }else{
                $scope.listaProductos = [];
            }

        },true);

        $scope.$watch('comercial.poliza', function(NewValue, OldValue) {

            if(!angular.isUndefined(NewValue) && NewValue!=null)
            {

                if ($scope.cambiarFraccion)
                {
                    $scope.comercial.fraccion=undefined;
                    $scope.habilitarPreferenciaFracc=false;
                }
                else
                {
                    $scope.cambiarFraccion=true;
                }

                    $scope.cargarFraccionamiento("N");

                if ($scope.editablesDescPoliza)
                {

                    var params = {};
                    params.numeroPolizaGrupo = NewValue;
                    params.moneda = $scope.vehiculo.moneda;
                    params.pathModule = $scope.pathModule;
                    $scope.promesaFraccion.promise.then(function() {

                        CotizacionVehiculoService.validarPolizaGrupo(params).then(function (response) {
                            if (response.data.error) {
                                $scope.comercial.poliza = undefined;
                                $scope.comercial.polizaPorct="";
                                $scope.comercial.nombrePolizaGrupo="";
                                $scope.monedaPolizaG=true;
                                $scope.fraccionPolizaG=true;
                                DialogService.showDialog(response.data.mensaje);


                            } else {
                                $scope.setearPorcentajeDesc(NewValue);
                                if (response.data.dato!=null)
                                {
                                    if (response.data.dato.monedaModificable=="S")
                                    {
                                        $scope.monedaPolizaG=true;
                                    }
                                    else
                                    {
                                        $scope.monedaPolizaG=false;
                                    }

                                    if (response.data.dato.fraccionamientoModificable=="S")
                                    {
                                        $scope.fraccionPolizaG=true;
                                    }
                                    else
                                    {
                                        $scope.fraccionPolizaG=false;
                                    }

                                    if (response.data.dato.codigoFraccionamiento!=null && response.data.dato.codigoFraccionamiento!="")
                                    {

                                        var fraccion=parseInt(response.data.dato.codigoFraccionamiento);
                                        var index=$scope.listaFraccion.map(function(e){return e.id;}).indexOf(fraccion);
                                        if (index !==-1)
                                        {
                                            $scope.comercial.fraccion=parseInt(response.data.dato.codigoFraccionamiento);
                                        }

                                    }
                                }





                            }
                        }).catch(function(error){
                            $scope.comercial.poliza = undefined;
                            $scope.comercial.polizaPorct="";
                            $scope.comercial.nombrePolizaGrupo="";
                            Message.error("Algo inesperado ha ocurrido, intente nuevamente!");
                        });
                    });


                }
                else
                {
                    $scope.editablesDescPoliza = true;
                    /**Calcular lo seteado por el buscar **/
                    $scope.setearPorcentajeDesc(NewValue);
                }


            }else{
                $scope.editablesDescPoliza = true;
                $scope.comercial.polizaPorct="";
                $scope.comercial.nombrePolizaGrupo="";


                if ($scope.cambiarFraccion )
                {
                    $scope.comercial.fraccion=undefined;
                    $scope.promesaFraccion.promise.$$state.status=0;
                    //$scope.habilitarPreferenciaFracc=false;
                    $scope.cargarFraccionamiento("N");
                }
                else
                {

                    $scope.cambiarFraccion=true;
                }







            }
            $scope.cambiarRangoDescuento();

        },true);
        $scope.setearPorcentajeDesc=function(descPoliza)
        {
            for (var i = 0; i < $scope.datosGrupoPoliza.length; i++) {
                if ($scope.datosGrupoPoliza[i].id == descPoliza) {
                    $scope.comercial.polizaPorct = $scope.datosGrupoPoliza[i].porcentaje;
                    break;
                }
            }
            for (var i = 0; i < $scope.listaGrupoPoliza.length; i++) {
                if ($scope.listaGrupoPoliza[i].id == descPoliza) {
                    $scope.nombrePolizaGrupo = $scope.listaGrupoPoliza[i].poliza;
                    break;
                }
            }
        }
        $scope.$watch('comercial.desctEspecial', function(NewValue, OldValue) {

            
            if(!angular.isUndefined(NewValue) && $scope.comercial.desctEspecial !=null ){

                for(var i=0; i<$scope.datosDescuentoEspecial.length; i++){
                    if ($scope.datosDescuentoEspecial[i].id==NewValue){
                        $scope.maxDescEspecial=parseInt($scope.datosDescuentoEspecial[i].desct);
                        $scope.comercial.desctEspecialPorct=parseInt($scope.datosDescuentoEspecial[i].desct);
                        break;
                    }
                }
                for(var i=0; i<$scope.listaDesctEspc.length; i++){
                    if ($scope.listaDesctEspc[i].id==NewValue){
                        $scope.nombreDescEspecial=$scope.listaDesctEspc[i].desct;
                        break;
                    }
                }



            }else{
                $scope.comercial.desctEspecialPorct=null;
            }
        },true);



       /* $scope.$watch('comercial.fraccion', function(NewValue, OldValue) {

            if(!angular.isUndefined(NewValue)){

                var  parametros ={};



            }else{

            }
        },true);*/

      
 $scope.$watch('datosGenerales.nuevo', function(NewValue, OldValue) {

             if(!angular.isUndefined(NewValue)){

             }else{
                   
             }


        },true);





        $scope.showAdvanced = function() {

           $rootScope.codCoti=$scope.datosGenerales.numeroCotizacion;
           $rootScope.monedaAbuscar=$scope.vehiculo.moneda;
           $rootScope.mostrarBuscadorCotizacion=true;
            $mdDialog.show({
                locals:{parent: $scope},   
                controller: 'BuscadorCotizacionCtrl',
                templateUrl: 'partials/ventanas-emergentes/buscador-cotizacion-partial.html',
                parent: angular.element(document.body),
                clickOutsideToClose:false,
                fullscreen: $scope.customFullscreen // Only for -xs, -sm breakpoints.
            }).then(function(answer) {
                 $scope.cargando=true;
                $scope.status = 'You said the information was "' + answer + '".';
                if (!angular.isUndefined(answer.numeroCotizacion) && answer.numeroCotizacion !="" && answer.numeroCotizacion!= null){
                    $scope.datosGenerales.numeroCotizacion = parseInt(answer.numeroCotizacion);
                }else{
                     Message.error("Numero de cotizacion inexistente");
                     return;
                }
               

                $scope.buscarCotizacion();


            }, function() {
                $scope.status = 'You cancelled the dialog.';
                //console.log($scope.status);
            });

        };
        $scope.guardadoParcialCabecera=function()
        {
            var dataVal={};
            dataVal.codigoMarca=$scope.vehiculo.marca;
            dataVal.nombreMarca=$scope.vehiculo.nombreMarca;
            dataVal.codigoModelo=$scope.vehiculo.modelo;
            dataVal.nombreModelo= $scope.nombreModelo;
            dataVal.codigoSubmodelo=$scope.vehiculo.subModelo;
            dataVal.nombreSubmodelo=$scope.nomSubModelo;
            dataVal.anioSubmodelo=$scope.vehiculo.anho;
            dataVal.codigoTipoVehiculo=$scope.vehiculo.codigoTipo;
            dataVal.nombreTipoVehiculo=$scope.vehiculo.tipo;
            dataVal.numeroPlazas=$scope.vehiculo.ocupantes;
            dataVal.sumaAsegurada=$scope.cobertura.sumaAsegurada;
            dataVal.descuentoComercial=$scope.comercial.desctComercial2;
            //dataVal.recargoComercial=$scope.comercial.recComercial;
            dataVal.bonus=$scope.comercial.bono2;
           // dataVal.malus=$scope.comercial.malus;
            dataVal.codigoPolizaGrupo=$scope.comercial.poliza;
            dataVal.nombrePolizaGrupo=$scope.nombrePolizaGrupo;
            dataVal.porcentajePolizaGrupo=$scope.comercial.polizaPorct;
            dataVal.codigoDescEspecial=$scope.comercial.desctEspecial;
            dataVal.nombreDescEspecial=$scope.nombreDescEspecial;
            dataVal.porcentajeDescEspecial=$scope.comercial.desctEspecialPorct;
            dataVal.codigoProducto= angular.isUndefined($scope.cobertura.producto)?null:$scope.cobertura.producto;
            dataVal.referido= $scope.vehiculo.referido;
            dataVal.codigoMoneda=$scope.vehiculo.moneda;
            dataVal.codigoFraccionamiento=$scope.comercial.fraccion;
            dataVal.importeInicial=$scope.comercial.inicial;
            dataVal.marcaCuotaIgual=$scope.comercial.primeraCuota;
            dataVal.marcaFlota='N';
            dataVal.cambio=$scope.vehiculo.cotizacion;
            //console.log("Numero de cotizacion ",$scope.datosGenerales.numeroCotizacion);
            dataVal.numeroCotizacion=$scope.datosGenerales.numeroCotizacion;
            return CotizacionVehiculoService.guardadoParcialCabecera(dataVal).then(
                function (response){
                    return response.data;
            });       
        };

     $scope.cargarListadoCostoVehiculo = function() {
         //console.log("Costo vehiculo ",$scope.listaCostoVehiculos);
        if( $scope.listaCostoVehiculos != null && $scope.listaCostoVehiculos.length>0) {
            //console.log("Entra aca");
            $scope.sindatost=true;
        }
        else
        {
            $scope.sindatost=false;
        }
        //$scope.cargando=false;
       // console.log("sIN DATOS TABLA", $scope.sindatost);
            
     } ;
     $scope.limpiarDatos=function()
     {
         $scope.obtenerCamposEditables();
         $scope.vehiculo.moneda=undefined;
         $scope.vehiculo.monto="2000";
         $scope.vehiculo.referido='N';
         $scope.vehiculo.marca=undefined;
         $scope.vehiculo.modelo=undefined;
         $scope.vehiculo.subModelo=undefined;
         $scope.vehiculo.anho=undefined;
         $scope.vehiculo.ocupantes=undefined;
         $scope.vehiculo.tipo=undefined;
         $scope.datosSubmodelo=[];
         $scope.listaSubModelos=[];
         //combo comercial
         $scope.comercial.desctComercial=undefined;
         $scope.comercial.desctP="1";
         $scope.comercial.desctEspecial=undefined;
         $scope.comercial.desctComercial2=undefined;
         $scope.comercial.recComercial=undefined;
         $scope.comercial.fraccion=undefined;
         $scope.comercial.cuota="S";
         $scope.comercial.poliza=undefined;
         $scope.comercial.polizaDescripcion="";
         $scope.comercial.bono=undefined;
         $scope.comercial.bono2=null;
        // $scope.comercial.malus=null;
         $scope.comercial.inicial=undefined;
         $scope.comercial.primeraCuota=undefined;
         $scope.comercial.polizaPorct=undefined;
         $scope.cobertura.cartaVerde=true;
         $scope.cobertura.cartaAzul=false;
         $scope.cobertura.producto=undefined;
         $scope.cobertura.sumaAsegurada=0;
         $scope.cobertura.minMonto=0;
         $scope.cobertura.maxMonto=0;
         $scope.debitoAutomatico ={};
         $scope.debitoAutomatico.prima="0";
         $scope.debitoAutomatico.costoTotal ="0";
         $scope.debitoAutomatico.cuota="0";
         $scope.debitoAutomatico.ultimaCuota="0";

         $scope.contado ={};
         $scope.contado.prima="0";
         $scope.contado.costoTotal ="0";

         $scope.chequera ={};
         $scope.chequera.prima="0";
         $scope.chequera.costoTotal ="0";
         $scope.chequera.cuota="0";
         $scope.chequera.ultimaCuota="0";
         $scope.desctComercial=false;
         $scope.recComercial=false; 
         $scope.coberturaDatos=[];
         $scope.minDescRec=-100;
         $scope.maxDescRec=100;

     };
     $scope.actualizarGTOSMED=function(etiqueta,nuevoValor){
         if(etiqueta=="OVP MUERTE"){

            for(var i=0;i<$scope.v1.length;i++){
                if($scope.v1[i].ETIQUETA=="OVP GTOS MED"){
                    $scope.v1[i].MONTO_BASE=Math.ceil(nuevoValor*$scope.v1[i].PORCENTAJE);
                }
            } 
            for(var i=0;i<$scope.datos.length;i++){
                if($scope.datos[i].ETIQUETA=="OVP GTOS MED"){
                    $scope.datos[i].MONTO_BASE=Math.ceil(nuevoValor*$scope.datos[i].PORCENTAJE);
                }
            } 
         }
     };
     $scope.buscarCotizacion = function() {

            //console.log("Buscar");

            if ($scope.datosGenerales.numeroCotizacion!=null)
            {
                $scope.promesaMarcas.promise.$$state.status=0;
                $scope.franquicia.promise.$$state.status=0;
                $scope.promesaProducto.promise.$$state.status=0;
                //$scope.promesaFraccion.promise.$$state.status=0;

                $scope.cargando=true;
                $scope.esBuscar=true;
                $scope.marcaNoPreferencia=true;
                var datosBuscador={};
                datosBuscador.numeroCotizacion=$scope.datosGenerales.numeroCotizacion;
                $scope.persistirProducto=false;
                $scope.persistir=false;
                $scope.sumaAseguradaBuscar=true;
                $scope.esNuevo ="N";

                $scope.limpiarDatos();
                $scope.cargarMarcas();
                $scope.cargarDescuentoEspecial();
                $timeout( function(){
                    CotizacionVehiculoService.getCotizacion(datosBuscador).then(

                        function (response) {

                            if(!response.data.error){


                                $scope.habilitarPropuesta=true;
                                $scope.bloquearBuscador=true;
                                $scope.editablesDescPoliza=false;
                                $scope.cambiarFraccion=false;



                                if(!angular.isUndefined(response.data.dato) && response.data.dato != null){

                                    if(response.data.dato.length >0){
                                        if (response.data.dato[0].codigoPolizaGrupo!="" && response.data.dato[0].codigoPolizaGrupo!=null)
                                        {
                                            $scope.promesaFraccion.promise.$$state.status=0;
                                        }
                                        $scope.cargarPlataforma();


                                        $scope.promesaMarcas.promise.then(
                                            function()
                                            {
                                                $scope.vehiculo.marca=parseInt(response.data.dato[0].codigoMarca);

                                            });
                                        $scope.promesaModelo.promise.then(
                                            function(){
                                                $scope.vehiculo.modelo=parseInt(response.data.dato[0].codigoModelo);
                                            }
                                        );

                                        $scope.promesaSubModelo.promise.then(
                                            function(){
                                                $scope.vehiculo.subModelo=parseInt(response.data.dato[0].codigoSubmodelo);
                                            }
                                        );
                                        $scope.promesaAnho.promise.then(
                                            function(){
                                                $scope.vehiculo.anho=parseInt(response.data.dato[0].anioSubmodelo);

                                            }
                                        );
                                        $scope.promesaProducto.promise.then(
                                            function(){

                                                if(response.data.dato[0].codigoProducto != null && response.data.dato[0].codigoProducto !=""){
                                                    $scope.cobertura.producto=parseInt(response.data.dato[0].codigoProducto);
                                                }else{
                                                    $scope.cobertura.producto=undefined;
                                                    $scope.persistirProducto=true;
                                                }


                                                //llamar a un metodo que cargue la cobertura de esta cotizacion
                                                $scope.datosCobertura=[];
                                                if (response.data.dato[0].coberturasVehiculo.length>0 && response.data.dato[0].coberturasVehiculo.length!= null)
                                                {
                                                    $scope.mostrarCartas=true;
                                                    for (var i=0; i< response.data.dato[0].coberturasVehiculo.length; i++)
                                                    {
                                                        // $scope.datosCobertura.push({"COD_COB": response.data.dato[0].coberturasVehiculo[i].cod_cob,"ETIQUETA":response.data.dato[0].coberturasVehiculo[i].etiqueta,"CAPITAL":Number(response.data.dato[0].coberturasVehiculo[i].capital),"MAXIMO":Number(response.data.dato[0].coberturasVehiculo[i].maximo), "INCREMENTO": Number(response.data.dato[0].coberturasVehiculo[i].incremento),"MCA_MODIFICABLE":response.data.dato[0].coberturasVehiculo[i].marcaModificable, "MONTO_BASE": Number(response.data.dato[0].coberturasVehiculo[i].capital) } );
                                                        $scope.datosCobertura.push({"COD_COB": response.data.dato[0].coberturasVehiculo[i].cod_cob,"ETIQUETA":response.data.dato[0].coberturasVehiculo[i].etiqueta,"CAPITAL":Number(response.data.dato[0].coberturasVehiculo[i].capital), "INCREMENTO": Number(response.data.dato[0].coberturasVehiculo[i].incremento),"MCA_MODIFICABLE":response.data.dato[0].coberturasVehiculo[i].marcaModificable, "MONTO_BASE": Number(response.data.dato[0].coberturasVehiculo[i].capital), "PORCENTAJE": parseFloat(response.data.dato[0].coberturasVehiculo[i].porcentajeCobertura) } );
                                                        if(response.data.dato[0].coberturasVehiculo[i].maximo!="" ){
                                                            $scope.datosCobertura[i].MAXIMO=Number(response.data.dato[0].coberturasVehiculo[i].maximo);
                                                        }else{
                                                            $scope.datosCobertura[i].MAXIMO=-1;
                                                        }

                                                    }
                                                    $scope.setearCobertura($scope.datosCobertura);
                                                    $scope.cargando=false;
                                                }
                                                else
                                                {

                                                    $scope.mostrarCartas=false;
                                                    $scope.cargando=false;
                                                }
                                            }
                                        );

                                        $scope.vehiculo.referido=response.data.dato[0].referido;
                                        $scope.promesaPoliza.promise.then(
                                            function(){
                                                $scope.comercial.poliza=response.data.dato[0].codigoPolizaGrupo;

                                            }
                                        );

                                        $scope.comercial.desctEspecial=response.data.dato[0].codigoDescEspecial;
                                        if (response.data.dato[0].descuentoComercial != null)
                                        {
                                            $scope.desctComercial=true;
                                        }
                                        $scope.comercial.desctComercial2=response.data.dato[0].descuentoComercial!=null && response.data.dato[0].descuentoComercial!=""?parseFloat(response.data.dato[0].descuentoComercial):undefined;
                                        //$scope.comercial.recComercial=response.data.dato[0].recargoComercial;
                                        $scope.promesaFraccion.promise.then(
                                            function(){
                                                if(response.data.dato[0].codigoFraccionamiento!= ""){
                                                    $scope.comercial.fraccion=parseInt(response.data.dato[0].codigoFraccionamiento);
                                                }else{
                                                    $scope.comercial.fraccion=null;
                                                }

                                            }
                                        );
                                        $scope.datosGenerales.numeroCotizacion =parseInt(response.data.dato[0].numeroCotizacion);
                                        $scope.datosGenerales.nuevo=response.data.dato[0].marcaRenovacion;
                                        $scope.comercial.primeraCuota=response.data.dato[0].marcaCuotaIgual==null?'N':response.data.dato[0].marcaCuotaIgual;
                                        $scope.comercial.inicial=response.data.dato[0].importeInicial;
                                        //$scope.comercial.malus =response.data.dato[0].malus;
                                        $scope.comercial.bono2=response.data.dato[0].bonus;
                                        $scope.vehiculo.moneda=parseInt(response.data.dato[0].codigoMoneda);
                                        $scope.vehiculo.ocupantes=parseInt(response.data.dato[0].numeroPlazas);


                                        $scope.listaCostoVehiculos=[];
                                        $scope.listaCostoVehiculos =response.data.dato[0].costoVehiculo;
                                        for(var i=0; i<$scope.listaCambio.length; i++){
                                            if ($scope.listaCambio[i].id==$scope.vehiculo.moneda){
                                                $scope.vehiculo.cotizacion = $scope.listaCambio[i].cambio;
                                                break;
                                            }
                                        }
                                        $scope.vehiculo.cotizacion=!angular.isUndefined(response.data.dato[0].cambio)&& response.data.dato[0].cambio!=null?parseInt(response.data.dato[0].cambio):1;

                                        $q.all( [
                                            $scope.promesaProducto.promise.then(),  $scope.franquicia.promise.then()
                                        ] ).then(function(sucess){
                                            if (response.data.dato[0].codigoFranquicia!=null && response.data.dato[0].importeFranquicia!=null && response.data.dato[0].codigoFranquicia!="" && response.data.dato[0].importeFranquicia!="")
                                            {
                                                //$scope.cobertura.franquicia={};
                                                $scope.cobertura.franquicia=response.data.dato[0].codigoFranquicia;
                                                //$scope.cobertura.franquicia.importeFranquicia=response.data.dato[0].importeFranquicia;
                                            }
                                            else
                                            {
                                                $scope.cobertura.franquicia=undefined;
                                            }
                                        });



                                        /*$scope.franquicia.promise.then(function()
                                        {
                                            if (response.data.dato[0].codigoFranquicia!=null && response.data.dato[0].importeFranquicia!=null)
                                            {
                                                //$scope.cobertura.franquicia={};
                                                $scope.cobertura.franquicia=response.data.dato[0].codigoFranquicia;
                                                //$scope.cobertura.franquicia.importeFranquicia=response.data.dato[0].importeFranquicia;
                                            }
                                        })*/
                                        $q.all( [$scope.promesaModelo.promise.then(), $scope.promesaSubModelo.promise.then(),$scope.promesaAnho.promise.then(),
                                            $scope.promesaProducto.promise.then(),$scope.promesaPoliza.promise.then() , $scope.promesaFraccion.promise.then()
                                        ] ).then(function(sucess){
                                            $scope.cobertura.sumaAsegurada=response.data.dato[0].sumaAsegurada;
                                            $scope.cargarListadoCostoVehiculo();
                                        });



                                    }

                                }else{
                                    Message.error(response.data.mensaje);
                                    $scope.cargando=false;
                                    
                                }
                            }else{
                                $scope.habilitarPropuesta=false;
                                $scope.recargar();
                                Message.error(response.data.mensaje);
                                $scope.cargando=false;
                                //

                            }





                        },
                        function(response){
                            $scope.persistirProducto=true;
                            $scope.persistir=true;
                            Message.error(response.data.mensaje);
                            
                        });

                }, 2000 );


            }
            
            

             
        };

        /**
         * Constructor / Entrypoint
         * @constructor
         */
        $scope.cargarCombos= function() {
            $scope.cargarFraccionamiento("S");
            
            $scope.cargarMonedas();
            $scope.cargarMarcas();
             

            $scope.cargarDescuentoEspecial();
            $scope.cargarPolizaGrupo()


        };

        $scope.recargar = function()
        {

            if(typeof $routeParams.numeroCotizacion != "undefined"){
                $location.search('numeroCotizacion', undefined);
                $rootScope.numeroCotizacionRoot = undefined;
                $location.path('cotizacion-vehiculo')

            }
            else
            {
                $route.reload();
            }


        };

                $scope.filteredText = $filter('number')($scope.cobertura.sumaAsegurada);




/*************cargacobertura******************/

$scope.cargarDatosCobertura = function(){
        //console.log("Cargar datos cobertura");
      if(!angular.isUndefined($scope.datosGenerales.numeroCotizacion)){
        var  parametros ={};
        parametros.numeroCotizacion= parseInt($scope.datosGenerales.numeroCotizacion);
        $scope.v1=[];
        $scope.v2=[];
        $scope.datosCobertura=[];
        $scope.datos=[];
        $scope.cargando=true;
        CotizacionVehiculoService.listarCoberturas(parametros).then(
                    function (response) {
                       //console.log(response.data.dato);
                        if (!response.data.error)
                        {
                            if (response.data.dato != null)
                            {
                                if(response.data.dato.length>0)
                                {
                                    var datosResponse=[];
                                    datosResponse=response.data.dato;
                                    //console.log(datosResponse);
                                    $scope.datosCobertura=[];
                                    for (var i=0; i< datosResponse.length; i++)
                                    {
                                        $scope.datosCobertura.push({"COD_COB": datosResponse[i].COD_COB,"ETIQUETA":datosResponse[i].ETIQUETA,"CAPITAL":datosResponse[i].CAPITAL,"MAXIMO":datosResponse[i].MAXIMO, "INCREMENTO": datosResponse[i].INCREMENTO,"MCA_MODIFICABLE":datosResponse[i].MCA_MODIFICABLE, "MONTO_BASE": datosResponse[i].CAPITAL } );


                                    }
                                    //$scope.datosCobertura=response.data.dato;
                                    /*   $scope.cobertura.producto=undefined;
                                       $scope.cobertura.sumaAsegurada=undefined;*/
                                    //$scope.sindatost=true;
                                    $scope.setearCobertura($scope.datosCobertura);
                                    //$scope.cargando=false;
                                }
                                else
                                {
                                    $scope.cargando=false;
                                }


                            }
                            else
                            {
                                $scope.sindatos=true;
                                $scope.cargando=false;
                            }
                        }
                        else
                        {
                            $scope.cargando=false;
                            $scope.sindatos=true;
                        }

                 },
                    function(response){
                       // promesaAnho.reject();
                        Message.error("Ocurrio un error, no se pudo obtener la lista de coberturas");
                        
                    });              

    }else{
        $scope.vehiculo.cotizacion=null;
    }
    $scope.cargando=false;

};
$scope.actualizarCotizacion=function ()
{
   // console.log("Valor de suma agregada ", $scope.cobertura.sumaAsegurada);
    //$scope.validarNumero();
    $scope.cargando=true;
    $scope.cobertura.franquicia=undefined;
    $scope.verificarFranquicia($scope.cobertura.producto,$scope.vehiculo.moneda, $scope.cobertura.sumaAsegurada);
    if ($scope.cobertura.sumaAsegurada != undefined && $scope.cobertura.sumaAsegurada != null)
    {
        var  parametros ={};
        parametros.esNuevo=$scope.esNuevo;
        parametros.codigoMarca=$scope.vehiculo.marca;
        parametros.codigoModelo=$scope.vehiculo.modelo;
        parametros.codigoSubModelo=$scope.vehiculo.subModelo;
        parametros.anho=$scope.vehiculo.anho;
        parametros.codigoMoneda=$scope.vehiculo.moneda;
        parametros.codigoRamo=501;
        parametros.numeroCotizacion=$scope.datosGenerales.numeroCotizacion;
        $scope.recalcularCotizacion(parametros);
    }
    else
    {
        $scope.cargando=false;
    }


};
$scope.recalcularCotizacion=function(parametros)
{
    $scope.validarSumaAsegurada();
    if ($scope.montoValido)
    {

        $scope.v1=[];
        $scope.datosCobertura=[];
        $scope.datos=[];
        $scope.cartas=[];
        var guardadoParcial=$scope.guardadoParcialCabecera();
               guardadoParcial.then(function (result)
               {

                if (result.error==false)
                   {
                    if (result.dato != null)
                    {
                        $scope.datosGenerales.numeroCotizacion=parseInt(result.dato.numeroCotizacion);
                        $scope.habilitarPropuesta=true;
                       //parametros.numeroCotizacion=$scope.datosGenerales.numeroCotizacion;
                      // console.log("Hace el guardado parcial");
                       /*CotizacionVehiculoService.listarCoberturas(parametros).then(
            
                        function (response2) {
                           if(response2.data.dato != null && response2.data.dato.length>0)
                           {
                            $scope.datosCobertura=[];
                            $scope.mostrarCartas=true;
                           // $scope.datosCobertura=response2.data.dato;
                           
                            for (var i=0; i< response2.data.dato.length; i++)
                            {
                                $scope.datosCobertura.push({"COD_COB": response2.data.dato[i].COD_COB,"ETIQUETA":response2.data.dato[i].ETIQUETA,"CAPITAL":response2.data.dato[i].CAPITAL,"MAXIMO":response2.data.dato[i].MAXIMO, "INCREMENTO": response2.data.dato[i].INCREMENTO,"MCA_MODIFICABLE":response2.data.dato[i].MCA_MODIFICABLE, "MONTO_BASE": response2.data.dato[i].CAPITAL } );
                                

                            }
                            //$scope.datosCobertura=response.data.dato;
                             /*   $scope.cobertura.producto=undefined;
                                $scope.cobertura.sumaAsegurada=undefined;*/
                            //$scope.sindatost=true;
                            /*$scope.setearCobertura($scope.datosCobertura);
                            //$scope.cargando=false;
                            $scope.sindatos=false;
                            
                            $scope.cobertura.codigoCobertura=response2.data.dato.COD_COB;
                            $scope.cobertura.etiqueta=response2.data.dato.ETIQUETA;
                            $scope.cobertura.capital=response2.data.dato.CAPITAL;
                              
        

                                //$scope.cargando=false;
                              /* $scope.cargarPlataforma();*/
                                $scope.actualizarDatos();

                              
                             /*   $scope.cobertura.producto=undefined;
                                $scope.cobertura.sumaAsegurada=undefined;*/
                         /*}

						 
						else
						{
							$scope.cargando=false;
                            $scope.mostrarCartas=false;
                            $scope.cargarPlataforma();
							//Message.error(response2.data.mensaje);
						}
					}).catch(function(response) {
                           $scope.cargando=false;
                           Message.error("Ocurrio un error, intente nuevamente!")
                       });*/
                    }
					else
                    {
                        $scope.cargando=false;
                        //Message.error(result.data.mensaje);
                    }
                    

                      
                   }
                   else
                   {
                       $scope.cargando=false;
                       Message.error(result.mensaje);
                   }
               }).catch(function(response) {
                $scope.cargando=false;
                console.log("Ocurrrio errror");
                Message.error("Ocurrio un error, intente nuevamente!")
                })
    }
    else
    {
        $scope.cargando=false;
    }
};
$scope.cambiarRangoDescuento=function()
{
    if (!angular.isUndefined($scope.comercial.poliza) && $scope.comercial.poliza!=null)
    {
        var roles=sessionStorage.getItem("roles");
        if (roles !="" && roles.indexOf("TECAUT")>0)
        {
            $scope.minDescRec=-100;
            $scope.maxDescRec=100;
        }
        else
        {
            $scope.minDescRec=0;
            $scope.maxDescRec=100;
        }


    }
    else
    {
        $scope.minDescRec=-100;
        $scope.maxDescRec=100;
    }
};
$scope.verificarMontoCobertura=function (cobertura)
{
    if(cobertura.MAXIMO!=-1){
    var montoActual=cobertura.MONTO_BASE
    if (montoActual> cobertura.MAXIMO && cobertura.MAXIMO>0) 
    {
        cobertura.MONTO_BASE=cobertura.MAXIMO;
    }
    else if (montoActual< cobertura.CAPITAL)
    {
        cobertura.MONTO_BASE=cobertura.CAPITAL;
    }
    else
    {
        cobertura.MONTO_BASE=montoActual;
    }
    if(montoActual!=cobertura.MONTO_BASE){
        $scope.actualizarGTOSMED(cobertura.ETIQUETA,cobertura.MONTO_BASE);
    }   
    }
};
$scope.incrementarCobertura=function (cobertura)
{
    var montoActual=cobertura.MONTO_BASE;
    if (montoActual>= cobertura.MAXIMO && cobertura.MAXIMO>0)
    {
        cobertura.MONTO_BASE=cobertura.MAXIMO;
    }
    else
    {
        cobertura.MONTO_BASE+=cobertura.INCREMENTO;
    }
};
$scope.decrementarCobertura=function (cobertura)
{
    var montoActual=cobertura.MONTO_BASE;
    if (montoActual<= cobertura.CAPITAL)
    {
        cobertura.MONTO_BASE=cobertura.CAPITAL;
    }
    else
    {
        cobertura.MONTO_BASE-=cobertura.INCREMENTO;
    }
};
$scope.limpiarFormasPago=function()
{
   /* $scope.debitoAutomatico ={};
    $scope.debitoAutomatico.prima="0";
    $scope.debitoAutomatico.costoTotal ="0";
    $scope.debitoAutomatico.cuota="0";
    $scope.debitoAutomatico.ultimaCuota="0";

    $scope.contado ={};
    $scope.contado.prima="0";
    $scope.contado.costoTotal ="0";

    $scope.chequera ={};
    $scope.chequera.prima="0";
    $scope.chequera.costoTotal ="0";
    $scope.chequera.cuota="0";
    $scope.chequera.ultimaCuota="0";*/
    $scope.listaCostoVehiculos=[];
    $scope.sindatost=false;
};
$scope.setearCobertura=function(coberturas)
{   
    $scope.sindatos=false;
    $scope.cartaVerde=false;
    $scope.cartaAzul=false;
    $scope.v1=[];
    $scope.v2=[];
    $scope.datosCobertura=[];
    $scope.datos=[];
    $scope.bloquearCartaVerde=true;
    $scope.bloquearCartaAzul=true;
    var CV,CA;
    CA=0,CV=0;
    $scope.datosCobertura=angular.copy(coberturas);
    $scope.cartas=[];

    //$scope.datos = angular.copy($scope.datosCobertura);

    
    for(var i=0;i<$scope.datosCobertura.length;i++)
    {

        if($scope.datosCobertura[i].ETIQUETA==="CARTA VERDE"){
            if ($scope.datosCobertura[i].MCA_MODIFICABLE=="S")
            {
                $scope.bloquearCartaVerde=false;
            }
            $scope.cartas.push($scope.datosCobertura[i]);
            $scope.cartaVerde = true;
            CV=i;
        }else if($scope.datosCobertura[i].ETIQUETA==="CARTA AZUL"){
            if ($scope.datosCobertura[i].MCA_MODIFICABLE=="S")
            {
                $scope.bloquearCartaAzul=false;
            }
            $scope.cartas.push($scope.datosCobertura[i]);
            $scope.cartaAzul = true;
            CA=i;
        }
        else
        {
            $scope.datos.push($scope.datosCobertura[i]);
        }
    }
    $scope.datosCobertura=angular.copy($scope.datos);

    if($scope.datosCobertura.length<=6){
        var i=0;
        while($scope.datos.length>0 && $scope.v1.length<=6){
            $scope.v1.push($scope.datos[i]);
           // i++;
           $scope.datos.splice(0,1);
        };
    }else{
        //var x=$scope.datosCobertura.length/2;
        var cant = UtilsService.truncar($scope.datosCobertura.length/2);

        var resto = $scope.datosCobertura.length%2;
        var cantxColum = cant + resto;
        var i=0;
        var temp =[];
        temp=angular.copy($scope.datos);
        while(temp.length>0 && $scope.v1.length< cantxColum){
            $scope.v1.push(temp[i]);
            $scope.datos.splice(0,1);
            i++;
        };
        

    }
        //console.log($scope.v1);
        //console.log($scope.datos);
            $scope.cargando=false;
    
    
};

$scope.setearDatosSubModelo=function()
{
    for(var i=0; i<$scope.datosSubmodelo.length; i++){
        if ($scope.datosSubmodelo[i].id==$scope.vehiculo.subModelo){
            $scope.vehiculo.tipo=$scope.datosSubmodelo[i].tipo;
            $scope.vehiculo.codigoTipo=$scope.datosSubmodelo[i].codTipo;
            if ($scope.esBuscar==false)
            {
                $scope.vehiculo.ocupantes=parseInt($scope.datosSubmodelo[i].cantOcup);
            }
            else
            {
                $scope.esBuscar=false;
            }
            $scope.minOcupantes=parseInt($scope.datosSubmodelo[i].cantMinOcup);
            $scope.maxOcupantes=parseInt($scope.datosSubmodelo[i].cantOcup);
            break;
        }
    }

    for(var i=0; i<$scope.listaSubModelos.length; i++){
        if ($scope.listaSubModelos[i].id==$scope.vehiculo.subModelo){
            $scope.nomSubModelo=$scope.listaSubModelos[i].subModelo;

            break;
        }
    }
};
/*********************************************/



    /**
     * Función creada para el salto de cotización a propuesta
     */
    $scope.goToPropuesta = function() {
        var path = $location.$$absUrl; 
        var n = path.search("module");
        var url =  path.substring(0 , n);
        $scope.cargando=true;
        if(typeof $scope.datosGenerales.numeroCotizacion != 'undefined' && $scope.datosGenerales.numeroCotizacion != null){

          location.href ='propuesta-vehiculo/propuesta/'+$scope.datosGenerales.numeroCotizacion;


        }else{            
            Message.warning("Debe ingresar un número de cotización");
        }
    }
     /*descargar carta oferta
     };*/
     $scope.verificarCamposForm=function(listaCampo, campo)
        {
            return UtilsService.verificarCamposForm(listaCampo, campo);
        };
     

     $scope.cargarPlataforma = function(){

        var paramPla={};
        paramPla.numeroCotizacion=$scope.datosGenerales.numeroCotizacion;
        paramPla.pathModule=$scope.pathModule;

      CotizacionVehiculoService.getPlataforma(paramPla).then(

                       
                        function (response) {
                          if(!response.data.error){
                             if(response.data.dato!=null  )  {
                                   
                                $scope.mostrarPlataforma=true;
                                 
                                   $scope.datosGenerales.plataforma=response.data.dato.mensaje;

                                
                            }

                          }
                     

                        }).catch(function(response){
                           
                            Message.error("Ocurrio un error intente nuevamente");
                           
                        });
          };
        $scope.obtenerAutorizaciones=function()
        {
             
            $scope.autorizacionesList = [];
            var params={};
            params.pathModule=$scope.pathModule;
            CotizacionVehiculoService.getAutorizaciones(params).then(function(response){
               if (!response.data.error)
               {
                   if (response.data.dato.length>0)
                   {
                       var campos=response.data.dato;
                       for (var i=0; i< campos.length; i++)
                       {
                           $scope.autorizacionesList.push(campos[i]);
                           if (campos[i]==='btnEliminar'){
                              $rootScope.botonEliminar=true;

                           }
                       }
                   }
                  
                   //console.log("Lista Autorizaciones: " + JSON.stringify($scope.autorizacionesList));
               }
               else
                   {
                   Message.error(response.data.mensaje);
               }
            });
        };
        $scope.obtenerCamposEditables=function()
        {

            $scope.camposEditablesList = [];
            
            
            var params={};
            params.pathModule=$scope.pathModule;
                      
            params.numeroCotizacion=angular.isUndefined($scope.datosGenerales.numeroCotizacion)|| $scope.datosGenerales.numeroCotizacion==null?"":$scope.datosGenerales.numeroCotizacion;
            CotizacionVehiculoService.getCamposEditables(params).then(function(response){
               if (!response.data.error)
               {
                   if (response.data.dato.length>0)
                   {
                       var campos=response.data.dato;
                       for (var i=0; i< campos.length; i++)
                       {
                           $scope.camposEditablesList.push(campos[i]);
                       }
                   }
                   }
               else
                   {
                   Message.error(response.data.mensaje);
               }
            });
        };
        $scope.obtenerCamposRequeridos=function()
        {

            $scope.camposRequeridosList = [];
            var params={};
            params.numeroCotizacion=angular.isUndefined($scope.datosGenerales.numeroCotizacion)?"":$scope.datosGenerales.numeroCotizacion!=null?$scope.datosGenerales.numeroCotizacion:"";
            params.pathModule=$scope.pathModule;
            CotizacionVehiculoService.getCamposRequeridos(params).then(function(response){
               if (!response.data.error)
               {
                   if (response.data.dato.length>0)
                   {
                       var campos=response.data.dato;
                       for (var i=0; i< campos.length; i++)
                       {
                           $scope.camposRequeridosList.push(campos[i]);
                       }
                   }
               }
               else
                   {
                   Message.error(response.data.mensaje);
               }
            });
        };
        $scope.emitirDocumento=function()
        {
            $scope.emitir=true;
        };

        $scope.llamarModal = function(value) {

        if(!angular.isUndefined($scope.datosGenerales.numeroCotizacion)&& $scope.datosGenerales.numeroCotizacion!=null && $scope.datosGenerales.numeroCotizacion!=""){ 
            $rootScope.numCotiza = $scope.datosGenerales.numeroCotizacion;
            $rootScope.autEsNuevo=$scope.esNuevo;
            $rootScope.modalCotizadorVehFlota=value;
            $rootScope.flagVehiculoFlota=true;
            $mdDialog.show({
                //locals:{mobile: $scope.esMobile},
                controller: 'ModalAutorizacionCtrl',
                templateUrl: 'partials/ventanas-emergentes/modal-autorizacion-partial.html',
                parent: angular.element(document.body),
                multiple: true,
                clickOutsideToClose:false,
               /* scope:$scope,
                preserveScope: true,*/
                fullscreen: $scope.customFullscreen // Only for -xs, -sm breakpoints.

            }).then(function(answer) {
                 
                /* $scope.cargando=true;
                 console.log("Entra aca ");
                $scope.status = 'You said the information was "' + answer + '".';
                if (!angular.isUndefined(answer.numeroCotizacion) && answer.numeroCotizacion !="" && answer.numeroCotizacion!= null){
                    $scope.datosGenerales.numeroCotizacion = parseInt(answer.numeroCotizacion);
                }else{
                     Message.error("Numero de cotizacion inexistente");
                     return;
               
                }*/

                
                $scope.buscarCotizacion();


            }, function() {
                $scope.status = 'You cancelled the dialog.';
                console.log($scope.status);
            });
           } 

        };
        $scope.verificarCamposForm=function(listaCampo, campo)
        {
            return UtilsService.verificarCamposForm(listaCampo, campo);
        };
        $scope.franquicia=$q.defer();
        $scope.verificarFranquicia=function(producto, moneda, sumaAsegurada)
        {
            $scope.cargando=true;

            $scope.listaFranquicias=[];
            $scope.mostrarFranquicia=false;
            if (!angular.isUndefined(producto) && producto!=null )
            {
                for (var i=0; i< $scope.listaProductos.length; i++)
                {
                    if ($scope.listaProductos[i].id==producto)
                    {
                        if ($scope.listaProductos[i].mcaFranquicia=="S")
                        {
                            $scope.mostrarFranquicia=true;
                            break;
                        }
                    }
                }
                if ($scope.mostrarFranquicia)
                {
                    var data=null;
                    var params={};
                    params.moneda=moneda;
                    params.sumaAsegurada=angular.isUndefined(sumaAsegurada)?null:sumaAsegurada;
                    CotizacionVehiculoService.getFranquicias(params).then(function(response) {
                        if (!response.data.error)
                        {

                            if (response.data.dato!=null && response.data.dato.length>0)
                            {
                                data=response.data.dato;
                                for (var i=0; i<data.length;i++)
                                {
                                    $scope.listaFranquicias.push(data[i]);
                                }
                                $scope.franquicia.resolve();
                                $scope.cargando=false;


                            }
                            else {
                                $scope.cargando=false;
                                $scope.franquicia.resolve();

                            }
                        }
                        else {
                            $scope.cargando=false;
                            $scope.franquicia.reject();
                            Message.error(response.data.mensaje);
                        }
                    })
                }
                else
                {
                    $scope.cargando=false;
                }
            }



        };
        $scope.recuperarImporte=function(codigo)
        {
            for (var i=0; i<$scope.listaFranquicias.length;i++) {
                if ($scope.listaFranquicias[i].codigoFranquicia == codigo) {
                    return $scope.listaFranquicias[i].importeFranquicia;
                }
            }
        };


        (function initialize() {

            $scope.sindatos=true;
            $scope.sindatost=false;
            $scope.comercial.primeraCuota='S';
            $scope.flagConfirmacion=true;
            $scope.persistir= true;
            $scope.persistirProducto=true;
            $scope.listaCostoVehiculos=[];
            $scope.mostrarCartas=false;
            $scope.controlRequerido = false;
           
            $scope.pathModule = UtilsService.retornarPath($location.path().split("/")[1]);
            $scope.obtenerCamposEditables();
            //$scope.obtenerCamposRequeridos();
            $scope.obtenerAutorizaciones();
        //    $scope.datosGenerales.nuevo=false;

            $scope.vehiculo.cotizacion=1;
            $scope.botonEliminar = undefined;


            //console.log($rootScope.usuarioActual);
            $scope.path = "/" +$location.$$path.split("/")[1] + "/";
            $scope.cargarCombos();
            //sessionStorage.setItem("hola","hola");
           //if ($scope.controlPermisos != undefined ){
            if ($window.sessionStorage["rolesAsignados"]!=undefined && $window.sessionStorage["rolesAsignados"]!=null){
                var listaRoles = $window.sessionStorage["rolesAsignados"].split(",");
                $scope.controlPermisos = listaRoles.indexOf("rol_1")>-1? true:false;
            }
            
           //}




            /**
             * Verifica si la ventana fue llamada desde propuesta
             */
            if(typeof $routeParams.numeroCotizacion != "undefined"){
                
                $rootScope.numeroCotizacionRoot = $routeParams.numeroCotizacion;
                $scope.datosGenerales.numeroCotizacion=$rootScope.numeroCotizacionRoot;
                $scope.buscarCotizacion();
            }else if(!angular.isUndefined($rootScope.numCotizacionBcp) && $rootScope.numCotizacionBcp!=null){
                //viene del bcp 
                $rootScope.numeroCotizacionRoot =  $rootScope.numCotizacionBcp;
                $scope.datosGenerales.numeroCotizacion=$rootScope.numeroCotizacionRoot;
                $rootScope.numCotizacionBcp=undefined;
                $scope.buscarCotizacion();
            }

        })();


    }]);
;app.controller('CotizacionVehiculoMobileFormCtrl', ['$scope', '$q','CotizacionVehiculoService','$timeout', '$controller', '$routeParams', '$location', 'SessionService', '$rootScope','$route', '$mdDialog', '$filter', 'ConfirmService', '$window','BuscadorCotizacionService', 'UtilsService','PropuestaService','$locale',
    function ($scope,$q, CotizacionVehiculoService, $timeout, $controller, $routeParams, $location, sessionService, $rootScope,$route, $mdDialog,  $filter, confirmService, $window, BuscadorCotizacionService,UtilsService, PropuestaService,$locale) {

        $rootScope.rootPathParent = $route.current.$$route.originalPath;
        $scope.service = PropuestaService;
        $locale.NUMBER_FORMATS.GROUP_SEP = '.';
        $locale.NUMBER_FORMATS.DECIMAL_SEP = ',';
        $scope.data = {};
        $scope.data.seccion = undefined;
        $scope.customFullscreen = false;
        $scope.mostrarDocumento = {};


        $scope.listaMarcas = [];
        $scope.datosSubmodelo = [];
        $scope.listaCambio = [];
        var parametros = {};

        // combos vehiculos
        $scope.listaGrupoPoliza = [];

        $scope.years = [];

        $scope.listaMonedas = [];
        $scope.datosGrupoPoliza = [];
        $scope.datosDescuentoEspecial = [];
        //combo comercial
        $scope.listaProductos = [];
        $scope.listaPolizas = [];
        $scope.listaDesctComercial = [];

        $scope.listaDesctEspc = [];

        $scope.listaFraccion = [];
        $scope.vehiculo = {};
        $scope.vehiculo.referido = 'N';
        $scope.vehiculo.marca = undefined;
        $scope.vehiculo.subModelo = undefined;
        $scope.vehiculo.modelo = undefined;
        $scope.vehiculo.anho = undefined;
        $scope.vehiculo.ocupantes = undefined;
        $scope.vehiculo.moneda = undefined;
        $scope.vehiculo.tipo = undefined;
        $scope.datosGenerales = {};
        $scope.datosGenerales.nuevo = "N";
        $scope.datosGenerales.numeroPoliza = undefined;
        $scope.datosGenerales.numeroPolizaAnterior = undefined;
        $scope.datosGenerales.numeroCotizacion = undefined;

        $scope.comercial = {};
        $scope.comercial.desctComercial = undefined;
        $scope.comercial.desctP = "1";
        $scope.comercial.desctEspecial = undefined;
        $scope.comercial.desctComercial2 = undefined;
        $scope.comercial.recComercial = undefined;
        $scope.comercial.fraccion = undefined;
        $scope.comercial.cuota = "S";
        $scope.comercial.poliza = undefined;
        $scope.comercial.polizaDescripcion = "";
        $scope.comercial.bono = undefined;
        $scope.comercial.bono2 = null;
        $scope.comercial.malus = null;
        $scope.comercial.inicial = undefined;
        $scope.comercial.primeraCuota = undefined;
        $scope.comercial.polizaPorct = undefined;

        $scope.cobertura = {};
        $scope.cobertura.rcPersonas = "200000000";
        $scope.cobertura.ovpGtosMdeOcup = "200000000";
        $scope.cobertura.robo = "200";
        $scope.cobertura.granizo = "200";
        $scope.cobertura.incendioEdificio = "200";
        $scope.cobertura.danhosVandalismo = "200";
        $scope.cobertura.rcDanhosMateriales = "200000000";
        $scope.cobertura.danhosPropiosTotal = "200";
        $scope.cobertura.roboParcialRadio = "2011";
        $scope.cobertura.accidentePersonales = "200";
        $scope.cobertura.incendioContenidoVivienda = "300";
        $scope.cobertura.airbag = "200";
        $scope.cobertura.ovpMteOcupante = "200000000";
        $scope.cobertura.danhosPropiedad = "200";
        $scope.cobertura.roboParcialRadio2 = "200";
        $scope.cobertura.gtoMedAccPersonales = "200";
        $scope.cobertura.sepelio = "200";
        $scope.cobertura.cartaVerde = true;
        $scope.cobertura.cartaAzul = false;
        $scope.cobertura.producto = undefined;
        $scope.cobertura.sumaAsegurada = 0;
        $scope.cobertura.minMonto = 0;
        $scope.cobertura.maxMonto = 0;
        $scope.debitoAutomatico = {};
        $scope.debitoAutomatico.prima = "0";
        $scope.debitoAutomatico.costoTotal = "0";
        $scope.debitoAutomatico.cuota = "0";
        $scope.debitoAutomatico.ultimaCuota = "0";

        $scope.contado = {};
        $scope.contado.prima = "0";
        $scope.contado.costoTotal = "0";

        $scope.chequera = {};
        $scope.chequera.prima = "0";
        $scope.chequera.costoTotal = "0";
        $scope.chequera.cuota = "0";
        $scope.chequera.ultimaCuota = "0";
        $scope.desctComercial = false;
        $scope.recComercial = false;
        $scope.coberturaDatos = [];
        $scope.minDescRec = -100;
        $scope.maxDescRec = 100;
        $scope.maxDescEspecial = 0;
        $scope.restriccion = "^[0-9]+(\,[0-9]{1,2})?$";
        $scope.camposEditablesList = [];
        $scope.submitted = false;
        $scope.emitir = false;
        $scope.todo_marcas = false;
        $scope.preferencia_marcas = $window.sessionStorage.getItem("preferencia_marcas");
        $scope.preferencia_moneda = $window.sessionStorage.getItem("preferencia_moneda");
        $scope.preferencia_fraccionamiento = $window.sessionStorage.getItem("preferencia_fraccionamiento");
        $scope.bloquearCartaVerde = true;
        $scope.bloquearCartaAzul = true;
        $scope.minOcupantes = 0;
        $scope.maxOcupantes = 0;
        $scope.esBuscar = false;
        $scope.sumaAseguradaBuscar = false;
        $scope.marcaNoPreferencia = false;
        $scope.nombrePDF = undefined;
        $scope.autorizacion = false;
        $scope.bloquearBuscador=false;
        $scope.promesaSave = $q.defer();
        $scope.editablesDescPoliza=true;
        $scope.monedaPolizaG=true;
        $scope.fraccionPolizaG=true;
        $scope.mostrarFranquicia=false;
        $scope.listaFranquicias=[];
        $scope.codigoFranquicia=undefined;
        $scope.cambiarFraccion=true;
        $scope.save = function () {
            $scope.cargando=true;
            //obtenemos los campos requeridos
            $scope.camposRequeridosList = [];
            var params = {};
            params.numeroCotizacion = angular.isUndefined($scope.datosGenerales.numeroCotizacion) ? "" : $scope.datosGenerales.numeroCotizacion != null ? $scope.datosGenerales.numeroCotizacion : "";
            params.pathModule=$scope.pathModule;
            CotizacionVehiculoService.getCamposRequeridos(params).then(function (response) {
                if (!response.data.error) {
                    if (response.data.dato.length > 0) {
                        var campos = response.data.dato;
                        $scope.camposRequeridosList=campos;
                        $timeout(function(){
                            if ($scope.CotizacionMobileForm.$invalid && !angular.isUndefined($scope.CotizacionMobileForm.$error.required)) {
                                $scope.cargando=false;
                                Message.warning("Existe campos requeridos sin completar");
                                return;
                            }
                            else
                            {
                                //console.log("Valido"); //llamar al guardar
                                $scope.camposRequeridosList = [];
                                $scope.validarSumaAsegurada();
                                if ($scope.montoValido) {
                                    var datosSave = {};
                                    datosSave.codigoMarca = $scope.vehiculo.marca;
                                    datosSave.nombreMarca = $scope.vehiculo.nombreMarca;
                                    datosSave.codigoModelo = $scope.vehiculo.modelo;
                                    datosSave.nombreModelo = $scope.nombreModelo;
                                    datosSave.codigoSubmodelo = $scope.vehiculo.subModelo;
                                    datosSave.nombreSubmodelo = $scope.nomSubModelo;
                                    datosSave.anioSubmodelo = $scope.vehiculo.anho;
                                    datosSave.codigoTipoVehiculo = $scope.vehiculo.codigoTipo;
                                    datosSave.nombreTipoVehiculo = $scope.vehiculo.tipo;
                                    datosSave.numeroPlazas = $scope.vehiculo.ocupantes;
                                    datosSave.sumaAsegurada = $scope.cobertura.sumaAsegurada;
                                    // console.log("Descuento comercial ", $scope.comercial.desctComercial2);
                                    datosSave.descuentoComercial = $scope.comercial.desctComercial2;
                                    //datosSave.recargoComercial=$scope.comercial.recComercial;
                                    datosSave.bonus = $scope.comercial.bono2;
                                    //datosSave.malus=$scope.comercial.malus;
                                    datosSave.codigoPolizaGrupo = $scope.comercial.poliza;
                                    datosSave.nombrePolizaGrupo = $scope.nombrePolizaGrupo;
                                    datosSave.porcentajePolizaGrupo = $scope.comercial.polizaPorct;
                                    datosSave.codigoDescEspecial = $scope.comercial.desctEspecial;
                                    datosSave.nombreDescEspecial = $scope.nombreDescEspecial;
                                    datosSave.porcentajeDescEspecial = $scope.comercial.desctEspecialPorct;
                                    datosSave.cambio = $scope.vehiculo.cotizacion;

                                    /*if (angular.isUndefined($scope.cobertura.producto)){
                                            $scope.controlRequerido = true;
                                            Message.info("Complete los valores requeridos");
                                            return;
                                        }else{
                                            $scope.controlRequerido = false;
                                        }*/
                                    datosSave.codigoProducto = angular.isUndefined($scope.cobertura.producto) ? null : $scope.cobertura.producto;
                                    datosSave.referido = $scope.vehiculo.referido;
                                    datosSave.codigoMoneda = $scope.vehiculo.moneda;
                                    datosSave.codigoFraccionamiento = $scope.comercial.fraccion;
                                    datosSave.importeInicial = $scope.comercial.inicial;
                                    datosSave.marcaCuotaIgual = $scope.comercial.primeraCuota;
                                    datosSave.marcaFlota = 'N';

                                    datosSave.numeroCotizacion = $scope.datosGenerales.numeroCotizacion;
                                    if (!angular.isUndefined($scope.cobertura.franquicia))
                                    {
                                        datosSave.codigoFranquicia=$scope.cobertura.franquicia;
                                        datosSave.importeFranquicia=$scope.recuperarImporte(datosSave.codigoFranquicia);
                                    }
                                    else
                                    {
                                        datosSave.codigoFranquicia=null;
                                        datosSave.importeFranquicia=null;
                                    }

                                    $scope.coberturaDatos = [];
                                    if ($scope.cartas)
                                    {
                                    //console.log("El valor de datos ", $scope.datos);                                          {
                                        for (var i=0; i< $scope.cartas.length;i++)
                                        {
                                            var obj = {
                                                numeroCotizacion: datosSave.numeroCotizacion,
                                                codigoCobertura: $scope.cartas[i].COD_COB,
                                                etiqueta: $scope.cartas[i].ETIQUETA,
                                                importeCapital: $scope.cartas[i].MONTO_BASE,
                                                marcaModificable: $scope.cartas[i].MCA_MODIFICABLE
                                            };
                                            $scope.coberturaDatos.push(obj);
                                        }
                                    }
                                    if ($scope.v1 && $scope.datos) {
                                        for (var i = 0; i < $scope.v1.length; i++) {

                                            var obj = {

                                                numeroCotizacion: datosSave.numeroCotizacion,
                                                codigoCobertura: $scope.v1[i].COD_COB,
                                                etiqueta: $scope.v1[i].ETIQUETA,
                                                importeCapital: $scope.v1[i].MONTO_BASE,
                                                marcaModificable: $scope.v1[i].MCA_MODIFICABLE
                                            };

                                            $scope.coberturaDatos.push(obj);
                                        }
                                        for (var i = 0; i < $scope.datos.length; i++) {
                                            var obj = {

                                                numeroCotizacion: datosSave.numeroCotizacion,
                                                codigoCobertura: $scope.datos[i].COD_COB,
                                                etiqueta: $scope.datos[i].ETIQUETA,
                                                importeCapital: $scope.datos[i].MONTO_BASE,
                                                marcaModificable: $scope.datos[i].MCA_MODIFICABLE
                                            };

                                            $scope.coberturaDatos.push(obj);
                                        }
                                        datosSave.coberturasVehiculo = angular.copy($scope.coberturaDatos);
                                    }
                                    else {
                                        datosSave.coberturasVehiculo = [];
                                    }
                                    $scope.cargando = true;
                                    CotizacionVehiculoService.guardarCotizacionVehiculo(datosSave).then(
                                        function (response) {
                                            if (!response.data.error) {
                                                if (response.data.dato.length > 0) {
                                                    $scope.listaCostoVehiculos = [];
                                                    $scope.listaCostoVehiculos = response.data.dato[0].costoVehiculo ? response.data.dato[0].costoVehiculo : [];
                                                    $scope.cargarListadoCostoVehiculo();


                                                    $scope.datosGenerales.numeroCotizacion = parseInt(response.data.dato[0].numeroCotizacion);


                                                    $scope.cargando = false;

                                                    Message.ok(response.data.mensaje);

                                                    $scope.clickButton = false;

                                                    $scope.promesaSave.resolve();


                                                }
                                                else
                                                {
                                                    $scope.cargando=false;
                                                }
                                                $scope.buscarCotizacion();

                                            } else {
                                                $scope.cargando = false;
                                                Message.error(response.data.mensaje);
                                                
                                                $scope.promesaSave.reject();

                                            }


                                        }).catch(function (response) {
                                        $scope.cargando = false;
                                        Message.error("Ocurrio un error intente nuevamente!");
                                        
                                        $scope.promesaSave.reject();
                                    });
                                    $scope.montoValido = false;

                                }
                                else {
                                    $scope.cargando = false;
                                }

                            }
                        }, 1000);

                    }
                    else
                    {
                        $scope.cargando=false;
                    }


                }
                else {
                    $scope.cargando=false;
                        Message.error(response.data.mensaje);
                    }
                });





        };
        $scope.actualizarDatos = function() {

            var datosSave={};
            datosSave.codigoMarca=$scope.vehiculo.marca;
            datosSave.nombreMarca=$scope.vehiculo.nombreMarca;
            datosSave.codigoModelo=$scope.vehiculo.modelo;
            datosSave.nombreModelo= $scope.nombreModelo;
            datosSave.codigoSubmodelo=$scope.vehiculo.subModelo;
            datosSave.nombreSubmodelo=$scope.nomSubModelo;
            datosSave.anioSubmodelo=$scope.vehiculo.anho;
            datosSave.codigoTipoVehiculo=$scope.vehiculo.codigoTipo;
            datosSave.nombreTipoVehiculo=$scope.vehiculo.tipo;
            datosSave.numeroPlazas=$scope.vehiculo.ocupantes;
            datosSave.sumaAsegurada=$scope.cobertura.sumaAsegurada;
            //console.log("Descuento comercial ", $scope.comercial.desctComercial2);
            datosSave.descuentoComercial=$scope.comercial.desctComercial2;
            //datosSave.recargoComercial=$scope.comercial.recComercial;
            datosSave.bonus=$scope.comercial.bono2;
            //datosSave.malus=$scope.comercial.malus;
            datosSave.codigoPolizaGrupo=$scope.comercial.poliza;
            datosSave.nombrePolizaGrupo=$scope.nombrePolizaGrupo;
            datosSave.porcentajePolizaGrupo=$scope.comercial.polizaPorct;
            datosSave.codigoDescEspecial=$scope.comercial.desctEspecial;
            datosSave.nombreDescEspecial=$scope.nombreDescEspecial;
            datosSave.porcentajeDescEspecial=$scope.comercial.desctEspecialPorct;
            datosSave.codigoProducto= angular.isUndefined($scope.cobertura.producto)?null:$scope.cobertura.producto;
            datosSave.referido= $scope.vehiculo.referido;
            datosSave.codigoMoneda=$scope.vehiculo.moneda;
            datosSave.codigoFraccionamiento=$scope.comercial.fraccion;
            datosSave.importeInicial=$scope.comercial.inicial;
            datosSave.marcaCuotaIgual=$scope.comercial.primeraCuota;
            datosSave.marcaFlota='N';

            datosSave.numeroCotizacion=$scope.datosGenerales.numeroCotizacion;
            datosSave.cambio=$scope.vehiculo.cotizacion;
            if (!angular.isUndefined($scope.cobertura.franquicia))
            {
                datosSave.codigoFranquicia=$scope.cobertura.franquicia.codigoFranquicia;
                datosSave.importeFranquicia=$scope.recuperarImporte(datosSave.codigoFranquicia);
            }
            else
            {
                datosSave.codigoFranquicia=null;
                datosSave.importeFranquicia=null;
            }
            $scope.coberturaDatos=[];
            if ($scope.cartas)
            {
                for (var i=0; i< $scope.cartas.length;i++)
                {
                    var obj = {

                        numeroCotizacion: datosSave.numeroCotizacion,
                        codigoCobertura: $scope.cartas[i].COD_COB,
                        etiqueta: $scope.cartas[i].ETIQUETA,
                        importeCapital: $scope.cartas[i].MONTO_BASE,
                        marcaModificable: $scope.cartas[i].MCA_MODIFICABLE
                    };
                    $scope.coberturaDatos.push(obj);
                }
            }


            for(var i=0; i<$scope.v1.length; i++){

                var obj = {

                    numeroCotizacion:datosSave.numeroCotizacion,
                    codigoCobertura:$scope.v1[i].COD_COB,
                    etiqueta:$scope.v1[i].ETIQUETA,
                    importeCapital:$scope.v1[i].MONTO_BASE,
                    marcaModificable:$scope.v1[i].MCA_MODIFICABLE
                };

                $scope.coberturaDatos.push(obj);
            }
            for (var i=0; i< $scope.datos.length;i++)
            {
                var obj = {

                    numeroCotizacion:datosSave.numeroCotizacion,
                    codigoCobertura:$scope.datos[i].COD_COB,
                    etiqueta:$scope.datos[i].ETIQUETA,
                    importeCapital:$scope.datos[i].MONTO_BASE,
                    marcaModificable:$scope.datos[i].MCA_MODIFICABLE
                };

                $scope.coberturaDatos.push(obj);
            }

            datosSave.coberturasVehiculo= angular.copy($scope.coberturaDatos);
            $scope.cargando=true;
            //console.log("Actualizar datos");
            CotizacionVehiculoService.guardarCotizacionVehiculo(datosSave).then(
                function (response) {
                    if(!response.data.error){
                        $scope.buscarCotizacion();
                        /*if(response.data.dato.length>0)  {
                            $scope.listaCostoVehiculos=[];
                            $scope.listaCostoVehiculos =response.data.dato[0].costoVehiculo?response.data.dato[0].costoVehiculo:[];
                            $scope.cargarListadoCostoVehiculo();


                            $scope.datosGenerales.numeroCotizacion=parseInt(response.data.dato[0].numeroCotizacion);
                            //$scope.cargarDatosCobertura();


                            //$scope.cargando=false;
                            //Message.ok("El registro se ha registrado exitosamente.");
                            //$scope.sindatost=true;

                            $scope.cargando=true;
                            $scope.buscarCotizacion();

                        }
                        else
                        {
                            $scope.cargando=false;
                        }*/


                    }else{
                        $scope.cargando=false;
                        Message.error(response.data.mensaje);
                        

                    }




                }).catch(function(response){
                $scope.cargando=false;
                Message.error("Ocurrio un error intente nuevamente!");
            });



        };
        $scope.validarSumaAsegurada = function () {
            //console.log($scope.cobertura.sumaAsegurada);
            //console.log($scope.cobertura.minMonto);
            if ($scope.cobertura.sumaAsegurada != null && $scope.cobertura.sumaAsegurada != 0 && !angular.isUndefined($scope.cobertura.sumaAsegurada)) {
                if (Number($scope.cobertura.sumaAsegurada) < Number($scope.cobertura.minMonto) || Number($scope.cobertura.sumaAsegurada) > Number($scope.cobertura.maxMonto)) {
                    if ($scope.verificarCamposForm($scope.camposEditablesList, 'sumaAsegurada')) {
                        Message.error("El monto asegurado ingresado no cumple con el rango requerido, el monto debe ser como mínimo " + $scope.cobertura.minMonto + " y como máximo " + $scope.cobertura.maxMonto + ", verifique el monto e intente nuevamente.");
                        $scope.montoValido = false;

                    }

                    else {
                        $scope.montoValido = true;
                    }
                }
                else {
                    $scope.montoValido = true;
                }
            }
            else {
                Message.error("El monto asegurado ingresado no es correcto, verifique el monto e intente nuevamente.");
                $scope.montoValido = false;
            }

        };


        $scope.buscarPoliza = function (evt) {
            if (angular.isUndefined(evt)) {
                //Ejecutado cuando $scope.buscar es invocado sin parametros --NO CREOQ QUE HAGA FALTA ESTE CONTROL

            } else {
                //enter
                if (angular.equals(evt.keyCode, 13)) {
                }
            }

        };
        $scope.buscarCotizacion = function (evt) {
            if (angular.isUndefined(evt)) {
                //Ejecutado cuando $scope.buscar es invocado sin parametros --NO CREOQ QUE HAGA FALTA ESTE CONTROL

            } else {
                //enter
                if (angular.equals(evt.keyCode, 13)) {
                }
            }
        };
        $scope.resetFilter = function () {
            $scope.comercial.inicial = undefined;
        };

        $scope.promesaMarcas = $q.defer();
        $scope.cargarMarcas = function () {

            var parametros = {};
            if ($scope.marcaNoPreferencia) {
                $scope.esBuscar = false;
                parametros.preferencia = "N";
                $scope.marcaNoPreferencia = false;
                $scope.todo_marcas = false;

            }
            else {
                if ($scope.preferencia_marcas == "S") {
                    parametros.preferencia = "S";
                    $scope.todo_marcas = true;
                }
                else {
                    parametros.preferencia = "N";
                    $scope.todo_marcas = false;
                }
            }

            parametros.esNuevo = $scope.esNuevo;
            CotizacionVehiculoService.getMarcas(parametros).then(
                function (response) {
                    if (response.data.error == false) {
                        if (response.data.dato != null) {
                            $scope.listaMarcas = [];
                            for (var i = 0; i < response.data.dato.length; i++) {
                                var obj = {
                                    id: response.data.dato[i].COD_MARCA,
                                    marca: response.data.dato[i].NOM_MARCA
                                };
                                $scope.listaMarcas.push(obj);

                            }
                        }


                    }
                    else {
                        Message.error(response.data.mensaje);
                    }
                    $scope.promesaMarcas.resolve();


                },
                function (response) {
                    $scope.promesaMarcas.reject();
                    Message.error(response.data.mensaje);
                    
                });

        };

        var valorGua;
        var valorDol;
        var valorEu;

        $scope.cargarMonedas = function () {
            //primero traemos todas las monedas
            var parametros = {};
            parametros.preferencia = "N"; //por defecto no tiene preferencia, luego consultar la variable que almacena
            parametros.esNuevo = $scope.esNuevo;
            CotizacionVehiculoService.getMonedas(parametros).then(
                function (response) {
                    if (response.data.error == false) {
                        if (response.data.dato !== null) {
                            for (var i = 0; i < response.data.dato.length; i++) {
                                var camb = {
                                    id: response.data.dato[i].COD_MON,
                                    cambio: response.data.dato[i].VAL_CAMBIO
                                };
                                var obj = {
                                    id: response.data.dato[i].COD_MON,
                                    moneda: response.data.dato[i].NOM_MON
                                };
                                $scope.listaMonedas.push(obj);
                                $scope.listaCambio.push(camb);

                                //valorGua= response.data.dato[0].VAL_CAMBIO;
                                //valorDol= response.data.dato[1].VAL_CAMBIO;
                                //valorEu= response.data.dato[2]? response.data.dato[2].VAL_CAMBIO: 0.0;


                            }
                            //aca procedemos a llamar si tiene preferencia o no
                            if ($scope.preferencia_moneda == "S") {
                                parametros = {};
                                parametros.esNuevo = $scope.esNuevo;
                                parametros.preferencia = $scope.preferencia_moneda;
                                //pasamos con el parametro que tiene preferencia
                                CotizacionVehiculoService.getMonedas(parametros).then(
                                    function (response) {
                                        if (response.data.error == false && response.data.dato.length > 0) {
                                            $scope.acti = false;
                                            $scope.vehiculo.moneda = parseInt(response.data.dato[0].COD_MON);
                                            /*if($scope.vehiculo.moneda==1){

                                                $scope.vehiculo.cotizacion=valorGua;
                                            }else if($scope.vehiculo.moneda==2){

                                                $scope.vehiculo.cotizacion=valorDol;
                                            }else{

                                                $scope.vehiculo.cotizacion=valorEu;
                                            };*/
                                            if ($scope.listaMonedas.length > 0) {
                                                for (var i = 0; i < $scope.listaCambio.length; i++) {
                                                    if ($scope.listaCambio[i].id == $scope.vehiculo.moneda) {
                                                        $scope.vehiculo.cotizacion = $scope.listaCambio[i].cambio;

                                                        break;
                                                    }
                                                }

                                            }
                                        }
                                    });
                            }
                            else {
                                //$scope.activar=true;
                                if ($scope.listaMonedas.length > 0) {
                                    $scope.vehiculo.moneda = $scope.listaMonedas[0].id;
                                    $scope.vehiculo.cotizacion = $scope.listaCambio[0].cambio;
                                    //$scope.vehiculo.moneda=1;
                                }

                            }
                        }

                    }
                    else {
                        Message.error(response.data.mensaje);

                    }


                },
                function (response) {
                    Message.error(response.data.mensaje);
                    
                });

        };

        $scope.promesaPoliza = $q.defer();
        $scope.cargarPolizaGrupo = function () {
            var parametros = {};
            parametros.esNuevo = $scope.esNuevo;
            parametros.pathModule =$scope.pathModule;
            CotizacionVehiculoService.getPolizaGrupo(parametros).then(
                function (response) {
                    if (response.data.error == false) {
                        if (response.data.dato != null) {
                            for (var i = 0; i < response.data.dato.length; i++) {
                                var dato = {
                                    id: response.data.dato[i].NUM_POLIZA,
                                    porcentaje: response.data.dato[i].PORC_DESCUENTO
                                };

                                var obj = {
                                    id: response.data.dato[i].NUM_POLIZA,
                                    poliza: response.data.dato[i].NOM_POLIZA
                                };
                                $scope.listaGrupoPoliza.push(obj);
                                $scope.datosGrupoPoliza.push(dato);
                            }
                        }

                    }
                    else {
                        Message.error(response.data.mensaje);
                    }

                    $scope.promesaPoliza.resolve();

                },
                function (response) {
                    $scope.promesaPoliza.reject();
                    Message.error(response.data.mensaje);
                    
                });

        };

        $scope.cargarDescuentoEspecial = function () {
            $scope.listaDesctEspc=[];
            $scope.datosDescuentoEspecial=[];
            var parametros = {};
            parametros.esNuevo = $scope.esNuevo;
            parametros.pathModule = $scope.pathModule;
            parametros.numeroCotizacion=$scope.datosGenerales.numeroCotizacion==null?"":$scope.datosGenerales.numeroCotizacion;
            CotizacionVehiculoService.getDescuentosEspeciales(parametros).then(
                function (response) {
                    if (response.data.error == false) {
                        if (response.data.dato != null) {
                            for (var i = 0; i < response.data.dato.length; i++) {

                                var objDatos = {
                                    id: response.data.dato[i].COD_VALOR,
                                    desct: response.data.dato[i].PCT_DESCUENTO
                                };

                                var obj = {
                                    id: response.data.dato[i].COD_VALOR,
                                    desct: response.data.dato[i].NOM_VALOR
                                };
                                $scope.listaDesctEspc.push(obj);
                                $scope.datosDescuentoEspecial.push(objDatos);
                            }
                        }

                    }
                    else {
                        Message.error(response.data.mensaje);
                    }


                },
                function (response) {
                    Message.error(response.data.mensaje);
                    
                });

        };


        $scope.promesaFraccion = $q.defer();
        $scope.cargarFraccionamiento = function (preferencia) {
            var parametros = {}; //al inicio traer todas las listas de fraccionamiento
            parametros.preferencia = "N";
            parametros.esNuevo = $scope.esNuevo;
            parametros.codigoGrupoPoliza= !angular.isUndefined($scope.comercial.poliza)?$scope.comercial.poliza!=null?$scope.comercial.poliza:"":"";
            $scope.listaFraccion=[];
            CotizacionVehiculoService.getFraccionamiento(parametros).then(
                function (response) {
                    if (response.data.error == false) {
                        if (response.data.dato != null) {
                            for (var i = 0; i < response.data.dato.length; i++) {
                                var obj = {
                                    id: response.data.dato[i].COD_FRACC_PAGO,
                                    fraccion: response.data.dato[i].NOM_FRACC_PAGO
                                };
                                $scope.listaFraccion.push(obj);
                            }
                            //si tiene preferencia entonces llamar a la preferencia y seleccionar por defecto
                            if ($scope.preferencia_fraccionamiento == "S") {
                                if ( preferencia=="S")
                                {
                                    //llamar al servicio que traiga la preferencia
                                    parametros = {};
                                    parametros.preferencia = $scope.preferencia_fraccionamiento;
                                    parametros.esNuevo = $scope.esNuevo;
                                    parametros.codigoGrupoPoliza= !angular.isUndefined($scope.comercial.poliza)?$scope.comercial.poliza!=null?$scope.comercial.poliza:"":"";
                                    CotizacionVehiculoService.getFraccionamiento(parametros).then(
                                        function (response) {
                                            if (response.data.error == false && response.data.dato != null && response.data.dato.length>0) {
                                                //se setea el fraccionamiento por defecto
                                                $scope.comercial.fraccion=parseInt(response.data.dato[0].COD_FORMA_PAGO);

                                            }

                                        })
                                }

                            }
                            else {
                                if (preferencia=="N")
                                {
                                    $scope.comercial.fraccion =99100;
                                }
                            }
                        }

                    }
                    else {
                        Message.error(response.data.mensaje);
                        
                    }

                    $scope.promesaFraccion.resolve();
                },
                function (response) {
                    $scope.promesaFraccion.reject();
                    Message.error(response.data.mensaje);
                    
                });

        };


        //cuando cambia el combo marca
        $scope.promesaModelo = $q.defer();
        $scope.$watch('vehiculo.marca', function (NewValue, OldValue) {

            if (!angular.isUndefined(NewValue) && NewValue != null) {
                if (NewValue == "todos") {
                    $scope.vehiculo.marca = undefined;
                    //aca llamar a marcas con tiene Preferencia de Marcas "N"
                    $scope.todo_marcas = false;
                    $scope.preferencia_marcas = "N";
                    $scope.cargarMarcas();


                }
                else {
                    var parametros = {};

                    parametros.preferencia = 0;
                    parametros.esNuevo = $scope.esNuevo;
                    parametros.codigoMarca = $scope.vehiculo.marca;

                    for (var i = 0; i < $scope.listaMarcas.length; i++) {
                        if ($scope.listaMarcas[i].id == NewValue) {
                            $scope.vehiculo.nombreMarca = $scope.listaMarcas[i].marca;
                            break;
                        }
                    }

                    //SE LIMPIAN LOS COMBOS DEPENDIENTES
                    $scope.listaModelos = [];
                    $scope.listaSubModelos = [];
                    $scope.years = [];
                    $scope.datosSubmodelo = [];

                    CotizacionVehiculoService.getModelos(parametros).then(
                        function (response) {
                            if (response.data.error == false && response.data.dato != null) {
                                for (var i = 0; i < response.data.dato.length; i++) {
                                    var obj = {
                                        id: response.data.dato[i].COD_MODELO,
                                        modelo: response.data.dato[i].NOM_MODELO
                                    };
                                    $scope.listaModelos.push(obj);
                                }
                            }
                            else {
                                Message.error("No se pudo obtener los modelos");
                            }

                            $scope.promesaModelo.resolve();

                        },
                        function (response) {
                            $scope.promesaModelo.reject(response);
                            Message.error(response.data.mensaje);
                            
                        });
                }


            } else {
                $scope.listaModelos = [];
                $scope.listaSubModelos = [];
                $scope.years = [];
                $scope.datosSubmodelo = [];
                $scope.vehiculo.tipo = null;
                $scope.vehiculo.ocupantes = null;
                $scope.listaProductos = [];
            }


        }, true);

        //
        $scope.promesaSubModelo = $q.defer();
        $scope.$watch('vehiculo.modelo', function (NewValue, OldValue) {
            if (!angular.isUndefined(NewValue) && NewValue != null) {

                var parametros = {};
                $scope.listaSubModelos = [];
                $scope.datosSubmodelo = [];
                if (!$scope.sumaAseguradaBuscar)
                {
                    $scope.cobertura.sumaAsegurada=0;
                }
                $scope.cobertura.minMonto = 0;
                $scope.cobertura.maxMonto = 0;

                parametros.esNuevo = $scope.esNuevo;
                parametros.codigoMarca = $scope.vehiculo.marca;
                parametros.codigoModelo = $scope.vehiculo.modelo;
                for (var i = 0; i < $scope.listaModelos.length; i++) {
                    if ($scope.listaModelos[i].id == NewValue) {
                        $scope.nombreModelo = $scope.listaModelos[i].modelo;
                        break;
                    }
                }


                CotizacionVehiculoService.getSubModelos(parametros).then(
                    function (response) {

                        for (var i = 0; i < response.data.dato.length; i++) {

                            var datos = {
                                id: response.data.dato[i].COD_SUB_MODELO,
                                tipo: response.data.dato[i].NOM_TIP_VEHI,
                                codTipo: response.data.dato[i].COD_TIP_VEHI,
                                cantOcup: response.data.dato[i].NUM_PLAZAS,
                                cantMinOcup: response.data.dato[i].NUM_PLAZAS_MIN,

                            }

                            var obj = {
                                id: response.data.dato[i].COD_SUB_MODELO,
                                subModelo: response.data.dato[i].NOM_SUB_MODELO
                            };
                            $scope.listaSubModelos.push(obj);
                            $scope.datosSubmodelo.push(datos);
                            //console.log($scope.datosSubmodelo);
                        }

                        $scope.promesaSubModelo.resolve();
                        //console.log("Datos Submodelo ", $scope.datosSubmodelo.length);
                        //setear el submodelo
                        $scope.setearDatosSubModelo();


                    },
                    function (response) {
                        $scope.promesaSubModelo.reject();
                        Message.error(response.data.mensaje);
                        
                    });


            } else {
                $scope.listaSubModelos = [];
                $scope.years = [];
                $scope.datosSubmodelo = [];
                $scope.vehiculo.tipo = null;
                $scope.vehiculo.ocupantes = null;
                $scope.cobertura.sumaAsegurada = 0;
                $scope.cobertura.minMonto = 0;
                $scope.cobertura.maxMonto = 0;
            }

        }, true);

        $scope.promesaAnho = $q.defer();
        $scope.$watch('vehiculo.subModelo', function (NewValue, OldValue) {

            if (!angular.isUndefined(NewValue) && NewValue != null) {
                $scope.submodel = NewValue;

                $scope.years = [];
                if (!$scope.sumaAseguradaBuscar)
                {
                    $scope.cobertura.sumaAsegurada=0;
                }
                $scope.cobertura.minMonto = 0;
                $scope.cobertura.maxMonto = 0;


                var parametros = {};
                parametros.esNuevo = $scope.esNuevo;
                parametros.codigoMarca = $scope.vehiculo.marca;
                parametros.codigoModelo = $scope.vehiculo.modelo;
                parametros.codigoSubModelo = $scope.vehiculo.subModelo;
                parametros.codigoMoneda = $scope.vehiculo.moneda;
                $scope.setearDatosSubModelo();


                $scope.yearsVehiculo = [];

                CotizacionVehiculoService.getAnhoSubModelos(parametros).then(
                    function (response) {
                        if (!response.data.error)
                        {
                            if (response.data.dato!=null && response.data.dato.length>0) {
                                $scope.yearsVehiculo = response.data.dato;
                                for (var i = 0; i < response.data.dato.length; i++) {
                                    var obj = {
                                        id: response.data.dato[i].ANIO_SUB_MODELO,
                                        value: response.data.dato[i].ANIO_SUB_MODELO
                                    };

                                    $scope.years.push(obj);
                                }
                            }

                        }
                        else
                        {
                            Message.error(response.data.mensaje);
                        }

                        $scope.promesaAnho.resolve();
                    },
                    function (response) {
                        $scope.promesaAnho.reject();
                        Message.error(response.data.mensaje);
                        
                    });

            } else {
                $scope.years = [];
                $scope.vehiculo.tipo = null;
                $scope.vehiculo.ocupantes = null;
            }

        }, true);

        $scope.datosCobertura = [];

        $scope.$watch('cobertura.producto', function (NewValue, OldValue) {
            if (!angular.isUndefined(NewValue) && NewValue != null) {
                //console.log("persistir producto", $scope.persistirProducto);
                if ($scope.persistirProducto == true) {
                    $scope.flagConfirmacion = false;
                    $scope.promesaSave.promise.$$state.status = 0;

                    $scope.cambioProducto = true;
                    var parametros = {};
                    parametros.esNuevo = $scope.esNuevo;
                    parametros.codigoMarca = $scope.vehiculo.marca;
                    parametros.codigoModelo = $scope.vehiculo.modelo;
                    parametros.codigoSubModelo = $scope.vehiculo.subModelo;
                    parametros.anho = $scope.vehiculo.anho;
                    parametros.codigoMoneda = $scope.vehiculo.moneda;
                    parametros.codigoRamo = 501;
                    parametros.numeroCotizacion = $scope.datosGenerales.numeroCotizacion;
                    $scope.cargando = true;
                    $scope.cobertura.franquicia=undefined;
                    /**verificar que el producto seleccionado tenga franquicia**/
                    $scope.verificarFranquicia(NewValue, $scope.vehiculo.moneda, $scope.cobertura.sumaAsegurada);
                    $scope.recalcularCotizacion(parametros);
                } else {
                    $scope.persistirProducto = true;
                    /**verificar que el producto seleccionado tenga franquicia**/
                    $scope.verificarFranquicia(NewValue, $scope.vehiculo.moneda, $scope.cobertura.sumaAsegurada);
                }


            } else {
                $scope.datosCobertura = [];
                $scope.mostrarCartas = false;
                $scope.mostrarFranquicia=false;
                $scope.setearCobertura($scope.datosCobertura);
                $scope.limpiarFormasPago();

                /* $scope.vehiculo.cotizacion=null;*/
            }


        }, true);

        var valorSub = 0;
        var valorSubMax;
        var valorSubMin;
        var valorCot;


        $scope.cambiarMoneda = function () {
            if (!angular.isUndefined($scope.vehiculo.moneda)) {
                var parametros = {};
                parametros.esNuevo = $scope.esNuevo;
                parametros.codigoMarca = $scope.vehiculo.marca;
                parametros.codigoModelo = $scope.vehiculo.modelo;
                parametros.codigoSubModelo = $scope.vehiculo.subModelo;
                parametros.anho = $scope.vehiculo.anho;
                parametros.codigoMoneda = $scope.vehiculo.moneda;
                parametros.codigoRamo = 501;
                parametros.numeroCotizacion = !angular.isUndefined($scope.datosGenerales.numeroCotizacion) && $scope.datosGenerales.numeroCotizacion != null ? $scope.datosGenerales.numeroCotizacion : "";
                //   $scope.listaProductos=[];

                if ($scope.vehiculo.marca != undefined && $scope.vehiculo.marca != null && $scope.vehiculo.modelo != undefined && $scope.vehiculo.modelo != null
                    && $scope.vehiculo.subModelo != undefined && $scope.vehiculo.subModelo != null && $scope.vehiculo.anho != undefined && $scope.vehiculo.anho != null && $scope.vehiculo.moneda != undefined && $scope.vehiculo.moneda != null) {

                    $scope.cargando = true;

                    CotizacionVehiculoService.getSumaAsegurada(parametros).then(
                        function (response) {
                            if (response.data.error == false) {
                                if (response.data.dato != null) {
                                    $scope.cobertura.sumaAsegurada=response.data.dato[0].VAL_SUB_MODELO;
                                    $scope.cobertura.minMonto = response.data.dato[0].VAL_SUB_MODELO_MIN;
                                    $scope.cobertura.maxMonto = response.data.dato[0].VAL_SUB_MODELO_MAX;

                                    if ($scope.cobertura.sumaAsegurada != undefined && $scope.cobertura.producto != undefined) {

                                        parametros.codigoProducto = $scope.cobertura.producto;
                                        parametros.SumaAsegurada = $scope.cobertura.sumaAsegurada;

                                        parametros.codigoMoneda = $scope.vehiculo.moneda;

                                        //volver a obtener la cotizacion
                                        for (var i = 0; i < $scope.listaCambio.length; i++) {
                                            if ($scope.listaCambio[i].id == $scope.vehiculo.moneda) {
                                                $scope.vehiculo.cotizacion = $scope.listaCambio[i].cambio;
                                                break;
                                            }
                                        }
                                        //llamar al guardado parcial de la cotizacion
                                        $scope.cobertura.franquicia=undefined;
                                        $scope.codigoFranquicia=undefined;
                                        $scope.verificarFranquicia($scope.cobertura.producto, $scope.vehiculo.moneda, $scope.cobertura.sumaAsegurada);
                                        $scope.recalcularCotizacion(parametros);
                                    }
                                    else
                                    {
                                        $scope.cobertura.franquicia=undefined;
                                        $scope.codigoFranquicia=undefined;
                                        $scope.verificarFranquicia($scope.cobertura.producto, $scope.vehiculo.moneda, $scope.cobertura.sumaAsegurada);
                                        $scope.cargando=false;
                                    }

                                }
                                else {
                                    $scope.cargando = false;
                                    $scope.cobertura.franquicia=undefined;
                                    $scope.codigoFranquicia=undefined;
                                    $scope.verificarFranquicia($scope.cobertura.producto, $scope.vehiculo.moneda, $scope.cobertura.sumaAsegurada);
                                }


                            }
                            else {
                                $scope.cargando = false;
                                Message.error(response.data.mensaje);
                            }

                        },
                        function (response) {
                            $scope.cargando = false;
                            Message.error(response.data.mensaje);
                            
                        });


                }


                for (var i = 0; i < $scope.listaCambio.length; i++) {
                    if ($scope.listaCambio[i].id == $scope.vehiculo.moneda) {
                        $scope.vehiculo.cotizacion = $scope.listaCambio[i].cambio;
                        break;
                    }
                }


                /*if($scope.vehiculo.moneda==1){

                             valorCot=valorDol;
                        }else if($scope.vehiculo.moneda==2){

                             valorCot=valorGua;
                        }else{

                             valorCot=valorEu;
                        };*/


                var sumaAsegurada = valorSub * valorCot;
                var sumaAseguradaMax = valorSubMax * $scope.vehiculo.cotizacion;
                var sumaAseguradaMin = valorSubMin * $scope.vehiculo.cotizacion;
                $scope.cobertura.sumaAsegurada = sumaAsegurada ? sumaAsegurada : 0;


                if ($scope.acti) {
                    $scope.acti == false;
                }
                $scope.comercial.inicial = undefined;


            }
            else {
                $scope.vehiculo.cotizacion = null;
                $scope.comercial.inicial = undefined;
            }
        };


        $scope.promesaProducto = $q.defer();
        $scope.promesaSumaAsegurada = $q.defer();
        $scope.$watch('vehiculo.anho', function (NewValue, OldValue) {
            if (!angular.isUndefined(NewValue) && NewValue != null) {

                if ($scope.vehiculo.moneda == 1) {

                    valorCot = valorDol;
                } else if ($scope.vehiculo.moneda == 2) {

                    valorCot = valorGua;
                } else {

                    valorCot = valorEu;
                }
                ;


                for (var i = 0; i < $scope.yearsVehiculo.length; i++) {
                    if ($scope.yearsVehiculo[i].ANIO_SUB_MODELO == NewValue) {
                        valorSub = $scope.yearsVehiculo[i].VAL_SUB_MODELO;
                        valorSubMax = $scope.yearsVehiculo[i].VAL_SUB_MODELO_MAX;
                        valorSubMin = $scope.yearsVehiculo[i].VAL_SUB_MODELO_MIN;

                        var sumaAsegurada = valorSub * valorCot;
                        var sumaAseguradaMax = valorSubMax * $scope.vehiculo.cotizacion;
                        var sumaAseguradaMin = valorSubMin * $scope.vehiculo.cotizacion;

                        break;

                    }


                }

                var parametros = {};
                parametros.esNuevo = $scope.esNuevo;
                parametros.codigoMarca = $scope.vehiculo.marca;
                parametros.codigoModelo = $scope.vehiculo.modelo;
                parametros.codigoSubModelo = $scope.vehiculo.subModelo;
                parametros.anho = $scope.vehiculo.anho;
                parametros.codigoMoneda = $scope.vehiculo.moneda;
                parametros.codigoRamo = 501;
                parametros.numeroCotizacion = !angular.isUndefined($scope.datosGenerales.numeroCotizacion) && $scope.datosGenerales.numeroCotizacion != null ? $scope.datosGenerales.numeroCotizacion : "";
                parametros.renovacion=$scope.datosGenerales.nuevo;
                $scope.cargando = true;


                CotizacionVehiculoService.getSumaAsegurada(parametros).then(
                    function (response) {
                        if (response.data.error == false) {
                            if (response.data.dato != null) {
                                if (!$scope.sumaAseguradaBuscar)
                                {
                                    $scope.cobertura.sumaAsegurada=response.data.dato[0].VAL_SUB_MODELO;
                                    $scope.cobertura.franquicia=undefined;
                                    $scope.verificarFranquicia($scope.cobertura.producto,$scope.vehiculo.moneda, $scope.cobertura.sumaAsegurada);
                                }
                                else {
                                    $scope.sumaAseguradaBuscar=false;
                                }
                                $scope.cobertura.minMonto = response.data.dato[0].VAL_SUB_MODELO_MIN;
                                $scope.cobertura.maxMonto = response.data.dato[0].VAL_SUB_MODELO_MAX;
                            }


                        }
                        else {
                            $scope.cobertura.sumaAsegurada = sumaAsegurada ? sumaAsegurada : 0;
                            $scope.cobertura.minMonto = sumaAseguradaMin;
                            $scope.cobertura.maxMonto = sumaAseguradaMax;
                            $scope.cobertura.franquicia=undefined;
                            $scope.verificarFranquicia($scope.cobertura.producto,$scope.vehiculo.moneda, $scope.cobertura.sumaAsegurada);
                            Message.error(response.data.mensaje);
                        }
                        $scope.promesaSumaAsegurada.resolve();

                    },
                    function (response) {
                        $scope.promesaSumaAsegurada.reject();
                        $scope.cargando = false;
                        $scope.sumaAseguradaBuscar=false;
                        Message.error(response.data.mensaje);
                        
                    });


                CotizacionVehiculoService.getProductos(parametros).then(
                    function (response) {
                        if (response.data.error == false) {
                            //console.log("El producto actual es ", $scope.cobertura.producto);
                            $scope.listaProductos = [];
                            if (response.data.dato!=null && response.data.dato.length > 0) {
                                for (var i = 0; i < response.data.dato.length; i++) {
                                    var obj = {
                                        id: response.data.dato[i].COD_MODALIDAD,
                                        producto: response.data.dato[i].NOM_MODALIDAD,
                                        mcaFranquicia:response.data.dato[i].MCA_FRANQUICIA,
                                    };
                                    $scope.listaProductos.push(obj);

                                }
                            }

                            //verificar que en esa lista este el producto anterior
                            //console.log("El producto actual es ", $scope.cobertura.producto);
                            //console.log("Se encuentra el producto ", estaProducto);
                            /*if (estaProducto==false)
                            {
                                $scope.cobertura.producto=null;
                            }*/
                        }
                        else {
                            $scope.cargando = false;
                            $scope.cobertura.producto = undefined;
                            Message.error(response.data.mensaje);
                        }

                        $scope.promesaProducto.resolve();

                    },
                    function (response) {
                        $scope.promesaProducto.reject();
                        $scope.cargando = false;
                        Message.error(response.data.mensaje);
                        
                    });


                $q.all([$scope.promesaProducto.promise.then(), $scope.promesaSumaAsegurada.promise.then(),
                ]).then(
                    function (response) {
                        //console.log("persistir", $scope.persistir);
                        if ($scope.persistir == true) {
                            $scope.flagConfirmacion = false;

                            $scope.recalcularCotizacion(parametros);
                        } else {
                            $scope.persistir = true;
                            $scope.cargando = false;

                        }

                    },
                    function (response) {

                    }
                );


            } else {
                $scope.listaProductos = [];
            }

        }, true);

        $scope.$watch('comercial.poliza', function(NewValue, OldValue) {

            if(!angular.isUndefined(NewValue) && NewValue!=null)
            {

                if ($scope.cambiarFraccion)
                {
                    $scope.comercial.fraccion=undefined;
                    $scope.habilitarPreferenciaFracc=false;
                }
                else
                {
                    $scope.cambiarFraccion=true;
                }

                $scope.cargarFraccionamiento("N");

                if ($scope.editablesDescPoliza)
                {

                    var params = {};
                    params.numeroPolizaGrupo = NewValue;
                    params.moneda = $scope.vehiculo.moneda;
                    params.pathModule = $scope.pathModule;
                    $scope.promesaFraccion.promise.then(function() {
             
                        CotizacionVehiculoService.validarPolizaGrupo(params).then(function (response) {
                            if (response.data.error) {
                                $scope.comercial.poliza = undefined;
                                $scope.comercial.polizaPorct="";
                                $scope.comercial.nombrePolizaGrupo="";
                                $scope.monedaPolizaG=true;
                                $scope.fraccionPolizaG=true;
                                DialogService.showDialog(response.data.mensaje);


                            } else {
                                $scope.setearPorcentajeDesc(NewValue);
                                if (response.data.dato!=null)
                                {
                                    if (response.data.dato.monedaModificable=="S")
                                    {
                                        $scope.monedaPolizaG=true;
                                    }
                                    else
                                    {
                                        $scope.monedaPolizaG=false;
                                    }

                                    if (response.data.dato.fraccionamientoModificable=="S")
                                    {
                                        $scope.fraccionPolizaG=true;
                                    }
                                    else
                                    {
                                        $scope.fraccionPolizaG=false;
                                    }

                                    if (response.data.dato.codigoFraccionamiento!=null && response.data.dato.codigoFraccionamiento!="")
                                    {

                                        var fraccion=parseInt(response.data.dato.codigoFraccionamiento);
                                        var index=$scope.listaFraccion.map(function(e){return e.id;}).indexOf(fraccion);
                                        if (index !==-1)
                                        {
                                            $scope.comercial.fraccion=parseInt(response.data.dato.codigoFraccionamiento);
                                        }

                                    }
                                }





                            }
                        }).catch(function(error){
                            $scope.comercial.poliza = undefined;
                            $scope.comercial.polizaPorct="";
                            $scope.comercial.nombrePolizaGrupo="";
                            Message.error("Algo inesperado ha ocurrido, intente nuevamente!");
                        });
                    });


                }
                else
                {
                    $scope.editablesDescPoliza = true;
                    /**Calcular lo seteado por el buscar **/
                    $scope.setearPorcentajeDesc(NewValue);
                }


            }else{
                $scope.editablesDescPoliza = true;
                $scope.comercial.polizaPorct="";
                $scope.comercial.nombrePolizaGrupo="";
                $scope.comercial.desctComercial2=undefined;

                if ($scope.cambiarFraccion )
                {
                    $scope.comercial.fraccion=undefined;
                    $scope.promesaFraccion.promise.$$state.status=0;
                    //$scope.habilitarPreferenciaFracc=false;
                    $scope.cargarFraccionamiento("N");
                }
                else
                {

                    $scope.cambiarFraccion=true;
                }







            }
            $scope.cambiarRangoDescuento();

        },true);
        $scope.setearPorcentajeDesc=function(descPoliza)
        {
            for (var i = 0; i < $scope.datosGrupoPoliza.length; i++) {
                if ($scope.datosGrupoPoliza[i].id == descPoliza) {
                    $scope.comercial.polizaPorct = $scope.datosGrupoPoliza[i].porcentaje;
                    break;
                }
            }
            for (var i = 0; i < $scope.listaGrupoPoliza.length; i++) {
                if ($scope.listaGrupoPoliza[i].id == descPoliza) {
                    $scope.nombrePolizaGrupo = $scope.listaGrupoPoliza[i].poliza;
                    break;
                }
            }
        }
        $scope.$watch('comercial.desctEspecial', function (NewValue, OldValue) {

            if (!angular.isUndefined(NewValue) && NewValue != null) {

                for (var i = 0; i < $scope.datosDescuentoEspecial.length; i++) {
                    if ($scope.datosDescuentoEspecial[i].id == NewValue) {
                        $scope.maxDescEspecial = parseInt($scope.datosDescuentoEspecial[i].desct);
                        $scope.comercial.desctEspecialPorct = parseInt($scope.datosDescuentoEspecial[i].desct);
                        break;
                    }
                }
                for (var i = 0; i < $scope.listaDesctEspc.length; i++) {
                    if ($scope.listaDesctEspc[i].id == NewValue) {
                        $scope.nombreDescEspecial = $scope.listaDesctEspc[i].desct;
                        break;
                    }
                }


            } else {
                $scope.comercial.desctEspecialPorct = null;
            }
        }, true);


        $scope.$watch('comercial.fraccion', function (NewValue, OldValue) {

            if (!angular.isUndefined(NewValue)) {

                var parametros = {};


            } else {

            }
        }, true);


        $scope.$watch('datosGenerales.nuevo', function (NewValue, OldValue) {

            if (!angular.isUndefined(NewValue)) {

            } else {

            }


        }, true);


        $scope.showAdvanced = function () {

            $rootScope.codCoti = $scope.datosGenerales.numeroCotizacion;
            $rootScope.monedaAbuscar = $scope.vehiculo.moneda;
            $rootScope.mostrarBuscadorCotizacion = true;
            $mdDialog.show({
                locals: {parent: $scope},
                controller: 'BuscadorCotizacionCtrl',
                templateUrl: 'partials/ventanas-emergentes/buscador-cotizacion-partial.html',
                parent: angular.element(document.body),
                clickOutsideToClose: false,
                fullscreen: $scope.customFullscreen // Only for -xs, -sm breakpoints.
            }).then(function (answer) {
                $scope.cargando = true;
                $scope.status = 'You said the information was "' + answer + '".';
                if (!angular.isUndefined(answer.numeroCotizacion) && answer.numeroCotizacion != "" && answer.numeroCotizacion != null) {
                    $scope.datosGenerales.numeroCotizacion = parseInt(answer.numeroCotizacion);
                } else {
                    Message.error("Numero de cotizacion inexistente");
                    return;
                }


                $scope.buscarCotizacion();


            }, function () {
                $scope.status = 'You cancelled the dialog.';
                console.log($scope.status);
            });

        };
        $scope.guardadoParcialCabecera = function () {
            var dataVal = {};
            dataVal.codigoMarca = $scope.vehiculo.marca;
            dataVal.nombreMarca = $scope.vehiculo.nombreMarca;
            dataVal.codigoModelo = $scope.vehiculo.modelo;
            dataVal.nombreModelo = $scope.nombreModelo;
            dataVal.codigoSubmodelo = $scope.vehiculo.subModelo;
            dataVal.nombreSubmodelo = $scope.nomSubModelo;
            dataVal.anioSubmodelo = $scope.vehiculo.anho;
            dataVal.codigoTipoVehiculo = $scope.vehiculo.codigoTipo;
            dataVal.nombreTipoVehiculo = $scope.vehiculo.tipo;
            dataVal.numeroPlazas = $scope.vehiculo.ocupantes;
            dataVal.sumaAsegurada = $scope.cobertura.sumaAsegurada;
            dataVal.descuentoComercial = $scope.comercial.desctComercial2;
            //dataVal.recargoComercial=$scope.comercial.recComercial;
            dataVal.bonus = $scope.comercial.bono2;
            //dataVal.malus=$scope.comercial.malus;
            dataVal.codigoPolizaGrupo = $scope.comercial.poliza;
            dataVal.nombrePolizaGrupo = $scope.nombrePolizaGrupo;
            dataVal.porcentajePolizaGrupo = $scope.comercial.polizaPorct;
            dataVal.codigoDescEspecial = $scope.comercial.desctEspecial;
            dataVal.nombreDescEspecial = $scope.nombreDescEspecial;
            dataVal.porcentajeDescEspecial = $scope.comercial.desctEspecialPorct;
            dataVal.codigoProducto = angular.isUndefined($scope.cobertura.producto) ? null : $scope.cobertura.producto;
            dataVal.referido = $scope.vehiculo.referido;
            dataVal.codigoMoneda = $scope.vehiculo.moneda;
            dataVal.codigoFraccionamiento = $scope.comercial.fraccion;
            dataVal.importeInicial = $scope.comercial.inicial;
            dataVal.marcaCuotaIgual = $scope.comercial.primeraCuota;
            dataVal.marcaFlota = 'N';
            dataVal.cambio = $scope.vehiculo.cotizacion;
            //console.log("Numero de cotizacion ",$scope.datosGenerales.numeroCotizacion);
            dataVal.numeroCotizacion = $scope.datosGenerales.numeroCotizacion;
            return CotizacionVehiculoService.guardadoParcialCabecera(dataVal).then(
                function (response) {
                    return response.data;
                });
        };

        $scope.cargarListadoCostoVehiculo = function () {
            //console.log("Costo vehiculo ",$scope.listaCostoVehiculos);
            if ($scope.listaCostoVehiculos != null && $scope.listaCostoVehiculos.length > 0) {
                //console.log("Entra aca");
                $scope.sindatost = true;
                /* for(var i=0; i<$scope.listaCostoVehiculos.length; i++){
                     if($scope.listaCostoVehiculos[i].tipo=="Contado"){
                         $scope.contado.prima=$scope.listaCostoVehiculos[i].impPrima;
                         $scope.contado.costoTotal =$scope.listaCostoVehiculos[i].impPremio;

                     }else if ($scope.listaCostoVehiculos[i].tipo=="Debito"){
                         $scope.debitoAutomatico.prima=$scope.listaCostoVehiculos[i].impPrima;
                         $scope.debitoAutomatico.costoTotal =$scope.listaCostoVehiculos[i].impPremio;
                         $scope.debitoAutomatico.cuota=$scope.listaCostoVehiculos[i].impCuota;
                         $scope.debitoAutomatico.ultimaCuota=$scope.listaCostoVehiculos[i].impUltimaCuota;


                     }else if($scope.listaCostoVehiculos[i].tipo=="Chequera"){
                         $scope.chequera.prima=$scope.listaCostoVehiculos[i].impPrima;
                         $scope.chequera.costoTotal =$scope.listaCostoVehiculos[i].impPremio;
                         $scope.chequera.cuota=$scope.listaCostoVehiculos[i].impCuota;
                         $scope.chequera.ultimaCuota=$scope.listaCostoVehiculos[i].impUltimaCuota;
                     }

                 }*/
            }
            else {
                $scope.sindatost = false;
            }
            //$scope.cargando = false;
            // console.log("sIN DATOS TABLA", $scope.sindatost);

        };
        $scope.limpiarDatos = function () {
            $scope.obtenerCamposEditables();
            $scope.vehiculo.moneda = undefined;
            $scope.vehiculo.monto = "2000";
            $scope.vehiculo.referido = 'N';
            $scope.vehiculo.marca = undefined;
            $scope.vehiculo.modelo = undefined;
            $scope.vehiculo.subModelo = undefined;
            $scope.vehiculo.anho = undefined;
            $scope.vehiculo.ocupantes = undefined;
            $scope.vehiculo.tipo = undefined;
            $scope.datosSubmodelo = [];
            $scope.listaSubModelos = [];
            //combo comercial
            $scope.comercial.desctComercial = undefined;
            $scope.comercial.desctP = "1";
            $scope.comercial.desctEspecial = undefined;
            $scope.comercial.desctComercial2 = undefined;
            $scope.comercial.recComercial = undefined;
            $scope.comercial.fraccion = undefined;
            $scope.comercial.cuota = "S";
            $scope.comercial.poliza = undefined;
            $scope.comercial.polizaDescripcion = "";
            $scope.comercial.bono = undefined;
            $scope.comercial.bono2 = null;
            //$scope.comercial.malus=null;
            $scope.comercial.inicial = undefined;
            $scope.comercial.primeraCuota = undefined;
            $scope.comercial.polizaPorct = undefined;
            $scope.cobertura.cartaVerde = true;
            $scope.cobertura.cartaAzul = false;
            $scope.cobertura.producto = undefined;
            $scope.cobertura.sumaAsegurada = 0;
            $scope.cobertura.minMonto = 0;
            $scope.cobertura.maxMonto = 0;
            $scope.debitoAutomatico = {};
            $scope.debitoAutomatico.prima = "0";
            $scope.debitoAutomatico.costoTotal = "0";
            $scope.debitoAutomatico.cuota = "0";
            $scope.debitoAutomatico.ultimaCuota = "0";

            $scope.contado = {};
            $scope.contado.prima = "0";
            $scope.contado.costoTotal = "0";

            $scope.chequera = {};
            $scope.chequera.prima = "0";
            $scope.chequera.costoTotal = "0";
            $scope.chequera.cuota = "0";
            $scope.chequera.ultimaCuota = "0";
            $scope.desctComercial = false;
            $scope.recComercial = false;
            $scope.coberturaDatos = [];
            $scope.minDescRec = -100;
            $scope.maxDescRec = 100;

        };
        $scope.actualizarGTOSMED=function(etiqueta,nuevoValor){
            if(etiqueta=="OVP MUERTE"){

                for(var i=0;i<$scope.v1.length;i++){
                    if($scope.v1[i].ETIQUETA=="OVP GTOS MED"){
                        $scope.v1[i].MONTO_BASE=Math.ceil(nuevoValor*$scope.v1[i].PORCENTAJE);
                    }
                }
                for(var i=0;i<$scope.datos.length;i++){
                    if($scope.datos[i].ETIQUETA=="OVP GTOS MED"){
                        $scope.datos[i].MONTO_BASE=Math.ceil(nuevoValor*$scope.datos[i].PORCENTAJE);
                    }
                }
            }
        };
        $scope.buscarCotizacion = function () {

            //console.log("Buscar");

            if ($scope.datosGenerales.numeroCotizacion != null) {
                $scope.cargando = true;
                $scope.esBuscar = true;
                $scope.marcaNoPreferencia = true;
                var datosBuscador = {};
                datosBuscador.numeroCotizacion = $scope.datosGenerales.numeroCotizacion;
                $scope.persistirProducto = false;
                $scope.persistir = false;
                $scope.sumaAseguradaBuscar = true;
                $scope.esNuevo ="N";
                $scope.limpiarDatos();
                $scope.cargarMarcas();
                $timeout( function(){
                    $scope.cargando = true;
                    CotizacionVehiculoService.getCotizacion(datosBuscador).then(
                        function (response) {
                            if (!response.data.error) {
                                $scope.bloquearBuscador=true;
                                $scope.editablesDescPoliza=false;
                                $scope.cambiarFraccion=false;
                                if (!angular.isUndefined(response.data.dato) && response.data.dato != null) {

                                    if (response.data.dato.length > 0) {
                                        $scope.cargarPlataforma();
                                        if (response.data.dato[0].codigoPolizaGrupo!="" && response.data.dato[0].codigoPolizaGrupo!=null)
                                        {
                                            $scope.promesaFraccion.promise.$$state.status=0;
                                        }

                                        $scope.promesaMarcas.promise.then(
                                            function () {
                                                $scope.vehiculo.marca = parseInt(response.data.dato[0].codigoMarca);
                                            });
                                        $scope.promesaModelo.promise.then(
                                            function () {
                                                $scope.vehiculo.modelo = parseInt(response.data.dato[0].codigoModelo);
                                            }
                                        );

                                        $scope.promesaSubModelo.promise.then(
                                            function () {
                                                $scope.vehiculo.subModelo = parseInt(response.data.dato[0].codigoSubmodelo);
                                            }
                                        );
                                        $scope.promesaAnho.promise.then(
                                            function () {
                                                $scope.vehiculo.anho = parseInt(response.data.dato[0].anioSubmodelo);

                                            }
                                        );
                                        $scope.promesaProducto.promise.then(
                                            function () {
                                                if (response.data.dato[0].codigoProducto != null && response.data.dato[0].codigoProducto != "") {
                                                    $scope.cobertura.producto = parseInt(response.data.dato[0].codigoProducto);
                                                } else {
                                                    $scope.cobertura.producto = undefined;
                                                    $scope.persistirProducto = true;
                                                }


                                                //llamar a un metodo que cargue la cobertura de esta cotizacion
                                                $scope.datosCobertura = [];
                                                if (response.data.dato[0].coberturasVehiculo.length > 0 && response.data.dato[0].coberturasVehiculo.length != null) {
                                                    $scope.mostrarCartas = true;
                                                    for (var i=0; i< response.data.dato[0].coberturasVehiculo.length; i++)
                                                    {
                                                        // $scope.datosCobertura.push({"COD_COB": response.data.dato[0].coberturasVehiculo[i].cod_cob,"ETIQUETA":response.data.dato[0].coberturasVehiculo[i].etiqueta,"CAPITAL":Number(response.data.dato[0].coberturasVehiculo[i].capital),"MAXIMO":Number(response.data.dato[0].coberturasVehiculo[i].maximo), "INCREMENTO": Number(response.data.dato[0].coberturasVehiculo[i].incremento),"MCA_MODIFICABLE":response.data.dato[0].coberturasVehiculo[i].marcaModificable, "MONTO_BASE": Number(response.data.dato[0].coberturasVehiculo[i].capital) } );
                                                        $scope.datosCobertura.push({"COD_COB": response.data.dato[0].coberturasVehiculo[i].cod_cob,"ETIQUETA":response.data.dato[0].coberturasVehiculo[i].etiqueta,"CAPITAL":Number(response.data.dato[0].coberturasVehiculo[i].capital), "INCREMENTO": Number(response.data.dato[0].coberturasVehiculo[i].incremento),"MCA_MODIFICABLE":response.data.dato[0].coberturasVehiculo[i].marcaModificable, "MONTO_BASE": Number(response.data.dato[0].coberturasVehiculo[i].capital), "PORCENTAJE": parseFloat(response.data.dato[0].coberturasVehiculo[i].porcentajeCobertura) } );
                                                        if(response.data.dato[0].coberturasVehiculo[i].maximo!="" ){
                                                            $scope.datosCobertura[i].MAXIMO=Number(response.data.dato[0].coberturasVehiculo[i].maximo);
                                                        }else{
                                                            $scope.datosCobertura[i].MAXIMO=-1;
                                                        }

                                                    }
                                                    $scope.setearCobertura($scope.datosCobertura);
                                                    $scope.cargando = false;
                                                }
                                                else {

                                                    $scope.mostrarCartas = false;
                                                    $scope.cargando = false;
                                                }
                                            }
                                        );

                                        $scope.vehiculo.referido = response.data.dato[0].referido;
                                        $scope.promesaPoliza.promise.then(
                                            function () {
                                                $scope.comercial.poliza = response.data.dato[0].codigoPolizaGrupo;
                                            }
                                        );

                                        $scope.comercial.desctEspecial = response.data.dato[0].codigoDescEspecial;
                                        if (response.data.dato[0].descuentoComercial != null) {
                                            $scope.desctComercial = true;
                                        }
                                        $scope.comercial.desctComercial2=response.data.dato[0].descuentoComercial!=null && response.data.dato[0].descuentoComercial!=""?parseFloat(response.data.dato[0].descuentoComercial):undefined;
                                        //$scope.comercial.recComercial=response.data.dato[0].recargoComercial;
                                        $scope.promesaFraccion.promise.then(
                                            function () {
                                                if(response.data.dato[0].codigoFraccionamiento!= ""){
                                                    $scope.comercial.fraccion = parseInt(response.data.dato[0].codigoFraccionamiento);                                                          $scope.comercial.fraccion=parseInt(response.data.dato[0].codigoFraccionamiento);
                                                } else {
                                                    $scope.comercial.fraccion = null;
                                                }

                                            }
                                        );
                                        $scope.datosGenerales.numeroCotizacion = parseInt(response.data.dato[0].numeroCotizacion);
                                        $scope.datosGenerales.nuevo = response.data.dato[0].marcaRenovacion;
                                        $scope.comercial.primeraCuota = response.data.dato[0].marcaCuotaIgual == null ? 'N' : response.data.dato[0].marcaCuotaIgual;
                                        $scope.comercial.inicial = response.data.dato[0].importeInicial;
                                        //$scope.comercial.malus =response.data.dato[0].malus;
                                        $scope.comercial.bono2 = response.data.dato[0].bonus;
                                        $scope.vehiculo.moneda = parseInt(response.data.dato[0].codigoMoneda);
                                        $scope.vehiculo.ocupantes = parseInt(response.data.dato[0].numeroPlazas);


                                        $scope.listaCostoVehiculos = [];
                                        $scope.listaCostoVehiculos = response.data.dato[0].costoVehiculo;
                                        for (var i = 0; i < $scope.listaCambio.length; i++) {
                                            if ($scope.listaCambio[i].id == $scope.vehiculo.moneda) {
                                                $scope.vehiculo.cotizacion = $scope.listaCambio[i].cambio;
                                                break;
                                            }
                                        }
                                        $scope.vehiculo.cotizacion = !angular.isUndefined(response.data.dato[0].cambio) && response.data.dato[0].cambio != null ? parseInt(response.data.dato[0].cambio) : 1;
                                        $q.all( [
                                            $scope.promesaProducto.promise.then(),  $scope.franquicia.promise.then()
                                        ] ).then(function(sucess){
                                            if (response.data.dato[0].codigoFranquicia!=null && response.data.dato[0].importeFranquicia!=null && response.data.dato[0].codigoFranquicia!="" && response.data.dato[0].importeFranquicia!="")
                                            {
                                                //$scope.cobertura.franquicia={};
                                                $scope.cobertura.franquicia=response.data.dato[0].codigoFranquicia;
                                                //$scope.cobertura.franquicia.importeFranquicia=response.data.dato[0].importeFranquicia;
                                            }
                                            else
                                            {
                                                $scope.cobertura.franquicia=undefined;
                                            }
                                        });
                                        $q.all([$scope.promesaModelo.promise.then(), $scope.promesaSubModelo.promise.then(), $scope.promesaAnho.promise.then(),
                                            $scope.promesaProducto.promise.then(), $scope.promesaPoliza.promise.then(), $scope.promesaFraccion.promise.then()
                                        ]).then(function (sucess) {
                                            $scope.cobertura.sumaAsegurada = response.data.dato[0].sumaAsegurada;
                                            $scope.cargarListadoCostoVehiculo();
                                        });


                                    }

                                } else {
                                    Message.error(response.data.mensaje);
                                    $scope.cargando = false;
                                    
                                }
                            } else {
                                $scope.recargar();
                                Message.error(response.data.mensaje);
                                $scope.cargando = false;
                                

                            }


                        },
                        function (response) {
                            $scope.persistirProducto = true;
                            $scope.persistir = true;
                            Message.error(response.data.mensaje);
                            
                        });
                }, 2000 );
            }


        };
        /*---------------------------------LISTADO COLUMNAS--------------------------------------*/
        $scope.dato = [
            {
                "COD_COB": 1,
                "ETIQUETA": "RC PERSONAS",
                "MCA_MODIFICABLE": "S",
                "CAPITAL": null
            }, {
                "COD_COB": 2,
                "ETIQUETA": "RC MATERIALES",
                "MCA_MODIFICABLE": "S",
                "CAPITAL": null
            }/*,{
                "COD_COB":4,
                "ETIQUETA":"ASISTENCIA EN VIAJE",
                "MCA_MODIFICABLE":"N","CAPITAL":null
            },{
                "COD_COB":5,
                "ETIQUETA":"ROBO",
                "MCA_MODIFICABLE":"S",
                "CAPITAL":null
            },{
                "COD_COB":6,
                "ETIQUETA":"DPT",
                "MCA_MODIFICABLE":"S",
                "CAPITAL":null
            },{
                "COD_COB":7,
                "ETIQUETA":"DPP",
                "MCA_MODIFICABLE":"S",
                "CAPITAL":null
            },{
                "COD_COB":11,
                "ETIQUETA":"CARTA VERDE",
                "MCA_MODIFICABLE":"S",
                "CAPITAL":1.0
            },{
                "COD_COB":12,
                "ETIQUETA":"OVP MUERTE",
                "MCA_MODIFICABLE":"S",
                "CAPITAL":null
            },{
                "COD_COB":13,
                "ETIQUETA":"OVP GTOS MED",
                "MCA_MODIFICABLE":"S",
                "CAPITAL":null
            }*/
        ];


        /**
         * Constructor / Entrypoint
         * @constructor
         */
        $scope.cargarCombos = function () {
            $scope.cargarFraccionamiento("S");

            $scope.cargarMonedas();
            $scope.cargarMarcas();


            $scope.cargarDescuentoEspecial();
            $scope.cargarPolizaGrupo()


        };

        $scope.recargar = function () {

            if (typeof $routeParams.numeroCotizacion != "undefined") {
                $location.search('numeroCotizacion', undefined);
                $rootScope.numeroCotizacionRoot = undefined;
                $location.path('cotizacion-vehiculo')

            }
            else {
                $route.reload();
            }


        };


        /*    $scope.$watch('cobertura.sumaAsegurada', function(NewValue, OldValue) {

         $scope.tags = $filter('number')($scope.tags);
              $scope.cobertura.sumaAsegurada = $filter('number')(NewValue);

       });*/

        $scope.filteredText = $filter('number')($scope.cobertura.sumaAsegurada);


        function numberFormat(numero) {
            // Variable que contendra el resultado final
            var resultado = "";
            var nuevoNumero = numero;
            // Si tiene decimales, se los quitamos al numero
            if (numero.indexOf(".") >= 0)
                nuevoNumero = numero.substring(0, numero.indexOf("."));

            // Ponemos un punto cada 3 caracteres
            for (j, i = nuevoNumero.length - 1, j = 0; i >= 0; i-- , j++)
                resultado = nuevoNumero.charAt(i) + ((j > 0) && (j % 3 == 0) ? "." : "") + resultado;

            // Si tiene decimales, se lo añadimos al numero una vez forateado con
            // los separadores de miles
            if (numero.indexOf(".") >= 0)
                resultado += "," + numero.substring(numero.indexOf(".") + 1);

            if (numero[0] == "-") {
                // Devolvemos el valor añadiendo al inicio el signo negativo
                return "-" + resultado;
            } else {
                return resultado;
            }
        }


        /*************cargacobertura******************/

        $scope.cargarDatosCobertura = function(){
            //console.log("Cargar datos cobertura");
            if(!angular.isUndefined($scope.datosGenerales.numeroCotizacion)){
                var  parametros ={};
                parametros.numeroCotizacion= parseInt($scope.datosGenerales.numeroCotizacion);
                $scope.v1=[];
                $scope.v2=[];
                $scope.datosCobertura=[];
                $scope.datos=[];
                $scope.cargando=true;
                CotizacionVehiculoService.listarCoberturas(parametros).then(
                    function (response) {
                        //console.log(response.data.dato);
                        if (!response.data.error)
                        {
                            if (response.data.dato != null)
                            {
                                if(response.data.dato.length>0)
                                {
                                    var datosResponse=[];
                                    datosResponse=response.data.dato;
                                    //console.log(datosResponse);
                                    $scope.datosCobertura=[];
                                    for (var i=0; i< datosResponse.length; i++)
                                    {
                                        $scope.datosCobertura.push({"COD_COB": datosResponse[i].COD_COB,"ETIQUETA":datosResponse[i].ETIQUETA,"CAPITAL":datosResponse[i].CAPITAL,"MAXIMO":datosResponse[i].MAXIMO, "INCREMENTO": datosResponse[i].INCREMENTO,"MCA_MODIFICABLE":datosResponse[i].MCA_MODIFICABLE, "MONTO_BASE": datosResponse[i].CAPITAL } );


                                    }
                                    //$scope.datosCobertura=response.data.dato;
                                    /*   $scope.cobertura.producto=undefined;
                                       $scope.cobertura.sumaAsegurada=undefined;*/
                                    //$scope.sindatost=true;
                                    $scope.setearCobertura($scope.datosCobertura);
                                    //$scope.cargando=false;
                                }
                                else
                                {
                                    $scope.cargando=false;
                                }


                            }
                            else
                            {
                                $scope.sindatos=true;
                                $scope.cargando=false;
                            }
                        }
                        else
                        {
                            $scope.cargando=false;
                            $scope.sindatos=true;
                        }

                    },
                    function(response){
                        // promesaAnho.reject();
                        Message.error(response.data.mensaje);
                        
                    });

            }else{
                $scope.vehiculo.cotizacion=null;
            }
            $scope.cargando=false;

        };
        $scope.actualizarCotizacion = function () {
            // console.log("Valor de suma agregada ", $scope.cobertura.sumaAsegurada);
            //$scope.validarNumero();
            $scope.cargando=true;
            $scope.cobertura.franquicia=undefined;
            $scope.verificarFranquicia($scope.cobertura.producto,$scope.vehiculo.moneda, $scope.cobertura.sumaAsegurada);
            if ($scope.cobertura.sumaAsegurada != undefined && $scope.cobertura.sumaAsegurada != null) {
                var parametros = {};
                parametros.esNuevo = $scope.esNuevo;
                parametros.codigoMarca = $scope.vehiculo.marca;
                parametros.codigoModelo = $scope.vehiculo.modelo;
                parametros.codigoSubModelo = $scope.vehiculo.subModelo;
                parametros.anho = $scope.vehiculo.anho;
                parametros.codigoMoneda = $scope.vehiculo.moneda;
                parametros.codigoRamo = 501;
                parametros.numeroCotizacion = $scope.datosGenerales.numeroCotizacion;
                $scope.recalcularCotizacion(parametros);
            }
            else
            {
                $scope.cargando=false;
            }


        };
        $scope.validarNumero = function () {
            console.log($scope.restriccion.match($scope.cobertura.sumaAsegurada));
        };
        $scope.recalcularCotizacion=function(parametros)
        {
            $scope.validarSumaAsegurada();
            if ($scope.montoValido)
            {

                $scope.v1=[];
                $scope.datosCobertura=[];
                $scope.datos=[];
                $scope.cartas=[];
                var guardadoParcial=$scope.guardadoParcialCabecera();
                guardadoParcial.then(function (result)
                {
                    if (result.error==false)
                    {
                        if (result.dato != null)
                        {
                            $scope.datosGenerales.numeroCotizacion=parseInt(result.dato.numeroCotizacion);
                            $scope.habilitarPropuesta=true;
                            /*parametros.numeroCotizacion=$scope.datosGenerales.numeroCotizacion;
                            // console.log("Hace el guardado parcial");
                            CotizacionVehiculoService.listarCoberturas(parametros).then(

                                function (response2) {
                                    if(response2.data.dato != null && response2.data.dato.length>0)
                                    {
                                        $scope.datosCobertura=[];
                                        $scope.mostrarCartas=true;
                                        // $scope.datosCobertura=response2.data.dato;

                                        for (var i=0; i< response2.data.dato.length; i++)
                                        {
                                            $scope.datosCobertura.push({"COD_COB": response2.data.dato[i].COD_COB,"ETIQUETA":response2.data.dato[i].ETIQUETA,"CAPITAL":response2.data.dato[i].CAPITAL,"MAXIMO":response2.data.dato[i].MAXIMO, "INCREMENTO": response2.data.dato[i].INCREMENTO,"MCA_MODIFICABLE":response2.data.dato[i].MCA_MODIFICABLE, "MONTO_BASE": response2.data.dato[i].CAPITAL } );


                                        }
                                        //$scope.datosCobertura=response.data.dato;
                                        /*   $scope.cobertura.producto=undefined;
                                           $scope.cobertura.sumaAsegurada=undefined;*/
                                        //$scope.sindatost=true;
                                        /*$scope.setearCobertura($scope.datosCobertura);
                                        //$scope.cargando=false;
                                        $scope.sindatos=false;

                                        $scope.cobertura.codigoCobertura=response2.data.dato.COD_COB;
                                        $scope.cobertura.etiqueta=response2.data.dato.ETIQUETA;
                                        $scope.cobertura.capital=response2.data.dato.CAPITAL;


                                        /*$scope.cobertura.rcPersonas="200";
                                        $scope.cobertura.ovpGtosMdeOcup="200";
                                        $scope.cobertura.robo="200";
                                        $scope.cobertura.granizo="200";
                                        $scope.cobertura.incendioEdificio="200";
                                        $scope.cobertura.danhosVandalismo="200";
                                        $scope.cobertura.rcDanhosMateriales="200";
                                        $scope.cobertura.danhosPropiosTotal="200";
                                        $scope.cobertura.roboParcialRadio="2011";
                                        $scope.cobertura.accidentePersonales="200";
                                        $scope.cobertura.incendioContenidoVivienda="300";
                                        $scope.cobertura.airbag="200";
                                        $scope.cobertura.ovpMteOcupante="200000000";
                                        $scope.cobertura.danhosPropiedad="200";
                                        $scope.cobertura.roboParcialRadio2="200";
                                        $scope.cobertura.gtoMedAccPersonales="200";
                                        $scope.cobertura.sepelio="200";
                                        $scope.cobertura.cartaVerde=true;
                                        $scope.cobertura.cartaAzul=false;*/
                                        //$scope.cargando=false;
                                        /*$scope.cargarPlataforma();*/
                                        $scope.actualizarDatos();


                                        /*   $scope.cobertura.producto=undefined;
                                           $scope.cobertura.sumaAsegurada=undefined;*/

                        }
                        else
                        {
                            $scope.cargando=false;
                            //Message.error(result.data.mensaje);
                        }



                    }
                    else
                    {
                        $scope.cargando=false;
                        Message.error(result.mensaje);
                    }
                }).catch(function(response) {
                    $scope.cargando=false;
                    Message.error("Ocurrio un error, intente nuevamente!")
                })
            }
            else
            {
                $scope.cargando=false;
            }
        };
        $scope.cambiarRangoDescuento = function () {
            if (!angular.isUndefined($scope.comercial.poliza) && $scope.comercial.poliza != null) {
                var roles=sessionStorage.getItem("roles");
                if (roles !="" && roles.indexOf("TECAUT")>0)
                {
                    $scope.minDescRec=-100;
                    $scope.maxDescRec=100;
                }
                else
                {
                    $scope.minDescRec=0;
                    $scope.maxDescRec=100;
                }

            }
            else {
                $scope.minDescRec = -100;
                $scope.maxDescRec = 100;
            }
        };
        $scope.verificarMontoCobertura = function (cobertura) {
            //console.log("Los datos de cobertura son ", cobertura);
            var montoActual = cobertura.MONTO_BASE
            if (montoActual > cobertura.MAXIMO && cobertura.MAXIMO > 0) {
                cobertura.MONTO_BASE = cobertura.MAXIMO;
            }
            else if (montoActual < cobertura.CAPITAL) {
                cobertura.MONTO_BASE = cobertura.CAPITAL;
            }
            else {
                cobertura.MONTO_BASE = montoActual;
            }
        };
        $scope.incrementarCobertura = function (cobertura) {
            //console.log("La cobertura es ", cobertura);
            var montoActual = cobertura.MONTO_BASE
            if (montoActual >= cobertura.MAXIMO && cobertura.MAXIMO > 0) {
                cobertura.MONTO_BASE = cobertura.MAXIMO;
            }
            else {
                cobertura.MONTO_BASE += cobertura.INCREMENTO;
            }
        };
        $scope.decrementarCobertura = function (cobertura) {
            //console.log("La cobertura es en decremento ", cobertura);
            var montoActual = cobertura.MONTO_BASE;
            if (montoActual <= cobertura.CAPITAL) {
                cobertura.MONTO_BASE = cobertura.CAPITAL;
            }
            else {
                cobertura.MONTO_BASE -= cobertura.INCREMENTO;
            }
        };
        $scope.limpiarFormasPago = function () {
            $scope.debitoAutomatico = {};
            $scope.debitoAutomatico.prima = "0";
            $scope.debitoAutomatico.costoTotal = "0";
            $scope.debitoAutomatico.cuota = "0";
            $scope.debitoAutomatico.ultimaCuota = "0";

            $scope.contado = {};
            $scope.contado.prima = "0";
            $scope.contado.costoTotal = "0";

            $scope.chequera = {};
            $scope.chequera.prima = "0";
            $scope.chequera.costoTotal = "0";
            $scope.chequera.cuota = "0";
            $scope.chequera.ultimaCuota = "0";
        };
        $scope.setearCobertura=function(coberturas)
        {
            $scope.sindatos=false;
            $scope.cartaVerde=false;
            $scope.cartaAzul=false;
            $scope.v1=[];
            $scope.v2=[];
            $scope.datosCobertura=[];
            $scope.datos=[];
            $scope.bloquearCartaVerde=true;
            $scope.bloquearCartaAzul=true;
            var CV,CA;
            CA=0,CV=0;
            $scope.datosCobertura=angular.copy(coberturas);
            $scope.cartas=[];

            $scope.datos = angular.copy($scope.datosCobertura);

            for(var i=0;i<$scope.datosCobertura.length;i++)
            {

                if($scope.datos[i].ETIQUETA==="CARTA VERDE"){
                    if ($scope.datos[i].MCA_MODIFICABLE=="S")
                    {
                        $scope.bloquearCartaVerde=false;
                    }
                    // $scope.datos.splice(i,1);
                    $scope.cartas.push($scope.datosCobertura[i]);
                    $scope.cartaVerde = true;


                    CV=i;
                }else if($scope.datos[i].ETIQUETA==="CARTA AZUL"){
                    if ($scope.datos[i].MCA_MODIFICABLE=="S")
                    {
                        $scope.bloquearCartaAzul=false;
                    }
                    //  $scope.datos.splice(i,1);
                    $scope.cartas.push($scope.datosCobertura[i]);
                    $scope.cartaAzul = true;
                    CA=i;
                }
                else
                {
                    $scope.datos.push($scope.datosCobertura[i]);
                }
            }
            $scope.datosCobertura=angular.copy($scope.datos);

            if($scope.datosCobertura.length<=6){
                var i=0;
                while($scope.datos.length>0 && $scope.v1.length<=6){
                    $scope.v1.push($scope.datos[i]);
                    // i++;
                    $scope.datos.splice(0,1);
                };
            }else{
                var cant = Math.trunc($scope.datosCobertura.length/2);
                var resto = $scope.datosCobertura.length%2;
                var cantxColum = cant + resto;
                var i=0;
                var temp =[];
                temp=angular.copy($scope.datos);
                while(temp.length>0 && $scope.v1.length< cantxColum){
                    $scope.v1.push(temp[i]);
                    $scope.datos.splice(0,1);
                    i++;
                };


            }
            $scope.cargando=false;


        };
        $scope.setearDatosSubModelo = function () {
            for (var i = 0; i < $scope.datosSubmodelo.length; i++) {
                if ($scope.datosSubmodelo[i].id == $scope.vehiculo.subModelo) {
                    $scope.vehiculo.tipo = $scope.datosSubmodelo[i].tipo;
                    $scope.vehiculo.codigoTipo = $scope.datosSubmodelo[i].codTipo;
                    if ($scope.esBuscar == false) {
                        $scope.vehiculo.ocupantes = parseInt($scope.datosSubmodelo[i].cantOcup);
                    }
                    else {
                        $scope.esBuscar = false;
                    }
                    $scope.minOcupantes = parseInt($scope.datosSubmodelo[i].cantMinOcup);
                    $scope.maxOcupantes = parseInt($scope.datosSubmodelo[i].cantOcup);
                    break;
                }
            }

            for (var i = 0; i < $scope.listaSubModelos.length; i++) {
                if ($scope.listaSubModelos[i].id == $scope.vehiculo.subModelo) {
                    $scope.nomSubModelo = $scope.listaSubModelos[i].subModelo;

                    break;
                }
            }
        };
        /*********************************************/


        /**
         * Función creada para el salto de cotización a propuesta
         */
        $scope.goToPropuesta = function () {
            var path = $location.$$absUrl;
            var n = path.search("module");
            var url = path.substring(0, n);

            if (typeof $scope.datosGenerales.numeroCotizacion != 'undefined' && $scope.datosGenerales.numeroCotizacion != null) {
                //location.href = 'propuesta-vehiculo/propuesta/' + $scope.datosGenerales.numeroCotizacion;
            } else {
                Message.warning("Debe ingresar un número de cotización");
            }

            /*descargar carta oferta*/
        };
        /*descargar carta oferta*/
         $scope.descargarCartaOferta = function () {

            //window.open(App.URL_BASE+'impresion/cartaoferta/vehiculo?numeroCotizacion='+$scope.datosGenerales.numeroCotizacion);
            var url = App.URL_BASE + 'impresion/vehiculo/cartaoferta/ie?numeroCotizacion=' + $scope.datosGenerales.numeroCotizacion+"&token="+encodeURI(sessionStorage.getItem("token"))+"&marcaMovil=S";
            
            window.open(url);
           // $scope.mostrarPDF(url, "carta_oferta");
        };
        $scope.descargarCartaVerde = function () {

            var url = App.URL_BASE + 'impresion/cartaverde/ie?numeroCotizacion=' + $scope.datosGenerales.numeroCotizacion;
            window.open(url);
           // $scope.mostrarPDF(url, "carta_verde");
        };


        $scope.descargarCartaPropuesta = function () {
            //window.open(App.URL_BASE+'impresion/propuesta?numeroCotizacion='+$scope.datosGenerales.numeroCotizacion);
            var url = App.URL_BASE + 'impresion/propuesta/ie?numeroCotizacion=' + $scope.datosGenerales.numeroCotizacion+'&'+$scope.pathModule+"&token="+encodeURI(sessionStorage.getItem("token"))+"&marcaMovil=S";
            window.open(url);
           // $scope.mostrarPDF(url, "carta_propuesta");
        };

        $scope.descargarCartaCobertura = function () {
            //window.open(App.URL_BASE+'impresion/certificadocobertura?numeroCotizacion='+$scope.datosGenerales.numeroCotizacion);
            var url = App.URL_BASE + 'impresion/certificadocobertura/ie?numeroCotizacion=' + $scope.datosGenerales.numeroCotizacion;
            window.open(url);
           // $scope.mostrarPDF(url, "carta_cobertura");
        };

        $scope.verificarCamposForm = function (listaCampo, campo) {
            return UtilsService.verificarCamposForm(listaCampo, campo);
        };

        $scope.mostrarPDF = function (url, nombre) {
            $scope.cargando = true;
            CotizacionVehiculoService.getPdf(url).then(
                function (response) {
                    $scope.cargando = false;
                    $scope.nombrePDF = nombre + ".pdf";
                    var pdf = 'data:application/octet-stream;base64,' + btoa(unescape(encodeURIComponent(response.data)));
                    var dlnk = document.getElementById('downloadPDF');
                    dlnk.download = $scope.nombrePDF;
                    dlnk.href = pdf;
                    dlnk.click();

                }).catch(function (response) {
                $scope.cargando = false;
                Message.error(response.data.mensaje);
            });
        };

        $scope.cargarPlataforma = function () {

            var paramPla = {};
            paramPla.numeroCotizacion = $scope.datosGenerales.numeroCotizacion;

            CotizacionVehiculoService.getPlataforma(paramPla).then(
                function (response) {
                    if (!response.data.error) {
                        if (response.data.dato != null) {

                            $scope.mostrarPlataforma = true;

                            $scope.datosGenerales.plataforma = response.data.dato.mensaje;


                        }

                    }


                }).catch(function (response) {

                Message.error(response.data.mensaje);

            });
        };
        $scope.obtenerAutorizaciones = function () {

            $scope.autorizacionesList = [];
            var param={};
            param.pathModule=UtilsService.retornarPath($location.path().split("/")[1]);
            CotizacionVehiculoService.getAutorizaciones(param).then(function (response) {
                if (!response.data.error) {
                    if (response.data.dato.length > 0) {
                        var campos = response.data.dato;
                        for (var i = 0; i < campos.length; i++) {
                            $scope.autorizacionesList.push(campos[i]);
                            if (campos[i] === 'btnEliminar') {
                                $rootScope.botonEliminar = true;

                            }
                        }
                    }

                    //console.log("Lista Autorizaciones: " + JSON.stringify($scope.autorizacionesList));
                }
                else {
                    Message.error(response.data.mensaje);
                }
            });
        };
        $scope.obtenerCamposEditables = function () {
            $scope.camposEditablesList = [];
            var params = {};
            params.marcaFlota = "N";
            $scope.pathModule = UtilsService.retornarPath($location.path().split("/")[1]);
            params.numeroCotizacion = angular.isUndefined($scope.datosGenerales.numeroCotizacion) || $scope.datosGenerales.numeroCotizacion == null ? "" : $scope.datosGenerales.numeroCotizacion;
            params.pathModule =$scope.pathModule;
            CotizacionVehiculoService.getCamposEditables(params).then(function (response) {
                if (!response.data.error) {
                    if (response.data.dato.length > 0) {
                        var campos = response.data.dato;
                        for (var i = 0; i < campos.length; i++) {
                            $scope.camposEditablesList.push(campos[i]);
                        }
                    }
                    //console.log("Campos editables ", $scope.camposEditablesList);
                }
                else {
                    Message.error(response.data.mensaje);
                }
            });
        };

        $scope.emitirDocumento = function () {
            $scope.emitir = true;
        };

        $scope.llamarModal = function (value) {

            if (!angular.isUndefined($scope.datosGenerales.numeroCotizacion) && $scope.datosGenerales.numeroCotizacion != null && $scope.datosGenerales.numeroCotizacion != "") {
                $rootScope.numCotiza = $scope.datosGenerales.numeroCotizacion;
                $rootScope.autEsNuevo = $scope.datosGenerales.nuevo;
                $rootScope.modalCotizadorVehFlota = value;
                $rootScope.flagVehiculoFlota = true;
                $scope.autorizacion = true;
                $rootScope.mostrarMovil = true;
                $mdDialog.show({
                    //locals:{mobile: $scope.esMobile},

                    controller: 'ModalAutorizacionCtrl',
                    templateUrl: 'partials/ventanas-emergentes/modal-autorizacion-partial.html',
                    parent: angular.element(document.querySelector('#autorizacion_div')),
                    multiple: true,
                    clickOutsideToClose: false,
                    /* scope:$scope,
                     preserveScope: true,*/
                    fullscreen: $scope.customFullscreen // Only for -xs, -sm breakpoints.

                }).then(function (answer) {

                    /* $scope.cargando=true;
                     console.log("Entra aca ");
                    $scope.status = 'You said the information was "' + answer + '".';
                    if (!angular.isUndefined(answer.numeroCotizacion) && answer.numeroCotizacion !="" && answer.numeroCotizacion!= null){
                        $scope.datosGenerales.numeroCotizacion = parseInt(answer.numeroCotizacion);
                    }else{
                         Message.error("Numero de cotizacion inexistente");
                         return;

                    }*/


                    $scope.buscarCotizacion();


                }, function () {
                    $scope.status = 'You cancelled the dialog.';
                    console.log($scope.status);
                });
            }

        };
        $scope.atrasSiguiente = function () {


            $scope.data.seccion = parseInt($scope.data.seccion) + 1;


            console.log($scope.data.seccion);
        };
        $scope.siguienteAtras = function () {

            $scope.data.seccion = parseInt($scope.data.seccion) - 1;


            console.log($scope.data.seccion);
        };
        $scope.franquicia=$q.defer();
        $scope.verificarFranquicia=function(producto, moneda, sumaAsegurada)
        {
            $scope.cargando=true;

            $scope.listaFranquicias=[];
            $scope.mostrarFranquicia=false;
            if (!angular.isUndefined(producto) && producto!=null )
            {
                for (var i=0; i< $scope.listaProductos.length; i++)
                {
                    if ($scope.listaProductos[i].id==producto)
                    {
                        if ($scope.listaProductos[i].mcaFranquicia=="S")
                        {
                            $scope.mostrarFranquicia=true;
                            break;
                        }
                    }
                }
                if ($scope.mostrarFranquicia)
                {
                    var data=null;
                    var params={};
                    params.moneda=moneda;
                    params.sumaAsegurada=angular.isUndefined(sumaAsegurada)?null:sumaAsegurada;
                    CotizacionVehiculoService.getFranquicias(params).then(function(response) {
                        if (!response.data.error)
                        {

                            if (response.data.dato!=null && response.data.dato.length>0)
                            {
                                data=response.data.dato;
                                for (var i=0; i<data.length;i++)
                                {
                                    $scope.listaFranquicias.push(data[i]);
                                }
                                $scope.franquicia.resolve();
                                $scope.cargando=false;


                            }
                            else {
                                $scope.cargando=false;
                                $scope.franquicia.resolve();

                            }
                        }
                        else {
                            $scope.cargando=false;
                            $scope.franquicia.reject();
                            Message.error(response.data.mensaje);
                        }
                    })
                }
                else
                {
                    $scope.cargando=false;
                }
            }



        };
        $scope.recuperarImporte=function(codigo)
        {
            for (var i=0; i<$scope.listaFranquicias.length;i++) {
                if ($scope.listaFranquicias[i].codigoFranquicia == codigo) {
                    return $scope.listaFranquicias[i].importeFranquicia;
                }
            }
        };

        (function initialize() {

            $scope.sindatos=true;
            $scope.sindatost=false;
            $scope.comercial.primeraCuota='S';
            $scope.flagConfirmacion=true;
            $scope.persistir= true;
            $scope.persistirProducto=true;
            $scope.listaCostoVehiculos=[];
            $scope.mostrarCartas=false;
            $scope.controlRequerido = false;
            $scope.pathModule = UtilsService.retornarPath($location.path().split("/")[1]);
            $scope.menus= [
                {id: '1', name: 'Datos Generales'},
                {id: '2', name: 'Vehiculos'},
                {id: '3', name: 'Comercial'},
                {id: '4', name: 'Cobertura'},
                {id: '5', name: 'Formas de Pago'}
            ];

            $scope.obtenerCamposEditables();
            //$scope.obtenerCamposRequeridos();
            $scope.obtenerAutorizaciones();
            //    $scope.datosGenerales.nuevo=false;
            $scope.data.seccion='1';
            $scope.vehiculo.cotizacion=1;
            $scope.botonEliminar = undefined;



            //console.log($rootScope.usuarioActual);
            $scope.path = "/" +$location.$$path.split("/")[1] + "/";
            $scope.cargarCombos();
            //sessionStorage.setItem("hola","hola");
            //if ($scope.controlPermisos != undefined ){
            if ($window.sessionStorage["rolesAsignados"]!=undefined && $window.sessionStorage["rolesAsignados"]!=null){
                var listaRoles = $window.sessionStorage["rolesAsignados"].split(",");
                $scope.controlPermisos = listaRoles.indexOf("rol_1")>-1? true:false;
            }

            //}


            console.log("Tengo permiso? " + $scope.controlPermisos);


            /**
             * Verifica si la ventana fue llamada desde propuesta
             */
            if(typeof $routeParams.numeroCotizacion != "undefined"){

                $rootScope.numeroCotizacionRoot = $routeParams.numeroCotizacion;
                $scope.datosGenerales.numeroCotizacion=$rootScope.numeroCotizacionRoot;
                $scope.buscarCotizacion();
            }

        })();


    }]);
;app.controller('FlotaAgregarCtrl', ['$scope','$filter', 'FlotaAgregarService', '$controller', '$routeParams', '$location', 'SessionService', '$rootScope', '$mdDialog', 'ConfirmService', 'UtilsService','$locale','FlotaService','$log','$q',
    function ($scope,filter,FlotaAgregarService, $controller, $routeParams, $location, sessionService, $rootScope, $mdDialog, confirmService, UtilsService, $locale, FlotaService, $log, $q) {

        $scope.nombre = "Flota";
        $locale.NUMBER_FORMATS.GROUP_SEP = '.';
        $locale.NUMBER_FORMATS.DECIMAL_SEP=',';
        var objetoCotizacion ={};

        $scope.datosCargaForm ={};

        $scope.datosAgregar ={};
        $scope.datosAgregar.numeroRiesgo=undefined;
        $scope.datosAgregar.marcaId=undefined;
        $scope.datosAgregar.marcaNombre=undefined;
        $scope.datosAgregar.modeloId=undefined;
        $scope.datosAgregar.modeloNombre=undefined;
        $scope.datosAgregar.subModeloId=undefined;
        $scope.datosAgregar.subModeloNombre=undefined;
        $scope.datosAgregar.anho=undefined;
        $scope.datosAgregar.ocupantes=undefined;
        $scope.datosAgregar.sumaAsegurada=undefined;
        $scope.datosAgregar.nombretipoVehiculo=undefined;
        $scope.datosAgregar.tipoVehiculoId=undefined;
        $scope.datosAgregar.dadarDeBajarDeBaja=undefined;
        $scope.datosAgregar.ocupantesMin=undefined;
        $scope.datosAgregar.ocupantesMax=undefined;
        $scope.datosAgregar.tieneAutorizacion="N";

        $scope.cobertura ={};
        $scope.cobertura.danhosPropiosParciales=11;
        $scope.cobertura.robo=13;
        $scope.cobertura.roboParcialRadio=14;
        $scope.cobertura.granizo=15;
        $scope.cobertura.gastosMedAccPersonales=16;
        $scope.cobertura.danhosParcialesVandalismo=17;
        $scope.cobertura.cartaVerde=true;
        $scope.cobertura.cartaAzul=true;
        $scope.cobertura.danhosPropiosTotales=18;
        $scope.cobertura.danhosPropiosParcFranq=19;
        $scope.cobertura.roboParcialRadio2=20;
        $scope.cobertura.accidentesPersonales=21;
        $scope.cobertura.sepelio=22;
        $scope.cobertura.airbag=23;
        $scope.camposEditablesList=[];
        $scope.cambiarSumaAsegurada=true;

        $scope.verificarCamposForm=function(listaCampo, campo)
        {
            return UtilsService.verificarCamposForm(listaCampo, campo);
        };

        $scope.obtenerAutorizaciones=function()
        {

            $scope.autorizacionesList = [];
            var params={};
            params.pathModule=$scope.pathModule;
            FlotaAgregarService.getAutorizaciones(params).then(function(response){
                if (!response.data.error)
                {
                    if (response.data.dato.length>0)
                    {
                        var campos=response.data.dato;
                        for (var i=0; i< campos.length; i++)
                        {
                            $scope.autorizacionesList.push(campos[i]);
                        }
                    }
                    $log.debug("Lista Autorizaciones: " + JSON.stringify($scope.autorizacionesList));
                }
                else
                {
                    Message.error(response.data.mensaje);
                }
            });
        };


        /*cargar todos los combos*/
        $scope.cargarCombos = function() {

            $scope.listadoModelos =[];
            $scope.listadoSubModelos =[];
            $scope.years =[];
            $scope.listadoMarcas=[];
            $scope.datosSumaAsegurada =[];
            $scope.cargarMarcas();


        };
        $scope.marcasPromise=$q.defer();
        $scope.cargarMarcas = function() {

            var parametros = {};
            parametros.tienePreferencia="N";
            parametros.esNuevo=$scope.nuevo;

            FlotaAgregarService.getMarcas(parametros).then(

                function (response) {

                    for(var i=0; i<response.data.dato.length; i++){
                        var obj = {
                            id:response.data.dato[i].COD_MARCA,
                            marca:response.data.dato[i].NOM_MARCA
                        };
                        $scope.listadoMarcas.push(obj);

                    }
                    $scope.marcasPromise.resolve();
                    /*if (sessionStorage.getItem('editar')=='S'){
                        var codigoMarca = parseInt(objetoCotizacion.codigoMarca);
                        $scope.datosAgregar.marcaId = codigoMarca;
                        ;
                        //console.log("entro en marcas");
                    }*/
                    //console.log($scope.listadoMarcas);




                },
                function(response){
                    $scope.marcasPromise.reject();
                    Message.error("No se pudo obtener las marcas");
                });

        };
        $scope.promesaModelo=$q.defer();
        $scope.$watch('datosAgregar.marcaId', function(NewValue, OldValue) {

            if(!angular.isUndefined(NewValue)){

                var parametros = {};

                parametros.tienePeferencia="N";
                parametros.esNuevo= $scope.nuevo;
                parametros.codigoMarca=$scope.datosAgregar.marcaId;

                for(var i=0; i<$scope.listadoMarcas.length; i++){
                    if ($scope.listadoMarcas[i].id==NewValue){
                        $scope.datosAgregar.marcaNombre= $scope.listadoMarcas[i].marca;
                        break;
                    }
                }

                //SE LIMPIAN LOS COMBOS DEPENDIENTES
                $scope.listadoModelos =[];
                $scope.listadoSubModelos =[];
                $scope.years =[];
                $scope.datosSubmodelo=[];
                $scope.datosAgregar.subModeloId=undefined;
                $scope.datosAgregar.anho=undefined;
                $scope.datosAgregar.ocupantes=undefined;
                $scope.datosAgregar.modeloId=undefined;


                FlotaAgregarService.getModelos(parametros).then(

                    function (response) {
                    if (!response.data.error)
                    {
                        for(var i=0; i<response.data.dato.length; i++){
                            var obj = {
                                id:response.data.dato[i].COD_MODELO,
                                modelo:response.data.dato[i].NOM_MODELO
                            };
                            $scope.listadoModelos.push(obj);
                        }
                        $scope.promesaModelo.resolve();
                    }
                    else
                    {
                        Message.error(response.data.mensaje);
                        $scope.promesaModelo.reject();
                    }
                        

                        /*if (sessionStorage.getItem('editar')=='S'){
                            $scope.datosAgregar.modeloId=parseInt( objetoCotizacion.codigoModelo);
                        }*/


                    },
                    function(response){

                        Message.error("No se pudo obtener los modelos");
                        $scope.promesaModelo.reject();
                    });

            }else{
                $scope.years =[];
                $scope.datosSubmodelo=[];
                $scope.listadoModelos =[];
                $scope.listadoSubModelos =[];


            }


        },true);

        $scope.promesaSubModelo=$q.defer();
        $scope.$watch('datosAgregar.modeloId', function(NewValue, OldValue) {
            if(!angular.isUndefined(NewValue)){

                var  parametros ={};
                $scope.listadoSubModelos =[];
                $scope.datosSubmodelo=[];

                parametros.esNuevo= $scope.nuevo;
                parametros.codigoMarca=$scope.datosAgregar.marcaId;
                parametros.codigoModelo=$scope.datosAgregar.modeloId;
                for(var i=0; i<$scope.listadoModelos.length; i++){
                    if ($scope.listadoModelos[i].id==NewValue){
                        $scope.datosAgregar.modeloNombre= $scope.listadoModelos[i].modelo;
                        break;
                    }
                }


                FlotaAgregarService.getSubModelos(parametros).then(

                    function (response) {
                        if (!response.data.error)
                        {
                            if (response.data.dato!=null)
                            {
                                for(var i=0; i<response.data.dato.length; i++){

                                    var datos ={
                                        id:response.data.dato[i].COD_SUB_MODELO,
                                        cantOcup:response.data.dato[i].NUM_PLAZAS,
                                        cantMinOcup: response.data.dato[i].NUM_PLAZAS_MIN,
                                        nombreTipoVehiculo :response.data.dato[i].NOM_TIP_VEHI,
                                        idTipoVehiculo :response.data.dato[i].COD_TIP_VEHI
                                    }

                                    var obj = {
                                        id:response.data.dato[i].COD_SUB_MODELO,
                                        subModelo:response.data.dato[i].NOM_SUB_MODELO
                                    };
                                    $scope.listadoSubModelos.push(obj);
                                    $scope.datosSubmodelo.push(datos);

                                 }
                                 $scope.promesaSubModelo.resolve();
                                
                            }
                            else
                            {
                             $scope.promesaSubModelo.resolve();   
                            }
                            
                        }
                        else
                        {
                            Message.error(response.data.mensaje);
                            $scope.promesaSubModelo.reject();
                        }
                        
                        /*if (sessionStorage.getItem('editar')=='S'){
                            $scope.datosAgregar.subModeloId=parseInt( objetoCotizacion.codigoSubModelo);
                        }*/


                    },
                    function(response){

                        Message.error("No se pudo obtener los sub modelos");
                    });

            }else{
                $scope.listadoSubModelos =[];
                $scope.years =[];
                $scope.datosSubmodelo=[];

            }

        },true);
        $scope.promesaAnho=$q.defer();
        $scope.$watch('datosAgregar.subModeloId', function(NewValue, OldValue) {
            if(!angular.isUndefined(NewValue)){
                $scope.datosAgregar.ocupantes=undefined;
                $scope.years =[];
                var  parametros ={};
                parametros.esNuevo= $scope.nuevo;
                parametros.codigoMarca=$scope.datosAgregar.marcaId;
                parametros.codigoModelo=$scope.datosAgregar.modeloId;
                parametros.codigoSubModelo=$scope.datosAgregar.subModeloId;
                for(var i=0; i<$scope.datosSubmodelo.length; i++){
                    if ($scope.datosSubmodelo[i].id==NewValue){
                        $scope.datosAgregar.ocupantes=$scope.datosSubmodelo[i].cantOcup;
                        $scope.datosAgregar.ocupantesMin=$scope.datosSubmodelo[i].cantMinOcup;
                        $scope.datosAgregar.ocupantesMax=$scope.datosSubmodelo[i].cantOcup;
                        $scope.datosAgregar.nombretipoVehiculo =$scope.datosSubmodelo[i].nombreTipoVehiculo;
                        $scope.datosAgregar.tipoVehiculoId =$scope.datosSubmodelo[i].idTipoVehiculo;
                        break;
                    }
                }

                for(var i=0; i<$scope.listadoSubModelos.length; i++){
                    if ($scope.listadoSubModelos[i].id==NewValue){
                        $scope.datosAgregar.subModeloNombre=$scope.listadoSubModelos[i].subModelo;
                        break;
                    }
                }

                parametros.codigoMoneda=objetoCotizacion.moneda;

                FlotaAgregarService.getAnhoSubModelos(parametros).then(
                    function (response) {
                        if (!response.data.error){
                            if (response.data.dato.length>0)
                            {
                                for(var i=0; i<response.data.dato.length; i++){
                                var obj = {
                                    id:response.data.dato[i].ANIO_SUB_MODELO,
                                    value:response.data.dato[i].ANIO_SUB_MODELO
                                };

                                var asegurado = {
                                    id:response.data.dato[i].ANIO_SUB_MODELO,
                                    montoAsegurado:response.data.dato[i].VAL_SUB_MODELO,
                                    montoMinimo :response.data.dato[i].VAL_SUB_MODELO_MIN,
                                    montoMaximo :response.data.dato[i].VAL_SUB_MODELO_MAX
                                };

                                $scope.datosSumaAsegurada.push(asegurado);

                                $scope.years.push(obj);
                                
                            }
                            $scope.promesaAnho.resolve();
                            }
                            else {
                              $scope.promesaAnho.resolve();   
                            }
                        }
                        else
                        {
                            Message.error(response.data.mensaje);
                            $scope.promesaAnho.reject();
                        }
                        
                    

                    },
                    function(response){
                        $scope.promesaAnho.reject();
                        Message.error("No se pudo obtener los anhos sub modelos");
                    });

            }else{
                $scope.years =[];
                $scope.datosAgregar.ocupantes = undefined;
            }

        },true);
        $scope.promesaSumaAsegurada=$q.defer();
        $scope.$watch('datosAgregar.anho', function(NewValue, OldValue) {
            if(!angular.isUndefined(NewValue)){
                var parametros={};
                parametros.codigoMoneda=objetoCotizacion.moneda;
                parametros.codigoMarca=$scope.datosAgregar.marcaId;
                parametros.codigoModelo=$scope.datosAgregar.modeloId;
                parametros.codigoSubModelo=$scope.datosAgregar.subModeloId;
                parametros.anho=NewValue;
                parametros.numeroCotizacion=objetoCotizacion.numeroCotizacion;
                parametros.numeroRiesgo=$scope.datosAgregar.numeroRiesgo;
                FlotaAgregarService.getSumaAseguradaRiesgo(parametros).then(function(response)
                {
                    if (!response.data.error)
                    {
                        if (response.data.dato !=null)
                        {
                            if (response.data.dato.length>0)
                            {
                                var result=response.data.dato;
                            /**este control se hace para no pisar el valor que viene al recuperar el riesgo**/
                            if ($scope.cambiarSumaAsegurada)
                            {
                                $scope.datosAgregar.sumaAsegurada=result[0].VAL_SUB_MODELO;
                            }
                            else
                            {
                                $scope.cambiarSumaAsegurada=true;
                            }
                            $scope.datosAgregar.montoMin = result[0].VAL_SUB_MODELO_MIN;
                            $scope.datosAgregar.montoMax = result[0].VAL_SUB_MODELO_MAX;
                        
                            }
                            $scope.promesaSumaAsegurada.resolve();
                        }
                        else
                        {
                            $scope.datosAgregar.sumaAsegurada=undefined;
                            $scope.datosAgregar.montoMin=undefined;
                            $scope.datosAgregar.montoMax=undefined;
                            $scope.promesaSumaAsegurada.resolve();
                        }
                    }
                    else
                    {
                        Message.error(response.data.mensaje);
                        $scope.promesaSumaAsegurada.reject();
                    }
                });



            }else{
                $scope.datosAgregar.sumaAsegurada=undefined;
                $scope.datosAgregar.montoMin=undefined;
                $scope.datosAgregar.montoMax=undefined;
            }


        },true);




        $scope.guardar = function(value) {

            $scope.guardarSalir=value;
            var objetoEnviar ={};
            // si es agregar un nuevo registro
            if (sessionStorage.getItem('editar')=='N'){
                //se verifica si viene con cotizacion existente
                if (!angular.isUndefined(objetoCotizacion.numeroCotizacion) && objetoCotizacion.numeroCotizacion != null ){
                    objetoEnviar.numeroCotizacion = objetoCotizacion.numeroCotizacion;
                }else{
                    objetoEnviar.numeroCotizacion=null;
                }


            }else{
                objetoEnviar.numeroCotizacion = objetoCotizacion.numeroCotizacion;
            }
            objetoEnviar.numeroRiesgo=$scope.datosAgregar.numeroRiesgo;
            objetoEnviar.codigoMarca=$scope.datosAgregar.marcaId;
            objetoEnviar.nombreMarca=$scope.datosAgregar.marcaNombre;
            objetoEnviar.codigoModelo=$scope.datosAgregar.modeloId;
            objetoEnviar.nombreModelo=$scope.datosAgregar.modeloNombre;
            objetoEnviar.codigoSubmodelo=$scope.datosAgregar.subModeloId;
            objetoEnviar.nombreSubmodelo=$scope.datosAgregar.subModeloNombre;
            objetoEnviar.codigoTipoVehiculo=$scope.datosAgregar.tipoVehiculoId;
            objetoEnviar.nombreTipoVehiculo=$scope.datosAgregar.nombretipoVehiculo;
            objetoEnviar.anioSubmodelo=$scope.datosAgregar.anho;
            objetoEnviar.numeroPlazas=$scope.datosAgregar.ocupantes;
            objetoEnviar.sumaAsegurada=$scope.datosAgregar.sumaAsegurada;
            objetoEnviar.baja = $scope.datosAgregar.darDeBaja;
            objetoEnviar.tienePreferencia='N';

            /*if($scope.datosAgregar.sumaAsegurada < $scope.datosAgregar.montoMin || $scope.datosAgregar.sumaAsegurada > $scope.datosAgregar.montoMax ){
                Message.warning("El monto asegurado no cumple el rango de requerido, verifique su monto.");
                return;

            }*/
            $scope.validarSumaAsegurada();
            if ($scope.montoValido)
            {
                var confirm = confirmService.showConfirm('¿Está seguro de guardar Riesgo?')

                    .then(function(answer) {
                        $scope.cargando=true;

                        if (sessionStorage.getItem('editar')=='N'){
                            FlotaAgregarService.guardarRiesgo(objetoEnviar).then(

                                function (response) {

                                    if(!response.data.error){
                                        if (objetoCotizacion.numeroCotizacion == null ){
                                            var obj ={}
                                            obj.numeroCotizacion= response.data.dato.numeroCotizacion;
                                            sessionStorage.setItem('objetoCotizacion', JSON.stringify(obj));
                                        }

                                        if( $scope.guardarSalir=='S'){
                                            //$location.url($scope.path);
                                            $location.url("flota/");
                                        }else{
                                            $scope.copiaObjeto.cantRiesgo= $scope.datosAgregar.numeroRiesgo;
                                            sessionStorage.setItem('objetoCotizacion', JSON.stringify( $scope.copiaObjeto));

                                            $scope.datosAgregar.numeroRiesgo=$scope.datosAgregar.numeroRiesgo +1;
                                            $scope.datosAgregar.marcaId =undefined;
                                            //sessionStorage.setItem("objetoCotizacion")=$scope.datosAgregar.numeroRiesgo;
                                        }
                                        $scope.cargando=false;
                                        //Message.ok(response.data.mensaje);

                                    }else{
                                        $scope.cargando=false;
                                        Message.error(response.data.mensaje);

                                    }


                                }).catch(function(response){
                                $scope.cargando=false;
                                Message.error(response.data.mensaje);

                            });


                        }else{
                            //aca verificar que se haya tocado el form
                            if ($scope.FlotaForm.$dirty)
                            {
                                sessionStorage.setItem("modificarTasa", "S");
                            }
                            else
                            {
                                sessionStorage.setItem("modificarTasa", "N");
                            }
                            FlotaAgregarService.editarRiesgo(objetoEnviar).then(

                                function (response) {

                                    if(!response.data.error){
                                        $scope.cargando=false;
                                        if( $scope.guardarSalir=='S'){
                                            $location.url("flota/");
                                        }
                                        else
                                        {
                                            $scope.cargarForGrilla();
                                        }

                                        //Message.ok(response.data.mensaje);
                                    }else{
                                        $scope.cargando=false;
                                        Message.error(response.data.mensaje);

                                    }


                                }).catch(function(response){
                                $scope.cargando=false;
                                Message.error(response.data.mensaje);

                            });

                        }






                    }, function() {
                        return;
                    });
            }
            else
            {
                return;
            }

        };

        $scope.cargarForGrilla = function() {

            var parametros = {};

            parametros.numeroRiesgo=$scope.datosAgregar.numeroRiesgo;
            parametros.numeroCotizacion=  $scope.datosAgregar.numCotizacion;
            $scope.cambiarSumaAsegurada=false;


            FlotaAgregarService.editarRiesgoGrilla(parametros).then(

                function (response) {
                    if (!response.data.error)
                    {
                        if (response.data.dato.length>0)
                        {
                            $scope.datosCargaForm=response.data.dato[0];
                            $scope.datosCoberturaRiesgos = $scope.datosCargaForm.coberturaRiesgos;
                            $scope.datosAgregar.numeroRiesgo = $scope.datosCargaForm.numeroRiesgo;
                            $scope.datosAgregar.numeroCotizacion=parametros.numeroCotizacion;

                            $scope.datosAgregar.sumaAsegurada=$scope.datosCargaForm.sumaAsegurada;
                            $scope.datosAgregar.ocupantes =parseInt($scope.datosCargaForm.numeroPlazas);
                            $scope.datosAgregar.tieneAutorizacion=$scope.datosCargaForm.autorizacion;
                            $scope.marcasPromise.promise.then(function(){
                                $scope.datosAgregar.marcaId=parseInt($scope.datosCargaForm.codigoMarca);
                            });
                             $scope.promesaModelo.promise.then(
                                function(){
                                $scope.datosAgregar.modeloId=parseInt($scope.datosCargaForm.codigoModelo);
                             })
                             $scope.promesaSubModelo.promise.then(
                                function(){
                                $scope.datosAgregar.subModeloId=parseInt($scope.datosCargaForm.codigoSubmodelo);
                             })
                             $scope.promesaAnho.promise.then(
                                function(){
                                $scope.datosAgregar.anho=parseInt($scope.datosCargaForm.anioSubmodelo);
                             })
                            // $scope.cargarCombos();
                            $scope.cobeturaDinamica();
                        }
                        else
                        {
                            Message.error("No se pudo obtener los detalles del riesgo");
                        }
                        
                    }
                    else {
                        Message.error(response.data.mensaje);
                    }
                   

                },
                function(response){
                     Message.error("No se pudo obtener los detalles del riesgo");
                });

        };

        $scope.cobeturaDinamica = function() {
            if(!angular.isUndefined($scope.datosCoberturaRiesgos)){
                if( $scope.datosCoberturaRiesgos.length>0){
                    $scope.sindatos=false;
                    $scope.cartaVerde=false;
                    $scope.cartaAzul=false;
                    var CV,CA;
                    CV=0,CA=0;
                    $scope.datos = angular.copy($scope.datosCoberturaRiesgos);

                    for(var i=0;i<$scope.datos.length;i++){
                        if($scope.datos[i].etiqueta==="CARTA VERDE"){
                            $scope.datos.splice(i,1);
                            $scope.cartaVerde = true;
                            CV=i;
                        }else if($scope.datos[i].etiqueta==="CARTA AZUL"){
                            $scope.datos.splice(i,1);
                            $scope.cartaAzul = true;
                            CA=i;
                        }
                    }

                    $scope.v1=[];
                    $scope.v2=[];

                    if($scope.datosCoberturaRiesgos.length<=6){
                        var i=0;
                        while($scope.datos.length>0 && $scope.v1.length<=6){
                            $scope.v1.push($scope.datos[i]);
                            $scope.datos.splice(i,1);
                        };
                    }else if($scope.datosCoberturaRiesgos.length>6 && $scope.datosCoberturaRiesgos.length<=18){
                        var i=0;
                        while($scope.datos.length>0 && $scope.v1.length<6){
                            $scope.v1.push($scope.datos[i]);
                            $scope.datos.splice(i,1);
                        };
                        var j=0;
                        while($scope.datos.length>0 && $scope.v2.length<6){
                            $scope.v2.push($scope.datos[j]);
                            $scope.datos.splice(j,1);
                        };
                    }else{
                        var cant = Math.trunc($scope.datosCoberturaRiesgos.length/3);
                        var resto = $scope.datosCoberturaRiesgos.length%3;
                        var cantxColum = cant + resto;
                        var i=0;
                        while($scope.datos.length>0 && $scope.v1.length< cantxColum){
                            $scope.v1.push($scope.datos[i]);
                            $scope.datos.splice(i,1);
                        };
                        var j=0;
                        while($scope.datos.length>0 && $scope.v2.length< cantxColum){
                            $scope.v2.push($scope.datos[j]);
                            $scope.datos.splice(j,1);
                        };

                    }
                    $log.debug($scope.v1);
                    $log.debug($scope.v2);
                    $log.debug($scope.datos);
                }else{
                    $scope.sindatos=true;
                }

            }

        };
        $scope.validarSumaAsegurada=function ()
        {
            if ($scope.datosAgregar.darDeBaja=='S')
            {
                $scope.montoValido=true;
            }
            else if ($scope.datosAgregar.tieneAutorizacion=="S" && sessionStorage.getItem('editar')=='S' )
            {
                $scope.montoValido=true;
            }
            else
            {
                if (Number($scope.datosAgregar.sumaAsegurada)< Number ($scope.datosAgregar.montoMin) ||Number($scope.datosAgregar.sumaAsegurada)>Number($scope.datosAgregar.montoMax))
                {
                    Message.warning("El monto asegurado ingresado no cumple con el rango requerido, el monto debe ser como mínimo "+$scope.datosAgregar.montoMin+" y como máximo "+$scope.datosAgregar.montoMax+", verifique el monto e intente nuevamente.");
                    $scope.montoValido=false;
                }
                else
                {
                    $scope.montoValido=true;
                }
            }


        };



        $scope.llamarModal = function(value) {
                

            if(!angular.isUndefined( $scope.datosAgregar.numCotizacion)&&  $scope.datosAgregar.numCotizacion!=null &&  $scope.datosAgregar.numCotizacion!=""){
                $rootScope.numCotiza =  $scope.datosAgregar.numCotizacion;
                $rootScope.numeroRiesgoFlota=$scope.datosAgregar.numeroRiesgo;
                $rootScope.modalCotizadorVehFlota=value;
                $rootScope.flagVehiculoFlota=false;
                $mdDialog.show({
                    //locals:{parent: $scope},
                    controller: 'ModalAutorizacionCtrl',
                    templateUrl: 'partials/ventanas-emergentes/modal-autorizacion-partial.html',
                    parent: angular.element(document.body),
                    multiple: true,
                    clickOutsideToClose:false,
                    scope:$scope,
                    preserveScope: true,
                    fullscreen: $scope.customFullscreen // Only for -xs, -sm breakpoints.
                }).then(function(answer) {
                    $scope.datosAgregar.sumaAsegurada=answer;
                    $scope.cargarForGrilla();


                }, function() {
                    $scope.status = 'You cancelled the dialog.';
                });
            }

        };
        $scope.obtenerCamposEditables=function()
        {
            var marcaFlota="S";
            var params={};
            params.numeroCotizacion=angular.isUndefined($scope.datosAgregar.numCotizacion)|| $scope.datosAgregar.numCotizacion==null?null:$scope.datosAgregar.numCotizacion;
            params.numeroRiesgo=$scope.datosAgregar.numeroRiesgo;
            params.marcaFlota=marcaFlota;
            params.pathModule=$scope.pathModule;
            FlotaService.getCamposEditables(params).then(function(response)
            {
                if (!response.data.error)
                {
                    if (response.data.dato.length>0)
                    {
                        var campos=response.data.dato;
                        for (var i=0; i< campos.length; i++)
                        {
                            $scope.camposEditablesList.push(campos[i]);
                        }
                    }

                }
                else
                {
                    Message.error(response.data.mensaje);
                }
            })
        };


        /**
         * Constructor / Entrypoint
         * @constructor
         */
        (function initialize() {
            $scope.esEditar=false;
            $scope.copiaObjeto={};
            $scope.cargando=false;
            $scope.pathModule = UtilsService.retornarPath($location.path().split("/")[1]);
            $scope.obtenerAutorizaciones();

            $scope.datosCoberturaRiesgos=[];
            var path1 = $location.$$path.split("-")[0];
            $scope.path=path1.split("/")[0];
            var param = $routeParams;
            $scope.nuevo= sessionStorage.getItem('agregarEsNuevo');

            if (sessionStorage.getItem('editar')=='N'){
                $scope.sindatos=true;
                $scope.mostrarBaja=false;
                $scope.titulo = "Agregar Vehiculo";
                if (!angular.isUndefined(sessionStorage.getItem("objetoCotizacion")) && sessionStorage.getItem("objetoCotizacion") != null ){
                    objetoCotizacion = JSON.parse(sessionStorage.getItem("objetoCotizacion"));
                    $scope.copiaObjeto =  objetoCotizacion;
                    $scope.datosAgregar.numeroRiesgo = parseInt(angular.isUndefined(objetoCotizacion.cantRiesgo)?0:objetoCotizacion.cantRiesgo ) + 1;
                    $scope.datosAgregar.numCotizacion = !angular.isUndefined(objetoCotizacion.numeroCotizacion) && objetoCotizacion.numeroCotizacion!=null?objetoCotizacion.numeroCotizacion:"";
                    $scope.obtenerCamposEditables();

                }else{
                    $scope.datosAgregar.numeroRiesgo =1;
                    objetoCotizacion.numeroCotizacion=null;
                    $scope.obtenerCamposEditables();
                }
                $scope.codigoProducto=objetoCotizacion.producto;
                $scope.cargarCombos();

            }else{
                $scope.mostrarBaja=true;
                $scope.titulo = "Editar Vehiculo";
                $scope.esEditar=true;
                if (!angular.isUndefined(sessionStorage.getItem("objetoCotizacionEdit")) && sessionStorage.getItem("objetoCotizacionEdit") != null ){
                    objetoCotizacion = JSON.parse(sessionStorage.getItem("objetoCotizacionEdit"));
                    $scope.datosAgregar.numeroRiesgo = parseInt(objetoCotizacion.numeroRiesgo);
                    $scope.datosAgregar.numCotizacion = parseInt(objetoCotizacion.numeroCotizacion);
                    $scope.datosAgregar.darDeBaja = objetoCotizacion.baja;
                    $scope.obtenerCamposEditables();

                    /*   $scope.datosAgregar.sumaAsegurada=parseInt(objetoCotizacion.capital);*/
                }
                $scope.cargarCombos();
                $scope.cargarForGrilla();
                


            }






        })();

    }]);
;app.controller('FlotaFormCtrl', ['$scope','$filter', 'FlotaService', '$controller', '$routeParams', '$location', 'SessionService', '$rootScope', '$route', '$mdDialog', 'ConfirmService','$q','CotizacionVehiculoService', 'UtilsService','$locale','PropuestaService','$log',
    function ($scope,filter,FlotaService, $controller, $routeParams, $location, sessionService, $rootScope, $route, $mdDialog, confirmService,$q,CotizacionVehiculoService, UtilsService, $locale,PropuestaService, $log) {
        $scope.service=PropuestaService;
        $scope.nombre = "Flota";
        $locale.NUMBER_FORMATS.GROUP_SEP = '.';
        $locale.NUMBER_FORMATS.DECIMAL_SEP=',';
        $rootScope.rootPathParent =$route.current.$$route.originalPath;
        $scope.flota = {};
        $scope.flota.nuevo="S";
        $scope.flota.producto=null;
        $scope.flota.tasa=undefined;
        $scope.flota.cantRiesgo=undefined;
        $scope.observarTasa=false;
       // $scope.flota.numeroPoliza=undefined;
        $scope.flota.numeroCotizacion=undefined;
        //$scope.flota.numeroCotizacionAnt=undefined;
        $scope.flota.formaPago=null;
        $scope.flota.moneda=undefined;
        $scope.flota.sumaAsegurada=undefined;
        $scope.flota.notificacion=undefined;
        $scope.flota.notificacionDisabled=false;
        $scope.flota.cambio=undefined;


        $scope.resumen = {};
        $scope.resumen.prima=undefined;
        $scope.resumen.recargo=undefined;
        $scope.resumen.premio=undefined;
        $scope.resumen.anhoPromedio=undefined;
        $scope.resumen.capitalPromedio=undefined;
        $scope.resumen.sumaAsegurada=undefined;
        $scope.resumen.cantRiesgoAlta=undefined;


        $scope.marcasRiesgo = {};
        $scope.marcasRiesgo.audi=undefined;
        $scope.marcasRiesgo.chevrolet=undefined;
        $scope.marcasRiesgo.volvo=undefined;
        $scope.marcasRiesgo.mercedez=undefined;
        $scope.marcasRiesgo.minicooper=undefined;

        $scope.cobertura = {};
        $scope.cobertura.persona=undefined;
        $scope.cobertura.danhosMateriales=undefined;
        $scope.cobertura.ovpMteOcupante=undefined;
        $scope.cobertura.ovpGtoMedOcupante=undefined;
        $scope.cobertura.flota = undefined;
        $scope.cobertura.sumaAsegurada=undefined;
        $scope.camposEditablesList=[];
        $scope.esBuscar=false;
        $scope.pagina=1;

        $scope.promesaProducto = $q.defer();

        $scope.obtenerAutorizaciones=function()
        {

            $scope.autorizacionesList = [];
            var params={};
            params.pathModule=$scope.pathModule;
            FlotaService.getAutorizaciones(params).then(function(response){
               if (!response.data.error)
               {
                   if (response.data.dato.length>0)
                   {
                       var campos=response.data.dato;
                       for (var i=0; i< campos.length; i++)
                       {
                           $scope.autorizacionesList.push(campos[i]);
                           if (campos[i]==='btnEliminar'){
                              $rootScope.botonEliminar=true;

                           }
                       }
                   }
               }
               else
                   {
                   Message.error(response.data.mensaje);
               }
            });
        };

        $scope.cargarProductos = function() {
            $scope.listaProductos =[];
            var parametros = {};
            parametros.numeroCotizacion= $scope.flota.numeroCotizacion;
            FlotaService.getProductos(parametros).then(

                function (response) {
                    if (!response.data.error)
                    {
                        if (response.data.dato.length>0)
                        {
                            for(var i=0; i<response.data.dato.length; i++){
                                var obj = {
                                    id:response.data.dato[i].COD_MODALIDAD,
                                    producto:response.data.dato[i].NOM_MODALIDAD
                                };
                                $scope.listaProductos.push(obj);
                            }
                            $scope.promesaProducto.resolve();
                        }
                        else
                        {
                            $scope.promesaProducto.resolve();
                        }
                    }
                    else
                    {
                        Message.error(response.data.mensaje);
                        $scope.promesaProducto.resolve();
                    }

                         


            },
                function(response){
                $scope.promesaProducto.reject();
                Message.error(response.data.mensaje);
                
                
            });

        };



        /*cargar todos los combos*/
        $scope.cargarCombos = function() {

            $scope.listaFormaPago = [];
            $scope.listaMonedas = [];
            $scope.listaCambio=[];
            $scope.listaProductos = [];
            $scope.cargarMonedas();
           

            
            $scope.itemsByPage =5;


        };

       /*funciones*/
        $scope.showModal = function() {
            $mdDialog.show({
                controller: 'ModaltFlotaCtrl',
                templateUrl: 'partials/ventanas-emergentes/modal-flota.html',
                parent: angular.element(document.body),
                clickOutsideToClose:false,
                fullscreen: $scope.customFullscreen // Only for -xs, -sm breakpoints.
            }).then(function(answer) {
                $scope.status = 'You said the information was "' + answer + '".';
                $scope.datos.idProductos = answer.id;
                $scope.datos.productoDescripcion =  answer.descripcion;
            }, function() {
                $scope.status = 'You cancelled the dialog.';
            });
        };



        $scope.guardar = function(value) {
           
             var lista =[];
             var parametros = {};
             //parametros.numeroPoliza=$scope.flota.numeroPoliza;
             parametros.numeroCotizacion=$scope.flota.numeroCotizacion;
             parametros.codigoProducto=$scope.flota.producto;
             parametros.codigoMoneda=$scope.flota.moneda;
             parametros.codigoFraccionamiento=$scope.flota.formaPago;
             parametros.tasa=$scope.flota.tasa;
            parametros.cambio=$scope.flota.cambio;

            if(!angular.isUndefined($scope.Coberturas) && $scope.Coberturas!=null && $scope.Coberturas.length>0)
              {
                 for (var i=0; i<$scope.Coberturas.length; i++) {
                     var obj = {
                         numeroRiesgo:$scope.flota.cantRiesgo,
                         codigoCobertura:$scope.Coberturas[i].COD_COB,
                         etiqueta :$scope.Coberturas[i].ETIQUETA,
                         importeCapital :$scope.Coberturas[i].ETIQUETA =='RC PERSONAS'?$scope.cobertura.persona:
                             $scope.Coberturas[i].ETIQUETA =='RC MATERIALES'?$scope.cobertura.danhosMateriales:
                                 $scope.Coberturas[i].ETIQUETA =='OVP MUERTE'?$scope.cobertura.ovpMteOcupante:
                                     $scope.Coberturas[i].ETIQUETA =='OVP GTOS MED'?$scope.cobertura.ovpGtoMedOcupante:null

                     };

                     lista.push(obj);
                 }
                 parametros.coberturaPoliza=lista;
                 //si es agregar
                 if (value==='A'){

                     $scope.cargando=true;
                     FlotaService.agregarCotizacion(parametros).then(
                         //sucess
                         function (response) {
                             if (!response.data.error)
                             {
                                 $scope.cargando=false;
                                 if (response.data.dato !=null)
                                 {
                                     $scope.flota.numeroCotizacion=parseInt(response.data.dato.numeroCotizacion);
                                     $scope.flagCotizacion= true;

                                 }
                                 $scope.setCotizacion();
                                 $location.url($scope.pathAgregar);
                             }
                             else {
                                 $scope.cargando=false;
                             }


                             //error
                         }).catch(function(response){
                         $scope.cargando=false;
                         Message.error(response.data.mensaje);
                         
                     });
                     //si es editar
                 }else if (value==='E'){

                    
                     FlotaService.getCotizacion(parametros).then(
                                //success
                        function (response) {
                        if(!response.data.error){
                            if (response.data.dato.length >0 && (response.data.dato[0].numeroCotizacion!=null && response.data.dato[0].numeroCotizacion !="")){
                              
                              if(!angular.isUndefined($scope.FlotaFormulario.$error.required)){
                         $scope.controlRequerido = true;
                         Message.info("Complete los valores requeridos");
                         return;
                     }

                     $scope.cargando=true;
                     
                     FlotaService.cotizar(parametros).then(
                         //sucess
                         function (response)
                         {
                             if (!response.data.error)
                             {
                                     $scope.cargando=false;
                                     response.data.dato;
                                     $scope.flota.numeroCotizacion=parseInt(response.data.dato.numeroCotizacion);
                                     $scope.flagCotizacion= true;
                                     $scope.setCotizacion();

                                     $scope.buscarCotizacion();
                                     Message.ok(response.data.mensaje);
                                 }
                                 else
                                 {
                                     $scope.cargando=false;
                                     Message.error(response.data.mensaje);
                                 }

                                 //error
                             }).catch(function(response){
                             $scope.cargando=false;
                             Message.error(response.data.mensaje);
                             
                         });
                                    

                                  


                        } else{

                            Message.error("Numero de cotizacion inexistente.No se puede cotizar");
                            return;
                        }  
                           
                    }else{   
                            Message.error("Numero de cotizacion inexistente.No se puede cotizar");
                            return;                   
                                       
                     }  
                                     
                    }).catch(function(response){ 
                             Message.error(response.data.mensaje);                   
                             
                             return;
                    });
 

                     

                 }
 

                 }
                 else
                 {
                     Message.error("No se pudo obtener la lista de Coberturas, verifique e intente nuevamente");
                 }




       


             

             

        };

        $scope.importar = function() {
            FlotaService.getAgentes().then(function (response) {
                $scope.datos.listaProveedores = [];

            }).catch(function(response){
                
            });

        };

        $scope.exportar = function() {
            var request= new XMLHttpRequest();
            request.open("GET", App.URL_BASE+'/flota/riesgos/exportar?numeroCotizacion=' + $scope.flota.numeroCotizacion );
            request.setRequestHeader("Authorization","Bearer "+ sessionStorage.getItem("token"));
            request.responseType='arraybuffer';
            request.onload = function(e) {
                var file = new Blob([this.response],{type:'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'});
                  var disposition = request.getResponseHeader('Content-Disposition');
                  var filenameRegex = /filename[^;=\n]*=((['"]).*?\2|[^;\n]*)/;
                  var matches = filenameRegex.exec(disposition);
                  var filename;
                  if (matches != null && matches[1]) {
                      filename = matches[1].replace(/['"]/g, '');
                  }
                  var a = document.createElement("a");
                  document.body.appendChild(a);
                  a.style = "display: none";
                  a.href = URL.createObjectURL(file);
                  a.download = filename;
                  a.click();
                };
              request.send();

            /*FlotaService.getAgentes().then(function (response) {
               // $scope.datos.listaProveedores = [];

                

            }).catch(function(response){
                
            });*/

        };

        $scope.verModal = function() {
            var respuestaModal = $dialogs.create(
                "partials/flota/desktop/modal/modal-flota.html",
                "ModalFlotaController",

                {
                    key: false,
                    back: 'static'
                }
            );

        };


        

      var promesamoneda = $q.defer();
        $scope.cargarMonedas = function() {
            var parametros = {};
            parametros.esNuevo=$scope.flota.nuevo;
            FlotaService.getMonedas(parametros).then(
                function (response) {
                    for(var i=0; i<response.data.dato.length; i++){
                       var camb ={
                          id :  response.data.dato[i].COD_MON,
                          cambio : response.data.dato[i].VAL_CAMBIO
                        };
                        var obj = {
                            id:response.data.dato[i].COD_MON,
                            moneda:response.data.dato[i].NOM_MON
                        };
                        $scope.listaMonedas.push(obj);
                        $scope.listaCambio.push(camb);
                    }
                    $scope.flota.moneda = 1;
                    $scope.cargarFraccionamiento();
                    promesamoneda.resolve();
                   
                },
                function(response){
                    Message.error(response.data.mensaje);
                    promesamoneda.reject();
                    
                });

        };


         $scope.cargarFraccionamiento = function() {
            var parametros = {};
            $scope.listaProductos=[];
            parametros.esNuevo=$scope.flota.nuevo;
            FlotaService.getFraccionamiento(parametros).then(
                function (response) {
                    for(var i=0; i<response.data.dato.length; i++){
                        var obj = {
                            id:response.data.dato[i].COD_FRACC_PAGO,
                            fraccion:response.data.dato[i].NOM_FRACC_PAGO
                        };
                        $scope.listaFormaPago.push(obj);
                    }
                    $scope.flota.formaPago =99100;
                },
                function(response){
                    Message.error(response.data.mensaje);
                    
                });

        };

        $scope.cargarRiesgos = function() {
              $scope.rowCollection = []; 
              var suma = 0;
              $scope.flota.sumaAsegurada = 0;
               var parametros = {};
              // parametros.codigoRamo=501;
               parametros.numeroCotizacion=$scope.flota.numeroCotizacion;
               parametros.numeroPagina=$scope.pagina;
               if (parametros.numeroCotizacion != null){
                 FlotaService.getListaRiesgos(parametros).then(
                   function (response) {
                     
                      if(response.data.dato!=null )  {
                          $scope.rowCollection=[];
                         $scope.flagMoneda=true;
                        for(var i=0; i<response.data.dato.lista.length; i++){
                           var objeto ={
                              numeroRiesgo :  response.data.dato.lista[i].NUM_RIESGO,
                              codigoMarca:response.data.dato.lista[i].COD_MARCA,
                              marca : response.data.dato.lista[i].NOM_MARCA,
                              codigoModelo :  response.data.dato.lista[i].COD_MODELO,
                              modelo :  response.data.dato.lista[i].NOM_MODELO,
                              codigoSubModelo : response.data.dato.lista[i].COD_SUB_MODELO,
                              subModelo : response.data.dato.lista[i].NOM_SUB_MODELO,
                              anho :  response.data.dato.lista[i].ANIO,
                              ocupantes:response.data.dato.lista[i].OCUPANTE,
                              capital : response.data.dato.lista[i].VALOR_VEHI,
                              baja :  response.data.dato.lista[i].MCA_BAJA_RIESGO,
                              numeroCotizacion :  $scope.flota.numeroCotizacion,
                            };
                            
                            suma +=  parseInt(isNaN(response.data.dato.lista[i].VALOR_VEHI)?0:response.data.dato.lista[i].VALOR_VEHI!= null?response.data.dato.lista[i].VALOR_VEHI :0);
                                   
                            $scope.rowCollection.push(objeto);
                        }
                        $scope.flota.cantRiesgo= response.data.dato.ultimoRiesgo;
                            //$scope.ultimoRiesgo();

                        $scope.flota.sumaAsegurada = suma ;
                        if ($scope.rowCollection.length>1){
                            $scope.flagProducto=false;
                         }
                          $scope.totalItems = response.data.dato.totalDatos;
                          $scope.pagina = response.data.dato.paginado;
                          var restoPaginas=$scope.totalItems % $scope.itemsByPage;
                          var totalPaginas=parseInt($scope.totalItems /$scope.itemsByPage);

                          $scope.cantidadPaginas = totalPaginas==0?1:totalPaginas+(restoPaginas>0?1:0);
                          $scope.verificarPagina();
                      }else{
                        $scope.flota.cantRiesgo=0;

                      }
                                     
                },
                function(response){

                    Message.error(response.data.mensaje);
                    
                });
               }
          

        };

        
        $scope.$watch('flota.tasa', function(NewValue, OldValue) {
            if($scope.observarTasa){
                /*if(NewValue!=OldValue){*/
                    var lista =[];
                    var dato = {};
                    //parametros.numeroPoliza=$scope.flota.numeroPoliza;
                    dato.numeroCotizacion=$scope.flota.numeroCotizacion;
                    $scope.cargando=true;
                    FlotaService.actualizarTasa(dato).then(function(response)
                    {
                        if (!response.data.error)
                        {
                            $scope.cargando=false;
                        }
                        else
                        {
                            $scope.cargando=false;
                            Message.error(response.data.mensaje);
                        }
                    })
                   /*}*/
            }
           
         
           
        },true);
    
        $scope.$watch('flota.moneda', function(NewValue, OldValue) {

            if (!angular.isUndefined(NewValue)) {

                if (sessionStorage.getItem("cambio")=="null") {


                    for (var i = 0; i < $scope.listaCambio.length; i++) {
                        if ($scope.listaCambio[i].id == NewValue) {
                            $scope.flota.cambio = $scope.listaCambio[i].cambio;
                            break;
                        }

                    }

                }
                else{
                    $scope.flota.cambio = parseInt(sessionStorage.getItem("cambio"));


                }

            if (angular.isUndefined($scope.flota.producto)) {
                $scope.cobertura.persona = 0;
                $scope.cobertura.danhosMateriales = 0;
                $scope.cobertura.ovpMteOcupante = 0;
                $scope.cobertura.ovpGtoMedOcupante = 0;
                $scope.Coberturas = [];
                $scope.Coberturas.push({"ETIQUETA": "RC PERSONAS"});
                $scope.Coberturas.push({"ETIQUETA": "RC MATERIALES"});
                $scope.Coberturas.push({"ETIQUETA": "OVP MUERTE"});
                $scope.Coberturas.push({"ETIQUETA": "OVP GTOS MED"});
            }
            else {
                var parametros = {};
                parametros.codigoMoneda = $scope.flota.moneda;

                parametros.codigoProducto = $scope.flota.producto;
                parametros.nroCotizacion = $scope.flota.numeroCotizacion;
                FlotaService.CoberturasFlota(parametros).then(
                    function (response) {
                        if (!response.data.error) {
                            if (response.data.dato != null && response.data.dato.length > 0) {
                                $scope.mostrardatos = true;
                                $scope.Coberturas = response.data.dato;
                                for (var i = 0; i < $scope.Coberturas.length; i++) {
                                    if ($scope.Coberturas[i].ETIQUETA == 'RC PERSONAS') {
                                        $scope.cobertura.persona = $scope.Coberturas[i].CAPITAL;
                                    } else if ($scope.Coberturas[i].ETIQUETA == 'RC MATERIALES') {
                                        $scope.cobertura.danhosMateriales = $scope.Coberturas[i].CAPITAL;
                                    } else if ($scope.Coberturas[i].ETIQUETA == 'OVP MUERTE') {
                                        $scope.cobertura.ovpMteOcupante = $scope.Coberturas[i].CAPITAL;
                                    } else if ($scope.Coberturas[i].ETIQUETA == 'OVP GTOS MED') {
                                        $scope.cobertura.ovpGtoMedOcupante = $scope.Coberturas[i].CAPITAL;
                                    }


                                }

                            }
                        }
                        else {
                            Message.error(response.data.mensaje);
                            
                        }


                    },
                    function (response) {
                        Message.error(response.data.mensaje);
                        
                    });


            }
            $scope.mostrardatos = true;
            $scope.habilitaAgregar = false;

                    }else{
                    $scope.flota.cambio=null;
                    $scope.mostrardatos=false;
                    $scope.cobertura ={};
                    $scope.habilitaAgregar = true;

                }


        },true);

        $scope.$watch('flota.producto', function(NewValue, OldValue) 
        {

            if(!angular.isUndefined(NewValue))
            {
                if(NewValue!=OldValue){
                    if ($scope.limpiarTasa==true){
                        $scope.flota.tasa=0;
                        $scope.observarTasa=true;

                      }
                       $scope.limpiarTasa=true;
                }
                

                 if ($scope.flota.moneda == null  || angular.isUndefined($scope.flota.moneda))
                 {
                    $scope.cobertura.persona=0;
                    $scope.cobertura.danhosMateriales=0;
                    $scope.cobertura.ovpMteOcupante=0;
                    $scope.cobertura.ovpGtoMedOcupante=0;
                 }
                 else
                 {
                    var parametros = {};
                    parametros.codigoMoneda= $scope.flota.moneda;
                    parametros.codigoProducto=$scope.flota.producto;
                    parametros.nroCotizacion=$scope.flota.numeroCotizacion;
                    FlotaService.CoberturasFlota(parametros).then(
                        function (response) {
                            if (!response.data.error)
                            {
                                if(response.data.dato != null && response.data.dato.length>0){
                                    $scope.mostrardatos = true;
                                    $scope.Coberturas=[];
                                    $scope.Coberturas = response.data.dato;
                                    for (var i=0; i<$scope.Coberturas.length; i++) {
                                        if ($scope.Coberturas[i].ETIQUETA =='RC PERSONAS'){
                                             $scope.cobertura.persona=$scope.Coberturas[i].CAPITAL;
                                        }else if($scope.Coberturas[i].ETIQUETA =='RC MATERIALES'){
                                             $scope.cobertura.danhosMateriales=$scope.Coberturas[i].CAPITAL;
                                        }else if($scope.Coberturas[i].ETIQUETA =='OVP MUERTE'){
                                             $scope.cobertura.ovpMteOcupante=$scope.Coberturas[i].CAPITAL;
                                        }else if($scope.Coberturas[i].ETIQUETA =='OVP GTOS MED'){
                                             $scope.cobertura.ovpGtoMedOcupante=$scope.Coberturas[i].CAPITAL;
                                        }



                                     }

                                }
                            }
                            else
                            {
                                Message.error(response.data.mensaje);
                            }
                           /*if(response.data != null){

                           }*/


                         },
                         function(response){
                           Message.error(response.data.mensaje);
                           
                        });

                        $scope.mostrardatos=true;
                        $scope.habilitaAgregar=false;

                 }

         
            } 


        },true);


        $scope.obtenerCoberturas= function(){
           var parametros = {};
           parametros.codigoMoneda= $scope.flota.moneda;
           parametros.producto=$scope.flota.producto;
           parametros.nroCotizacion=$scope.flota.numeroCotizacion;

            if (!angular.isUndefined($scope.flota.moneda))
            {
                FlotaService.CoberturasFlota(parametros).then(
                    function (response) {
                        if(response.data.dato != null){
                            if(response.data.dato.length>0){
                                $scope.mostrardatos = true;
                                $scope.Coberturas = response.data.dato;

                            }
                        }

                    },
                    function(response){
                        Message.error(response.data.mensaje);
                        
                    });
            }

        };



        $scope.$watch('flota.nuevo', function(NewValue, OldValue) {

             if(!angular.isUndefined(NewValue)){

                 sessionStorage.setItem('agregarEsNuevo', $scope.flota.nuevo);
             }else{
                   
             }

        },true);

         $scope.changeFraccionamiento = function() {
             $scope.flota.tasa=0;
             $scope.observarTasa=true;
          };
        

       $scope.setCotizacion = function() {

          if(!angular.isUndefined($scope.flota)){

             sessionStorage.setItem('objetoCotizacion', JSON.stringify($scope.flota));
            
          }

        }

         $scope.buscarCotizacion = function() {
             $scope.habilitarBtnIrPropuesta=false;
             $scope.limpiarTasa=true;
             $scope.flota.cantRiesgoAlta=0;
            if($scope.flota.numeroCotizacion != null && $scope.flota.numeroCotizacion != ""){
                $scope.obtenerCamposEditables();
              var parametros={};
              parametros.numeroCotizacion=$scope.flota.numeroCotizacion;
              $scope.cargando=true;
             $q.all( [promesamoneda.promise.then()] ).then(
                            function(response){

                            FlotaService.getCotizacion(parametros).then(
                //success
                function (response) {
                if(!response.data.error){
                    if (response.data.dato.length >0 && (response.data.dato[0].numeroCotizacion!=null && response.data.dato[0].numeroCotizacion !="")){
                        $scope.habilitarBtnIrPropuesta=true;
                        $scope.limpiarTasa=false;
                         
                        var cambio=!angular.isUndefined(response.data.dato[0].cambio)&& response.data.dato[0].cambio!=null && response.data.dato[0].cambio!=""?response.data.dato[0].cambio:null;
                        sessionStorage.setItem("cambio", cambio);
                        $scope.flota.cambio=!angular.isUndefined(response.data.dato[0].cambio)&& response.data.dato[0].cambio!=null && response.data.dato[0].cambio!=""?parseInt(response.data.dato[0].cambio):1;
                        //$scope.flota.moneda=undefined;
                        $scope.flota.moneda = parseInt(response.data.dato[0].codigoMoneda);
                       $scope.cargarProductos();
                       $scope.cargarPlataforma();
                       $scope.cargarRiesgos();

                       //se setean los resumenes
                       if (!angular.isUndefined(response.data.dato[0].resumen[0])){
                           $scope.resumen.prima= response.data.dato[0].resumen[0].impPrima;
                           $scope.resumen.recargo=response.data.dato[0].resumen[0].recargo;
                           $scope.resumen.premio=response.data.dato[0].resumen[0].imPremio;
                           $scope.resumen.anhoPromedio=response.data.dato[0].resumen[0].promedioAnio;
                           $scope.resumen.capitalPromedio=response.data.dato[0].resumen[0].promedioCapital;
                           $scope.resumen.sumaAsegurada=response.data.dato[0].resumen[0].sumaAsegurada;
                           $scope.resumen.cantRiesgoAlta=parseInt(response.data.dato[0].resumen[0].cantidadRiesgos);
                       }
                       
                       //se setean marcas
                       $scope.marcasRiesgo.audi=angular.isUndefined(response.data.dato[0].marcas[0])? null :response.data.dato[0].marcas[0].marca;
                       $scope.marcasRiesgo.chevrolet=angular.isUndefined(response.data.dato[0].marcas[1])? null :response.data.dato[0].marcas[1].marca;
                       $scope.marcasRiesgo.volvo=angular.isUndefined(response.data.dato[0].marcas[2])? null :response.data.dato[0].marcas[2].marca;
                       $scope.marcasRiesgo.mercedez=angular.isUndefined(response.data.dato[0].marcas[3])? null :response.data.dato[0].marcas[3].marca;
                       $scope.marcasRiesgo.minicooper= angular.isUndefined(response.data.dato[0].marcas[4])? null :  response.data.dato[0].marcas[4].marca;
                       //datos cobertura
                       $scope.coberturaCotizaciones=response.data.dato[0].coberturaPoliza;
                       for (var i=0; i<$scope.coberturaCotizaciones.length; i++) {
                            if ($scope.coberturaCotizaciones[i].etiqueta =='RC PERSONAS'){
                                 $scope.cobertura.persona=$scope.coberturaCotizaciones[i].importeCapital;
                            }else if($scope.coberturaCotizaciones[i].etiqueta =='RC MATERIALES'){
                                 $scope.cobertura.danhosMateriales=$scope.coberturaCotizaciones[i].importeCapital;
                            }else if($scope.coberturaCotizaciones[i].etiqueta =='OVP MUERTE'){
                                 $scope.cobertura.ovpMteOcupante=$scope.coberturaCotizaciones[i].importeCapital;
                            }else if($scope.coberturaCotizaciones[i].etiqueta =='OVP GTOS MED'){
                                 $scope.cobertura.ovpGtoMedOcupante=$scope.coberturaCotizaciones[i].importeCapital;
                            }
                        } 
                        
                            //se ubica los id de combos
                         $scope.promesaProducto.promise.then(
                              function(){
                                  var encontrado=false;
                                  if (response.data.dato[0].codigoProducto!=null)
                                  {
                                      for (var i=0; i<$scope.listaProductos.length;i++)
                                      {

                                          if ($scope.listaProductos[i].id==parseInt(response.data.dato[0].codigoProducto))
                                          {
                                              encontrado=true;
                                              break;
                                          }
                                      }
                                      if (!encontrado)
                                      {
                                          $scope.flota.producto=null;
                                      }
                                      else{
                                          $scope.flota.producto =parseInt(response.data.dato[0].codigoProducto);
                                      }

                                  }
                                  else
                                  {
                                      $scope.flota.producto=null;
                                  }


                              $scope.promesaProducto.promise.$$state.status=0;
                            }
                          );
                          $scope.flota.formaPago=parseInt(response.data.dato[0].codigoFraccionamiento);
                        if (!angular.isUndefined(sessionStorage.getItem("modificarTasa")) && sessionStorage.getItem("modificarTasa") !=null  ){
                            if (sessionStorage.getItem("modificarTasa")=="S")
                            {
                                $scope.flota.tasa=0;
                                $scope.observarTasa=true;
                            }
                            else
                            {
                                $scope.observarTasa=false;
                                $scope.flota.tasa=response.data.dato[0].tasa;
                            }
                            sessionStorage.removeItem("modificarTasa");
                        }
                        else
                        {
                            $scope.observarTasa=false;
                            $scope.flota.tasa=response.data.dato[0].tasa;
                        }

                                  
                        
                        
                          $scope.cargando=false;

                    }else{
                        
                        $scope.cargando=false;
                        $scope.recargar();
                        $scope.rowCollection=[];
                       
                         
                        $scope.listaProductos =[];
                        Message.error(response.data.mensaje);
                        $scope.flota.numeroCotizacion=null;
                    }

                }else{
                       
                       $scope.cargando=false;
                       Message.error(response.data.mensaje);
                       $scope.recargar();
                       
                }  
                     
                }).catch(function(response){                    
                    $scope.recargar();
                    $scope.cargando=false;
                    Message.error(response.data.mensaje);
                    
                });



                                
                            },
                            function(response){
                              $scope.cargando=false;
                                
                            }
                        );

             
         };
    }
            

        

   $scope.editRow = function(row) {
      sessionStorage.setItem('editar','S');
      sessionStorage.setItem('paginaRiesgoCotizador',$scope.pagina);
      $scope.setCotizacion();
      row.moneda =  $scope.flota.moneda;
      sessionStorage.setItem('objetoCotizacionEdit',JSON.stringify(row));
      $location.url($scope.pathAgregar);
   };

     $scope.recargar = function() {
            sessionStorage.removeItem('objetoCotizacion');
            sessionStorage.removeItem('objetoCotizacionEdit');
            sessionStorage.removeItem("cambio");
            $scope.eliminarPagina();
            if(typeof $routeParams.numeroCotizacion != "undefined"){
                $location.search('numeroCotizacion', undefined);
                $rootScope.numeroCotizacionRoot = undefined;
                $location.path('flota')

            }
            else
            {
                $route.reload();
            }

            //

        };

    $scope.incrementarCobertura=function (cobertura)
    {
        var montoActual= 0;
        if (cobertura.ETIQUETA==='RC PERSONAS')
        {
            montoActual=$scope.cobertura.persona;
            montoActual+=cobertura.INCREMENTO;
            $scope.cobertura.persona=montoActual;
            if (montoActual >= cobertura.CAPITAL_MAX)
            {
                $scope.cobertura.persona=cobertura.CAPITAL_MAX;
            }
            else
            {
                $scope.cobertura.persona=montoActual;
            }
        }
        else if (cobertura.ETIQUETA==='RC MATERIALES')
        {
            montoActual=$scope.cobertura.danhosMateriales;
            montoActual+=cobertura.INCREMENTO;
            $scope.cobertura.danhosMateriales=montoActual;
            if (montoActual >= cobertura.CAPITAL_MAX)
            {
                $scope.cobertura.danhosMateriales=cobertura.CAPITAL_MAX;
            }
            else
            {
                $scope.cobertura.danhosMateriales=montoActual;
            }
        }
        else if (cobertura.ETIQUETA==='OVP MUERTE')
        {
            montoActual=$scope.cobertura.ovpMteOcupante;
            montoActual+=cobertura.INCREMENTO;
            $scope.cobertura.ovpMteOcupante=montoActual;
            if (montoActual >= cobertura.CAPITAL_MAX)
            {
                $scope.cobertura.ovpMteOcupante=cobertura.CAPITAL_MAX;
            }
            else
            {
                $scope.cobertura.ovpMteOcupante=montoActual;
            }
        }
        else if (cobertura.ETIQUETA==='OVP GTOS MED')
        {
            montoActual=$scope.cobertura.ovpGtoMedOcupante;
            montoActual+=cobertura.INCREMENTO;
            $scope.cobertura.ovpGtoMedOcupante=montoActual;
            if (montoActual >= cobertura.CAPITAL_MAX)
            {
                $scope.cobertura.ovpGtoMedOcupante=cobertura.CAPITAL_MAX;
            }
            else
            {
                $scope.cobertura.ovpGtoMedOcupante=montoActual;
            }
        }
    };
    $scope.decrementarCobertura=function (cobertura)
    {
        var montoActual= 0;
        if (cobertura.ETIQUETA==='RC PERSONAS')
        {
            montoActual=$scope.cobertura.persona;
            montoActual-=cobertura.INCREMENTO;
            if (montoActual <= cobertura.CAPITAL_MIN)
            {
                $scope.cobertura.persona=cobertura.CAPITAL_MIN;
            }
            else
            {
                $scope.cobertura.persona=montoActual;
            }
        }
        else if (cobertura.ETIQUETA==='RC MATERIALES')
        {
            montoActual=$scope.cobertura.danhosMateriales;
            montoActual-=cobertura.INCREMENTO;
            if (montoActual <= cobertura.CAPITAL)
            {
                $scope.cobertura.danhosMateriales=cobertura.CAPITAL_MIN;
            }
            else
            {
                $scope.cobertura.danhosMateriales=montoActual;
            }
        }
        else if (cobertura.ETIQUETA==='OVP MUERTE')
        {
            montoActual=$scope.cobertura.ovpMteOcupante;
            montoActual-=cobertura.INCREMENTO;
            if (montoActual <= cobertura.CAPITAL_MIN)
            {
                $scope.cobertura.ovpMteOcupante=cobertura.CAPITAL_MIN;
            }
            else
            {
                $scope.cobertura.ovpMteOcupante=montoActual;
            }
        }
        else if (cobertura.ETIQUETA==='OVP GTOS MED')
        {
            montoActual=$scope.cobertura.ovpGtoMedOcupante;
            montoActual-=cobertura.INCREMENTO;
            if (montoActual <= cobertura.CAPITAL_MIN)
            {
                $scope.cobertura.ovpGtoMedOcupante=cobertura.CAPITAL_MIN;
            }
            else
            {
                $scope.cobertura.ovpGtoMedOcupante=montoActual;
            }

        }
    };
   $scope.verificarMontoCobertura=function (cobertura)
    {
        var montoActual= 0;
        $scope.flota.tasa=0;
        $scope.observarTasa=true;
        if (cobertura.ETIQUETA==='RC PERSONAS')
        {
            montoActual=$scope.cobertura.persona;
            if (montoActual >= cobertura.CAPITAL_MAX)
            {
                $scope.cobertura.persona=cobertura.CAPITAL_MAX;
            }
            else if(montoActual <= cobertura.CAPITAL_MIN)
            {
                $scope.cobertura.persona=cobertura.CAPITAL_MIN;
            }
            else
            {
                $scope.cobertura.persona=montoActual;
            }
        }
        else if (cobertura.ETIQUETA==='RC MATERIALES')
        {
            montoActual=$scope.cobertura.danhosMateriales;

            if (montoActual >= cobertura.CAPITAL_MAX)
            {
                $scope.cobertura.danhosMateriales=cobertura.CAPITAL_MAX;
            }
            else if (montoActual <= cobertura.CAPITAL_MIN)
            {
                $scope.cobertura.danhosMateriales=cobertura.CAPITAL_MIN;
            }
            else
            {
                $scope.cobertura.danhosMateriales=montoActual;
            }
        }
        else if (cobertura.ETIQUETA==='OVP MUERTE')
        {
            montoActual=$scope.cobertura.ovpMteOcupante;
            if (montoActual >= cobertura.CAPITAL_MAX)
            {
                $scope.cobertura.ovpMteOcupante=cobertura.CAPITAL_MAX;
            }
            else if (montoActual <= cobertura.CAPITAL_MIN)
            {
                $scope.cobertura.ovpMteOcupante=cobertura.CAPITAL_MIN;
            }
            else
            {
                $scope.cobertura.ovpMteOcupante=montoActual;
            }
        }
        else if (cobertura.ETIQUETA==='OVP GTOS MED')
        {
            montoActual=$scope.cobertura.ovpGtoMedOcupante;

            if (montoActual >= cobertura.CAPITAL_MAX)
            {
                $scope.cobertura.ovpGtoMedOcupante=cobertura.CAPITAL_MAX;
            }
            else if (montoActual <= cobertura.CAPITAL_MIN)
            {
                $scope.cobertura.ovpGtoMedOcupante=cobertura.CAPITAL_MIN;
            }
            else
            {
                $scope.cobertura.ovpGtoMedOcupante=montoActual;
            }
        }

    };

       $scope.irPropuesta=function (){
           $scope.pathPropuesta="/propuesta/propuesta-vehiculo/propuesta";
          
          $location.url($scope.pathPropuesta);
       };

        /**
         * Función creada para el salto de cotización a propuesta
         */
        $scope.goToPropuesta = function() {
            var path = $location.$$absUrl; 
            var n = path.search("module");
            var url =  path.substring(0 , n);
            
            if(typeof $scope.flota.numeroCotizacion != 'undefined' && $scope.flota.numeroCotizacion != null){
                location.href ='propuesta-flota/propuesta/'+$scope.flota.numeroCotizacion;
            }else{            
                Message.warning("Debe ingresar un número de cotización");
            }
        };

       $scope.cargarPlataforma = function(){

        var paramPla={};
        paramPla.numeroCotizacion=$scope.flota.numeroCotizacion;

        CotizacionVehiculoService.getPlataforma(paramPla).then(

                       
                        function (response) {
                          if(!response.data.error){
                             if(response.data.dato!=null  )  {
                                   
                                $scope.mostrarPlataforma=true;
                                 
                                   $scope.flota.plataforma=response.data.dato.mensaje;

                                
                            }

                          }
                     

                        }).catch(function(response){
                           
                            Message.error(response.data.mensaje);
                           
                        });
          };


          $scope.llamarModal = function(value) {

        if(!angular.isUndefined($scope.flota.numeroCotizacion)&& $scope.flota.numeroCotizacion!=null &&$scope.flota.numeroCotizacion!=""){ 
            $rootScope.numCotiza = $scope.flota.numeroCotizacion;
            $rootScope.autEsNuevo=$scope.flota.nuevo;
            $rootScope.modalCotizadorVehFlota=value;
            $rootScope.flagVehiculoFlota = false;
            $mdDialog.show({
                locals:{parent: $scope},   
                controller: 'ModalAutorizacionCtrl',
                templateUrl: 'partials/ventanas-emergentes/modal-autorizacion-partial.html',
                parent: angular.element(document.body),
                multiple: true,
                clickOutsideToClose:false,
                fullscreen: $scope.customFullscreen // Only for -xs, -sm breakpoints.
            }).then(function(answer) {
                 /*$scope.cargando=true;
                $scope.status = 'You said the information was "' + answer + '".';
                if (!angular.isUndefined(answer.numeroCotizacion) && answer.numeroCotizacion !="" && answer.numeroCotizacion!= null){
                    $scope.datosGenerales.numeroCotizacion = parseInt(answer.numeroCotizacion);
                }else{
                     Message.error("Numero de cotizacion inexistente");
                     return;
                }*/
               

                $scope.buscarCotizacion();


            }, function() {
                $scope.status = 'You cancelled the dialog.';
            });
           } 

        };

        $scope.verificarCamposForm=function(listaCampo, campo)
        {
            return UtilsService.verificarCamposForm(listaCampo, campo);
        };
        $scope.obtenerCamposEditables=function()
        {
            var marcaFlota="S";
            var params={};
            params.numeroCotizacion=angular.isUndefined($scope.flota.numeroCotizacion)|| $scope.flota.numeroCotizacion==null?"":$scope.flota.numeroCotizacion;
            params.numeroRiesgo="";
            params.marcaFlota=marcaFlota;
            params.pathModule=$scope.pathModule;
            $scope.camposEditablesList=[];
            FlotaService.getCamposEditables(params).then(function(response)
            {
                if (!response.data.error)
                {
                    if (response.data.dato.length>0)
                    {
                        var campos=response.data.dato;
                        for (var i=0; i< campos.length; i++)
                        {
                            $scope.camposEditablesList.push(campos[i]);
                        }
                    }

                }
                else
                {
                    Message.error(response.data.mensaje);
                }
            })
        };

        $scope.showAdvanced = function() {

          /* $rootScope.codCoti=$scope.datosGenerales.numeroCotizacion;
           $rootScope.monedaAbuscar=$scope.vehiculo.moneda;*/
            $rootScope.mostrarBuscadorCotizacion=false;
            $mdDialog.show({
                locals:{parent: $scope},   
                controller: 'BuscadorCotizacionCtrl',
                templateUrl: 'partials/ventanas-emergentes/buscador-cotizacion-partial.html',
                parent: angular.element(document.body),
                clickOutsideToClose:false,
                fullscreen: $scope.customFullscreen // Only for -xs, -sm breakpoints.
            }).then(function(answer) {
                 $scope.cargando=true;
                $scope.status = 'You said the information was "' + answer + '".';
                if (!angular.isUndefined(answer.numeroCotizacion) && answer.numeroCotizacion !="" && answer.numeroCotizacion!= null){
                    $scope.flota.numeroCotizacion = parseInt(answer.numeroCotizacion);
                }else{
                     Message.error("Numero de cotizacion inexistente");
                     return;
                }
               

                $scope.buscarCotizacion();


            }, function() {
                $scope.status = 'You cancelled the dialog.';
            });

        };
        $scope.verificarPagina = function () {
            if ($scope.pagina == 1) {
                $scope.anterior = true;
            } else {
                $scope.anterior = false;
            }
            if ($scope.pagina == $scope.cantidadPaginas) {
                $scope.siguiente = true;
            } else {
                $scope.siguiente = false;

            }


        };
        $scope.cambiarPagina = function (p) {
            if($scope.pagina!=p){
                $scope.pagina = p;
                $scope.cargarRiesgos();
            }
        };
        $scope.anteriorPagina = function () {
            if (!$scope.anterior) {
                if ($scope.pagina != 1) {
                    $scope.pagina--;
                }
                $scope.cargarRiesgos();
            }

        };
        $scope.siguientePagina = function () {
            if (!$scope.siguiente) {
                if ($scope.pagina != $scope.totalItems) {
                    $scope.pagina++;
                    $scope.cargarRiesgos();
                }
            }

        };
        $scope.eliminarPagina=function()
        {
            sessionStorage.removeItem("paginaRiesgoCotizador");
        };


       (function initialize() {
           $scope.pathModule = UtilsService.retornarPath($location.path().split("/")[1]);
           $scope.obtenerAutorizaciones();
           $scope.mostrardatos=true;
           $scope.obtenerCoberturas();
           $scope.path = "/" +$location.$$path.split("/")[1] + "/";
           $scope.cargarCombos();
           $scope.pathAgregar="/" +$location.$$path.split("/")[1] +"-agregar/";
           $scope.flagProducto=true;
           $scope.flagMoneda=false;
           $scope.formato = false;
           $scope.flagCotizacion = false;
           $scope.habilitaAgregar=true;
           $scope.controlRequerido = false;
           $rootScope.botonEliminar=undefined;
           sessionStorage.setItem("cambio", null);
           $scope.habilitarBtnIrPropuesta=false;
           $scope.limpiarTasa=true;
           //se inicializa a N para que al abrir sea siempre agregar y no editar
           sessionStorage.setItem('editar','N');
           //control para recargar datos, si ya se uso agregar
           if (!angular.isUndefined(sessionStorage.getItem("objetoCotizacion")) && sessionStorage.getItem("objetoCotizacion") !=null  ){

                var objeto = JSON.parse(sessionStorage.getItem("objetoCotizacion"));
                if (objeto.numeroCotizacion!=null){
                    $scope.flota.numeroCotizacion=parseInt(objeto.numeroCotizacion);
                    $scope.buscarCotizacion();
                }
                if (!angular.isUndefined(sessionStorage.getItem("paginaRiesgoCotizador")) && sessionStorage.getItem("paginaRiesgoCotizador") !=null)
                {
                    $scope.pagina=parseInt(sessionStorage.getItem("paginaRiesgoCotizador"));
                    $scope.eliminarPagina();
                }
                 $scope.flota.nuevo= objeto.nuevo;
                 $scope.flota.producto=objeto.producto;
                 $scope.observarTasa=false;
                 $scope.flota.tasa=objeto.tasa;

                 $scope.flota.cantRiesgo=objeto.cantRiesgo;
                 //$scope.flota.numeroPoliza=objeto.numeroPoliza;
                          
                //$scope.flota.numeroCotizacionAnt=objeto.numeroCotizacionAnt;
                 $scope.flota.formaPago=objeto.formaPago;
                 $scope.flota.moneda=objeto.moneda;
                 $scope.flota.sumaAsegurada=objeto.sumaAsegurada;
                 $scope.flota.notificacion=objeto.notificacion;
                 $scope.flota.notificacionDisabled=objeto.notificacionDisabled;
                 $scope.flota.cambio=objeto.cambio; 
                
                 //$scope.cargarRiesgos();
                $scope.flota.moneda =  objeto.moneda;
                sessionStorage.removeItem("objetoCotizacion");

           }

            /**
             * Verifica si la ventana fue llamada desde propuesta
             */
            else if(typeof $routeParams.numeroCotizacion != "undefined"){
                
                $rootScope.numeroCotizacionRoot = $routeParams.numeroCotizacion;
                $scope.flota.numeroCotizacion=$rootScope.numeroCotizacionRoot;
                $scope.buscarCotizacion();
               $scope.eliminarPagina();

            }else if(!angular.isUndefined($rootScope.numCotizacionBcp) && $rootScope.numCotizacionBcp!=null){
                //viene del bcp 
                $rootScope.numeroCotizacionRoot =  $rootScope.numCotizacionBcp;
                 $scope.flota.numeroCotizacion=$rootScope.numeroCotizacionRoot;
                $rootScope.numCotizacionBcp=undefined;
                $scope.buscarCotizacion();
                $scope.eliminarPagina();
            }
            else
           {
               $scope.obtenerCamposEditables();
               $scope.eliminarPagina();
           }

        })();

    }]);
;app.controller('LoginCtrl', ['$scope','$rootScope',  '$controller', '$routeParams', '$location', 'SessionService','$window',
    function ($scope,$rootScope, $controller, $routeParams, $location, SessionService, $window) {


    $rootScope.currentPath = $location.url();

    $scope.login = null;
    $window.sessionStorage.clear();

            $scope.mostrarMensaje = false;         

    $scope.ingresar = function(){
         $scope.mostrarMensaje = true;
        $scope.mensaje = "Comprobando..."
    	if ($scope.login != null && $scope.login.username != null && $scope.login.password != null){
    		SessionService.login($scope.login.username,$scope.login.password).then(function(response){
                //console.log("respuesta:" + JSON.stringify(response));
                //console.log($rootScope.isAuth);
                if (response.data.error){
                    $scope.mensaje = response.data.mensaje;


                }else if(!angular.isUndefined(response.data.dato) && response.data.dato != null){
                  $window.sessionStorage["token"] = response.data.dato.token;
                  $window.sessionStorage["codigoAgente"]=response.data.dato.codigoAgente;
                  $window.sessionStorage["rolesAsignados"] = ["rol_1", "rol_2"];
				  $window.sessionStorage["preferencia_marcas"]=angular.isUndefined(response.data.dato.marcaPreferenciaMarcas)?"S": response.data.dato.marcaPreferenciaMarcas;
				  $window.sessionStorage["preferencia_moneda"]=angular.isUndefined(response.data.dato.marcaPreferenciaMoneda)?"S": response.data.dato.marcaPreferenciaMoneda;
				  $window.sessionStorage["preferencia_fraccionamiento"]=angular.isUndefined(response.data.dato.marcaPreferenciaFraccionamiento)?"S": response.data.dato.marcaPreferenciaFraccionamiento;
				  $window.sessionStorage["preferencia_concesionarias"]=angular.isUndefined(response.data.dato.marcaPreferenciaConcesionarias)?"S": response.data.dato.marcaPreferenciaConcesionarias;
				  $window.sessionStorage["preferencia_forma_pago"]=angular.isUndefined(response.data.dato.marcaPreferenciaFormaPago )?"S": response.data.dato.marcaPreferenciaFormaPago;


                    $rootScope.isAuth = true;
				  sessionStorage.setItem("usuarioLogueado",angular.isUndefined(response.data.dato.codigoUsuario)?"undefined":response.data.dato.codigoUsuario);
				  sessionStorage.setItem("nombreUsuario",angular.isUndefined(response.data.dato.nombreUsuario)?"undefinde":response.data.dato.nombreUsuario);
				  sessionStorage.setItem("grupoUsuario", !angular.isUndefined(response.data.dato.idGrupo) && response.data.dato.idGrupo!=null?parseInt(response.data.dato.idGrupo):"");
				  sessionStorage.setItem("roles",angular.isUndefined(response.data.dato.roles)?"undefined":response.data.dato.roles);
				  $rootScope.$broadcast('set-user');
                   $rootScope.$broadcast('get-user');
                   $location.path("/dashboard");
                }else{
                    $scope.mensaje = response.data.mensaje;
                   //  $scope.mostrarMensaje = true;
                    
                }//refrescar en el dashboard los datos del usuario que se logea
				
                //console.log($rootScope.isAuth);
                
            });
        }
        
    },

    (function initialize() {
            $rootScope.isAuth = false;
        })();


}
]);
;app.controller('PreferenciaListCtrl', ['$scope','$rootScope',  '$controller', '$routeParams', '$location', 'SessionService','$window','utils','PreferenciaService','$log',
    function ($scope,$rootScope, $controller, $routeParams, $location, SessionService, $window, utils,PreferenciaService, $log) {
        $scope.list1 = []; //lista de marcas, usada por la directiva
        $scope.list2 = []; //lista de marcas seleccionadas por el usuario
        $scope.list3 = []; //lista de consecionarias, usada por la directiva
        $scope.list4 = []; //lista de consecionarias seleccionadas por el usuario
        $scope.marcasList = [];
        $scope.concesionariaList = [];
        $scope.fraccionamientoList = [];
        $scope.formasPagos = [];
        $scope.gestoresPagos=[];
        $scope.gestoresList = [];
        $scope.monedasList = [];
        $scope.preferencias = {};
        $scope.preferencias.conCarta = "N";
        $scope.preferencias.conPropuesta = "N";
        $scope.preferencias.formaPago = undefined;
        $scope.preferencias.gestor = undefined;
        $scope.preferencias.moneda = undefined;
        $scope.preferencias.fraccionamiento = undefined;
        $scope.codigoCampo = undefined;
        $scope.cargando = false;
        $scope.path = '/preferencia';

        $scope.gestoresPago = function () {
            PreferenciaService.getGestoresPago().then(function (response) {
                if (!response.data.error) {
                    //console.log(response.data.dato);
                    if (response.data.dato.length > 0) {

                        for (var i = 0; i < response.data.dato.length; i++) {
                            //console.log(response.data.dato[i]);
                            $scope.gestoresPagos.push(response.data.dato[i]);
                        }

                    }
                    else {
                        $log.debug("No hay nada");
                    }
                }
                else {
                    //mostrar error
                }
                //console.log($scope.formasPagos);
            })
        };
        /* $scope.$watch('preferencias.formaPago', function(NewValue, OldValue){
             if (!angular.isUndefined(NewValue))
             {
                 var params={};
                 params.codFormaPago=$scope.preferencias.formaPago;
                 PreferenciaService.getGestor(params).then(function(response)
                 {
                     if (!response.data.error)
                     {
                         if (response.data.dato !=null && response.data.dato.length>0)
                         {
                             for (var i=0; i< response.data.dato.length; i++)
                             {
                                 //console.log(response.data.dato[i]);
                                 $scope.gestoresList.push(response.data.dato[i]);
                             }
                             //console.log(response.data.dato);
                         }
                     }
                     else
                     {
                         //mostrar error
                     }
                 })
             }
             else
             {
                 $scope.preferencias.gestor=undefined;
             }
         });*/
        $scope.obtenerMarcas = function () {
            PreferenciaService.getMarcas().then(function (response) {
                if (!response.data.error) {
                    for (var i = 0; i < response.data.dato.length; i++) {
                        $scope.marcasList.push({
                            codigoId: response.data.dato[i].COD_MARCA,
                            nombre: response.data.dato[i].NOM_MARCA
                        });
                    }
                    //console.log(response.data.dato);
                    utils.insertData($scope.list1, $scope.marcasList.length, $scope.marcasList);
                    //console.log("Valor de list1", $scope.list1);
                }
                else {

                    //mostrar error
                }
            })
        };
        $scope.obtenerConcesionarias = function () {
            PreferenciaService.getConcesionaria().then(function (response) {
                if (!response.data.error) {
                    // console.log(response.data.dato);
                    for (var i = 0; i < response.data.dato.length; i++) {
                        $scope.concesionariaList.push({
                            codigoId: response.data.dato[i].DOCUMENTO,
                            nombre: response.data.dato[i].CONCESIONARIA
                        });
                    }
                    //console.log(response.data.dato);
                    utils.insertData($scope.list3, $scope.concesionariaList.length, $scope.concesionariaList);
                    //console.log("Valor de list3", $scope.list3);
                }
                else {
                    var mensaje = response.data.mensaje;
                    Message.error(mensaje);
                    //mostrar error
                }
            })
        };
        $scope.obtenerMonedas = function () {
            PreferenciaService.getMonedas().then(function (response) {
                if (!response.data.error) {
                    //console.log("Resultados monedas ", response.data.dato);
                    if (response.data.dato.length > 0) {
                        var result = response.data.dato;
                        for (var i = 0; i < result.length; i++) {
                            $scope.monedasList.push(result[i]);
                        }
                    }
                    else {
                        Message.error("No se encontraron las monedas");
                    }
                }
                else {
                    //mostrar error
                    var mensaje = response.data.mensaje;
                    Message.error(mensaje);
                }
            })
        };
        $scope.obtenerFraccionamiento = function () {
            PreferenciaService.getFraccionamiento().then(function (response) {
                if (!response.data.error) {

                    if (response.data.dato.length > 0) {
                        var result = response.data.dato;
                        for (var i = 0; i < result.length; i++) {
                            $scope.fraccionamientoList.push(result[i]);
                        }
                    }
                    else {
                        Message.error("No se encontraron los fraccionamientos");
                    }
                }
                else {
                    var mensaje = response.data.mensaje;
                    Message.error(mensaje);
                }
            })
        };
        $scope.guardarMarcas = function () {
            $scope.codigoCampo = "MARCA";
            $scope.listaMarcas = "";
            //console.log($scope.listas);
            //procedemos a ver la lista de marcas seleccionadas

            //var data= $scope.listas.getAllSelectMarcas();
            if ($scope.list2.length > 0) {
                $scope.listaMarcas += $scope.list2[0].codigoId;
                for (var i = 1; i < $scope.list2.length; i++) {
                    $scope.listaMarcas += ",";
                    $scope.listaMarcas += $scope.list2[i].codigoId;

                }
                $scope.cargando = true;
                //ahora hay que proceder a llamar
                var param = {};
                param.valorCampo = $scope.listaMarcas;

                PreferenciaService.guardarLista($scope.codigoCampo, param).then(function (response) {
                    $scope.cargando = false;
                    if (!response.data.error) {
                        Message.ok("La operacion se realizó con exito!");
                    }
                    else {
                        var mensaje = response.data.mensaje;
                        Message.error(mensaje);
                    }
                })
            }
            else {
                Message.error("No se puede guardar las marcas, debe seleccionar al menos uno!");
            }
        };
        $scope.guardarConcesionarias = function () {
            $scope.codigoCampo = "CONCESIONARIAS";
            $scope.listaConcesionarias = "";
            //procedemos a ver la lista de marcas seleccionadas
            if ($scope.list4.length > 0) {
                $scope.listaConcesionarias += $scope.list4[0].codigoId;
                for (var i = 1; i < $scope.list4.length; i++) {
                    $scope.listaConcesionarias += ",";
                    $scope.listaConcesionarias += $scope.list4[i].codigoId;

                }
                //ahora hay que proceder a llamar
                $scope.cargando = true;
                var param = {};
                param.valorCampo = $scope.listaConcesionarias;
                PreferenciaService.guardarLista($scope.codigoCampo, param).then(function (response) {
                    $scope.cargando = false;
                    if (!response.data.error) {
                        Message.ok("La operacion se realizó con exito!");
                    }
                    else {
                        var mensaje = response.data.mensaje;
                        Message.error(mensaje);
                    }
                })
            }
            else {
                Message.error("No se puede guardar las marcas, debe seleccionar al menos uno!");
            }
        };
        $scope.enviarCarta = function () {
            $scope.codigoCampo = "CARTA_OFERTA_MAIL";
            var param = {};
            param.valorCampo = $scope.preferencias.conCarta;
            $scope.cargando = true;
            PreferenciaService.guardarPreferencia($scope.codigoCampo, param).then(function (response) {
                $scope.cargando = false;
                if (response.data.error) {
                    var mensaje = response.data.mensaje;
                    Message.error(mensaje);
                }

            })
        };
        $scope.enviarPropuesta = function () {
            $scope.codigoCampo = "PROPUESTA_MAIL";
            var param = {};
            param.valorCampo = $scope.preferencias.conPropuesta;
            $scope.cargando = true;
            PreferenciaService.guardarPreferencia($scope.codigoCampo, param).then(function (response) {
                $scope.cargando = false;
                if (response.data.error) {
                    var mensaje = response.data.mensaje;
                    Message.error(mensaje);
                }

            })
        };

        $scope.guardarMoneda = function () {
            $scope.codigoCampo = "MONEDA";
            var param = {};
            param.valorCampo = $scope.preferencias.moneda;
            $scope.cargando = true;
            PreferenciaService.guardarPreferencia($scope.codigoCampo, param).then(function (response) {
                $scope.cargando = false;
                if (!response.data.error) {
                    Message.ok("La operacion se realizó con exito!");
                }
                else {
                    var mensaje = response.data.mensaje;
                    Message.error(mensaje);
                }
            })
        };
        $scope.guardarFraccionamiento = function () {
            $scope.codigoCampo = "FRACCIONAMIENTO";
            var param = {};
            param.valorCampo = $scope.preferencias.fraccionamiento;
            $scope.cargando = true;
            PreferenciaService.guardarPreferencia($scope.codigoCampo, param).then(function (response) {
                $scope.cargando = false;
                if (!response.data.error) {
                    Message.ok("La operacion se realizó con exito!");
                }
                else {
                    var mensaje = response.data.mensaje;
                    Message.error(mensaje);
                }
            })
        };
        $scope.guardarGestor = function () {
            $scope.codigoCampo = "TIPO_GESTOR";
            var param = {};
            param.valorCampo = $scope.preferencias.gestor;
            $scope.cargando = true;
            PreferenciaService.guardarPreferencia($scope.codigoCampo, param).then(function (response) {
                $scope.cargando = false;
                if (!response.data.error) {
                    Message.ok("La operacion se realizó con exito!");
                }
                else {
                    var mensaje = response.data.mensaje;
                    Message.error(mensaje);
                }
            })
        };
        $scope.guardarFormaPago = function () {
            $scope.codigoCampo = "FORMA_PAGO";
            var param = {};
            param.valorCampo = $scope.preferencias.formaPago;
            $scope.cargando = true;
            PreferenciaService.guardarPreferencia($scope.codigoCampo, param).then(function (response) {
                $scope.cargando = false;
                if (!response.data.error) {
                    Message.ok("La operacion se realizó con exito!");
                }
                else {
                    var mensaje = response.data.mensaje;
                    Message.error(mensaje);
                }
            })
        };
        $scope.obtenerMarcasSeleccionadas = function () {
            $scope.tipoCampo = "MARCA";
            PreferenciaService.getPreferencias($scope.tipoCampo).then(function (response) {
                var marcasSelect = [];
                if (!response.data.error) {
                    if (response.data.dato.length > 0) {
                        for (var i = 0; i < response.data.dato.length; i++) {
                            marcasSelect.push({
                                codigoId: response.data.dato[i].COD_MARCA,
                                nombre: response.data.dato[i].NOM_MARCA
                            });
                        }
                        utils.insertData($scope.list2, marcasSelect.length, marcasSelect);
                        //ahora procedemos a borrar de la lista de marcas, lo que ya estan seleccionados
                        for (var i = 0; i < $scope.list2.length; i++) {
                            for (var j = 0; j < $scope.list1.length; j++) {
                                if ($scope.list2[i].codigoId == $scope.list1[j].codigoId) {
                                    $scope.list1.splice(j, 1);
                                }
                            }
                        }

                    }


                }
                else {
                    var mensaje = response.data.mensaje;
                    Message.error(mensaje);
                }
            })
        };
        $scope.obtenerMonedaSeleccionada = function () {
            $scope.tipoCampo = "MONEDA";
            PreferenciaService.getPreferencias($scope.tipoCampo).then(function (response) {
                if (!response.data.error) {
                    if (response.data.dato.length > 0) {
                        $scope.preferencias.moneda = response.data.dato[0].COD_MON;
                    }

                }
                else {
                    var mensaje = response.data.mensaje;
                    Message.error(mensaje);
                }
            })
        };
        $scope.obtenerCartaOfertaSeleccionada = function () {
            $scope.tipoCampo = "CARTA_OFERTA_MAIL";
            PreferenciaService.getPreferencias($scope.tipoCampo).then(function (response) {
                if (!response.data.error) {
                    if (response.data.dato.length > 0) {
                        if (response.data.dato[0].VAL_CAMPO == 'S') {
                            $scope.preferencias.conCarta = 'S';
                        }
                        else {
                            $scope.preferencias.conCarta = 'N';
                        }
                    }
                    else {
                        $scope.preferencias.conCarta = 'N';
                    }
                }
                else {
                    var mensaje = response.data.mensaje;
                    Message.error(mensaje);
                }
            })
        };
        $scope.obtenerPropuestaSeleccionada = function () {
            $scope.tipoCampo = "PROPUESTA_MAIL";
            PreferenciaService.getPreferencias($scope.tipoCampo).then(function (response) {
                if (!response.data.error) {
                    if (response.data.dato.length > 0) {
                        if (response.data.dato[0].VAL_CAMPO == 'S') {
                            $scope.preferencias.conPropuesta = 'S';
                        }
                        else {
                            $scope.preferencias.conPropuesta = 'N';
                        }
                    }
                    else {
                        $scope.preferencias.conPropuesta = 'N';
                    }
                }
                else {
                    var mensaje = response.data.mensaje;
                    Message.error(mensaje);
                }
            })
        };
        $scope.obtenerFraccionamientoSeleccionado = function () {
            $scope.tipoCampo = "FRACCIONAMIENTO";
            PreferenciaService.getPreferencias($scope.tipoCampo).then(function (response) {
                if (!response.data.error) {
                    if (response.data.dato.length > 0) {
                        $scope.preferencias.fraccionamiento = response.data.dato[0].COD_FRACC_PAGO;
                    }

                }
                else {
                    var mensaje = response.data.mensaje;
                    Message.error(mensaje);
                }
            })
        };
        $scope.obtenerGestorSeleccionado = function () {
            $scope.tipoCampo = "TIPO_GESTOR";
            PreferenciaService.getPreferencias($scope.tipoCampo).then(function (response) {
                if (!response.data.error) {
                    if (response.data.dato.length > 0) {
                        $scope.preferencias.gestor = response.data.dato[0].TIP_GESTOR;
                    }

                }
                else {
                    var mensaje = response.data.mensaje;
                    Message.error(mensaje);
                }
            })
        };
        $scope.obtenerConcesionariasSeleccionadas = function () {
            $scope.tipoCampo = "CONCESIONARIAS";
            PreferenciaService.getPreferencias($scope.tipoCampo).then(function (response) {
                var concesionariaSelect = [];
                if (!response.data.error) {
                    if (response.data.dato.length > 0) {
                        for (var i = 0; i < response.data.dato.length; i++) {
                            concesionariaSelect.push({
                                codigoId: response.data.dato[i].DOCUMENTO,
                                nombre: response.data.dato[i].CONCESIONARIA
                            });
                        }
                        utils.insertData($scope.list4, concesionariaSelect.length, concesionariaSelect);
                        //ahora procedemos a borrar de la lista de concesionarias, las que ya estan seleccionadas
                        for (var i = 0; i < $scope.list4.length; i++) {
                            for (var j = 0; j < $scope.list3.length; j++) {
                                if ($scope.list4[i].codigoId == $scope.list3[j].codigoId) {
                                    $scope.list3.splice(j, 1);
                                }
                            }
                        }

                    }


                }
                else {
                    var mensaje = response.data.mensaje;
                    Message.error(mensaje);
                }
            })
        };
        $scope.obtenerFormasPagos=function()
        {
            PreferenciaService.getFormasPago().then(function (response) {
                if (!response.data.error) {
                    //console.log(response.data.dato);
                    if (response.data.dato.length > 0) {

                        for (var i = 0; i < response.data.dato.length; i++) {
                            //console.log(response.data.dato[i]);
                            $scope.formasPagos.push(response.data.dato[i]);
                        }

                    }
                    else {
                        $log.debug("No hay nada");
                    }
                }
                else {
                    //mostrar error
                }
                //console.log($scope.formasPagos);
            })
        };
        $scope.obtenerFormaPagoSeleccionado=function()
        {
            $scope.tipoCampo = "FORMA_PAGO";
            PreferenciaService.getPreferencias($scope.tipoCampo).then(function (response) {
                if (!response.data.error) {
                    if (response.data.dato.length > 0) {
                        $scope.preferencias.formaPago = response.data.dato[0].COD_FORMA_PAGO;
                    }
                }
                else {
                    var mensaje = response.data.mensaje;
                    Message.error(mensaje);
                }
            })
        };
        $scope.changeColor=function(marca)
        {
            return marca.active ? "green" : "white";
        };
        (function initialize() {
            $scope.gestoresPago();
            $scope.obtenerMarcas();
            $scope.obtenerConcesionarias();
            $scope.obtenerMonedas();
            $scope.obtenerFraccionamiento();
            $scope.obtenerFormasPagos();
            $scope.obtenerMarcasSeleccionadas();
            $scope.obtenerMonedaSeleccionada();
            $scope.obtenerCartaOfertaSeleccionada();
            $scope.obtenerPropuestaSeleccionada();
            $scope.obtenerFraccionamientoSeleccionado()
            $scope.obtenerGestorSeleccionado();
            $scope.obtenerConcesionariasSeleccionadas();
            $scope.obtenerFormaPagoSeleccionado();

        })()
    }
]);
;app.controller('AseguradoFlotaFormCtrl', ['$scope', '$q', '$controller', '$routeParams', '$location', 'SessionService', '$rootScope','$route', '$mdDialog', '$filter', 'ConfirmService', '$window', 'AseguradoService','CotizacionVehiculoPropuestaService', 'UtilsService','PropuestaService',
    function ($scope,$q, $controller, $routeParams, $location, sessionService, $rootScope,$route, $mdDialog,  $filter, confirmService, $window, AseguradoService,CotizacionVehiculoPropuestaService, UtilsService, PropuestaService) {

        
        $scope.controlPermisos = true;
        $rootScope.rootPathParent =$route.current.$$route.originalPath;
        $scope.nombre = "Lista de asegurados";

        $scope.subtipo = $route.current.$$route.subtipo;
        $scope.cargando=false;
        $scope.prop={};
        $scope.prop.plataforma=null;
        $scope.service = PropuestaService;
        $scope.pagina=1;
        $scope.cantidadPaginas=1;

        $scope.verificarCamposForm=function(listaCampo, campo)
        {
            return UtilsService.verificarCamposForm(listaCampo, campo);
        };
      $scope.cargarPlataforma = function(){

        var paramPla={};
        paramPla.numeroCotizacion=$scope.numeroCotizacionRoot;
        paramPla.marcaFlota=$scope.subtipo=='Flota'?'S':'N';
        paramPla.pathModule=$scope.pathModule;
        CotizacionVehiculoPropuestaService.getPlataforma(paramPla).then(

                       
                        function (response) {
                          if(!response.data.error){
                             if(response.data.dato!=null  )  {
                                   
                                $scope.mostrarPlataforma=true;
                                 
                                   //$scope.plataforma=response.data.dato.mensaje;
                                   $scope.prop.plataforma=response.data.dato.mensaje;
                                  

                                
                            }

                          }
                     

                        }).catch(function(response){
                           
                            Message.error(response.data.mensaje);
                           
                        });
          };

        $scope.obtenerListaAsegurados = function(){

            var param = {};
            param.numeroCotizacion=$scope.numeroCotizacionRoot;
            param.numeroPagina=$scope.pagina;
            $scope.cargando=true;
            $scope.numeroCotizacion=$scope.numeroCotizacionRoot;
        	AseguradoService.obtenerListaAsegurados(param).then(function(response){
                    if(!response.data.error){

                        $scope.cargarPlataforma();
                        if (response.data.dato!=null)
                        {
                            $scope.listaAsegurados = response.data.dato.lista;
                            $scope.rowCollection = $scope.listaAsegurados;
                            $scope.totalItems = response.data.dato.totalDatos;
                            $scope.pagina = response.data.dato.paginado;
                            var restoPaginas=$scope.totalItems % $scope.itemsByPage;
                            var totalPaginas=parseInt($scope.totalItems /$scope.itemsByPage);
                            $scope.cantidadPaginas = totalPaginas==0?1:totalPaginas+(restoPaginas>0?1:0);
                            $scope.verificarPagina();
                        }

                        $scope.cargando=false;
                    }else{
                        ;
                        $scope.cargando=false;
                    }
        		
        	}, function(response){
                $scope.cargando=false;

        	});
        };

        $scope.editRow = function(row, pagina){

            $rootScope.aseguradoTipoDocumento=row.TIP_DOCUM;
            $rootScope.aseguradoCodigoDocumento=row.COD_DOCUM;
            sessionStorage.setItem("paginaAsegurado", $scope.pagina);
            //console.log(row);
            $window.sessionStorage["editar"] = row.NUM_RIESGO;
            $window.sessionStorage["metodo"] = "edicion";
        	$location.url($scope.pathAgregar);
        };

         $scope.eliminar = function(row){

             var confirm = confirmService.showConfirm('¿Está seguro de eliminar asegurado?')

                        .then(function(answer) {
                            var param = {}; 
                            param.numeroCotizacion = $scope.numeroCotizacionRoot;
							param.tipoDocumento=row.TIP_DOCUM;
							param.codigoDocumento=row.COD_DOCUM;
                            param.marcaModulo = $scope.pathModule.split("marcaModulo=")[1];
                            AseguradoService.eliminarAsegurado(param)
                            .then(function (data) {
                                if (!data.data.error)
                                {
                                    Message.ok(data.data.mensaje);
                                    $scope.obtenerListaAsegurados();
                                }
                                else
                                {
                                    Message.error(data.data.mensaje);
                                }
                               

                            }).catch(function (data, code) {
                            Message.error(data.data.mensaje);
                        });
                            

                        }, function() {
                            return;
                        });
        
          
        };


        $scope.agregar = function(row){
             $rootScope.aseguradoTipoDocumento=null;
            $rootScope.aseguradoCodigoDocumento=null;
            //console.log(row);
            $window.sessionStorage["metodo"] = "crear";
            $location.url($scope.pathAgregar);
        };
        /**
         * Función creada para el salto de propuesta a cotizacion
         */
        $scope.goToCotizacion = function() {
            var path = $location.$$absUrl;
            var n = path.search("module");
            var url =  path.substring(0 , n);

            if(typeof $scope.numeroCotizacionRoot != 'undefined' && $scope.numeroCotizacionRoot != null){
                var subtipo = 'flota';
                if ($scope.subtipo == 'Vehiculos'){
                    subtipo = 'cotizacion-vehiculo';


                }
                location.href =subtipo+'/'+$scope.numeroCotizacionRoot;

            }
            else
            {
                Message.warning("Debe ingresar un número de cotización");
            }
        };
        $scope.verificarPagina = function () {
            if ($scope.pagina == 1) {
                $scope.anterior = true;
            } else {
                $scope.anterior = false;
            }
            if ($scope.pagina == $scope.cantidadPaginas) {
                $scope.siguiente = true;
            } else {
                $scope.siguiente = false;

            }


        };
        $scope.cambiarPagina = function (p) {
            if($scope.pagina!=p){
                $scope.pagina = p;
                $scope.obtenerListaAsegurados();
            }
        };
        $scope.anteriorPagina = function () {
            if (!$scope.anterior) {
                if ($scope.pagina != 1) {
                    $scope.pagina--;
                }
                $scope.obtenerListaAsegurados();
            }

        };
        $scope.siguientePagina = function () {
            if (!$scope.siguiente) {
                if ($scope.pagina != $scope.totalItems) {
                    $scope.pagina++;
                    $scope.obtenerListaAsegurados();
                }
            }

        };
        $scope.eliminarPagina=function()
        {
            sessionStorage.removeItem("paginaAsegurado");
        };

  

        (function initialize() {
            $rootScope.currentPage = 'sin-acciones';
            $rootScope.tabs = AseguradoService.getTabInicial();
        	$scope.pathAgregar="/" +$location.$$path.split("/")[1] +"/asegurado-agregar";
        	//obtenerListaAsegurados();
            $scope.pathModule = UtilsService.retornarPath($location.path().split("/")[1]);
        	$scope.rowCollection = [];
            $scope.itemsByPage =5;

             if (!angular.isUndefined($scope.numeroCotizacionRoot) && $scope.numeroCotizacionRoot!= null && $scope.numeroCotizacionRoot!=""){
                 
                var param ={};
                param.numeroCotizacion=$scope.numeroCotizacionRoot;  
                param.marcaFlota=$scope.subtipo=='Flota'?'S':'N';
                param.pathModule=$scope.pathModule;
                param.tab="ASEGURADO";
                AseguradoService.getTabs(param);
                 if (!angular.isUndefined(sessionStorage.getItem("paginaAsegurado")) && sessionStorage.getItem("paginaAsegurado") !=null)
                 {
                     $scope.pagina=parseInt(sessionStorage.getItem("paginaAsegurado"));
                     $scope.eliminarPagina();
                 }

             $scope.obtenerListaAsegurados();
             if ($window.sessionStorage["rolesAsignados"]!=undefined && $window.sessionStorage["rolesAsignados"]!=null){
                var listaRoles = $window.sessionStorage["rolesAsignados"].split(",");
                $scope.controlPermisos = listaRoles.indexOf("rol_1")>-1? true:false;
            }
          }else{
            AseguradoService.goToPropuestaOrigen($scope.pathModule.split("marcaModulo=")[1]);
          }

        })();


    }]);
;app.controller('DocumentosFormCtrl', ['$scope', '$q', '$controller', '$routeParams', '$location', 'SessionService', '$rootScope','$route', '$mdDialog', '$filter','DocumentosService', 'ConfirmService', '$window','Upload','PropuestaService','CotizacionVehiculoPropuestaService','UtilsService','$log',
    function ($scope,$q, $controller, $routeParams, $location, sessionService, $rootScope,$route, $mdDialog,  $filter, DocumentosService, confirmService, $window, Upload, PropuestaService,CotizacionVehiculoPropuestaService, UtilsService, $log)
    {
        $scope.service = PropuestaService;
        $scope.subtipo = $route.current.$$route.subtipo;
        $scope.habilitarCargaTomador = false;
        $scope.showTomador = false;
        $scope.showCotProp = false;
        $scope.cargando=false;
        $scope.cargaTomador = false;
        $scope.cargaCotPro = false;
        $rootScope.rootPathParent =$route.current.$$route.originalPath;
        $scope.listaDocumentosCotizacionPropuesta=[];
        $scope.listaDocumentosTomadorAsegurado = [];
        $rootScope.listaDocumentosCotizacionPropuestaTemp = [];
        $rootScope.listaDocumentosTomadorAseguradoTemp = [];
        
        $scope.documento={};
        $scope.documento.plataforma=null;



        if ($scope.subtipo=="Vehiculos")
        {
            $scope.path="propuesta-vehiculo/documentos";
        }
        
         else if($scope.subtipo=="Flota")
        {   $scope.path="propuesta-flota/documentos";
        }
        else if ($scope.subtipo=="Propuesta Hogar"){
            $scope.path="propuesta-hogar/documentos";
        }


        $scope.verificarCamposForm=function(listaCampo, campo)
        {
            //console.log("LISTA: " + listaCampo);
            return UtilsService.verificarCamposForm(listaCampo, campo);
        };

        $scope.obtenerDocumentosCotizacionPropuesta = function () {
            $scope.cargarPlataforma();
           
            if(typeof $scope.numeroCotizacionRoot != 'undefined' && $scope.numeroCotizacionRoot != null){               
                $scope.cargando=true;
                $scope.cargaCotPro = false;  
                DocumentosService.obtenerDocumentosCotizacionPropuesta($scope.numeroCotizacionRoot, $scope.pathModule ).then(function(response){
                    $scope.listaDocumentosCotizacionPropuestaTemp = response.data.dato;
                    if(typeof $scope.listaDocumentosCotizacionPropuestaTemp != 'undefined' &&  $scope.listaDocumentosCotizacionPropuestaTemp != null && $scope.listaDocumentosCotizacionPropuestaTemp.length > 0){
                        
                    for(var doc in $scope.listaDocumentosCotizacionPropuestaTemp){
                        DocumentosService.descargarCotProp($scope.numeroCotizacionRoot, $scope.listaDocumentosCotizacionPropuestaTemp[doc].NUM_ITEM, doc , $scope.listaDocumentosCotizacionPropuestaTemp[doc]) ;
                        /* DocumentosService.descargarCotProp($scope.numeroCotizacionRoot, $scope.listaDocumentosCotizacionPropuestaTemp[doc].NUM_ITEM, doc).then(function(response){ 
                            $scope.listaDocumentosCotizacionPropuestaTemp[doc].BASE64 = "data:image/png;base64," +response.data ; 
                        }, function(response){
                            Message.error("No se pudo desplegar la imagen");
                        }); */
                    }
                    $scope.listaDocumentosCotizacionPropuesta = $scope.listaDocumentosCotizacionPropuestaTemp;
                        $scope.showCotProp = true;
                        $scope.cargando=false;
                    }else{
                        $scope.showCotProp = false;
                        $scope.cargando=false;

                    }
                    $scope.cargaCotPro = true;
                    $scope.verificarCarga();

                }, function(response){
                    $scope.cargaCotPro = true;
                    $scope.verificarCarga();
                    Message.error("No se pudo obtener los documentos de Cotización/Propuesta");
                });
            }
        };
        
        $scope.obtenerTomador= function () {
            if(typeof $scope.numeroCotizacionRoot != 'undefined' && $scope.numeroCotizacionRoot != null){    
                DocumentosService.obtenerTomador($scope.numeroCotizacionRoot, $scope.pathModule  ).then(function(response){
                    if (response.data.dato!=null)
                    {
                        $scope.datosTomador = response.data.dato;
                        if( $scope.datosTomador.tipoDocumento != null && $scope.datosTomador.tipoDocumento != ""){
                            $scope.obtenerDocumentosTomadorAsegurado();
                            $scope.habilitarCargaTomador = true;
                        }else{
                            $scope.cargaTomador = true;
                            $scope.verificarCarga();
                        }

                    }
                    else
                    {
                        Message.warning("No se encontraron los datos del Tomador");
                        $scope.habilitarCargaTomador = false;
                        $scope.cargando=false;
                    }

                }, function(response){
                    $scope.cargaTomador = true;
                    $scope.verificarCarga();
                    Message.error("No se pudo obtener los datos del Tomador");
                });
            }
        };

        $scope.obtenerDocumentosTomadorAsegurado= function () {
            $scope.cargaTomador = false;               
            $scope.cargando=true;
            DocumentosService.obtenerDocumentosTomadorAsegurado($scope.datosTomador.tipoDocumento, $scope.datosTomador.codigoDocumento,  $scope.pathModule).then(function(response){
                $scope.listaDocumentosTomadorAseguradoTemp = response.data.dato; 
                if(typeof $scope.listaDocumentosTomadorAseguradoTemp != 'undefined' && $scope.listaDocumentosTomadorAseguradoTemp != null && $scope.listaDocumentosTomadorAseguradoTemp.length > 0){
                    $scope.showTomador = true;
                    $scope.habilitarCargaTomador = true;
                    for(var docTom in $scope.listaDocumentosTomadorAseguradoTemp){
                        DocumentosService.descargarTomador($scope.datosTomador.tipoDocumento, $scope.datosTomador.codigoDocumento, $scope.listaDocumentosTomadorAseguradoTemp[docTom].NUM_ITEM, docTom , $scope.listaDocumentosTomadorAseguradoTemp[docTom]) ;
                        
                        /* DocumentosService.descargarTomador($scope.datosTomador.TIP_DOCUM, $scope.datosTomador.COD_DOCUM, $scope.listaDocumentosTomadorAseguradoTemp[docTom].NUM_ITEM).then(function(response){ 
                            $scope.listaDocumentosTomadorAseguradoTemp[docTom].BASE64 = "data:image/png;base64," +response.data; 
                        }, function(response){
                            Message.error("No se pudo desplegar la imagen");
                        }); */
                    }
                    $scope.listaDocumentosTomadorAsegurado = $scope.listaDocumentosTomadorAseguradoTemp;
                    $scope.cargando=false;
                    
                }else{
                    $scope.showTomador = false;
                    $scope.cargando=false;
                }
                $scope.cargaTomador = true;
                $scope.verificarCarga();
            }, function(response){
                $scope.cargaTomador = true;
                $scope.verificarCarga();
                Message.error("No se pudo obtener los documentos de Cotización/Propuesta");
            });
        };
        
        $scope.listarTipoDocumentos= function () { 
            var param = {};
            param.pathModule =$scope.pathModule; 
            DocumentosService.listarTipoDocumentos(param).then(function(response){
                $scope.listaTipoDocumentos = response.data.dato;    
            }, function(response){
                Message.error("No se pudo obtener la lista de los tipos de documentos");

            });
        };
        
        $scope.cargarPlataforma = function() {
            var paramPla = {};
            paramPla.numeroCotizacion = $scope.numeroCotizacionRoot;
            paramPla.marcaFlota = $scope.subtipo == 'Flota' ? 'S' : 'N';
            paramPla.pathModule =$scope.pathModule;
            CotizacionVehiculoPropuestaService.getPlataforma(paramPla).then(
                function(response) {
                    if (!response.data.error) {
                        if (response.data.dato != null) {
                            $scope.mostrarPlataforma = true;
                            $scope.documento.plataforma = response.data.dato.mensaje;
                        }
                    }        
                }).catch(function(response) {
                Message.error(response.data.mensaje);
            });
        };
        /**
         * UPLOAD DE ARCHIVOS PARA COTIZACION / PROPUESTA
         */
        $scope.$watch('fileCotizador', function() {
            var file = $scope.fileCotizador;
            if (!file) {
              return;
            }
            
            if($scope.tipoDocumento != null && typeof $scope.tipoDocumento != 'undefined'){
                if($scope.numeroCotizacionRoot != null && typeof $scope.numeroCotizacionRoot != 'undefined'){                    
                    Upload.upload({
                        url: App.URL_BASE+ 'documentos/propuesta/subiradjunto?numeroPropuesta=0&numeroCotizacion='+ $scope.numeroCotizacionRoot+'&tipoDocumento='+$scope.tipoDocumento+'&'+$scope.pathModule,
                        file: file
                    }).success(function(data, status, headers, config) {
                        var param ={};
                        param.numeroCotizacion=$scope.numeroCotizacionRoot;  
                        param.marcaFlota=$scope.subtipo=='Flota'?'S':'N';
                        param.pathModule=$scope.pathModule;
                        DocumentosService.getTabs(param);
                        $scope.obtenerDocumentosCotizacionPropuesta();
                        $scope.tipoDocumento = null;

                    }).error(function(data, status, headers, config) {
                        Message.error("Error al subir el archivo");
                    })
                }else{
                    Message.warning("Debe seleccionar un numero de cotización para continuar");
                }
            }else{
                Message.warning("Debe seleccionar un tipo de documento");
            }
          });

        /**
         * UPLOAD DE ARCHIVOS PARA TOMADOR
         */
        $scope.$watch('file', function() {
            var file = $scope.file;
            if (!file) {
              return;
            }
            
            if($scope.habilitarCargaTomador){
                Upload.upload({
                  url: App.URL_BASE+ 'documentos/terceros/subiradjunto?tipoDocumento='+$scope.datosTomador.tipoDocumento+'&codigoDocumento='+$scope.datosTomador.codigoDocumento,
                  file: file
                }).success(function(data, status, headers, config) {
                    $scope.obtenerDocumentosTomadorAsegurado();


                }).error(function(data, status, headers, config) {
                    Message.error("Error al subir el archivo");
                })
            }else{
                Message.warning("No se cuentan con datos del tomador");
            }
          });

        
        
        $scope.descargarCotProp= function (file) {  
            
            download("data:application/octet-stream;base64,"+file.BASE64.substring(22, file.BASE64.lenght), file.NOM_FICHERO , "application/octet-stream;base64"); 
            /* console.log($rootScope.listaDocumentosCotizacionPropuestaTemp);
            DocumentosService.descargarCotProp($scope.numeroCotizacionRoot, item).then(function(response){
            }, function(response){
                Message.error("No se pudo obtener la lista de los tipos de documentos");
            }); */
        };
        
        $scope.descargarTomador= function (file) { 
            
            download("data:application/octet-stream;base64,"+file.BASE64.substring(22, file.BASE64.lenght), file.NOM_FICHERO , "application/octet-stream;base64"); 
            /* DocumentosService.descargarTomador($scope.datosTomador.TIP_DOCUM, $scope.datosTomador.COD_DOCUM, item).then(function(response){ 
                download("data:application/octet-stream;base64,"+file.BASE64, file.NOM_FICHERO , "application/octet-stream;base64"); 
            }, function(response){
                Message.error("No se pudo obtener la lista de los tipos de documentos");
            }); */
        };
        //    download("data:application/octet-stream;base64,YOUR BASE64URL", "dlDataUrlText.jpeg", "application/octet-stream;base64");
        
        $scope.verificarCarga = function(){                
            $scope.cargando=true;
            if($scope.cargaTomador && $scope.cargaCotPro){                
                $scope.cargando=false;
            }
            else
            {
                $scope.cargando=false;
            }
        };
        /**
         * Función creada para el salto de propuesta a cotizacion
         */
        $scope.goToCotizacion = function() {
            var path = $location.$$absUrl;
            var n = path.search("module");
            var url =  path.substring(0 , n);

            if(typeof $scope.numeroCotizacionRoot != 'undefined' && $scope.numeroCotizacionRoot != null){
                var subtipo = 'flota';
                if ($scope.subtipo == 'Vehiculos'){
                    subtipo = 'cotizacion-vehiculo';


                 }else if ($scope.subtipo== 'Flota'){
                          subtipo = 'flota';
                }else if ($scope.subtipo== 'Propuesta Hogar'){
                           subtipo = 'cotizacion-hogar';
                }
                location.href =subtipo+'/'+$scope.numeroCotizacionRoot;

            }
            else
            {
                Message.warning("Debe ingresar un número de cotización");
            }
        };

        $scope.mostrarArchivo = function(file){  
            if(typeof file != 'undefined'){   
                if (file.NOM_FICHERO.toLowerCase().indexOf("png")!=-1 || file.NOM_FICHERO.toLowerCase().indexOf("jpg")!=-1 || file.NOM_FICHERO.toLowerCase().indexOf("tif")!=-1 )
                    {
                        return true;
                    }
                    return false;
            }else{
                return false;
            }   
        };
        $scope.obtenerIcono = function(file){
            switch(true){
                case typeof file == 'undefined':
                return 'pdf_logo.png';
                break;

                case file.NOM_FICHERO.indexOf("xlsx")!=-1:
                return 'xlsx_logo.png';
                break;

                case file.NOM_FICHERO.indexOf("pdf")!=-1:
                return 'pdf_logo.png';
                break;
            }
        };

        $scope.desplegarImagen= function (item, nombre) { 
            DocumentosService.descargarTomador($scope.datosTomador.tipoDocumento, $scope.datosTomador.codigoDocumento, item).then(function(response){
                return "data:image/png;base64," +response.data, nombre ; 
            }, function(response){
                Message.error("No se pudo desplegar la imagen");
            });
        };

        $scope.init = function(){
            $rootScope.currentPage = 'documento';
            $scope.pathModule = UtilsService.retornarPath($location.path().split("/")[1]);
            $rootScope.tabs = DocumentosService.getTabInicial();

            $scope.bloquearBuscador=false;

            if (!angular.isUndefined($scope.numeroCotizacionRoot) && $scope.numeroCotizacionRoot!= null && $scope.numeroCotizacionRoot!=""){ 
                
                var param ={};
                param.numeroCotizacion=$scope.numeroCotizacionRoot;  
                param.marcaFlota=$scope.subtipo=='Flota'?'S':'N';
                param.tab="DOCUMENTOS";
                param.pathModule=$scope.pathModule;
                DocumentosService.getTabs(param);
                $scope.cargando=true;
                $scope.obtenerDocumentosCotizacionPropuesta();
                $scope.obtenerTomador();
                $scope.listarTipoDocumentos();



            }else{
                DocumentosService.goToPropuestaOrigen($scope.pathModule.split("marcaModulo=")[1]);
            }
        }
        $scope.init();
    }]);
;app.controller('FlotaNoIndividualAgregarCtrl', ['$scope','$filter', 'FlotaAgregarService', '$controller', '$routeParams', '$location', 'SessionService', '$rootScope', '$mdDialog', 'ConfirmService',
    function ($scope,filter,FlotaAgregarService, $controller, $routeParams, $location, sessionService, $rootScope, $mdDialog, confirmService) {
    
     $scope.nombre = "Flota";
     var objetoCotizacion ={};

     $scope.datosCargaForm ={};
    
     $scope.datosAgregar ={};
     $scope.datosAgregar.numeroRiesgo=undefined;
     $scope.datosAgregar.marcaId=undefined;
     $scope.datosAgregar.marcaNombre=undefined;
     $scope.datosAgregar.modeloId=undefined;
     $scope.datosAgregar.modeloNombre=undefined;
     $scope.datosAgregar.subModeloId=undefined;
     $scope.datosAgregar.subModeloNombre=undefined;
     $scope.datosAgregar.anho=undefined;
     $scope.datosAgregar.ocupantes=undefined;
     $scope.datosAgregar.sumaAsegurada=undefined;
     $scope.datosAgregar.nombretipoVehiculo=undefined;
     $scope.datosAgregar.tipoVehiculoId=undefined;
     $scope.datosAgregar.darDeBaja="N";

     $scope.cobertura ={};
     $scope.cobertura.danhosPropiosParciales=11;
     $scope.cobertura.robo=13;
     $scope.cobertura.roboParcialRadio=14;
     $scope.cobertura.granizo=15;
     $scope.cobertura.gastosMedAccPersonales=16;
     $scope.cobertura.danhosParcialesVandalismo=17;
     $scope.cobertura.cartaVerde=true;
     $scope.cobertura.cartaAzul=true;
     $scope.cobertura.danhosPropiosTotales=18;
     $scope.cobertura.danhosPropiosParcFranq=19;
     $scope.cobertura.roboParcialRadio2=20;
     $scope.cobertura.accidentesPersonales=21;
     $scope.cobertura.sepelio=22;
     $scope.cobertura.airbag=23;


 /*cargar todos los combos*/
        $scope.cargarCombos = function() {

            $scope.listadoModelos =[];
            $scope.listadoSubModelos =[];
            $scope.years =[];
            $scope.listadoMarcas=[];
            $scope.datosSumaAsegurada =[];
            $scope.cargarMarcas();
          
           


        };

        $scope.cargarMarcas = function() {

            var parametros = {};


            FlotaAgregarService.getMarcas(parametros).then(

                function (response) {

                    for(var i=0; i<response.data.dato.length; i++){
                        var obj = {
                            id:response.data.dato[i].COD_MARCA,
                            marca:response.data.dato[i].NOM_MARCA
                        };
                        $scope.listadoMarcas.push(obj);

                    }
                    if (sessionStorage.getItem('editar')=='S'){
                        $scope.datosAgregar.marcaId=parseInt(objetoCotizacion.codigoMarca);
                    }

                   
                     

            },
                function(response){
                Message.error("No se pudo obtener las marcas");
                
            });

        };

    $scope.$watch('datosAgregar.marcaId', function(NewValue, OldValue) {

             if(!angular.isUndefined(NewValue)){

                 var parametros = {};

                 parametros.preferencia=0;
                 parametros.esNuevo= $scope.nuevo;
                 parametros.codigoMarca=$scope.datosAgregar.marcaId;

                 for(var i=0; i<$scope.listadoMarcas.length; i++){
                     if ($scope.listadoMarcas[i].id==NewValue){
                         $scope.datosAgregar.marcaNombre= $scope.listadoMarcas[i].marca;
                         break;
                     }
                 }

                 //SE LIMPIAN LOS COMBOS DEPENDIENTES
                 $scope.listadoModelos =[];
                 $scope.listadoSubModelos =[];
                 $scope.years =[];
                 $scope.datosSubmodelo=[];

                 FlotaAgregarService.getModelos(parametros).then(

                     function (response) {

                         for(var i=0; i<response.data.dato.length; i++){
                             var obj = {
                                 id:response.data.dato[i].COD_MODELO,
                                 modelo:response.data.dato[i].NOM_MODELO
                             };
                             $scope.listadoModelos.push(obj);
                         }

                         if (sessionStorage.getItem('editar')=='S'){
                             $scope.datosAgregar.modeloId=parseInt( objetoCotizacion.codigoModelo);
                         }
                        

                     },
                     function(response){
                        
                         Message.error("No se pudo obtener los modelos");
                         
                     });

             }else{
                 $scope.listadoModelos =[];
                 $scope.listadoSubModelos =[];
                 $scope.years =[];
                 $scope.datosSubmodelo=[];
                
                 
             }


        },true);


    $scope.$watch('datosAgregar.modeloId', function(NewValue, OldValue) {
            if(!angular.isUndefined(NewValue)){

                var  parametros ={};
                $scope.listadoSubModelos =[];
                $scope.datosSubmodelo=[];

                parametros.esNuevo= $scope.nuevo;
                parametros.codigoMarca=$scope.datosAgregar.marcaId;
                parametros.codigoModelo=$scope.datosAgregar.modeloId;
               for(var i=0; i<$scope.listadoModelos.length; i++){
                     if ($scope.listadoModelos[i].id==NewValue){
                         $scope.datosAgregar.modeloNombre= $scope.listadoModelos[i].modelo;
                         break;
                     }
                 }


                FlotaAgregarService.getSubModelos(parametros).then(

                    function (response) {

                        for(var i=0; i<response.data.dato.length; i++){

                            var datos ={
                                id:response.data.dato[i].COD_SUB_MODELO,
                                cantOcup:response.data.dato[i].NUM_PLAZAS,
                                nombreTipoVehiculo :response.data.dato[i].NOM_TIP_VEHI,
                                idTipoVehiculo :response.data.dato[i].COD_TIP_VEHI
                            }

                            var obj = {
                                id:response.data.dato[i].COD_SUB_MODELO,
                                subModelo:response.data.dato[i].NOM_SUB_MODELO
                            };
                            $scope.listadoSubModelos.push(obj);
                            $scope.datosSubmodelo.push(datos);

                        }
                        if (sessionStorage.getItem('editar')=='S'){
                            $scope.datosAgregar.subModeloId=parseInt( objetoCotizacion.codigoSubModelo);
                         }
                         
         
                    },
                    function(response){
                      
                        Message.error("No se pudo obtener los sub modelos");
                        
                    });

            }else{
                $scope.listadoSubModelos =[];
                $scope.years =[];
                $scope.datosSubmodelo=[];
                 
            }

        },true);

     $scope.$watch('datosAgregar.subModeloId', function(NewValue, OldValue) {
            if(!angular.isUndefined(NewValue)){
                
                var  parametros ={};
                $scope.datosAgregar.ocupantes=null;
    
                parametros.esNuevo= $scope.nuevo;
                parametros.codigoMarca=$scope.datosAgregar.marcaId;
                parametros.codigoModelo=$scope.datosAgregar.modeloId;
                parametros.codigoSubModelo=$scope.datosAgregar.subModeloId;
                 for(var i=0; i<$scope.datosSubmodelo.length; i++){
                    if ($scope.datosSubmodelo[i].id==NewValue){
                        $scope.datosAgregar.ocupantes=$scope.datosSubmodelo[i].cantOcup;
                        $scope.datosAgregar.nombretipoVehiculo =$scope.datosSubmodelo[i].nombreTipoVehiculo;
                        $scope.datosAgregar.tipoVehiculoId =$scope.datosSubmodelo[i].idTipoVehiculo;
                        break;
                    }
                }

                 for(var i=0; i<$scope.listadoSubModelos.length; i++){
                    if ($scope.listadoSubModelos[i].id==NewValue){
                        $scope.datosAgregar.subModeloNombre=$scope.listadoSubModelos[i].subModelo;
                        break;
                    }
                }
                


                FlotaAgregarService.getAnhoSubModelos(parametros).then(
                    function (response) {
                        for(var i=0; i<response.data.dato.length; i++){
                            var obj = {
                                id:response.data.dato[i].ANIO_SUB_MODELO,
                                value:response.data.dato[i].ANIO_SUB_MODELO
                            };

                             var asegurado = {
                                id:response.data.dato[i].ANIO_SUB_MODELO,
                                montoAsegurado:response.data.dato[i].VAL_SUB_MODELO,
                                montoMinimo :response.data.dato[i].VAL_SUB_MODELO_MIN,
                                montoMaximo :response.data.dato[i].VAL_SUB_MODELO_MAX
                            };

                           $scope.datosSumaAsegurada.push(asegurado);
                            
                            $scope.years.push(obj);
                        }
                          if (sessionStorage.getItem('editar')=='S'){
                               $scope.datosAgregar.anho=parseInt(objetoCotizacion.anho);
                              $scope.datosAgregar.ocupantes =parseInt(objetoCotizacion.ocupantes);
                          }
                        
                    },
                    function(response){
                        
                        Message.error("No se pudo obtener los anhos sub modelos");
                        
                    });

            }else{
                $scope.years =[];
                $scope.datosAgregar.ocupantes = undefined;
            }

        },true);

     $scope.$watch('datosAgregar.anho', function(NewValue, OldValue) {
     	  if(!angular.isUndefined(NewValue)){
     	  	for(var i=0; i< $scope.datosSumaAsegurada.length; i++){
                    if ($scope.datosSumaAsegurada[i].id==NewValue){
                        $scope.datosAgregar.sumaAsegurada=$scope.datosSumaAsegurada[i].montoAsegurado;
                        $scope.datosAgregar.montoMin = $scope.datosSumaAsegurada[i].montoMinimo;
                        $scope.datosAgregar.montoMax = $scope.datosSumaAsegurada[i].montoMaximo;
                        break;
                    }
                }

     	  }else{
     	  	$scope.datosAgregar.sumaAsegurada=undefined;
     	  }


     },true);




   $scope.guardar = function() {

       var objetoEnviar ={};
       // si es agregar un nuevo registro
       if (sessionStorage.getItem('editar')=='N'){
            //se verifica si viene con cotizacion existente
             if (!angular.isUndefined(objetoCotizacion.numeroCotizacion) && objetoCotizacion.numeroCotizacion != null ){
                  objetoEnviar.numeroCotizacion = objetoCotizacion.numeroCotizacion;
             }else{
                 objetoEnviar.numeroCotizacion=null;
             }


       }else{
            objetoEnviar.numeroCotizacion = objetoCotizacion.numeroCotizacion;
       }
		     objetoEnviar.numeroRiesgo=$scope.datosAgregar.numeroRiesgo;
		     objetoEnviar.codigoMarca=$scope.datosAgregar.marcaId;
		     objetoEnviar.nombreMarca=$scope.datosAgregar.marcaNombre;
		     objetoEnviar.codigoModelo=$scope.datosAgregar.modeloId;
		     objetoEnviar.nombreModelo=$scope.datosAgregar.modeloNombre;
		     objetoEnviar.codigoSubmodelo=$scope.datosAgregar.subModeloId;
		     objetoEnviar.nombreSubmodelo=$scope.datosAgregar.subModeloNombre;
		     objetoEnviar.codigoTipoVehiculo=$scope.datosAgregar.tipoVehiculoId;
		     objetoEnviar.nombreTipoVehiculo=$scope.datosAgregar.nombretipoVehiculo;
		     objetoEnviar.anioSubmodelo=$scope.datosAgregar.anho;
		     objetoEnviar.numeroPlazas=$scope.datosAgregar.ocupantes;
		     objetoEnviar.sumaAsegurada=$scope.datosAgregar.sumaAsegurada;
		     objetoEnviar.baja = $scope.datosAgregar.darDeBaja
		    
		    if($scope.datosAgregar.sumaAsegurada < $scope.datosAgregar.montoMin || $scope.datosAgregar.sumaAsegurada > $scope.datosAgregar.montoMax ){
                Message.warning("El monto asegurado no cumple el rango de requerido, verifique su monto.");
                return;
              
		    }

		     var confirm = confirmService.showConfirm('¿Está seguro de guardar Riesgo?')

		                .then(function(answer) {

                           if (sessionStorage.getItem('editar')=='N'){
                               FlotaAgregarService.guardarRiesgo(objetoEnviar).then(
		                       
		                         function (response) {
		                           
			                     $location.url($scope.path);
			                     Message.ok("La operacion se ha registrado exitosamente.");
			                    }).catch(function(response){
			                     Message.error("No se pudo realizar la operacion");
			                     
			                   });
                              

                           }else{
                               FlotaAgregarService.editarRiesgo(objetoEnviar).then(
		                       
		                         function (response) {
		                           
			                     $location.url($scope.path);
			                     Message.ok("La operacion se ha registrado exitosamente.");
			                    }).catch(function(response){
			                     Message.error("No se pudo realizar la operacion");
			                     
			                   });

                           }

		                  

		                


		                }, function() {
		                    return;
		                });
      };

         $scope.cargarForGrilla = function() {

            var parametros = {};

            parametros.numeroRiesgo=$scope.datosAgregar.numeroRiesgo;
            parametros.numeroCotizacion=  $scope.datosAgregar.numCotizacion;


            FlotaAgregarService.editarRiesgoGrilla(parametros).then(

                function (response) {
                     $scope.datosCargaForm=response.data.dato[0];
                     $scope.datosCoberturaRiesgos = $scope.datosCargaForm.coberturaRiesgos;
                     $scope.datosAgregar.numeroRiesgo = $scope.datosCargaForm.numeroRiesgo;
                     $scope.datosAgregar.numeroCotizacion=parametros.numeroCotizacion;
                     $scope.datosAgregar.sumaAsegurada=$scope.datosCargaForm.sumaAsegurada;

                     $scope.cargarCombos();
                    if( $scope.datosCoberturaRiesgos.length>0){
                        $scope.sindatos=false;
                        $scope.cartaVerde=false;
                        $scope.cartaAzul=false;
                        var CV,CA;
                        CV=0,CA=0;
                        $scope.datos = angular.copy($scope.datosCoberturaRiesgos);

                        for(var i=0;i<$scope.datos.length;i++){
                            if($scope.datos[i].etiqueta==="CARTA VERDE"){
                                $scope.datos.splice(i,1);
                                $scope.cartaVerde = true;
                                CV=i;
                            }else if($scope.datos[i].etiqueta==="CARTA AZUL"){
                                $scope.datos.splice(i,1);
                                $scope.cartaAzul = true;
                                CA=i;
                            }
                        }

                        $scope.v1=[];
                        $scope.v2=[];
                    
                        if($scope.datosCoberturaRiesgos.length<=6){
                            var i=0;
                            while($scope.datos.length>0 && $scope.v1.length<=6){
                                $scope.v1.push($scope.datos[i]);
                                $scope.datos.splice(i,1);
                            };
                        }else if($scope.datosCoberturaRiesgos.length>6 && $scope.datosCoberturaRiesgos.length<=18){
                            var i=0;
                            while($scope.datos.length>0 && $scope.v1.length<6){
                                $scope.v1.push($scope.datos[i]);
                                $scope.datos.splice(i,1);
                            };
                            var j=0;
                            while($scope.datos.length>0 && $scope.v2.length<6){
                                $scope.v2.push($scope.datos[j]);
                                $scope.datos.splice(j,1);
                            };
                        }else{
                            var cant = Math.trunc($scope.datosCoberturaRiesgos.length/3);
                            var resto = $scope.datosCoberturaRiesgos.length%3;
                            var cantxColum = cant + resto;
                            var i=0;
                            while($scope.datos.length>0 && $scope.v1.length< cantxColum){
                                $scope.v1.push($scope.datos[i]);
                                $scope.datos.splice(i,1);
                            };
                            var j=0;
                            while($scope.datos.length>0 && $scope.v2.length< cantxColum){
                                $scope.v2.push($scope.datos[j]);
                                $scope.datos.splice(j,1);
                            };
                    
                        }
                    }else{
                        $scope.sindatos=true;
                    }
            },
                function(response){
                Message.error("No se pudo obtener las marcas");
                
            });

        };


        $scope.llamarModal = function(value) {

        if(!angular.isUndefined( $scope.datosAgregar.numCotizacion)&&  $scope.datosAgregar.numCotizacion!=null &&  $scope.datosAgregar.numCotizacion!=""){ 
            $rootScope.numCotiza = $scope.datosAgregar.numCotizacion;
            $rootScope.autEsNuevo=$scope.nuevo;
            $rootScope.numeroRiesgoFlota=$scope.datosAgregar.numeroRiesgo;
            $rootScope.modalCotizadorVehFlota=value;
            $mdDialog.show({
                locals:{parent: $scope},   
                controller: 'ModalAutorizacionCtrl',
                templateUrl: 'partials/ventanas-emergentes/modal-autorizacion-partial.html',
                parent: angular.element(document.body),
                multiple: true,
                clickOutsideToClose:false,
                fullscreen: $scope.customFullscreen // Only for -xs, -sm breakpoints.
            }).then(function(answer) {
                
                 /*$scope.cargando=true;
                $scope.status = 'You said the information was "' + answer + '".';
                if (!angular.isUndefined(answer.numeroCotizacion) && answer.numeroCotizacion !="" && answer.numeroCotizacion!= null){
                    $scope.datosGenerales.numeroCotizacion = parseInt(answer.numeroCotizacion);
                }else{
                     Message.error("Numero de cotizacion inexistente");
                     return;
                }*/
               

                


            }, function() {
                $scope.status = 'You cancelled the dialog.';
                
            });
           } 

        };
/**
         * Constructor / Entrypoint
         * @constructor
         */
        (function initialize() {
            
           
           
            $scope.path = $location.$$path.split("-")[0] + "/";
            var param = $routeParams;
            $scope.nuevo= localStorage.agregarEsNuevo;
           
            if (sessionStorage.getItem('editar')=='N'){
                $scope.sindatos=true;
                $scope.titulo = "Agregar Vehiculo";
                if (!angular.isUndefined(sessionStorage.getItem("objetoCotizacion")) && sessionStorage.getItem("objetoCotizacion") != null ){
            	     objetoCotizacion = JSON.parse(sessionStorage.getItem("objetoCotizacion"));
               	     $scope.datosAgregar.numeroRiesgo = parseInt(objetoCotizacion.cantRiesgo ) + 1;
 					 $scope.datosAgregar.numCotizacion = parseInt(objetoCotizacion.numeroCotizacion);                 
                    }else{
                 	  $scope.datosAgregar.numeroRiesgo =1;
                      objetoCotizacion.numeroCotizacion=null;
                 }
                  $scope.cargarCombos();

            }else{
	            $scope.titulo = "Editar Vehiculo";
                if (!angular.isUndefined(sessionStorage.getItem("objetoCotizacionEdit")) && sessionStorage.getItem("objetoCotizacionEdit") != null ){
            	     objetoCotizacion = JSON.parse(sessionStorage.getItem("objetoCotizacionEdit"));
               	     $scope.datosAgregar.numeroRiesgo = parseInt(objetoCotizacion.numeroRiesgo);
                      $scope.datosAgregar.numCotizacion = parseInt(objetoCotizacion.numeroCotizacion);
               	  /*   $scope.datosAgregar.sumaAsegurada=parseInt(objetoCotizacion.capital);*/
                 }
                  $scope.cargarForGrilla();
                  $scope.cargarCombos();
                   

            }


            
            
            
            
        })();

 }]);
;app.controller('HojasAnexasFormCtrl', ['$scope','$controller', 'TomadorService','$route','$window','HojaAnexaService', '$rootScope','PropuestaService','CotizacionVehiculoPropuestaService','$location','UtilsService','$log','$timeout',
    function ($scope,$controller, modeloService, $route, $window, hojaAnexaService, $rootScope, PropuestaService,CotizacionVehiculoPropuestaService, $location, UtilsService, $log, $timeout ) {
        $scope.service = PropuestaService;
        $rootScope.rootPathParent =$route.current.$$route.originalPath;
        $scope.panel1=false;
        $scope.panel2=false;
        $scope.mostrarDPrevios=false;
        $scope.hojasAnexas={};
        $scope.hojasAnexas.accesoriosDetalle=undefined;
        $scope.hojasAnexas.danhoDetalle=undefined;
        $scope.hojasAnexas.cabecercaDanhoUnformat=undefined;
        $scope.hojasAnexas.cabeceraAccesoriosUnformat=undefined;
        $scope.hojasAnexas.cabecercaDanhoFormat=undefined;
        $scope.hojasAnexas.cabeceraAccesoriosFormat=undefined;
        $scope.subtipo = $route.current.$$route.subtipo;        
        $scope.cargando=false;
        $scope.datosGenerales={};
        $scope.datosGenerales.plataforma=null;
        $scope.cabeceraAccesorioRow=2;
        $scope.cabeceraDanhoRow=6;
        $scope.accesiorioRow=15;
        $scope.danhoRow=15;
        $scope.tab="HOJA_ANEXA";
        //console.log("subtipo ",$scope.subtipo);
        if ($scope.subtipo=="Vehiculos")
        {
            $scope.path="propuesta-vehiculo/hojas-anexas";
        }
        else if($scope.subtipo=="Flota")
        {
            $scope.path="propuesta-flota/hojas-anexas";
        }
        else if ($scope.subtipo=="Propuesta Hogar")
        {
            $scope.path="propuesta-hogar/hojas-anexas";
        }



        $scope.verificarCamposForm=function(listaCampo, campo)
        {
            //console.log("LISTA: " + listaCampo);
            return UtilsService.verificarCamposForm(listaCampo, campo);
        };

        $scope.obtenerHojasAnexas = function () {

            if(typeof $scope.numeroCotizacionRoot != 'undefined' && $scope.numeroCotizacionRoot != null){
                
              if( $scope.subtipo!="Propuesta Hogar"){
                 //obtener cabecera
                hojaAnexaService.obtenerCabecera().then(function(response)
                {
                    if (!response.data.error)
                    {
                        $scope.hojasAnexas.cabeceraAccesoriosUnformat="";
                        $scope.hojasAnexas.cabeceraAccesoriosFormat="";
                        $scope.hojasAnexas.cabecercaDanhoUnformat="";
                        $scope.hojasAnexas.cabecercaDanhoFormat="";
                        if (response.data.dato!=null)
                        {
                            var datos=response.data.dato;
                            if (datos.cabeceraAccesorios.length>0)
                            {
                                for (var i=0; i<datos.cabeceraAccesorios.length;i++)
                                {
                                    $scope.hojasAnexas.cabeceraAccesoriosUnformat+=datos.cabeceraAccesorios[i]+" ";
                                    $scope.hojasAnexas.cabeceraAccesoriosFormat+=datos.cabeceraAccesorios[i]+'\n';
                                }

                            }
                            $scope.cabeceraAccesorioRow=datos.cabeceraAccesorios.length+1; //mas uno porque el formateado tiene el /n
                            if (datos.cabeceraDaniosPrevios.length>0) {
                                for (var i = 0; i < datos.cabeceraDaniosPrevios.length; i++)
                                {
                                    $scope.hojasAnexas.cabecercaDanhoUnformat += datos.cabeceraDaniosPrevios[i]+" ";
                                    $scope.hojasAnexas.cabecercaDanhoFormat += datos.cabeceraDaniosPrevios[i]+'\n';
                                }
                                $scope.cabeceraDanhoRow=datos.cabeceraDaniosPrevios.length+1; //mas uno porque el formateado tiene el /n

                            }



                        }
                    }
                });

              }
                

                 
                hojaAnexaService.obtenerHojasAnexas($scope.numeroCotizacionRoot,  $scope.pathModule).then(function(response){
                    
                    if(response.data.error != true){

                        $scope.bloquearBuscador=true;
                        $scope.cargarPlataforma();
                        //PROCESAR LA RESPUESTA DEL SERVICIO DE HOJAS ANEXAS
                        var accesorios = null;
                        if($scope.subtipo =="Propuesta Hogar") {
                              accesorios = response.data.dato.listaHogar;
                        }else{
                             accesorios = response.data.dato.listaAccesorios;
                        }
                        
                        var unformat = "";
                        var format = "";
                        for (var i in accesorios)
                        {
                            format += accesorios[i] +'\n';
                            unformat += accesorios[i];
                        }
                        $scope.hojasAnexas.accesoriosDetalleFormat = format; 
                        $scope.hojasAnexas.accesoriosDetalle = unformat;
                        if (accesorios!=null)
                        {
                            if (accesorios.length>$scope.accesiorioRow)
                            {
                                $scope.accesiorioRow=accesorios.length+1;//+1 del /n
                            }
                        }

        
        
                        var daniosPrevios = response.data.dato.listaDaniosPrevios;
                        var unformat = "";
                        var format = "";
                        for (var i in daniosPrevios)
                        {
                            format += daniosPrevios[i] +'\n';
                            unformat += daniosPrevios[i];
                        }
                        $scope.hojasAnexas.danhoDetalleFormat = format; 
                        $scope.hojasAnexas.danhoDetalle = unformat;
                        if (daniosPrevios!=null)
                        {
                            if (daniosPrevios.length>$scope.danhoRow)
                            {
                                $scope.danhoRow=daniosPrevios.length+1;//+1 del /n
                            }
                        }

                        $scope.cargando=false;

                    }else{
                        Message.error(response.data.mensaje);
                        $scope.cargando=false;
                    }
    
                }, function(response){
                    $scope.cargando=false;
                    Message.error("No se pudo obtener los datos de las Hojas Anexas");
                    //console.error(response);
                });

            }
        }

        $scope.cargarPlataforma = function(){

        var paramPla={};
        paramPla.numeroCotizacion=$scope.numeroCotizacionRoot;
        paramPla.marcaFlota=$scope.subtipo=='Flota'?'S':'N';
        paramPla.pathModule=$scope.pathModule;
        CotizacionVehiculoPropuestaService.getPlataforma(paramPla).then(

                       
                        function (response) {
                          if(!response.data.error){
                             if(response.data.dato!=null  )  {
                                   
                                $scope.mostrarPlataforma=true;

                                 
                                   //$scope.plataforma=response.data.dato.mensaje;
                                   $scope.datosGenerales.plataforma=response.data.dato.mensaje;
 
                            }

                          }
                     

                        }).catch(function(response){
                           
                            Message.error(response.data.mensaje);
                           
                        });
          };

        $scope.guardarHojasAnexas = function(clickButton){
            if (!angular.isUndefined($scope.numeroCotizacionRoot)){
                
                $scope.cargando=true;
                var param = null;
                if ($scope.subtipo=="Propuesta Hogar"){
                    param ={
                        "numeroCotizacion": $scope.numeroCotizacionRoot,
                        "hogar":$scope.hojasAnexas.accesoriosDetalle ,
                        "marcaModulo": angular.isUndefined($scope.pathModule)?null:$scope.pathModule.split("marcaModulo=")[1]
                         }
                }else{
                    
                     param ={
                        "numeroCotizacion": $scope.numeroCotizacionRoot,
                        "accesorios":$scope.hojasAnexas.accesoriosDetalle ,
                        "daniosPrevios": $scope.hojasAnexas.danhoDetalle,
                        "marcaModulo": angular.isUndefined($scope.pathModule)?null:$scope.pathModule.split("marcaModulo=")[1]
                         }
                }
                


                hojaAnexaService.guardarHojasAnexas(param).then(function(response){

                    
                if(response.data.error != true){
                    
                    //PROCESAR LA RESPUESTA DEL SERVICIO DE HOJAS ANEXAS 
                    var accesorios = null;
                    if ($scope.subtipo=="Propuesta Hogar"){
                       accesorios = response.data.dato.listaHogar;
                    }else{
                       accesorios = response.data.dato.listaAccesorios;
                    }
                     
                     
                    var unformat = "";
                    var format = "";
                    for (var i in accesorios)
                    {
                        format += accesorios[i]+" " +'\n';
                        unformat += accesorios[i]+" ";
                    }
                    $scope.hojasAnexas.accesoriosDetalleFormat = format; 
                    $scope.hojasAnexas.accesoriosDetalle = unformat;
                    
                    
                    var daniosPrevios = response.data.dato.listaDaniosPrevios;
                    var unformat = "";
                    var format = "";
                    for (var i in daniosPrevios)
                    {
                        format += daniosPrevios[i] +'\n';
                        unformat += daniosPrevios[i];
                    }
                    $scope.hojasAnexas.danhoDetalleFormat = format; 
                    $scope.hojasAnexas.danhoDetalle = unformat;
                    if (clickButton=="S")
                    {
                        var param ={};
                        param.numeroCotizacion=$scope.numeroCotizacion;
                        param.marcaFlota=$scope.subtipo=='Flota'?'S':'N';
                        param.pathModule=$scope.pathModule;
                        param.tab=$scope.tab;
                        PropuestaService.getTabs(param);
                    }
                    else
                    {
                        $scope.cambiarTab=1;
                    }
                    Message.ok(response.data.mensaje);
                    $scope.cargando=false;
                }else{
                   Message.error(response.data.mensaje);
                   $scope.cargando=false;
                   $scope.cambiarTab=2;
                }

            }, function(response){
               $scope.cambiarTab=2;
                $scope.cargando=false;
                Message.error("No se pudo guardar los datos de las Hojas Anexas");
            });
         }

        };
       $scope.limpiarDatos = function() {
             $scope.hojasAnexas.accesoriosDetalle=undefined;
             $scope.hojasAnexas.danhoDetalle=undefined;
             $scope.hojasAnexas.accesoriosDetalleFormat=undefined;
             $scope.hojasAnexas.danhoDetalleFormat=undefined;
       };


        $scope.recargar = function() {
          
          $scope.bloquearBuscador=false;
           $scope.datosGenerales.plataforma=null;

          $rootScope.numeroCotizacionRoot=undefined;
          $rootScope.nroPropuesta=undefined;
          $scope.limpiarDatos();

        };
        /**
         * Función creada para el salto de propuesta a cotizacion
         */
        $scope.goToCotizacion = function() {
            var path = $location.$$absUrl;
            var n = path.search("module");
            var url =  path.substring(0 , n);

            if(typeof $scope.numeroCotizacionRoot != 'undefined' && $scope.numeroCotizacionRoot != null){
                var subtipo = 'flota';
                if ($scope.subtipo == 'Vehiculos'){
                    subtipo = 'cotizacion-vehiculo';


                }else if ($scope.subtipo== 'Flota'){
                          subtipo = 'flota';
                }else if ($scope.subtipo== 'Propuesta Hogar'){
                           subtipo = 'cotizacion-hogar';
                }
                location.href =subtipo+'/'+$scope.numeroCotizacionRoot;

            }
            else
            {
                Message.warning("Debe ingresar un número de cotización");
            }
        };
        $scope.$watch('cambiarTab', function(newValue, oldValue) {
            if (newValue!=0)
            {
                if (newValue==1)
                {
                    //hacer el redirect
                    var params={};
                    params.marcaFlota=$scope.subtipo=="Flota"?'S':'N';
                    params.numeroCotizacion=angular.isUndefined($scope.numeroCotizacionRoot)|| $scope.numeroCotizacionRoot==null?"":$scope.numeroCotizacionRoot;
                    params.tab=$rootScope.sigTab;
                    params.pathModule=$scope.pathModule;
                    $scope.service.getCamposEditablesList(params);
                    $timeout($location.url($rootScope.url_destino),1000);

                }
                else
                {
                    newValue=0; //para que vuelva a cambiar e intentar
                }
            }


        },true);


        $(function()
        {
            $(document).on('keyup keydown paste cut', 'textarea', function(e) {

                //  the following will help the text expand as typing takes place
                //var incremento=$(this).height+$(this).outerHeight();
                //$(this).height(incremento);
                if (this.clientHeight < this.scrollHeight)
                {
                    $(this).height(this.scrollHeight + 'px');
                }

            });

        });




        $scope.init = function(){
            $rootScope.currentPage = 'hojaAnexa';
            $scope.pathModule = UtilsService.retornarPath($location.path().split("/")[1]);
            $rootScope.tabs = hojaAnexaService.getTabInicial();
            $scope.datoT=50;
             $scope.datoTooltip=$scope.datoT +"% completado.";

            $scope.bloquearBuscador=false;
            $scope.cargarPlataforma();
            if (!angular.isUndefined($scope.numeroCotizacionRoot) && $scope.numeroCotizacionRoot!= null && $scope.numeroCotizacionRoot!=""){
                $scope.cargando=true;

                var param ={};
                param.numeroCotizacion=$scope.numeroCotizacionRoot;  
                param.marcaFlota=$scope.subtipo=='Flota'?'S':'N';
                param.pathModule=$scope.pathModule;
                param.tab="HOJA_ANEXA";
                hojaAnexaService.getTabs(param);

                $scope.obtenerHojasAnexas();
            }else{
                hojaAnexaService.goToPropuestaOrigen($scope.pathModule.split("marcaModulo=")[1]);
            }
        }
        $scope.init();
    }
]);
;app.controller('PropuestaFlotaFormCtrl', ['$scope','$filter', '$controller', '$routeParams', '$location', 'SessionService', '$rootScope', '$route', '$mdDialog', 'ConfirmService','$location',
    function ($scope,filter, $controller, $routeParams, $location, sessionService, $rootScope, $route, $mdDialog, confirmService,$location) {

        $scope.nombre = "Propuesta Flota";

       (function initialize() {


        })();

    }]);
;app.controller('RiesgoAgregarFormCtrl', ['$scope', '$q', '$controller', '$routeParams', '$location', 'SessionService', '$rootScope','$route', '$mdDialog', '$filter', 'ConfirmService', '$window', 'RiesgoService', 'VehiculoService','AseguradoService','UtilsService','$log',
    function ($scope,$q, $controller, $routeParams, $location, sessionService, $rootScope,$route, $mdDialog,  $filter, confirmService, $window, RiesgoService, VehiculoService,AseguradoService,UtilsService, $log) {


        $scope.nombre = "Riesgo";
        $scope.titulo = "Agregar";
        $scope.edicion = false;
        $scope.detallesRiesgo={};
        $scope.subtipo = $route.current.$$route.subtipo;
        $scope.nroInspeccion={};
        $scope.numChapa={};
        $scope.numChasis={}
        $scope.anhonac={};
        $scope.modelo={};
        $scope.colorSelected={};
        $scope.colorSelected.valor=null;
        $scope.usoSelected={};
        $scope.usoSelected.valor=null;
        $scope.aseguradoSelected={};
        $scope.aseguradoSelected.valor=null;
        $scope.conductor1={};
        $scope.conductor1.valor="";
        $scope.conductor2={};
        $scope.conductor2.valor="";
        $scope.marcaCeroKm={};
        $scope.marcaCeroKm.valor="N"



        $scope.formatearFecha=function(fecha){
           $scope.aplicarFormato(fecha);
        };

        var obtenerDetallesRiesgo = function(numeroRiesgo){
            var param ={};
            param.numeroRiesgo= numeroRiesgo;
            param.numeroCotizacion=$scope.numeroCotizacion;
            $scope.cargando=true;
            RiesgoService.obtenerDetallesRiesgo(param).then(
                
                function(response){
                    if (!response.data.error)
                    {
                        if (response.data.dato.length>0)
                        {
                            $scope.codigoTipoVehiculo=response.data.dato[0].codigoTipoVehiculo;
                            $scope.detallesRiesgo = response.data.dato[0];
                            $scope.numeroCotizacion =response.data.dato[0].numeroCotizacion;
                            $scope.nroInspeccion.valor=response.data.dato[0].numeroInspeccion;
                            $scope.numChapa.valor=response.data.dato[0].matricula!=null && response.data.dato[0].matricula!=""?response.data.dato[0].matricula.toUpperCase():response.data.dato[0].matricula;
                            $scope.numChasis.valor=response.data.dato[0].numeroChasis;
                            $scope.anhonac.valor=response.data.dato[0].anioNacionalidad;
                            $scope.usoSelected.valor=response.data.dato[0].codigoUso!=null && response.data.dato[0].codigoUso!=""?parseInt(response.data.dato[0].codigoUso):null;


                            promesaColores.promise.then(
                                function(){

                                    for(var i=0;i<$scope.listaColores.length;i++){
                                        if ($scope.listaColores[i].COD_COLOR==parseInt(response.data.dato[0].codigoColor)){
                                            $scope.colorSelected ={};
                                            $scope.colorSelected.valor=null;
                                            $scope.colorSelected.valor=$scope.listaColores[i];
                                            break;

                                        }
                                    }
                                });


                            promesaAsegurados.promise.then(
                                function(){
                                    if($scope.listaAsegurados !=null){

                                       for(var i=0;i<$scope.listaAsegurados.length;i++){
                                           if ($scope.listaAsegurados[i].TIP_DOCUM +'-'+$scope.listaAsegurados[i].COD_DOCUM=== response.data.dato[0].tipoDocumentoAsegurado+'-'+ response.data.dato[0].codigoDocumentoAsegurado ) {
                                                $scope.aseguradoSelected ={};
                                                $scope.aseguradoSelected.valor=null;
                                                $scope.aseguradoSelected.valor=$scope.listaAsegurados[i];
                                                break;

                                            }
                                        }
                                    }

                                });


                            $scope.conductor1.valor=response.data.dato[0].conductorUno;
                            $scope.conductor2.valor=response.data.dato[0].conductorDos;
                            $scope.cargando=false;
                            /*$scope.marcaCeroKm.valor=response.data.dato[0].marca0km;
                            $scope.modelo.fechaCert =null;
                            $scope.modelo.fechaEntrega= null;
                            $scope.modelo.fechaCert =angular.isUndefined(response.data.dato[0].fechaCertificacion)?null:$scope.convertirDate(response.data.dato[0].fechaCertificacion);
                            $scope.modelo.fechaEntrega=angular.isUndefined(response.data.dato[0].fechaEntrega)?null:$scope.convertirDate(response.data.dato[0].fechaEntrega);
            */
                        }
                        else
                        {
                            $scope.cargando=false;
                        }

                    }
                    else
                    {
                        $scope.cargando=false;
                        Message.error(response.data.mensaje);
                    }

            }, function(error){
               $scope.cargando=false;
                Message.error("Ocurrio un error al obtener los datos!");

            });
        };
        var guardarRiesgo = function(riesgo){
            RiesgoService.guardarRiesgo(riesgo).then(function(response){
                
                $location.url($scope.path);
            }, function(response){
                Message.error(response.data.mensaje);
            });

        };

        var promesaColores = $q.defer();
        var obtenerColores = function(){
            VehiculoService.obtenerColores().then(function(response){
                $scope.listaColores = response.data.dato;
                promesaColores.resolve();
            }, function(response){
                Message.error("No se pudo obtener los colores");
                promesaColores.reject();
            });
        };
       
        var promesaUsos = $q.defer();
        var obtenerUsos = function(){
            var param={};
            param.codTipoVehiculo=angular.isUndefined($scope.codigoTipoVehiculo)?1: $scope.codigoTipoVehiculo!=null?$scope.codigoTipoVehiculo:1;
            VehiculoService.obtenerUsos(param).then(function(response){
                $scope.listaUsos = response.data.dato;
                promesaUsos.resolve();
            }, function(response){
                Message.error("No se pudo obtener los usos de vehiculos");
                promesaUsos.reject();
            });
        };

        var promesaAsegurados = $q.defer();
        var obtenerAsegurados = function(){
            var param ={};
            param.numeroCotizacion =$scope.numeroCotizacion;
            param.numeroPagina=0;
            AseguradoService.obtenerListaAsegurados(param).then(
                function(response){

                $scope.listaAsegurados = response.data.dato.lista;
                promesaAsegurados.resolve();
               }, 
               function(response){
                Message.error("No se pudo obtener los Asegurados+");
                promesaAsegurados.reject();
            });
        };

        $scope.actualizar = function(){
            var riesgo ={};
            if ((!angular.isUndefined($scope.numeroCotizacion) && $scope.numeroCotizacion!=null)

                && ( !angular.isUndefined($scope.detallesRiesgo.numeroRiesgo) && $scope.detallesRiesgo.numeroRiesgo!=null)){
                riesgo.numeroCotizacion=$scope.numeroCotizacion;
                riesgo.numeroInspeccion= $scope.nroInspeccion.valor;
                riesgo.numeroMatricula=$scope.numChapa.valor;
                riesgo.numeroChassis=$scope.numChasis.valor;
                riesgo.anioNacionalizacion=$scope.anhonac.valor;
                riesgo.codigoTipoVehiculo =$scope.codigoTipoVehiculo;
                /*riesgo.marcaCeroKm=$scope.marcaCeroKm.valor;
                riesgo.fechaCertificado=$scope.modelo.fechaCert;
                riesgo.fechaEntrega=$scope.modelo.fechaEntrega;*/
                $scope.RiesgoAgregarForm.color.$error.required;
                /*if (angular.isUndefined($scope.colorSelected.valor) || $scope.colorSelected.valor==null ||angular.isUndefined($scope.usoSelected.valor)||$scope.usoSelected.valor==null){
                   $scope.requerido = true;
                   Message.info("Complete los valores requeridos");
                 return;

                }else{
                     $scope.requerido = false;
                }*/
                riesgo.codigoColor=!angular.isUndefined($scope.colorSelected.valor) && $scope.colorSelected.valor!=null ?$scope.colorSelected.valor.COD_COLOR:null;
                riesgo.codigoUsoVehiculo=!angular.isUndefined($scope.usoSelected.valor) && $scope.usoSelected.valor!=null ?$scope.usoSelected.valor:null;
                riesgo.numeroRiesgo=$scope.detallesRiesgo.numeroRiesgo;
                riesgo.ConductorUno=$scope.conductor1.valor;
                riesgo.ConductorDos=$scope.conductor2.valor;
                riesgo.tipoDocumentoAsegurado=angular.isUndefined($scope.aseguradoSelected.valor)?null:$scope.aseguradoSelected.valor!= null ? $scope.aseguradoSelected.valor.TIP_DOCUM:null;
                riesgo.codigoDocumentoAsegurado=angular.isUndefined($scope.aseguradoSelected.valor)?null:$scope.aseguradoSelected.valor!=null?$scope.aseguradoSelected.valor.COD_DOCUM:null;
                riesgo.marcaModulo = $scope.pathModule.split("marcaModulo=")[1];
              var param = JSON.stringify(riesgo);
            }else{
                Message.info("Necesita numero de cotizacion y riesgo.");
                return;
            }
                  
            RiesgoService.actualizarRiesgo(riesgo).then(
                //succes
               function(response){
                  if(!response.data.error){
                      Message.ok(response.data.mensaje);
                      $window.sessionStorage.removeItem("editar");
                      $location.url($scope.path);
                  }else{
                       Message.error(response.data.mensaje);
                  }
                
               }, 
               //erroror
               function(response){
                Message.error(response.data.mensaje);
            });

           
            
        };

        $scope.guardar = function(){
            $scope.detallesRiesgo.numeroCotizacion=$scope.numeroCotizacion;
            guardarRiesgo($scope.detallesRiesgo);
            
        };
        /**
         * Función creada para el salto de propuesta a cotizacion
         */
        $scope.goToCotizacion = function() {
            var path = $location.$$absUrl;
            var n = path.search("module");
            var url =  path.substring(0 , n);

            if(typeof $scope.numeroCotizacionRoot != 'undefined' && $scope.numeroCotizacionRoot != null){
                var subtipo = 'flota';
                location.href =subtipo+'/'+$scope.numeroCotizacionRoot;

            }
            else
            {
                Message.warning("Debe ingresar un número de cotización");
            }
        };
        $scope.verificarCamposForm=function(listaCampo, campo)
        {
            //console.log("LISTA: " + listaCampo);
            return UtilsService.verificarCamposForm(listaCampo, campo);
        };
        $scope.$watch('codigoTipoVehiculo', function(NewValue, OldValue) {
            if(!angular.isUndefined(NewValue) && NewValue!=null ){
                obtenerUsos();

            }

        },true);

        (function initialize() {
            $rootScope.currentPage = 'riesgo';
            $scope.pathModule = UtilsService.retornarPath($location.path().split("/")[1]);
            if (!angular.isUndefined($scope.numeroCotizacionRoot))
            {
                $scope.numeroCotizacion=$scope.numeroCotizacionRoot;
                //$scope.requerido = false;

                $log.debug("metodo: " + $window.sessionStorage["metodo"]);
                $scope.path=$location.$$path.split("/")[1] +"/riesgo";

                obtenerColores();
                obtenerAsegurados();
                if ($window.sessionStorage["metodo"]=="edicion"){
                    $scope.edicion = true;
                    obtenerDetallesRiesgo($window.sessionStorage["editar"]);
                }else{
                    $scope.edicion =false;
                    obtenerUsos();
                }
            }
            else
            {
                $window.sessionStorage.removeItem("metodo");
                $location.path("propuesta-flota/propuesta");
            }


        })();


    }]);
;app.controller('RiesgoFormCtrl', ['$scope', '$q', '$controller', '$routeParams', '$location', 'SessionService', '$rootScope','$route', '$mdDialog', '$filter', 'ConfirmService', '$window', 'RiesgoService','CotizacionVehiculoPropuestaService','PropuestaService','UtilsService','AseguradoService','$log',
    function ($scope,$q, $controller, $routeParams, $location, sessionService, $rootScope,$route, $mdDialog,  $filter, confirmService, $window, RiesgoService,CotizacionVehiculoPropuestaService, PropuestaService, UtilsService, AseguradoService, $log) {

        $scope.service = PropuestaService;
        $scope.nombre = "Riesgo";

        $scope.subtipo = $route.current.$$route.subtipo;
        $scope.tab="RIESGO";
        $scope.listaAsegurados=[];
        $scope.todosAsegurados="N";
        $scope.aseguradoSelecionado = null;
        $scope.disabledSwitchRiesgo = true;
        $scope.showSwitchRiesgo = false;
        $scope.pagina=1;

        $scope.obtenerRiesgos = function(){
            var numeroCotizacion = angular.isUndefined($scope.numeroCotizacionRoot)?null:$scope.numeroCotizacionRoot;
            var param ={};
            param.numeroCotizacion=numeroCotizacion;
            param.marcaFlota=$scope.subtipo=='Flota'?'S':'N';
            param.pathModule =$scope.pathModule;
            param.tab=$scope.tab;

            $scope.cargando=true;
            $scope.numeroCotizacion=$scope.numeroCotizacionRoot;
            var paramRiesgo={};
            paramRiesgo.numeroCotizacion=$scope.numeroCotizacionRoot;
            paramRiesgo.numeroPagina=$scope.pagina;
            RiesgoService.obtenerRiesgos(paramRiesgo).then(function(response){
                if(!response.data.error){
                    RiesgoService.getTabs(param);
                    $scope.cargarPlataforma();
                    $scope.bloquearBuscador=true;
                    $scope.listaRiesgos = response.data.dato.lista;
                    $scope.rowCollection = $scope.listaRiesgos;
                    $scope.totalItems = response.data.dato.totalDatos;
                    $scope.pagina = response.data.dato.paginado;
                    var restoPaginas=$scope.totalItems % $scope.itemsByPage;
                    var totalPaginas=parseInt($scope.totalItems /$scope.itemsByPage);
                    $scope.cantidadPaginas = totalPaginas==0?1:totalPaginas+(restoPaginas>0?1:0);

                    $scope.verificarPagina();
                    $scope.cargando=false;
                }else{
                    $scope.cargando=false;
                    Message.error(response.data.mensaje);
                }



            }, function(error){
                $scope.cargando=false;
                Message.error("Ocurrio un error al obtener los riesgos");
            });
        };

        $scope.editRow = function(row, pagina){
            sessionStorage.setItem("paginaRiesgoPropuesta", pagina);
            $window.sessionStorage["editar"] = row.NUM_RIESGO;
            $window.sessionStorage["metodo"] = "edicion";
            $location.url($scope.pathAgregar);
        };

        $scope.agregar = function(row){
            $window.sessionStorage["metodo"] = "crear";
            $location.url($scope.pathAgregar);
        };

        $scope.cargarPlataforma = function(){

            var paramPla={};
            paramPla.numeroCotizacion=$scope.numeroCotizacion;
            paramPla.marcaFlota=$scope.subtipo=='Flota'?'S':'N';
            paramPla.pathModule=$scope.pathModule;
            CotizacionVehiculoPropuestaService.getPlataforma(paramPla).then(


                function (response) {
                    if(!response.data.error){
                        if(response.data.dato!=null  )  {

                            $scope.mostrarPlataforma=true;

                            $scope.plataforma=response.data.dato.mensaje;


                        }

                    }


                }).catch(function(response){

                Message.error(response.data.mensaje);

            });
        };
        $scope.recargar=function()
        {
            $scope.listaRiesgos=[];
            $rootScope.numeroCotizacionRoot=undefined;
            $rootScope.nroPropuesta=undefined;
            $scope.bloquearBuscador=false;
        };
        /**
         * Función creada para el salto de propuesta a cotizacion
         */
        $scope.goToCotizacion = function() {
            var path = $location.$$absUrl;
            var n = path.search("module");
            var url =  path.substring(0 , n);

            if(typeof $scope.numeroCotizacionRoot != 'undefined' && $scope.numeroCotizacionRoot != null){
                var subtipo = 'flota';
                location.href =subtipo+'/'+$scope.numeroCotizacionRoot;

            }
            else
            {
                Message.warning("Debe ingresar un número de cotización");
            }
        };
        $scope.verificarCamposForm=function(listaCampo, campo)
        {
            return UtilsService.verificarCamposForm(listaCampo, campo);
        };
        $scope.obtenerListaAsegurados = function(){

            var param = {};
            param.numeroCotizacion=$scope.numeroCotizacionRoot;
            param.numeroPagina=0;
            $scope.cargando=true;
            $scope.numeroCotizacion=$scope.numeroCotizacionRoot;
            $scope.showSwitchRiesgo = false;
            AseguradoService.obtenerListaAsegurados(param).then(function(response){
                if(!response.data.error){

                    var asegurados=response.data.dato.lista;
                    $scope.listaAsegurados =asegurados;
                    if(typeof $scope.listaAsegurados != undefined && $scope.listaAsegurados != null && $scope.listaAsegurados.length > 0){
                        $scope.showSwitchRiesgo = true;
                    }

                }else{
                    Message.error(response.data.mensaje);
                }

            }, function(response){
                $scope.cargando=false;

                
            });
        };
        $scope.guardarAsegurados=function()
        {   
            /*var confirmParam = {
                header: 'CONFIRMAR' ,  
                body:'Está seguro que desea aplicar el asegurado '+$scope.aseguradoSelecionado.NOM_COMPLETO+' a todos los riesgos?'
            };
            var confirm = confirmService.showConfirm(confirmParam)*/
            var confirm = confirmService.showConfirm('Está seguro que desea aplicar el asegurado '+$scope.aseguradoSelecionado.NOM_COMPLETO+' a todos los riesgos?')
                .then(function(answer) {
                    /**
                     * EJECUTAR GUARDADO
                     */
                    
                    $scope.cargando=true;
                    var param ={
                        "numeroCotizacion": $scope.numeroCotizacionRoot,
                        "tipoDocumento":$scope.aseguradoSelecionado.TIP_DOCUM ,
                        "codigoDocumento": $scope.aseguradoSelecionado.COD_DOCUM
                    }
                    
                    RiesgoService.actualizarAsegurado(param).then(function(response){                        
                        if(response.data.error != true){
                            Message.ok("Proceso realizado con éxito para el asegurado: "+$scope.aseguradoSelecionado.NOM_COMPLETO);
                            $scope.disabledSwitchRiesgo = true;
                            $scope.todosAsegurados = 'N';
                            $scope.aseguradoSelecionado = null;
                            $scope.asegurado = null;
                            $scope.cargando=false;
                            $scope.obtenerRiesgos();
                        }else{
                            Message.error("No se pudo procesar la petición.");
                            $scope.cargando=false;
                            $scope.todosAsegurados = 'N';
                        }

                    }, function(response){
                        Message.error("No se pudo procesar la petición.");
                        $scope.cargando=false;
                        $scope.todosAsegurados = 'N';
                        
                    });
                }, function() {
                    $scope.todosAsegurados = 'N';
                    return;
                });
        };
        $scope.changeAsegurado=function(codigoDocumento)
        {
            $scope.aseguradoSelecionado = null;
            $scope.disabledSwitchRiesgo = true;
            if(typeof codigoDocumento != 'undefined' &&  codigoDocumento != null && codigoDocumento != ''){
                for(var i in $scope.listaAsegurados){
                    if($scope.listaAsegurados[i].COD_DOCUM == codigoDocumento){
                        $scope.aseguradoSelecionado = $scope.listaAsegurados[i];
                        $scope.disabledSwitchRiesgo = false;
                        break;
                    }
                }
            }
            for(var i in $scope.listaAsegurados){
                if($scope.listaAsegurados[i].COD_DOCUM == codigoDocumento){
                    $scope.aseguradoSelecionado = $scope.listaAsegurados[i];
                    $scope.disabledSwitchRiesgo = false;
                    break;
                }
            }
        };
        $scope.verificarPagina = function () {
            if ($scope.pagina == 1) {
                $scope.anterior = true;
            } else {
                $scope.anterior = false;
            }
            if ($scope.pagina == $scope.cantidadPaginas) {
                $scope.siguiente = true;
            } else {
                $scope.siguiente = false;

            }


        };
        $scope.cambiarPagina = function (p) {
            if($scope.pagina!=p){
                $scope.pagina = p;
                $scope.obtenerRiesgos();
            }
        };
        $scope.anteriorPagina = function () {
            if (!$scope.anterior) {
                if ($scope.pagina != 1) {
                    $scope.pagina--;
                }
                $scope.obtenerRiesgos();
            }

        };
        $scope.siguientePagina = function () {
            if (!$scope.siguiente) {
                if ($scope.pagina != $scope.totalItems) {
                    $scope.pagina++;
                    $scope.obtenerRiesgos();
                }
            }

        };
        $scope.eliminarPagina=function()
        {
            sessionStorage.removeItem("paginaRiesgoPropuesta");
        };
        (function initialize() {
            $rootScope.currentPage = 'sin-acciones';
            $rootScope.tabs = RiesgoService.getTabInicial();
            $scope.pathAgregar="/" +$location.$$path.split("/")[1] +"/riesgo-agregar/";
            //obtenerRiesgos();
            $scope.pathModule = UtilsService.retornarPath($location.path().split("/")[1]);
            $scope.rowCollection = [];
            $scope.itemsByPage =5;
            if (!angular.isUndefined($scope.numeroCotizacionRoot) && $scope.numeroCotizacionRoot!= null && $scope.numeroCotizacionRoot!=""){


                if (!angular.isUndefined(sessionStorage.getItem("paginaRiesgoPropuesta")) && sessionStorage.getItem("paginaRiesgoPropuesta") !=null)
                {
                    $scope.pagina=parseInt(sessionStorage.getItem("paginaRiesgoPropuesta"));
                    $scope.eliminarPagina();
                }
                $scope.numeroCotizacion =$scope.numeroCotizacionRoot;
                $scope.obtenerRiesgos();
                $scope.obtenerListaAsegurados();


            }else{
                RiesgoService.goToPropuestaOrigen($scope.pathModule.split("marcaModulo=")[1]);
                $scope.eliminarPagina();
            }


        })();


    }]);
;app.controller('SidebarFlotaCtrl', ['$scope','$controller','$route','$window', '$location','$rootScope', '$timeout', 'BaseService','UtilsService',
    function ($scope,$controller,$route, $window, $location, $rootScope, $timeout, baseService, UtilsService) {
       
        $scope.init=function(subtipo)
        {
            //console.log("Le llama a init");
            //console.log("tipo", $scope.subtipo);
        };
        $scope.verificarOpcionesMenuFlota=function()
        {            
            if($window.sessionStorage.getItem("asegurado_Flota")==null)
            {
                $scope.aseguradoFlota=false;
            }
            else
            {
                if ($window.sessionStorage["asegurado_Flota"]=="true")
                {
                $scope.aseguradoFlota=true;

                }
                else
                {
                    $scope.aseguradoFlota=false;
                }
            }
        };
        $scope.verificarOpcionesMenuVehiculos=function()
        {            
            if($window.sessionStorage.getItem("asegurado_Vehiculos")==null)
            {
                $scope.aseguradoVehiculo=false;
            }
            else
            {
                if ($window.sessionStorage["asegurado_Vehiculos"]=="true")
                {
                $scope.aseguradoVehiculo=true;

                }
                else
                {
                    $scope.aseguradoVehiculo=false;
                }
            }

        };
        $scope.setearEstilo=function()
        {
            var currentRoute=$location.path();
            //$scope.flotaHojas=1;
           
            if ($scope.subtipo=="Flota")
            {
                if (currentRoute.indexOf("hojas")!=-1)
                {
                    //debemos de pintar 
                    $scope.hojasFlota = true;
                }
                else if (currentRoute.indexOf("tomador")!=-1)
                {
                    $scope.flotaTomador=true;
                } 
                else if (currentRoute.indexOf("asegurado")!=-1)
                {
                    $scope.flotaAsegurado=true;
                }
                else if (currentRoute.indexOf("riesgo")!=-1)
                {
                    $scope.flotaRiesgo=true;
                } 
                else if (currentRoute.indexOf("riesgo-agregar")!=-1)
                {
                    $scope.flotaRiesgo=true;
                }               
                else if (currentRoute.indexOf("documentos")!=-1)
                {
                    $scope.flotaDocumentos=true;
                }
                else if (currentRoute.indexOf("propuesta")!=-1)
                {
                    $scope.flotaPropuesta=true;
                } 
                //console.log("Hojas ", $scope.flotaHojas);
            }
            if ($scope.subtipo=="Vehiculos")
            {
               // console.log("Tipo vehiculo");
                if (currentRoute.indexOf("hojas")!=-1)
                {
                    //debemos de pintar 
                    $scope.hojasVehiculo = true;
                }
                else if (currentRoute.indexOf("asegurado")!=-1)
                {
                    $scope.aseguradoVehiculo=true;
                }
                else if (currentRoute.indexOf("tomador")!=-1)
                {
                    $scope.tomadorVehiculo=true;
                }
                else if (currentRoute.indexOf("/vehiculo")!=-1)
                {
                   // console.log("Entra aca");
                    $scope.vehiculo=true;
                }               
                else if (currentRoute.indexOf("documentos")!=-1)
                {
                    $scope.documentosVehiculo=true;
                }
                else if (currentRoute.indexOf("/propuesta")!=-1)
                {
                    $scope.propuestaVehiculo=true;
                }
                
            }

            if ($scope.subtipo=="Propuesta Hogar")
            {
               // console.log("Tipo vehiculo");
                if (currentRoute.indexOf("hojas")!=-1)
                {
                    //debemos de pintar 
                    $scope.hojasVehiculo = true;
                }
                else if (currentRoute.indexOf("asegurado")!=-1)
                {
                    $scope.aseguradoVehiculo=true;
                }
                else if (currentRoute.indexOf("tomador")!=-1)
                {
                    $scope.tomadorVehiculo=true;
                }
                else if (currentRoute.indexOf("propuesta-hogar/propuesta")>0)
                {
                   // console.log("Entra aca");
                    $scope.propuestaHogar=true;
                }               
                else if (currentRoute.indexOf("documentos")!=-1)
                {
                    $scope.documentosVehiculo=true;
                }
                else if (currentRoute.indexOf("propuesta-hogar/hogar")>0)
                {
                    $scope.hogar=true;
                }
                
            }


            if ($scope.subtipo=="Multiriesgos")
            {
               // console.log("Tipo vehiculo");
                if (currentRoute.indexOf("hojas")!=-1)
                {
                    //debemos de pintar 
                    $scope.hojasVehiculo = true;
                }
                else if (currentRoute.indexOf("asegurado")!=-1)
                {
                    $scope.aseguradoVehiculo=true;
                }
                else if (currentRoute.indexOf("tomador")!=-1)
                {
                    $scope.tomadorVehiculo=true;
                }
                else if (currentRoute.indexOf("propuesta-multiriesgo/propuesta")>0)
                {
                   // console.log("Entra aca");
                    $scope.propuestaHogar=true;
                }               
                else if (currentRoute.indexOf("documentos")!=-1)
                {
                    $scope.documentosVehiculo=true;
                }
                else if (currentRoute.indexOf("propuesta-multiriesgo/multiriesgo")>0)
                {
                    $scope.hogar=true;
                }
                
            }
            
        };
        $scope.$on("cambiarMenuFlota", function (event, data) {
            
            $scope.verificarOpcionesMenuFlota();            
              });
              $scope.$on("cambiarMenuVehiculo", function (event, data) {
                     
                $scope.verificarOpcionesMenuVehiculos();      
        });
        
        $scope.goTo = function($event, url, tab){
            $rootScope.sigTab=tab;
            $rootScope.url_destino = url;
            $event.preventDefault();
            // /*control temporal*/
            // if (url.indexOf("hogar") !== -1){
            //     $scope.numeroCotizacionRoot = 2;
            // }
            
            if (!angular.isUndefined($scope.numeroCotizacionRoot) && $scope.numeroCotizacionRoot!= null && $scope.numeroCotizacionRoot!=""){
                switch ($rootScope.currentPage) {
                
                    case 'propuesta': 
                        if($scope.verificarGuardar()){                   
                            $scope.$parent.$parent.save($scope.$parent.$parent.PropuestaVehiculoForm);
                            //$scope.getCamposEditables(tab);
                        }else{
                            $scope.getCamposEditables(tab,url); 
                        }   
                        break;
                    case 'propuestaHogar': 
                        if($scope.verificarGuardar()){                   
                            $scope.$parent.$parent.save($scope.$parent.$parent.HogarPropuestaForm);
                            //$scope.getCamposEditables(tab);
                        }else{
                            $scope.getCamposEditables(tab,url); 
                        }   
                        break;  
                    case 'hogar':
                        if($scope.verificarGuardar()){                   
                            $scope.$parent.$parent.save($scope.$parent.$parent.PropuestaHogarForm);
                            //$scope.getCamposEditables(tab);
                        }else{
                            $scope.getCamposEditables(tab,url); 
                        }   
                        break;        
                    case 'vehiculo':
                        if($scope.verificarGuardar()){
                            $scope.$parent.$parent.save($scope.$parent.$parent.VehiculoForm);
                            //$scope.getCamposEditables(tab);
                        }else{
                            $scope.getCamposEditables(tab,url); 
                        }
                        break;
                    case 'tomador':
                        if($scope.verificarGuardar()){
                            if( $scope.verificarNulos($scope.$parent.$parent.modelo.tipoDocumento)  && 
                                $scope.verificarNulos($scope.$parent.$parent.modelo.nroDocumento) && 
                                $scope.verificarNulos($scope.$parent.$parent.modelo.nombres)){
                                $scope.$parent.$parent.save($scope.$parent.$parent.modeloForm); 
                                //$scope.getCamposEditables(tab);
                            }else{
                                $scope.getCamposEditables(tab,url);
                            }
                        }else{
                            $scope.getCamposEditables(tab,url);
                        }
                        break;
                    case 'asegurado':
                        if($scope.verificarGuardar()){
                            if( $scope.verificarNulos($scope.$parent.$parent.modelo.tipoDocumento)  &&
                                $scope.verificarNulos($scope.$parent.$parent.modelo.nroDocumento) &&
                                $scope.verificarNulos($scope.$parent.$parent.modelo.nombres)){
                                $scope.$parent.$parent.save($scope.$parent.$parent.modeloForm);
                                //$scope.getCamposEditables(tab);
                            }else{
                                $scope.getCamposEditables(tab,url);
                            }
                        }else{
                            $scope.getCamposEditables(tab,url);
                        }
                        break;
                    case 'hojaAnexa':
                        if($scope.verificarGuardar()){
                            $scope.$parent.$parent.guardarHojasAnexas();
                            //$scope.getCamposEditables(tab);
                        }else{
                            $scope.getCamposEditables(tab,url); 
                        }
                        break;
                    case 'documento':
                        $scope.getCamposEditables(tab,url);
                        break;
                    case 'riesgo':
                        if($scope.verificarGuardar()){
                            $scope.$parent.$parent.actualizar();
                            //$scope.getCamposEditables(tab);
                        }else{
                            $scope.getCamposEditables(tab,url);
                        }
                        break;
                    case 'propuestaMultiriesgo':
                        if($scope.verificarGuardar()){                   
                            $scope.$parent.$parent.save($scope.$parent.$parent.MultiriesgoPropuestaForm);
                           
                        }else{
                            $scope.getCamposEditables(tab,url); 
                        }   
                        break; 
                    case 'propuestaRiesgo':
                        if($scope.verificarGuardar()){                   
                            $scope.$parent.$parent.save($scope.$parent.$parent.RiesgoForm);
                           
                        }else{
                            $scope.getCamposEditables(tab,url); 
                        }   
                        break;     

                    default:
                        $scope.getCamposEditables(tab,url);
                        break;
                };
            }else{
                Message.warning("Debe seleccionar un número de cotización para continuar");
            }
            
        };

        $scope.verificarNulos = function(propiedad){            
            if(typeof propiedad != 'undefined' && propiedad != null && propiedad != ''){
                return true;

            }
            return false;
        };
        $scope.redirectWait = function(){
            $location.path($rootScope.url_destino);
        };
        $scope.getCamposEditables = function(tab,pathModule){
            if($scope.verificarNulos(tab)){
                var paramsEditables={};
                paramsEditables.marcaFlota=$scope.subtipo=='Flota'?'S':'N';
                paramsEditables.pathModule=UtilsService.retornarPath(pathModule.split("/")[0]);
                paramsEditables.numeroCotizacion=angular.isUndefined($rootScope.numeroCotizacionRoot)|| $rootScope.numeroCotizacionRoot==null?"":$rootScope.numeroCotizacionRoot;
                paramsEditables.tab=tab;
                baseService.getCamposEditablesList(paramsEditables);                
            }

            // SE ESPERA 1 (UN) SEGUNDO LUEGO DE EJECUTAR EL GUARDAR ANTES DE HACER LA REDIRECCION
            $timeout($scope.redirectWait, 1000);
        };
        $scope.verificarGuardar = function(){
            return $scope.$parent.$parent.verificarCamposForm($rootScope.camposEditablesList, 'guardar');
        };

        (function initialize() {

              $scope.datoT=50;
             $scope.datoTooltip=$scope.datoT +"% completado.";
           
            //$scope.flotaHojas=0;
            $scope.verificarOpcionesMenuFlota();
            $scope.setearEstilo();
        })();
        
    }]);
;app.controller('TomadorFormCtrl', 
            ['$scope','$controller', 'TomadorService','$route','$q','$filter','$window','$mdDialog','$location','$rootScope','AseguradoService','CotizacionVehiculoPropuestaService', 'UtilsService', '$location','PropuestaService','$log','$timeout',
    function ($scope,$controller, TomadorService, $route,$q,$filter, $window, $mdDialog, SidebarFlotaCtrl,$rootScope,AseguradoService,CotizacionVehiculoPropuestaService, UtilsService, $location,PropuestaService, $log, $timeout ) {
    $rootScope.rootPathParent =$route.current.$$route.originalPath;
    $scope.controlPermisos = true;
    $scope.modelo={};
    $scope.modelo.tipoDocumento=undefined;
    $scope.modelo.nroDocumento=undefined;
    $scope.modelo.personaFisica="S";
    $scope.modelo.nombres=undefined;
    $scope.modelo.apellido1=undefined;
    $scope.modelo.apellido2=undefined;
    $scope.modelo.sexo="1";
    $scope.modelo.estadoCivil=undefined;
    $scope.modelo.nacionalidad=undefined;
    $scope.modelo.fechaNacimiento= undefined;
    $scope.modelo.profesion=undefined;
    $scope.modelo.actividad=undefined;
    $scope.modelo.direccion1=undefined;
    $scope.modelo.direccion2=undefined;
    $scope.modelo.direccion3=undefined;
    $scope.modelo.ciudad=undefined;
    $scope.modelo.barrio=undefined;
    $scope.modelo.telefonoPais="595";
    $scope.modelo.telefonoPrefijo=undefined;
    $scope.modelo.telefono=undefined;
    $scope.modelo.fax=undefined;
    $scope.modelo.email=undefined;
    $scope.modelo.telMovil=undefined;
    $scope.modelo.datosDomicilioParticular='1';
    $scope.modelo.direccionLaboral1=undefined;
    $scope.modelo.direccionLaboral2=undefined;
    $scope.modelo.direccionLaboral3=undefined;
    $scope.modelo.ciudadLaboral=undefined;
    $scope.modelo.barrioLaboral=undefined;
    $scope.modelo.telefonoLaboralPais="595";
    $scope.modelo.telefonoLaboralPrefijo=undefined;
    $scope.modelo.telefonoLaboral=undefined;
    $scope.modelo.faxLaboral=undefined;
    $scope.modelo.emailLaboral=undefined;
    $scope.modelo.mcaBloquedo=undefined;
    $rootScope.nroPropuesta=undefined;
    $scope.modelo.correspondencia='1';
    $scope.modelo.asegurado="'N'";
    $scope.tiposDocumentos=[];
    $scope.estadoCiviles=[];
    $scope.profesiones=[];
    $scope.actividades=[];
    $scope.nacionalidades=[];
    $scope.ciudades=[];
    $scope.barrios=[];
    $scope.barriosLaboral=[];
    $scope.ciudadesLaboral=[];
    $scope.desactivar=false;
    $scope.loading=false;
    $scope.esPersona=false;
    $scope.service = PropuestaService;
    $scope.emailFormat = /^[a-z]+[a-z0-9._]+@[a-z]+\.[a-z]+(\.[a-z]{2})?$/;
    $scope.tomador={};
    $scope.tomador.plataforma=null;
    $scope.valorBarrioParticular=undefined;
    $scope.valorBarrioLaboral=undefined;
    $rootScope.marcaTercero=false;
    $scope.camposTercero={};
    $scope.validPatternE=true;
    $scope.validPatternEl=true;
    $scope.validarEmail=function(email)
    {
        if (email!=null && email!="" && email.lastIndexOf("*")>0)
        {
           return false
        }
        return true;

    };

    $scope.formatearFecha=function(fecha)
      {
         $scope.aplicarFormato(fecha);
      };

    $scope.submitted = false;
    $scope.tab="TOMADOR";
    $scope.sinc=0; /**variable que almcena las promesas resueltas o fracasadas*/
    var cantModeloSinc=0; /**variable que almacena la cantidad de datos que vienen en el buscar, que requieren otras llamadas de promesas**/
    $scope.cambiarTab=0;
    $scope.obtenerCamposRequeridos=function()
    {
        var subtipo = "Flota";
        if ($scope.subtipo == "Vehiculos") subtipo = "Vehiculo";
        $scope.camposRequeridosList = [];
        TomadorService.getCamposRequeridos(subtipo, $scope.tipo.toUpperCase()).then(function(response){
            //console.log("RESPONSE: " + JSON.stringify(response));
           if (!response.data.error)
           {
                //console.log("LENGTH RESPONSE: " + response.data.dato.length);
               if (response.data.dato.length>0)
               {
                   var campos=response.data.dato;
                   for (var i=0; i< campos.length; i++)
                   {
                       $scope.camposRequeridosList.push(campos[i]);
                   }
               }

           }
           else
               {
               Message.error(response.data.mensaje);
           }
        });
    };

    $scope.verificarCamposForm=function(listaCampo, campo)
    {
       // console.log("campo: ", campo);
       return UtilsService.verificarCamposForm(listaCampo, campo);
    };

    $scope.bloquearCamposTercero=function(listaCampo, campo,camposTercero)
    {
       // console.log("campo: ", campo);
       return UtilsService.bloquearCamposTercero(listaCampo, campo,camposTercero);
    };


    

        
    $scope.igualarDatos=function()
    {

        if ($scope.modelo.datosDomicilioParticular=="2")
        {
            $scope.desactivar=true;
            //hay que copiar lo que hay en datos particulares a datos laborales
            $scope.modelo.direccionLaboral1=$scope.modelo.direccion1;
            $scope.modelo.direccionLaboral2=$scope.modelo.direccion2;
            $scope.modelo.direccionLaboral3=$scope.modelo.direccion3;
            $scope.modelo.ciudadLaboral=$scope.modelo.ciudad;
            $scope.barriosLaboral=$scope.barrios;
            $scope.modelo.telefonoLaboral=$scope.modelo.telefono;
            $scope.modelo.telefonoLaboralPrefijo=$scope.modelo.telefonoPrefijo;
            $scope.modelo.telefonoLaboralPais=$scope.modelo.telefonoPais;
            $scope.modelo.emailLaboral=$scope.modelo.email;
            $scope.modelo.faxLaboral=$scope.modelo.fax;
            $scope.modelo.barrioLaboral=$scope.modelo.barrio;

        }
        else
        {
            $scope.desactivar=false;
            $scope.modelo.direccionLaboral1=undefined;
            $scope.modelo.direccionLaboral2=undefined;
            $scope.modelo.direccionLaboral2=undefined;
            $scope.modelo.direccionLaboral3=undefined;
            $scope.modelo.ciudadLaboral=undefined;
            $scope.modelo.barrioLaboral=undefined;
            $scope.modelo.telefonoLaboral=undefined;
            $scope.modelo.telefonoLaboralPrefijo=undefined;
            $scope.modelo.telefonoLaboralPais=undefined;
            $scope.modelo.emailLaboral=undefined;
            $scope.modelo.faxLaboral=undefined;
        }
    };
    $scope.refrescarDatos=function()
    {
      if ($scope.modelo.datosDomicilioParticular=="2")
      {
          $scope.desactivar=true;
          //hay que copiar lo que hay en datos particulares a datos laborales
          $scope.modelo.direccionLaboral1=$scope.modelo.direccion1;
          $scope.modelo.direccionLaboral2=$scope.modelo.direccion2;
          $scope.modelo.direccionLaboral3=$scope.modelo.direccion3;
          $scope.modelo.ciudadLaboral=$scope.modelo.ciudad;
          $scope.barriosLaboral=$scope.barrios;
          $scope.modelo.telefonoLaboral=$scope.modelo.telefono;
          $scope.modelo.telefonoLaboralPrefijo=$scope.modelo.telefonoPrefijo;
          $scope.modelo.telefonoLaboralPais=$scope.modelo.telefonoPais;
          $scope.modelo.emailLaboral=$scope.modelo.email;
          $scope.modelo.faxLaboral=$scope.modelo.fax;
          $scope.modelo.barrioLaboral=$scope.modelo.barrio;
      }
    };
   
  
    $scope.mostrarMensaje=function(ev)
    {
        //$window.sessionStorage.setItem("asegurado","true");
        if ($scope.modelo.asegurado=="'S'")
        {
            //console.log("Bloquear menu de asegurado");
            $window.sessionStorage.setItem("asegurado"+"_"+$scope.subtipo,true);
            //mostrar popup
            
            $mdDialog.show(
                $mdDialog.alert()
                  .parent(angular.element(document.querySelector('#popupContainer')))
                  .clickOutsideToClose(true)
                  .title('Aviso')
                  .textContent('Este campo ya no es requerido, no necesita ser cargado!')
                  .ariaLabel('Alert Dialog Demo')
                  .ok('Aceptar')
                  .targetEvent(ev)
              );

        }
        else
        {
            $window.sessionStorage.setItem("asegurado"+"_"+$scope.subtipo,false);
           
        }
        if ($scope.subtipo=="Flota")
        {
            $scope.$broadcast("cambiarMenuFlota", "Event");
        }
        else
        {
            $scope.$broadcast("cambiarMenuVehiculo", "Event");
        }
    };
       var promesaBarrios= $q.defer();
    $scope.cambiarBarrio=function(tag)
    {

            if(!angular.isUndefined($scope.modelo.ciudad) && $scope.modelo.ciudad !== ""){
                    if (tag=='S')
                    {
                        $scope.modelo.barrio=undefined;
                    }
                    for(var i=0; i<$scope.ciudades.length; i++){
                        if ($scope.ciudades[i].id==$scope.modelo.ciudad){
                            $scope.codigoEstado= $scope.ciudades[i].COD_ESTADO;
                            break;
                        }
                    }
                    if ($scope.modelo.ciudad!=null && $scope.modelo.ciudad!="")
                    {
                        var parametros = {};
                        parametros.codigo=$scope.modelo.ciudad;
                        TomadorService.getBarrios(parametros).then(function(response) {
                            if (!response.data.error)
                            {
                                $scope.barrios=[];
                                if (response.data.dato!=null)
                                {
                                    if (response.data.dato.length > 0) {
                                        var data = response.data.dato;
                                        for (var i = 0; i < data.length; i++) {
                                            $scope.barrios.push(data[i]);
                                        }
                                        promesaBarrios.resolve();

                                    } else {

                                        Message.info("No se pudo obtener los barrios");
                                        promesaBarrios.resolve();
                                    }
                                }


                            }
                            else
                            {
                                promesaBarrios.resolve();
                                Message.error(response.data.mensaje);
                            }



                        }).catch(function(error){
                            Message.error("Ocurrió un error al obtener la lista de barrios ");
                            promesaBarrios.reject();
                            $scope.modelo.barrio=$scope.valorBarrioParticular;
                            $scope.incrementarSincronizador($scope.valorBarrioParticular);
                        });
                        $scope.refrescarDatos();
                    }




            }
    };
    var promesaBarriosLaboral= $q.defer();
    $scope.cambiarBarrioLaboral=function(desdeHtml)
    {
            if(!angular.isUndefined($scope.modelo.ciudadLaboral) && $scope.modelo.ciudadLaboral !== ""){
                if (desdeHtml=='S')
                {
                    $scope.modelo.barrioLaboral=undefined;
                }
                for(var i=0; i<$scope.ciudadesLaboral.length; i++){
                    if ($scope.ciudadesLaboral[i].id==$scope.modelo.ciudadLaboral){
                        $scope.codigoEstadoCom= $scope.ciudadesLaboral[i].COD_ESTADO;
                        break;
                    }
                }
                if ($scope.modelo.ciudadLaboral!=null)
                {
                    var parametros = {};
                    parametros.codigo=$scope.modelo.ciudadLaboral;
                    TomadorService.getBarrios(parametros).then(function(response){
                        if (!response.data.error)
                        {
                            $scope.barriosLaboral=[];
                            if (response.data.dato!=null)
                            {
                                if (response.data.dato.length>0) {
                                    var data=response.data.dato;
                                    for (var i=0; i<data.length;i++){
                                        $scope.barriosLaboral.push(data[i]);

                                    }
                                    promesaBarriosLaboral.resolve();

                                }else{
                                    promesaBarriosLaboral.resolve();
                                    Message.info("No se pudo obtener la lista de barrios");
                                }
                            }


                        }
                        else
                        {
                            promesaBarriosLaboral.resolve();
                            Message.error(response.data.mensaje);
                        }

                    }).catch(function(error){
                        Message.error("Ocurrió un error al obtener la lista de barrios ");
                        promesaBarriosLaboral.reject();
                        $scope.modelo.barrioLaboral=$scope.valorBarrioLaboral;
                        $scope.incrementarSincronizador($scope.modelo.barrioLaboral);
                    });
                    $scope.refrescarDatos();
                }

            }
            else{
                $scope.modelo.barrioLaboral=undefined;
                $scope.barriosLaboral=[];

            }
    };
    $scope.verificarRecargaPagina=function()
    {
        if ($window.performance)
        {
            //console.log("Window performance funciona para el navegador");
        }
        if (performance.navigation.type==1)
        {
            //console.log("Esta pagina fue recargada");
            var nombre="asegurado"+"_"+$scope.subtipo;
            //console.log(nombre);
            $window.sessionStorage.removeItem(nombre);
            /*if ($scope.subtipo=="Flota")
            {
                $rootScope.aseguradoFlota=false;
            }
            else
            {
                $rootScope.aseguradoVehiculos=false;
            }*/
        }

    };
    $scope.obtenerDatosInicio=function()
    {
        var paramValue = $route.current.$$route.tipo;
        //console.log("tipo ",paramValue);
        $scope.tipo=$route.current.$$route.tipo;
        $scope.subtipo = $route.current.$$route.subtipo;
        //console.log("subtipo ",$scope.subtipo);

        if($scope.subtipo=="Flota")
        {
            //aca debemos de redirigirle a una pagina que le diga sin asegurado
        }
    };
    $scope.obtenerPersona=function()
    {
      if(!angular.isUndefined($scope.modelo.nroDocumento)&& $scope.modelo.nroDocumento!=null && $scope.modelo.nroDocumento!="" ){
           $scope.loading=true;
         var parametros={};
         parametros.tipoDoc=$scope.modelo.tipoDocumento;
         parametros.codigoDoc=$scope.modelo.nroDocumento;
         TomadorService.getPersona(parametros).then(function(response){
             $scope.loading=false;
             if (!response.data.error)
             {
                if (response.data.dato!=null)
                {
                    $rootScope.marcaTercero=true;
                    $scope.camposTercero=response.data.dato;
                    if (response.data.dato.tipoDocumento==null && response.data.dato.codigoDocumento==null)
                    {
                        Message.error("Los datos ingresados de la persona, no fueron encontrados!");
                        $scope.setearPersona(response.data.dato);
                    }
                    else {
                        $scope.setearPersona(response.data.dato);
                    }

                }
                else
                {
                   Message.error("Los datos ingresados de la persona, no fueron encontrados!");
                   //$scope.limpiarDatosPersona();
                }
             }
             else
             {
                 $rootScope.marcaTercero=false;
                Message.error(response.data.mensaje);
             }
            
             
         },
         function(error){
             Message.error("Ocurrió un error al realizar la operación");
             //console.error(response);
        })
         //llamar al loading
      }else{

      }
         

    };
    $scope.limpiarDatosPersona=function()
    {   
        $scope.modelo.tipoDocumento=undefined;
        $scope.modelo.nroDocumento=undefined;
        $scope.modelo.personaFisica="S";
        $scope.modelo.nombres=undefined;
        $scope.modelo.apellido1=undefined;
        $scope.modelo.apellido2=undefined;
        $scope.modelo.sexo="1";
        $scope.modelo.estadoCivil=undefined;
        $scope.modelo.nacionalidad=undefined;
        $scope.modelo.fechaNacimiento= undefined;
        $scope.modelo.profesion=undefined;
        $scope.modelo.actividad=undefined;
        $scope.modelo.direccion1=undefined;
        $scope.modelo.direccion2=undefined;
        $scope.modelo.direccion3=undefined;
        $scope.modelo.ciudad=undefined;
        $scope.modelo.barrio=undefined;
        $scope.modelo.telefonoPais=undefined;
        $scope.modelo.telefonoPrefijo=undefined;
        $scope.modelo.telefono=undefined;
        $scope.modelo.fax=undefined;
        $scope.modelo.email=undefined;
        $scope.modelo.telMovil=undefined;
        $scope.modelo.datosDomicilioParticular='1';
        $scope.modelo.direccionLaboral=undefined;
        $scope.modelo.ciudadLaboral=undefined;
        $scope.modelo.barrioLaboral=undefined;
        $scope.modelo.telefonoLaboralPais=undefined;
        $scope.modelo.telefonoLaboralPrefijo=undefined;
        $scope.modelo.telefonoLaboral=undefined;
        $scope.modelo.faxLaboral=undefined;
        $scope.modelo.emailLaboral=undefined;
        $scope.modelo.mcaBloquedo=undefined;
    
    };
    $scope.setearPersona=function (data)
    {
        $scope.esPersona=true;
        $scope.modelo.nombres=data.nombre;
        $scope.modelo.apellido1=data.primerApellido;
        $scope.modelo.apellido2=data.segundoApellido;
        $scope.modelo.sexo=data.marcaSexo==null?"1":data.marcaSexo;
        $scope.modelo.personaFisica=data.marcaFisico==null?"S":data.marcaFisico;
        $scope.modelo.estadoCivil=data.codigoEstadoCivil!="" && data.codigoEstadoCivil!=null?data.codigoEstadoCivil:undefined;
        $scope.modelo.nacionalidad=data.codigoNacionalidad!="" && data.codigoNacionalidad!=null ?data.codigoNacionalidad:undefined;
        $scope.modelo.profesion=data.codigoProfesion!=null &&  data.codigoProfesion!=""? parseInt(data.codigoProfesion):undefined;
        $scope.modelo.actividad=data.codigoActividad!=null && data.codigoActividad!=""?parseInt(data.codigoActividad):undefined;
       // $scope.modelo.fechaNacimiento=data.FEC_NACIMIENTO!=null?$scope.convertirDate(data.FEC_NACIMIENTO):null;
        $scope.modelo.fechaNacimiento=angular.isUndefined(data.fechaNacimiento)?undefined:data.fechaNacimiento!=null && data.fechaNacimiento!=""? $scope.convertirDate(data.fechaNacimiento):undefined;
        //$scope.modelo.estadoCivil=data.COD_EST_CIVIL;
        $scope.modelo.direccion1=data.primeraDireccion;
        $scope.modelo.direccion2=data.segundaDireccion;
        $scope.modelo.direccion3=data.terceraDireccion;
        $scope.modelo.ciudad= data.codigoCiudad==""  || data.codigoCiudad==null?null:parseInt(data.codigoCiudad);
        $scope.modelo.telefonoPais=data.codigoPaisTelefono==null?"595":data.codigoPaisTelefono;
        $scope.modelo.telefonoPrefijo=data.codigoCiudadTelefono;
        $scope.modelo.telefono=data.numeroTelefono;
        $scope.modelo.codigoPais=data.codigoPais;
        $scope.modelo.fax=data.numeroFax;
        $scope.modelo.email=data.email;
        $scope.validPatternE=$scope.validarEmail($scope.modelo.email);
        $scope.modelo.barrio=data.codigoBarrio=="" || data.codigoBarrio==null?null:parseInt(data.codigoBarrio);
        $scope.cambiarBarrio('N');
        var encuentBarr=false
        promesaBarrios.promise.then (function ()
        {
            if ($scope.modelo.barrio !=null)
            {
                for (var i=0; i< $scope.barrios.length;i++)
                {
                    if ($scope.barrios[i].COD_LOCALIDAD==$scope.modelo.barrio)
                    {
                        encuentBarr=true;
                        break;
                    }
                }
                if (encuentBarr==false)
                {
                    $scope.modelo.barrio=null;
                }
            }

        });
        $scope.modelo.direccionLaboral1=data.primeraDireccionCom;
        $scope.modelo.direccionLaboral2=data.segundaDireccionCom;
        $scope.modelo.direccionLaboral3=data.terceraDireccionCom;
        $scope.modelo.ciudadLaboral=data.codigoCiudadCom=="" || data.codigoCiudadCom==null?null:parseInt(data.codigoCiudadCom);
        $scope.modelo.telefonoLaboralPais=data.codigoPaisTelefonoCom==null?"595":data.codigoPaisTelefonoCom;
        $scope.modelo.telefonoLaboralPrefijo=data.codigoCiudadTelefonoCom;
        $scope.modelo.telefonoLaboral=data.numeroTelefonoCom;
        $scope.modelo.faxLaboral=data.numeroFaxCom;
        $scope.modelo.emailLaboral=data.emailCom;
        $scope.validPatternEl=$scope.validarEmail($scope.modelo.emailLaboral);
        $scope.modelo.barrioLaboral=data.codigoBarrioCom=="" || data.codigoBarrioCom==null ?null:parseInt(data.codigoBarrioCom);
        $scope.modelo.telMovil=data.numeroMovil;
        var encuentBarrLab=false;
        $scope.cambiarBarrioLaboral('N');
        promesaBarrios.promise.then (function ()
        {
            if ($scope.modelo.barrioLaboral !=null)
            {
                for (var i=0; i< $scope.barrios.length;i++)
                {
                    if ($scope.barrios[i].COD_LOCALIDAD==$scope.modelo.barrioLaboral)
                    {
                        encuentBarrLab=true
                        break;
                    }
                }
                if (encuentBarrLab==false)
                {
                    $scope.modelo.barrioLaboral=null;
                }
            }

        });
        $rootScope.marcaTercero=false;
        $scope.modelo.datosDomicilioParticular=data.igualarDireccionCorrespondencia!=null? data.igualarDireccionCorrespondencia=="N"?"1":"2":"1";

        
    };

    $scope.save = function(clickButton){
        $scope.numeroCotizacion = $scope.numeroCotizacionRoot;
        var obejtoAEnviar ={};
        obejtoAEnviar.numeroCotizacion=$scope.numeroCotizacion;//218631;
        obejtoAEnviar.tipoDocumento=angular.isUndefined($scope.modelo.tipoDocumento)?null:$scope.modelo.tipoDocumento;
        obejtoAEnviar.codigoDocumento=angular.isUndefined($scope.modelo.nroDocumento)?null:$scope.modelo.nroDocumento;
        obejtoAEnviar.marcaFisico=angular.isUndefined($scope.modelo.personaFisica)?null:$scope.modelo.personaFisica;
        obejtoAEnviar.nombre=angular.isUndefined($scope.modelo.nombres)?null:$scope.modelo.nombres;
        obejtoAEnviar.primerApellido=angular.isUndefined($scope.modelo.apellido1)?null:$scope.modelo.apellido1;
        obejtoAEnviar.segundoApellido=angular.isUndefined($scope.modelo.apellido2)?null:$scope.modelo.apellido2;
        obejtoAEnviar.marcaSexo=angular.isUndefined($scope.modelo.sexo)?null:$scope.modelo.sexo;
        obejtoAEnviar.codigoEstadoCivil=angular.isUndefined($scope.modelo.estadoCivil)?null:$scope.modelo.estadoCivil;
        obejtoAEnviar.codigoNacionalidad=angular.isUndefined($scope.modelo.nacionalidad)?null:$scope.modelo.nacionalidad;
        obejtoAEnviar.fechaNacimiento= angular.isUndefined($scope.modelo.fechaNacimiento)?null:$scope.modelo.fechaNacimiento!=null ?moment($scope.modelo.fechaNacimiento).format("DD/MM/YYYY"):null;
        obejtoAEnviar.codigoProfesion=angular.isUndefined($scope.modelo.profesion)?null:$scope.modelo.profesion;
        obejtoAEnviar.codigoActividad=angular.isUndefined($scope.modelo.actividad)?null:$scope.modelo.actividad;
        obejtoAEnviar.primeraDireccion=angular.isUndefined($scope.modelo.direccion1)?null:$scope.modelo.direccion1;
        obejtoAEnviar.segundaDireccion=angular.isUndefined($scope.modelo.direccion2)?null:$scope.modelo.direccion2;
        obejtoAEnviar.terceraDireccion=angular.isUndefined($scope.modelo.direccion3)?null:$scope.modelo.direccion3;
        obejtoAEnviar.codigoPais=angular.isUndefined($scope.modelo.codigoPais)?null:$scope.modelo.codigoPais;
        
        obejtoAEnviar.codigoEstado=angular.isUndefined($scope.codigoEstado)?null: $scope.codigoEstado!=null ? $scope.codigoEstado:null;
        obejtoAEnviar.codigoCiudad=angular.isUndefined($scope.modelo.ciudad)?null: $scope.modelo.ciudad !=null? $scope.modelo.ciudad:null;
        obejtoAEnviar.codigoBarrio=angular.isUndefined($scope.modelo.barrio)?null:$scope.modelo.barrio!=null?$scope.modelo.barrio:null;
        obejtoAEnviar.codigoPaisTelefono=angular.isUndefined($scope.modelo.telefonoPais)?null:$scope.modelo.telefonoPais;
        obejtoAEnviar.codigoCiudadTelefono=angular.isUndefined($scope.modelo.telefonoPrefijo)?null:$scope.modelo.telefonoPrefijo;
        obejtoAEnviar.numeroTelefono=angular.isUndefined($scope.modelo.telefono)?null:$scope.modelo.telefono;
        obejtoAEnviar.numeroFax=angular.isUndefined($scope.modelo.fax)?null:$scope.modelo.fax;
        obejtoAEnviar.numeroMovil=angular.isUndefined($scope.modelo.telMovil)?null:$scope.modelo.telMovil;
        obejtoAEnviar.email=angular.isUndefined($scope.modelo.email)?null:$scope.modelo.email;
        obejtoAEnviar.primeraDireccionCom=angular.isUndefined($scope.modelo.direccionLaboral1)?null:$scope.modelo.direccionLaboral1;
        obejtoAEnviar.segundaDireccionCom=angular.isUndefined($scope.modelo.direccionLaboral2)?null:$scope.modelo.direccionLaboral2;
        obejtoAEnviar.terceraDireccionCom=angular.isUndefined($scope.modelo.direccionLaboral3)?null:$scope.modelo.direccionLaboral3;
        obejtoAEnviar.codigoPaisCom=angular.isUndefined($scope.modelo.ciudadLaboral)?null:$scope.modelo.ciudadLaboral!=null?$scope.modelo.ciudadLaboral.COD_PAIS:null;
        obejtoAEnviar.codigoEstadoCom=angular.isUndefined( $scope.codigoEstadoCom)?null:$scope.codigoEstadoCom!= null?$scope.codigoEstadoCom:null;
        obejtoAEnviar.codigoCiudadCom=angular.isUndefined($scope.modelo.ciudadLaboral)?null:$scope.modelo.ciudadLaboral !=null?$scope.modelo.ciudadLaboral:null;
        obejtoAEnviar.codigoBarrioCom=angular.isUndefined($scope.modelo.barrioLaboral)?null:$scope.modelo.barrioLaboral!=null?$scope.modelo.barrioLaboral:null;
        obejtoAEnviar.codigoPaisTelefonoCom=angular.isUndefined($scope.modelo.telefonoLaboralPais)?null:$scope.modelo.telefonoLaboralPais;
        obejtoAEnviar.codigoCiudadTelefonoCom=angular.isUndefined($scope.modelo.telefonoLaboralPrefijo)?null:$scope.modelo.telefonoLaboralPrefijo;
        obejtoAEnviar.numeroTelefonoCom=angular.isUndefined($scope.modelo.telefonoLaboral)?null:$scope.modelo.telefonoLaboral;
        obejtoAEnviar.numeroFaxCom=angular.isUndefined($scope.modelo.faxLaboral)?null:$scope.modelo.faxLaboral;
        obejtoAEnviar.emailCom=angular.isUndefined($scope.modelo.emailLaboral)?null:$scope.modelo.emailLaboral;
        obejtoAEnviar.tipoBeneficiario=$scope.tipo=="Asegurado"?2:0;
        obejtoAEnviar.igualarTomadorAsegurado=angular.isUndefined($scope.modelo.asegurado)?"N":$scope.modelo.asegurado;
        obejtoAEnviar.igualarDireccionCorrespondencia=angular.isUndefined($scope.modelo.datosDomicilioParticular)?null:$scope.modelo.datosDomicilioParticular;
        obejtoAEnviar.marcaDireccionCorrespondecia = angular.isUndefined($scope.modelo.correspondencia)?null:$scope.modelo.correspondencia;
        obejtoAEnviar.marcaModulo = angular.isUndefined($scope.pathModule)?null:$scope.pathModule.split("marcaModulo=")[1];


        var param = JSON.stringify(obejtoAEnviar);
        $scope.loading=true;

        if( $scope.path==="/propuesta-flota/asegurado-agregar"){
            if(sessionStorage.getItem('metodo')==='edicion'){
                 AseguradoService.actualizarAsegurado(obejtoAEnviar).then(
                    //sucess
                    function (response) {
                           
                        if(!response.data.error){
                            $location.url("propuesta-flota/asegurado");
                            Message.ok(response.data.mensaje);
                        }else{
                               Message.error(response.data.mensaje);

                        }
                         $scope.loading=false;


                            
                        //error
                    }).catch(function(response){
                         $scope.loading=false;
                        Message.error("Ocurrió un error al realizar la operación");
                        //console.error(response);
                    });
            }else{
                 AseguradoService.guardarAsegurado(obejtoAEnviar).then(
                    //sucess
                    function (response) {
                           
                        if(!response.data.error){

                            Message.ok(response.data.mensaje);
                            $location.url("propuesta-flota/asegurado");
                        }else{
                               Message.error(response.data.mensaje);
                               //console.error(response);
                        }
                         $scope.loading=false;    
                        //error
                    }).catch(function(response){
                          $scope.loading=false;
                     Message.error("Ocurrió un error al realizar la operación");
                     //console.error(response);
                    });

            }



        }else{

            TomadorService.guardarPropuestaTomadorAsegurado(obejtoAEnviar).then(
            //sucess
            function (response) {
                   
                if(!response.data.error){
                    if ($scope.modelo.asegurado=="'S'") {
                        $rootScope.llamarAsegurado = false;
                    }
                    else
                    {
                        $rootScope.llamarAsegurado = true;
                        $window.sessionStorage.setItem("asegurado"+"_"+$scope.subtipo,false);
                    }
                    if (clickButton=="S")
                    {
                        var param ={};
                        param.numeroCotizacion=$scope.numeroCotizacion;
                        param.marcaFlota=$scope.subtipo=='Flota'?'S':'N';
                        param.tab=$scope.tab;
                        param.pathModule=$scope.pathModule;
                        PropuestaService.getTabs(param);
                    }
                    else
                    {
                        $scope.cambiarTab=1;
                    }
                    Message.ok(response.data.mensaje);
                }else{
                       Message.error(response.data.mensaje);
                       $scope.cambiarTab=2;
                       //console.error(response);
                }
                 $scope.loading=false; 
                //error
            }).catch(function(response){
                 $scope.loading=false;
                $scope.cambiarTab=2;
                Message.error("Ocurrió un error al realizar la operación");
                //console.error(response);
            });

        };


        



    };

     $scope.buscar = function() {
         $scope.numeroCotizacion =  $scope.numeroCotizacionRoot;
         var paramEditables ={};
         paramEditables.numeroCotizacion=$scope.numeroCotizacion;
         paramEditables.marcaFlota=$scope.subtipo=='Flota'?'S':'N';
         paramEditables.tab=$scope.tab;
         paramEditables.pathModule=$scope.pathModule;

            //$rootScope.camposRequeridosList=[];
           if(!angular.isUndefined($scope.numeroCotizacion)){
              if($scope.numeroCotizacion!=null && $scope.numeroCotizacion!=""){
                 $scope.loading=true; 

                   var param ={};
                   param.numeroCotizacion=$scope.numeroCotizacion;  
                   param.tipoBeneficiario=$scope.tipo=="Asegurado"?2:0;
                   param.marcaFlota=$scope.subtipo=='Flota'?'S':'N';
                   param.pathModule=$scope.pathModule;
                  $scope.sinc=0;
                  cantModeloSinc=0;
                  if (param.tipoBeneficiario==2)
                  {
                      $rootScope.currentPage="asegurado";
                  }
                  if( $scope.path==="/propuesta-flota/asegurado-agregar"){
                        paramEditables.tipoDocumento=angular.isUndefined($scope.modelo.tipoDocumento)?null:$scope.modelo.tipoDocumento!=null?$scope.modelo.tipoDocumento:null;
                        paramEditables.codigoDocumento=angular.isUndefined($scope.modelo.nroDocumento)?null:$scope.modelo.nroDocumento!=null?$scope.modelo.nroDocumento:null;
                        //param.marcaFlota=$scope.subtipo=='Flota'?'S':'N';
                        
                         AseguradoService.recuperarAsegurado(paramEditables).then(
                        //sucess
                        function (response) {//218631
                        if(!response.data.error){
                            AseguradoService.getTabs(param);
                            if(response.data.dato!=null){
                                $scope.bloquearBuscador=true;
                                $scope.camposTercero=response.data.dato;
                                $scope.cargarPlataforma();
                                /*debemos contar la cantidad de llamadas asincronas requeridas */
                                $scope.setearCantidadModelos(response);
                                $scope.modelo.tipoDocumento= response.data.dato.tipoDocumento;
                                $scope.modelo.nroDocumento=response.data.dato.codigoDocumento;
                                $scope.modelo.personaFisica=response.data.dato.marcaFisico;
                                $scope.modelo.nombres=response.data.dato.nombre;
                                $scope.modelo.apellido1=response.data.dato.primerApellido;
                                $scope.modelo.apellido2=response.data.dato.segundoApellido;
                                $scope.modelo.sexo=response.data.dato.marcaSexo;
                                $scope.modelo.estadoCivil=response.data.dato.codigoEstadoCivil ==""?undefined:response.data.dato.codigoEstadoCivil;
                                $scope.modelo.nacionalidad=response.data.dato.codigoNacionalidad;
                                $scope.modelo.fechaNacimiento=angular.isUndefined(response.data.dato.fechaNacimiento)?undefined:response.data.dato.fechaNacimiento!=null && response.data.dato.fechaNacimiento!="" ? $scope.convertirDate(response.data.dato.fechaNacimiento):undefined;
                                $scope.modelo.profesion=response.data.dato.codigoProfesion!=null && response.data.dato.codigoProfesion!="" ? parseInt(response.data.dato.codigoProfesion):undefined;
                                $scope.modelo.actividad=response.data.dato.codigoActividad!=null && response.data.dato.codigoActividad!="" ?parseInt(response.data.dato.codigoActividad):undefined;
                                                                                        
                                $scope.modelo.direccion1=response.data.dato.primeraDireccion;
                                $scope.modelo.direccion2=response.data.dato.segundaDireccion;
                                $scope.modelo.direccion3=response.data.dato.terceraDireccion;
                             
                                $scope.modelo.ciudad=response.data.dato.codigoCiudad==""?null:parseInt(response.data.dato.codigoCiudad);
                                $scope.modelo.mcaBloquedo=response.data.dato.codigoCiudad;

                                promesaBarrios.promise.$$state.status=0;
                                $scope.cambiarBarrio('N');
                                 promesaBarrios.promise.then(
                                 function(){
                                     $scope.modelo.barrio=response.data.dato.codigoBarrio==null?null:parseInt(response.data.dato.codigoBarrio);
                                     $scope.incrementarSincronizador($scope.modelo.barrio);

                                     if (response.data.dato.codigoBarrio!=null) {
                                         $scope.modelo.barrio=null;
                                         for (var i = 0; i < $scope.barrios.length; i++) {
                                             if ($scope.barrios[i].COD_LOCALIDAD == parseInt(response.data.dato.codigoBarrio)){
                                                 $scope.modelo.barrio=parseInt(response.data.dato.codigoBarrio);
                                                 break;
                                             }
                                        }

                                     }



                                 });

                                $scope.modelo.telefonoPais=response.data.dato.codigoPaisTelefono==null?"595":response.data.dato.codigoPaisTelefono;
                                $scope.modelo.telefonoPrefijo= response.data.dato.codigoCiudadTelefono;
                                $scope.modelo.telefono=response.data.dato.numeroTelefono;
                                $scope.modelo.fax=response.data.dato.numeroFax;
                                $scope.modelo.telMovil=response.data.dato.numeroMovil;
                                $scope.modelo.email=response.data.dato.email;
                                $scope.modelo.correspondencia = response.data.dato.marcaDireccionCorrespondecia;

                                $scope.modelo.direccionLaboral1=response.data.dato.primeraDireccionCom;
                                $scope.modelo.direccionLaboral2=response.data.dato.segundaDireccionCom;
                                $scope.modelo.direccionLaboral3=response.data.dato.terceraDireccionCom;
                                $scope.modelo.ciudadLaboral=response.data.dato.codigoCiudadCom==""?null: parseInt(response.data.dato.codigoCiudadCom);
                                $scope.modelo.telefonoLaboralPais=response.data.dato.codigoPaisTelefonoCom==null?"595":response.data.dato.codigoPaisTelefonoCom;
                                $scope.modelo.telefonoLaboralPrefijo=response.data.dato.codigoCiudadTelefonoCom;
                                $scope.modelo.telefonoLaboral=response.data.dato.numeroTelefonoCom;
                                $scope.modelo.faxLaboral=response.data.dato.numeroFaxCom;
                                promesaBarriosLaboral.promise.$$state.status=0;
                                $scope.cambiarBarrioLaboral('N');
                                //$scope.filtrarBarrios('ciudadLaboral');
                                promesaBarriosLaboral.promise.then(
                                function(){
                                    $scope.modelo.barrioLaboral=response.data.dato.codigoBarrioCom==null? null:parseInt(response.data.dato.codigoBarrioCom);
                                    $scope.incrementarSincronizador($scope.modelo.barrioLaboral);
                                    if (response.data.dato.codigoBarrioCom!=null) {
                                        $scope.modelo.barrioLaboral=null;
                                        for (var i = 0; i < $scope.barriosLaboral.length; i++) {
                                            if ($scope.barriosLaboral[i].COD_LOCALIDAD == parseInt(response.data.dato.codigoBarrioCom)){
                                                $scope.modelo.barrioLaboral=parseInt(response.data.dato.codigoBarrio);
                                                break;
                                            }
                                        }

                                    }
                                    //$scope.modelo.barrioLaboral=response.data.dato.codigoBarrioCom==null?null:parseInt(response.data.dato.codigoBarrioCom);

                                });

                               
                                $scope.modelo.emailLaboral=response.data.dato.emailCom;
                                $scope.modelo.asegurado =response.data.dato.igualarTomadorAsegurado;
                                $rootScope.nroPropuesta=response.data.dato.numeroPropuesta;
                                $scope.modelo.datosDomicilioParticular=response.data.dato.igualarDireccionCorrespondencia!=null? response.data.dato.igualarDireccionCorrespondencia=="N"?"1":"2":"1";

                                //$scope.loading=false;


                            }else{
                                $scope.limpiarDatosPersona();
                                 $scope.loading=false;
                                
                            }

                            
                        }else{
                           $scope.loading=false;
                           $scope.limpiarDatosPersona();
                          // Message.error(response.data.mensaje);
                        }
                        
                        //error
                        }, function(error){
                            $scope.limpiarDatosPersona();
                            $scope.loading=false;
                            Message.error("Error al realizar la operación");
                            //console.error(error);
                        });
                    }else{


                       param.pathModule=$scope.pathModule;
                      TomadorService.getPropuestaTomadorAsegurado(param).then(
                      //sucess
                      function (response) {//218631
                       
                        if(!response.data.error){
                            AseguradoService.getTabs(paramEditables);
                            if(response.data.dato!=null ){
                                $scope.camposTercero=response.data.dato;
                                $scope.bloquearBuscador=true;
                                $scope.cargarPlataforma();
                                /*contar la cantidad de llamadas asincronas*/
                                $scope.setearCantidadModelos(response);
                                $scope.modelo.tipoDocumento= response.data.dato.tipoDocumento;
                                $scope.modelo.nroDocumento=response.data.dato.codigoDocumento;
                                if (param.tipoBeneficiario==0 && (response.data.dato.nombre=="" || response.data.dato.nombre==null))
                                {
                                    $scope.obtenerPersona();
                                }
                                else
                                {

                                    $scope.modelo.personaFisica=response.data.dato.marcaFisico;
                                    $scope.modelo.nombres=response.data.dato.nombre;
                                    $scope.modelo.apellido1=response.data.dato.primerApellido;
                                    $scope.modelo.apellido2=response.data.dato.segundoApellido;
                                    $scope.modelo.sexo=response.data.dato.marcaSexo;
                                    $scope.modelo.estadoCivil=response.data.dato.codigoEstadoCivil==""?undefined:response.data.dato.codigoEstadoCivil;
                                    $scope.modelo.nacionalidad=response.data.dato.codigoNacionalidad;
                                    $scope.modelo.fechaNacimiento=angular.isUndefined(response.data.dato.fechaNacimiento)?undefined:response.data.dato.fechaNacimiento!=null && response.data.dato.fechaNacimiento!=""? $scope.convertirDate(response.data.dato.fechaNacimiento):undefined;
                                    $scope.modelo.profesion=response.data.dato.codigoProfesion!=null && response.data.dato.codigoProfesion!=""? parseInt(response.data.dato.codigoProfesion):undefined;
                                    $scope.modelo.actividad=response.data.dato.codigoActividad!=null && response.data.dato.codigoActividad!="" ?parseInt(response.data.dato.codigoActividad):undefined;

                                    $scope.modelo.direccion1=response.data.dato.primeraDireccion;
                                    $scope.modelo.direccion2=response.data.dato.segundaDireccion;
                                    $scope.modelo.direccion3=response.data.dato.terceraDireccion;

                                    $scope.modelo.ciudad=response.data.dato.codigoCiudad==""?null:parseInt(response.data.dato.codigoCiudad);

                                    promesaBarrios.promise.$$state.status=0;
                                    $scope.cambiarBarrio('N');
                                    promesaBarrios.promise.then(
                                        function(){
                                            $scope.modelo.barrio=response.data.dato.codigoBarrio==null?null:parseInt(response.data.dato.codigoBarrio);
                                            $scope.incrementarSincronizador($scope.modelo.barrio);
                                            /**esto se hace para ver si el barrio realmente se encuentra en la lista**/
                                            if (response.data.dato.codigoBarrio!=null) {
                                                $scope.modelo.barrio=null;
                                                for (var i = 0; i < $scope.barrios.length; i++) {
                                                    if ($scope.barrios[i].COD_LOCALIDAD == parseInt(response.data.dato.codigoBarrio)){
                                                        $scope.modelo.barrio=parseInt(response.data.dato.codigoBarrio);
                                                        break;
                                                    }
                                                }

                                            }
                                        });

                                    $scope.modelo.telefonoPais=response.data.dato.codigoPaisTelefono==null?"595":response.data.dato.codigoPaisTelefono;
                                    $scope.modelo.telefonoPrefijo=response.data.dato.codigoCiudadTelefono;
                                    $scope.modelo.telefono=response.data.dato.numeroTelefono;
                                    $scope.modelo.fax=response.data.dato.numeroFax;
                                    $scope.modelo.telMovil=response.data.dato.numeroMovil;
                                    $scope.modelo.email=response.data.dato.email;
                                    $scope.validPatternE=$scope.validarEmail($scope.modelo.email);
                                    $scope.modelo.correspondencia = response.data.dato.marcaDireccionCorrespondecia;

                                    $scope.modelo.direccionLaboral1=response.data.dato.primeraDireccionCom;
                                    $scope.modelo.direccionLaboral2=response.data.dato.segundaDireccionCom;
                                    $scope.modelo.direccionLaboral3=response.data.dato.terceraDireccionCom;
                                    $scope.modelo.ciudadLaboral=response.data.dato.codigoCiudadCom==""?null:parseInt(response.data.dato.codigoCiudadCom);
                                    $scope.modelo.telefonoLaboralPais=response.data.dato.codigoPaisTelefonoCom==null?"595":response.data.dato.codigoPaisTelefonoCom;
                                    $scope.modelo.telefonoLaboralPrefijo=response.data.dato.codigoCiudadTelefonoCom;
                                    $scope.modelo.telefonoLaboral=response.data.dato.numeroTelefonoCom;
                                    $scope.modelo.faxLaboral=response.data.dato.numeroFaxCom;
                                    promesaBarriosLaboral.promise.$$state.status=0;
                                    $scope.cambiarBarrioLaboral('N');
                                    promesaBarriosLaboral.promise.then(
                                        function(){
                                            $scope.modelo.barrioLaboral=response.data.dato.codigoBarrioCom==null? null:parseInt(response.data.dato.codigoBarrioCom);
                                            $scope.incrementarSincronizador($scope.modelo.barrioLaboral);
                                            if (response.data.dato.codigoBarrioCom!=null) {
                                                $scope.modelo.barrioLaboral=null;
                                                for (var i = 0; i < $scope.barriosLaboral.length; i++) {
                                                    if ($scope.barriosLaboral[i].COD_LOCALIDAD == parseInt(response.data.dato.codigoBarrioCom)){
                                                        $scope.modelo.barrioLaboral=parseInt(response.data.dato.codigoBarrio);
                                                        break;
                                                    }
                                                }

                                            }

                                            //$scope.modelo.barrioLaboral=response.data.dato.codigoBarrioCom==null?null:parseInt(response.data.dato.codigoBarrioCom);
                                        });


                                    $scope.modelo.emailLaboral=response.data.dato.emailCom;
                                    $scope.validPatternEl=$scope.validarEmail($scope.modelo.emailLaboral);
                                }
                                $rootScope.nroPropuesta=response.data.dato.numeroPropuesta;
                                $scope.modelo.asegurado =response.data.dato.igualarTomadorAsegurado;
                                if( response.data.dato.igualarTomadorAsegurado==='S'){

                                    $rootScope.llamarAsegurado=false;
                                 }  else{
                                    $rootScope.llamarAsegurado=true;
                                  } 
                                //$scope.modelo.datosDomicilioParticular=$scope.modelo.datosDomicilioParticular=response.data.dato.igualarDireccionCorrespondencia!=null? response.data.dato.igualarDireccionCorrespondencia=="N"?"1":"2":"1";
                                $scope.modelo.datosDomicilioParticular=$scope.modelo.datosDomicilioParticular=response.data.dato.igualarDireccionCorrespondencia!=null? response.data.dato.igualarDireccionCorrespondencia=="N"?"1":"2":"1";
                                 //$scope.loading=false;


                            }else{
                                $scope.limpiarDatosPersona();
                                $rootScope.llamarAsegurado=true;
                                $scope.loading=false;
                                //Message.info(response.data.mensaje);
                            }

                            
                        }else{
                           $scope.limpiarDatosPersona();
                           $rootScope.llamarAsegurado=true;
                           $scope.loading=false;
                           Message.error(response.data.mensaje);
                           //console.error(response);
                        }
                        
                    //error
                    }).catch(function(error){
                        $rootScope.llamarAsegurado=true;
                        $scope.loading=false;
                        $log.debug(error);
                        Message.error("Ocurrió un error al realizar la operación");
                        //console.error(response);
                    });

                    }

                   
              }

           }
    };

    $scope.$watch('modelo.fechaNacimiento', function(NewValue, OldValue) {
         if(!angular.isUndefined(NewValue)){
            if (NewValue != OldValue){
                
              
            }

         }

    },true);

   $scope.cargarPlataforma = function(){

        var paramPla={};
        paramPla.numeroCotizacion=$scope.numeroCotizacion;
        paramPla.marcaFlota=$scope.subtipo=='Flota'?'S':'N';
        paramPla.pathModule=$scope.pathModule;
        CotizacionVehiculoPropuestaService.getPlataforma(paramPla).then(

                       
                        function (response) {
                          if(!response.data.error){
                             if(response.data.dato!=null  )  {
                                   
                                $scope.mostrarPlataforma=true;
                                 
                                   $scope.tomador.plataforma=response.data.dato.mensaje;

                                
                            }

                          }
                     

                        }).catch(function(response){
                           
                            Message.error(response.data.mensaje);
                           
                        });
          };

        $scope.recargar = function() {
          $scope.bloquearBuscador=false;
          $rootScope.camposRequeridosList=[];
          $scope.limpiarDatosPersona();
          $rootScope.numeroCotizacionRoot=undefined;
          $scope.tomador.plataforma=null;
          $rootScope.nroPropuesta=undefined;
          $scope.mostrarPlataforma=false;

        };
        /**
         * Función creada para el salto de propuesta a cotizacion
         */
        $scope.goToCotizacion = function() {
            var path = $location.$$absUrl;
            var n = path.search("module");
            var url =  path.substring(0 , n);

            if(typeof $scope.numeroCotizacionRoot != 'undefined' && $scope.numeroCotizacionRoot != null){
                var subtipo = 'flota';
                if ($scope.subtipo == 'Vehiculos'){
                    subtipo = 'cotizacion-vehiculo';

                }else if ($scope.subtipo== 'Flota'){
                          subtipo = 'flota';
                }else if ($scope.subtipo== 'Propuesta Hogar'){
                           subtipo = 'cotizacion-hogar';
                }else if ($scope.subtipo== 'Multiriesgos'){
                           subtipo = 'cotizacion-multiriesgo';
                }

                location.href =subtipo+'/'+$scope.numeroCotizacionRoot;

            }
            else
            {
                Message.warning("Debe ingresar un número de cotización");
            }
        };


    $scope.$watch('modelo.personaFisica', function(NewValue, OldValue) {
         if(!angular.isUndefined(NewValue)){
            if (NewValue === 'N'){
            
                
                $scope.modelo.apellido1=undefined;
                $scope.modelo.apellido2=undefined;
                $scope.modelo.sexo=undefined;
                $scope.modelo.estadoCivil=undefined;
                $scope.modelo.nacionalidad=undefined;
                $scope.modelo.fechaNacimiento= undefined;
                $scope.modelo.profesion=undefined;
                $scope.modelo.actividad=undefined;
                $scope.flagDatosPersonales=false;
              
            }

         }

    },true);
    /**Funcion que se encarga de incrementar la variable de sincronizacion cuando las promesas se resuelven o tienen error*/
    $scope.incrementarSincronizador=function(campo)
    {
        if(campo!=null)
        {
            $scope.sinc++;
        }
    };
        /**Este Watch se dispara cuando las promesas se resuelven o tiene error, y la condicion principal debe ser
         * que el valor del sinc sea mayor a 0, sino ocurre eso es porque hay un error en el buscar o viene vacio el modelo de buscar**/

        $scope.$watch('sinc', function(NewValue, OldValue) {

            if (NewValue==cantModeloSinc && NewValue>0)
            {
                $scope.loading=false;
                $scope.sinc=0; //cantidad de modelos seteados una vez obtenida la promesa
                cantModeloSinc=0; //cantidad de modelos que necesitan llamadas de servicios
            }


        },true);
        $scope.setearCantidadModelos=function(response)
        {
            if (response.data.dato.codigoBarrio != null && response.data.dato.codigoBarrio != "" && 
                response.data.dato.codigoCiudad != null &&  response.data.dato.codigoCiudad != "") {

                $scope.valorBarrioParticular = parseInt(response.data.dato.codigoBarrio);
                cantModeloSinc++;
            }else{
                //nullamos todo sino cumple
                 $scope.modelo.barrio = null;
                 $scope.modelo.ciudad = null;

            }
            if (response.data.dato.codigoBarrioCom != null && response.data.dato.codigoBarrioCom != ""
                && response.data.dato.codigoCiudadCom != null && response.data.dato.codigoCiudadCom !="") {

                $scope.valorBarrioLaboral = parseInt(response.data.dato.codigoBarrioCom);
                cantModeloSinc++;
            }else{
                $scope.modelo.ciudadLaboral = null;
                $scope.modelo.barrioLaboral = null;

            }
            /**Si no hay datos en el modelo que necesitan promesas entonces se debe de ocultar el cargando*/
            if (cantModeloSinc == 0)
            {
                $scope.loading = false;
            }
        };
        $scope.$watch('cambiarTab', function(newValue, oldValue) {
            if (newValue!=0)
            {
                if (newValue==1)
                {
                    //hacer el redirect
                    var params={};
                    params.marcaFlota=$scope.subtipo=="Flota"?'S':'N';
                    params.numeroCotizacion=angular.isUndefined($scope.numeroCotizacionRoot)|| $scope.numeroCotizacionRoot==null?"":$scope.numeroCotizacionRoot;
                    params.tab=$rootScope.sigTab;
                    params.pathModule=$scope.pathModule;
                    $scope.service.getCamposEditablesList(params);
                    $timeout($location.url($rootScope.url_destino),1000);
                }
                else
                {
                    newValue=0; //para que vuelva a cambiar e intentar
                }
            }


        },true);

    (function initialize() {
        $rootScope.currentPage = 'tomador';
        $rootScope.tabs = TomadorService.getTabInicial();
        $scope.pathModule = UtilsService.retornarPath($location.path().split("/")[1]);
        $rootScope.currentModule=$scope.pathModule;
        $scope.flagDatosPersonales=true;
        $rootScope.llamarAsegurado=true;
        $scope.bloquearBuscador=false;
        angular.extend(this, $controller('UtilsCtrl', {
                    "$scope": $scope
        }));
      
        $scope.path = SidebarFlotaCtrl.$$path;
        $scope.obtenerDatosInicio(); 
        $scope.verificarRecargaPagina();
        //$scope.obtenerCamposEditables();
        //$scope.obtenerCamposRequeridos();
       if ($window.sessionStorage["rolesAsignados"]!=undefined && $window.sessionStorage["rolesAsignados"]!=null){
                var listaRoles = $window.sessionStorage["rolesAsignados"].split(",");
                $scope.controlPermisos = listaRoles.indexOf("rol_1")>-1? true:false;
            }

        TomadorService.getTipoDocumento().then(function(response){
            if (response.data.dato.length>0)
            {
                var data=response.data.dato;
                //seteamos en una lista los tipos de documentos
                for (var i=0; i<data.length;i++)
                {
                    $scope.tiposDocumentos.push(data[i]);
                }
                //console.log($scope.tiposDocumentos);
            }
            //console.log("Tipo de documentos ", response);
        },
        function(error){
            Message.error("Ocurrió un error al realizar la operación");
        })
        TomadorService.getEstadoCivil().then(function(response){
            if (response.data.dato.length>0)
            {
                var data=response.data.dato;
                for (var i=0; i<data.length;i++)
                {
                    $scope.estadoCiviles.push(data[i]);
                }
                //console.log($scope.estadoCiviles);
            }
           // console.log("Estado civiles ", response);
        },
        function(error){
            Message.error("Ocurrió un error al realizar la operación");
            //console.error(response);
        })
        TomadorService.getNacionalidad().then(function(response){
            if (response.data.dato.length>0)
            {
                var data=response.data.dato;
                for (var i=0; i<data.length;i++)
                {
                    $scope.nacionalidades.push(data[i]);
                }
                
            }
        })
        TomadorService.getProfesion().then(function(response){
            if (response.data.dato.length>0)
            {
                var data=response.data.dato;
                for (var i=0; i<data.length;i++)
                {
                    $scope.profesiones.push(data[i]);
                }
                //console.log($scope.profesiones);
            }
            //console.log("Profesiones ", response);
        },
        function(error){
            Message.error("Ocurrió un error al realizar la operación");
            //console.error(response);
        })
        TomadorService.getActividades().then(function(response){
            if (response.data.dato.length>0)
            {
                var data=response.data.dato;
                for (var i=0; i<data.length;i++)
                {
                    $scope.actividades.push(data[i]);
                }
                //console.log($scope.actividades);
            }
        })
        TomadorService.getCiudades().then(function (response){
            if (response.data.dato.length>0)
            {
                var data=response.data.dato;
                for (var i=0; i<data.length;i++)
                {
                    $scope.ciudades.push(data[i]);
                    $scope.ciudadesLaboral.push(data[i]);
                }
                $scope.modelo.codigoPais= response.data.dato[0].COD_PAIS

            }
           //console.log($scope.ciudades);
        })
       if (!angular.isUndefined($scope.numeroCotizacionRoot) && $scope.numeroCotizacionRoot!= null && $scope.numeroCotizacionRoot!=""){

           if( $scope.path==="/propuesta-flota/asegurado-agregar"){
               $scope.modelo.tipoDocumento=$scope.aseguradoTipoDocumento ;
               $scope.modelo.nroDocumento=$scope.aseguradoCodigoDocumento ;
               $scope.tab="ASEGURADO";
           }
             $scope.buscar();
        }else{
            TomadorService.goToPropuestaOrigen($scope.pathModule.split("marcaModulo=")[1]);
        }
    })();
}
]);
;app.controller('HogarFormCtrl', ['$scope', '$q', '$controller', '$routeParams', '$location', 'SessionService', '$rootScope','$route', '$mdDialog', '$filter', 'ConfirmService', '$window', 'PropuestaService','CotizacionVehiculoPropuestaService','UtilsService','CotizacionVehiculoService','$log','$timeout','PropuestaHogarService','TomadorService',
        function ($scope,$q, $controller, $routeParams, $location, sessionService, $rootScope,$route, $mdDialog,  $filter, confirmService, $window, PropuestaService,CotizacionVehiculoPropuestaService, UtilsService ,CotizacionVehiculoService, $log, $timeout,PropuestaHogarService, TomadorService) {
            $scope.service = PropuestaService;
            $scope.controlPermisos = true;
            $scope.nombre = $route.current.$$route.subtipo;
            $rootScope.rootPathParent = $route.current.$$route.originalPath;
           // $scope.listaComision = [];
            $scope.subtipo = $scope.nombre;
            $scope.agenteSelected = undefined;
            $scope.comisionSelected = undefined;
           // $scope.formaPagoSelected = undefined;
           // $scope.nroCobroAnt = {};
           // $scope.modelo = {};
            $scope.nroTarjeta = {};
            $scope.vtotarjeta = {};
            $scope.cargando = false;
            $scope.prop = {};
            $scope.prop.plataforma = null;
            $scope.nroPropuesta = null;
           // $scope.gestorSelected = undefined;
           // $scope.entidadSelected = undefined;
            $scope.todo_concesionarias = true;
            $scope.submitted = false;
            $scope.valorConcesionaria = undefined;
            $scope.valorComision = undefined;
            $scope.valorOficina = undefined;
            $scope.valorEjecutivo = undefined;
            $scope.valorAcreedor = undefined;
            $scope.valorTipoGestor = undefined;
            $scope.valorOficina = undefined;
            $scope.valorTipoTarjeta = undefined;
            $scope.valorEnvio = undefined;
            $scope.valorCodTarjeta = undefined;
            $scope.cambiarValores = true;
            $scope.permitirCambio = true;
            $scope.validCarga = false;
          //  $scope.cambiarGestor = true;
            $scope.tab = "HOGAR";
            $scope.sinc = 0;
            $scope.ciudades=[];
            $scope.barrios=[];
            $scope.listaFraccion = [];
            $scope.comercial={};
            $scope.comercial.fraccion=undefined;
            $scope.listaAcreedores = [];
            $scope.listaTechos = [];
            $scope.listaParedes = [];
            $scope.listaPisos = [];
            $scope.listaCielosRasos = [];
            $scope.listaEntrePisos = [];
            $scope.listaOcupacion=[];
            $scope.riesgo ={};
			$scope.riesgo.ciudad = null;
			$scope.riesgo.barrio = null;
			$scope.riesgo.direccion = null;
            $scope.riesgo.acreedorHipotecario =null;
            $scope.riesgo.importeCesion =null;
            $scope.riesgo.techo = null;
            $scope.riesgo.pared = undefined;
            $scope.riesgo.piso = null;
            //$scope.riesgo.cantidadPlantas=null;
            $scope.riesgo.numeroInspeccion=null;
            $scope.riesgo.numero = null;
            $scope.riesgo.ctacatastral = null;
            $scope.riesgo.finca = null;
            $scope.riesgo.edificio = null;
           // $scope.riesgo.departamento = null;

            $scope.seguridad ={};
            $scope.seguridad.extintores='N';
            $scope.seguridad.rociadores='N';
            $scope.seguridad.bocaIncendio='N';
            $scope.seguridad.sensorHumo='N';
            $scope.seguridad.redHidrantes='N';
            $scope.seguridad.guardias='N';
            $scope.seguridad.empresaRespaldo='N';
            $scope.seguridad.alarmaSonora='N';
            $scope.seguridad.circuitoCerrado='N';
            $scope.seguridad.sensorMovimiento='N';
            $scope.seguridad.funcionanDispositivos='N';
            $scope.seguridad.otros='N';
            $scope.habilitarImpCesion=false;

            $scope.ocupacion =undefined;

            $scope.ocupacionesPersisList=[];
            $scope.valor={};
            $scope.valor.barrio = undefined;
            
            /**variable que almcena las promesas resueltas o fracasadas*/
            var cantModeloSinc = 0;
            /**variable que almacena la cantidad de datos que vienen en el buscar, que requieren otras llamadas de promesas**/
            $scope.pagoPreferencia = undefined;
            $scope.cambiarTab = 0; //valor inicial
            $scope.verificarCamposForm = function (listaCampo, campo) {
                return UtilsService.verificarCamposForm(listaCampo, campo);
            };

            /**Funcion que se encarga de incrementar la variable de sincronizacion cuando las promesas se resuelven o tienen error*/
            $scope.incrementarSincronizador = function (campo) {
                if (campo != null) {
                    $scope.sinc++;
                }
            }

           // var promesaObtenerFormasPago = $q.defer();
            // var obtenerFormasPago = function () {
            //     var preferencia;
            //     preferencia = "N";
            //     PropuestaService.obtenerFormasPago(preferencia).then(function (response) {
            //         if (!response.data.error) {
            //             $scope.listaFormasPago = response.data.dato;

            //             //obtener las que son de preferencia y setear
            //             if ($scope.subtipo != "Flota") {

            //                 preferencia = window.sessionStorage.getItem("preferencia_forma_pago");
            //                 if (preferencia == "S") {
            //                     PropuestaService.obtenerFormasPago(preferencia).then(function (response) {
            //                         //$scope.formaPagoSelected.valor = response.data.dato[0].TIP_GESTOR;
            //                         //$scope.formaPagoSelected = response.data.dato[0].TIP_GESTOR;
            //                         if (!response.data.error) {
            //                             if (response.data.dato.length > 0) {
            //                                 $scope.pagoPreferencia = response.data.dato[0].TIP_GESTOR;
            //                             }
            //                             promesaObtenerFormasPago.resolve();
            //                         } else {
            //                             promesaObtenerFormasPago.resolve();
            //                             Message.error(response.data.error);
            //                         }

            //                     }, function (response) {
            //                         promesaObtenerFormasPago.reject();
            //                         Message.error("No se pudo obtener las formas de pago de preferencia");

            //                     });
            //                 } else {
            //                     promesaObtenerFormasPago.resolve();
            //                     //$scope.formaPagoSelected.valor=undefined;
            //                     $scope.formaPagoSelected = undefined;
            //                 }

            //             }
            //             else
            //             {
            //                 promesaObtenerFormasPago.resolve();
            //             }

            //         } else {
            //             promesaObtenerFormasPago.resolve();
            //             Message.error(response.data.mensaje);
            //         }



            //     }).catch(function (response) {
            //         promesaObtenerFormasPago.reject();
            //         $scope.formaPagoSelected = $scope.valorTipoGestor;
            //         $scope.incrementarSincronizador($scope.formaPagoSelected);
            //         Message.error("No se pudo obtener las formas de pago");
            //     });


            // };



            // var obtenerGestores = function (codigoFormaPago) {
            //     var param = {};
            //     param.codigoFormaPago = codigoFormaPago;
            //     PropuestaService.obtenerGestores(param).then(function (response) {
            //         if (!response.data.error) {
            //             $scope.listaGestores = response.data.dato;
            //         } else {
            //             Message.error(response.data.mensaje);
            //         }

            //         promesaGestores.resolve();

            //     }).catch(function (response) {
            //         promesaGestores.reject();
            //         $scope.gestorSelected = $scope.valorCodGestor;
            //         $scope.incrementarSincronizador($scope.gestorSelected);
            //         Message.error("No se pudo obtener los gestores");

            //     });
            // };

            // var promesaAgentes = $q.defer();
            // var obtenerAgentes = function () {
            //     PropuestaService.obtenerAgentes().then(function (response) {
            //         $scope.listaAgentes = response.data.dato;
            //         promesaAgentes.resolve();
            //     }, function (response) {
            //         promesaAgentes.reject();
            //         Message.error("No se pudo obtener los agentes");

            //     });
            // };

            // $scope.$watch('agenteSelected', function (newValue, oldValue) {
            //     if (!angular.isUndefined(newValue)) {
            //         $scope.concesionariaSelected = undefined;
            //        // $scope.referidoSelected = undefined;
            //       //  $scope.comisionSelected = undefined;
            //      //   $scope.oficinaSelected = undefined;
            //       //  obtenerConcesionarias(newValue);
            //       //  obtenerComision(newValue);
            //         //obtenerOficina(newValue);
            //     } else {
            //         $scope.concesionariaSelected = undefined;
            //       //  $scope.referidoSelected = undefined;
            //       //  $scope.comisionSelected = undefined;
            //         //$scope.oficinaSelected = undefined;
            //        // $scope.listaConcesionarias = [];
            //         //$scope.listaComision=[];
            //        // $scope.listaOficina = [];
            //         $scope.listaReferidos = [];
            //     }
            // }, true);
            $scope.$watch('riesgo.acreedorHipotecario', function (newValue, oldValue) {
                if (!angular.isUndefined(newValue) && newValue != null) {
                    //$scope.sinc++;
                    $scope.habilitarImpCesion=true;
                    $scope.riesgo.importeCesion=0;
                }
                else
                {
                    $scope.habilitarImpCesion=false;
                    $scope.riesgo.importeCesion=null;
                }

            }, true);
            // var promesaGestores = $q.defer();
            // $scope.$watch('formaPagoSelected', function (newValue, oldValue) {

            //     if (!angular.isUndefined(newValue) && newValue != null) {

            //         obtenerGestores(newValue)
            //         //esta bandera sirve basicamente para no pisar los datos que se setean desde el buscar
            //         if ($scope.cambiarGestor == true) //este es el caso en que se haya cambiado desde el HTML, o desde el initialize
            //         {
            //             $scope.gestorSelected = undefined;
            //             $scope.limpiarDatosGestores(newValue);
            //             //$scope.gestorSelected.valor=undefined;


            //         } else //esto es en caso que sea desde el buscar
            //         {
            //             $scope.cambiarGestor = true;
            //         }


            //     } else {
            //         $scope.gestorSelected = undefined;
            //         $scope.listaGestores = [];
            //     }


            // }, true);
          //  $scope.limpiarDatosGestores = function (newValue) {
             //   if (newValue == "CO") {
                    // if (!angular.isUndefined($scope.entidadSelected)) {
                    //     //$scope.entidadSelected.valor=undefined;
                    //     $scope.entidadSelected = undefined;
                    // }
                    // if (!angular.isUndefined($scope.sucursalSelected)) {
                    //     //$scope.sucursalSelected.valor=undefined;
                    //     $scope.sucursalSelected = undefined;
                    // }
                   // $scope.nroTarjeta.valor = undefined;
                   // $scope.vtotarjeta.valor = undefined;
                    //$scope.nroCuentaCte.valor = undefined;
                    // if (!angular.isUndefined($scope.tipoTarjetaSelected)) {
                    //     $scope.tipoTarjetaSelected = undefined;
                    //     //$scope.tipoTarjetaSelected.valor=undefined;

                    // }
                    // if (!angular.isUndefined($scope.codTarjetaSelected)) {
                    //     $scope.codTarjetaSelected = undefined;
                    //     //$scope.codTarjetaSelected.valor=undefined;
                    // }

            //    } else if (newValue == "DB") {
                    //$scope.nroTarjeta.valor = undefined;
                  //  $scope.vtotarjeta.valor = undefined;
                    // if (!angular.isUndefined($scope.tipoTarjetaSelected)) {
                    //     $scope.tipoTarjetaSelected = undefined;
                    // }
                    // if (!angular.isUndefined($scope.codTarjetaSelected)) {
                    //     $scope.codTarjetaSelected = undefined;
                    // }
            //    } else if (newValue == "TA") {
                  //  $scope.nroCuentaCte.valor = undefined;
                    // if (!angular.isUndefined($scope.entidadSelected)) {
                    //     $scope.entidadSelected = undefined;
                    // }
                    // if (!angular.isUndefined($scope.sucursalSelected)) {
                    //     $scope.sucursalSelected = undefined;
                    // }
             //   } else {
                  //  $scope.entidadSelected = undefined;
                //    $scope.sucursalSelected = undefined;
                  //  $scope.nroTarjeta.valor = undefined;
                 //   $scope.vtotarjeta.valor = undefined;
                   // $scope.tipoTarjetaSelected = undefined;
                  //  $scope.codTarjetaSelected = undefined;
                  //  $scope.nroCuentaCte.valor = undefined;
             //   }

           // };

            $scope.save = function (clickButton) {


                $scope.submitted = false;
                $scope.numeroCotizacion = $scope.numeroCotizacionRoot;

                var hogar = {};
                hogar.numeroCotizacion = $scope.numeroCotizacion;
                hogar.codigoCiudad = angular.isUndefined($scope.riesgo.ciudad)?"":$scope.riesgo.ciudad;
                hogar.codigoBarrio=angular.isUndefined($scope.riesgo.barrio)?"":$scope.riesgo.barrio;
                hogar.direccion=$scope.riesgo.direccion;
                hogar.numeroCasa=$scope.riesgo.numero;
                hogar.numeroFinca=$scope.riesgo.finca;
                hogar.acreedor=angular.isUndefined($scope.riesgo.acreedorHipotecario)?"":$scope.riesgo.acreedorHipotecario;
                hogar.impCesion=$scope.riesgo.importeCesion;
                hogar.tipoTecho=angular.isUndefined($scope.riesgo.techo)?"":$scope.riesgo.techo;
                hogar.tipoPiso=angular.isUndefined($scope.riesgo.piso)?"":$scope.riesgo.piso;
                hogar.tipoCieloraso=angular.isUndefined($scope.riesgo.cieloraso)?"":$scope.riesgo.cieloraso;
                hogar.tipoPared=angular.isUndefined($scope.riesgo.pared)?"":$scope.riesgo.pared;
                hogar.tipoEntrePiso=angular.isUndefined($scope.riesgo.entrepiso)?"":$scope.riesgo.entrepiso;
                hogar.numeroInspeccion=angular.isUndefined($scope.riesgo.numeroInspeccion)?"":$scope.riesgo.numeroInspeccion;
                hogar.cuentaCorriente=angular.isUndefined($scope.riesgo.ctacatastral)?"":$scope.riesgo.ctacatastral;
                hogar.seguridad= [ {
                    "campo": "extintores",
                    "check": $scope.seguridad.extintores
                },
                    {
                        "campo": "rociadores",
                        "check": $scope.seguridad.rociadores
                    },
                    {
                        "campo": "bocaIncendio",
                        "check": $scope.seguridad.bocaIncendio
                    },
                    {
                        "campo": "sensorHumo",
                        "check": $scope.seguridad.sensorHumo
                    },
                    {
                        "campo": "redHidrantes",
                        "check": $scope.seguridad.redHidrantes
                    },
                    {
                        "campo": "guardias",
                        "check": $scope.seguridad.guardias
                    },
                    {
                        "campo": "empresaRespaldo",
                        "check": $scope.seguridad.empresaRespaldo
                    },
                    {
                        "campo": "alarmaSonora",
                        "check": $scope.seguridad.alarmaSonora
                    },
                    {
                        "campo": "circuitoCerrado",
                        "check": $scope.seguridad.circuitoCerrado
                    },
                    {
                        "campo": "sensorMovimiento",
                        "check": $scope.seguridad.sensorHumo
                    },
                    {
                        "campo": "funcionanDispositivos",
                        "check": $scope.seguridad.funcionanDispositivos
                    },
                    {
                        "campo": "otros",
                        "check": $scope.seguridad.otros
                    }  ]

                var param = JSON.stringify(hogar);
                $scope.cargando = true;
                PropuestaHogarService.guardarHogar(hogar).then(
                    //sucess
                    function (response) {

                        if (!response.data.error) {

                            if (clickButton == "S") {
                                var param = {};
                                param.numeroCotizacion = $scope.numeroCotizacion;
                                param.marcaFlota = $scope.subtipo == 'Flota' ? 'S' : 'N';
                                param.tab = $scope.tab;
                                param.pathModule=$scope.pathModule;
                                PropuestaHogarService.getTabs(param);
                            } else {
                                $scope.cambiarTab = 1; //exito
                            }


                            Message.ok(response.data.mensaje);
                        } else {
                            $scope.cambiarTab = 2; //error
                            Message.error(response.data.mensaje);

                        }
                        $scope.cargando = false;
                        //error
                    }).catch(function (response) {
                    $scope.cargando = false;
                    $scope.cambiarTab = 2; //error
                    Message.error(response.data.mensaje);

                });


            };


            $scope.buscar = function () {
                $scope.numeroCotizacion = $scope.numeroCotizacionRoot;
                if (!angular.isUndefined($scope.numeroCotizacion)) {
                    if ($scope.numeroCotizacion != null && $scope.numeroCotizacion != "") {
                        $scope.cargando = true;
                        var param = {};
                        param.numeroCotizacion = $scope.numeroCotizacion;
                        param.marcaFlota = $scope.subtipo == 'Flota' ? 'S' : 'N';
                        param.tab = $scope.tab;
                        param.pathModule=$scope.pathModule;
                        $scope.todo_concesionarias = false;
                       // $scope.agenteSelected = undefined;
                        $scope.sinc = 0;
                        cantModeloSinc = 0;
                        $scope.permitirCambio = false;


                        PropuestaHogarService.buscarHogar(param).then(
                            //sucess
                            function (response) {

                                if (!response.data.error) {
                                    PropuestaHogarService.getTabs(param)
                                    if (response.data.dato != null ) {


                                        $scope.bloquearBuscador = true;
                                        $scope.cambiarValores = false;
                                        $scope.cargarPlataforma();
                                      //  $scope.tieneIva = response.data.dato[0].MCA_IVA == null ? 'S' : response.data.dato[0].MCA_IVA;
                                       // $scope.firmaDigital = response.data.dato[0].MCA_FIRMA_ELECTRONICA == null ? 'N' : response.data.dato[0].MCA_FIRMA_ELECTRONICA;
                                        $scope.setearCantidadModelos(response);


                                        $scope.riesgo.ciudad = response.data.dato.codigoCiudad!=null? parseInt(response.data.dato.codigoCiudad):undefined;
                                        $scope.cambiarBarrio("N");
                                        promesaBarrios.promise.then(function () {
                                            $scope.riesgo.barrio=response.data.dato.codigoBarrio!=null?parseInt(response.data.dato.codigoBarrio):undefined;
                                            $scope.incrementarSincronizador($scope.riesgo.barrio);
                                        
                                        })


                                        $scope.riesgo.direccion =response.data.dato.direccion;
                                        $scope.riesgo.numeroInspeccion = response.data.dato.numeroInspeccion;
                                        $scope.riesgo.numero = response.data.dato.numeroCasa;
                                        $scope.riesgo.ctacatastral =  response.data.dato.cuentaCorriente;
                                        $scope.riesgo.finca =  response.data.dato.numeroFinca;
                                        $scope.riesgo.edificio = response.data.dato.nombreEdificio;
                                        $scope.riesgo.importeCesion = response.data.dato.impCesion;
                                        if (response.data.dato.seguridad.length>0)
                                        {
                                            console.log("Viene seguridad");
                                            var seguridadSelect=response.data.dato.seguridad;
                                            for (var i=0; i<seguridadSelect.length;i++)
                                            {
                                                console.log("Itera ", i)
                                                if (seguridadSelect[i].campo=="extintores")
                                                {
                                                    $scope.seguridad.extintores=seguridadSelect[i].check;
                                                    console.log("Entra aca");
                                                }
                                                else if (seguridadSelect[i].campo=="bocaIncendio")
                                                {
                                                    $scope.seguridad.bocaIncendio=seguridadSelect[i].check
                                                    console.log("Entra aca, bocaIncendio");
                                                }
                                                else if (seguridadSelect[i].campo=="redHidrantes")
                                                {
                                                    $scope.seguridad.redHidrantes=seguridadSelect[i].check
                                                    console.log("Entra aca, redHidrantes");
                                                }
                                                else if (seguridadSelect[i].campo=="alarmaSonora")
                                                {
                                                    $scope.seguridad.alarmaSonora=seguridadSelect[i].check
                                                }
                                                else if (seguridadSelect[i].campo=="empresaRespaldo")
                                                {
                                                    $scope.seguridad.empresaRespaldo=seguridadSelect[i].check
                                                }
                                                else if (seguridadSelect[i].campo=="sensorHumo")
                                                {
                                                    $scope.seguridad.sensorHumo=seguridadSelect[i].check
                                                }
                                                else if (seguridadSelect[i].campo=="guardias")
                                                {
                                                    $scope.seguridad.guardias=seguridadSelect[i].check
                                                }
                                                else if (seguridadSelect[i].campo=="rociadores")
                                                {
                                                    $scope.seguridad.rociadores=seguridadSelect[i].check
                                                }
                                                else if (seguridadSelect[i].campo=="circuitoCerrado")
                                                {
                                                    $scope.seguridad.circuitoCerrado=seguridadSelect[i].check
                                                }
                                                else if (seguridadSelect[i].campo=="sensorMovimiento")
                                                {
                                                    $scope.seguridad.sensorMovimiento=seguridadSelect[i].check
                                                }
                                                else if (seguridadSelect[i].campo=="funcionanDispositivos")
                                                {
                                                    $scope.seguridad.funcionanDispositivos=seguridadSelect[i].check
                                                }
                                                else  {
                                                    $log.debug("Este check no esta previsto ", seguridadSelect[i])
                                                }

                                            }

                                            //seguridadSelect.extintores=
                                        }




                                        $scope.promesaAcreedores.promise.then(
                                            function () {
                                                $scope.riesgo.acreedorHipotecario =  response.data.dato.acreedor==null?undefined:response.data.dato.acreedor==""?undefined:response.data.dato.acreedor;                                  
                                                
                                              //  $scope.incrementarSincronizador($scope.riesgo.acreedorHipotecario);

                                                
                                        });
                                     


                                        $scope.promesaTecho.promise.then(
                                            function () {
                                                                                     
                                                $scope.riesgo.techo=response.data.dato.tipoTecho==null?undefined:response.data.dato.tipoTecho==""?undefined:response.data.dato.tipoTecho;
                                               // $scope.incrementarSincronizador($scope.riesgo.techo);

                                                
                                        });

                                        $scope.promesaPared.promise.then(
                                            function () {
                                                
                                               $scope.riesgo.pared=response.data.dato.tipoPared==null?undefined:response.data.dato.tipoPared==""?undefined:response.data.dato.tipoPared;
                                              // $scope.incrementarSincronizador($scope.riesgo.pared);

                                        });
                                        

                                       
                                        $scope.promesaPiso.promise.then(function () {
                                            $scope.riesgo.piso = response.data.dato.tipoPiso==null?undefined :response.data.dato.tipoPiso==""?undefined:response.data.dato.tipoPiso;
                                            $scope.incrementarSincronizador($scope.riesgo.piso);

                                        });

                                        $scope.promesaCieloRaso.promise.then(function () {
                                            $scope.riesgo.cieloraso = response.data.dato.tipoCieloraso==null ?undefined:response.data.dato.tipoCieloraso==""?undefined:response.data.dato.tipoCieloraso;
                                           // $scope.incrementarSincronizador($scope.riesgo.cieloraso);

                                        });


                                       $scope.promesaEntrePiso.promise.then(
                                            function () {
                                                $scope.riesgo.entrepiso = response.data.dato.tipoEntrepiso ==null? undefined:response.data.dato.tipoEntrepiso==""?undefined:response.data.dato.tipoEntrepiso ;
                                               // $scope.incrementarSincronizador($scope.riesgo.entrepiso);
 

                                        });

 
                                        $rootScope.nroPropuesta = angular.isUndefined(response.data.dato.numeroPropuesta) ? null : response.data.dato.numeroPropuesta;
                                      


                                       
                                     $scope.cargando = false;

                                    } else {
                                        $scope.limpiar();
                                       // $rootScope.llamarAsegurado = true;
                                        Message.warning(response.data.mensaje);
                                        $scope.cargando = false;
                                    }


                                } else {
                                    $scope.limpiar();
                                   // $rootScope.llamarAsegurado = true;
                                    $scope.cargando = false;
                                    Message.error(response.data.mensaje);
                                }

                                //error
                            }).catch(function (response) {
                            $scope.limpiar();
                          //  $rootScope.llamarAsegurado = true;
                            $scope.cargando = false;
                            console.log(response);
                            Message.error("Ocurrió un error, intente nuevamente");

                        });

                    }

                }


            };
            $scope.$watch('numeroCotizacion', function (NewValue, OldValue) {
                if (!angular.isUndefined(NewValue) && NewValue != null) {
                    var param={};
                    param.numeroCotizacion=NewValue;
                    param.pathModule = $scope.pathModule;
                    $scope.ocupacionesPersisList=[];
                    PropuestaHogarService.recuperarOcupacion(param).then(function (response) {
                        if (!response.data.error) {
                            var result=response.data.dato
                            if (result!=null && result.length>0)
                            {
                                for (var i=0; i<result.length;i++)
                                {
                                     var data={};
                                     data.idOcupacion= result[i].codigoOcupacion;
                                     data.descripcionOcupacion=result[i].nombreOcupacion;
                                    $scope.ocupacionesPersisList.push(data);

                                }
                            }

                        } else {
                            Message.error(response.data.mensaje);
                        }
                    })
                }



            }, true);


            /**formato para el datepicker**/
            $scope.formatearFecha = function (fecha) {
                $scope.aplicarFormato(fecha);
            };


            $scope.cargarPlataforma = function () {

                var paramPla = {};
                paramPla.numeroCotizacion = $scope.numeroCotizacion;
                paramPla.marcaFlota = $scope.subtipo == 'Flota' ? 'S' : 'N';
                paramPla.pathModule = $scope.pathModule;
                CotizacionVehiculoPropuestaService.getPlataforma(paramPla).then(
                    function (response) {
                        if (!response.data.error) {
                            if (response.data.dato != null) {

                                $scope.mostrarPlataforma = true;

                                $scope.prop.plataforma = response.data.dato.mensaje;


                            }

                        }


                    }).catch(function (response) {

                    Message.error(response.data.mensaje);

                });
            };


            /**
             * Función creada para el salto de propuesta a cotizacion
             */
            $scope.goToCotizacion = function () {
                var path = $location.$$absUrl;
                var n = path.search("module");
                var url = path.substring(0, n);

                if (typeof $scope.numeroCotizacionRoot != 'undefined' && $scope.numeroCotizacionRoot != null) {
  var subtipo = 'flota';
                   if ($scope.subtipo == 'Vehiculos') {
                        subtipo = 'cotizacion-vehiculo';


                    }else if ($scope.subtipo== 'Flota'){
                          subtipo = 'flota';
                    }else if ($scope.subtipo== 'Propuesta Hogar'){
                           subtipo = 'cotizacion-hogar';
                    }


                    location.href = subtipo + '/' + $scope.numeroCotizacionRoot;

                } else {
                    Message.warning("Debe ingresar un número de cotización");
                }
            }


            $scope.limpiar = function () {

                $rootScope.camposRequeridosList = [];
                $rootScope.numeroCotizacionRoot = undefined;
                $rootScope.nroPropuesta = undefined;
                $scope.eliminarPagina();
                if (typeof $routeParams.numeroCotizacion != "undefined") {
                    $location.search('numeroCotizacion', undefined);
                    $rootScope.numeroCotizacionRoot = undefined;
                    if ($scope.subtipo == "Flota") {
                        $location.path('propuesta-flota/propuesta')
                    } else if ($scope.subtipo == "Vehiculos"){
                        $location.path('propuesta-vehiculo/propuesta')
                    } else if ($scope.subtipo == "Propuesta Hogar"){
                        $location.path('propuesta-hogar/hogar')
                    }


                } else {
                    $route.reload();
                }

            };
            $scope.recargar = function () {
                $scope.agenteSelected = undefined;
                $scope.bloquearBuscador = false;
                $scope.mostrarPlataforma = false;
                $scope.limpiar();

            };

            $scope.llamarModal = function (value) {

                if (!angular.isUndefined($rootScope.numeroCotizacionRoot) && $rootScope.numeroCotizacionRoot != null && $rootScope.numeroCotizacionRoot != "") {
                    $rootScope.numCotiza = $rootScope.numeroCotizacionRoot;
                    $rootScope.modalCotizadorVehFlota = value;
                    $rootScope.flagVehiculoFlota = false;
                    $rootScope.flagHogar=true;
                    $mdDialog.show({
                        //locals:{parent: $scope},
                        controller: 'ModalAutorizacionCtrl',
                        templateUrl: 'partials/ventanas-emergentes/modal-autorizacion-partial.html',
                        parent: angular.element(document.body),
                        multiple: true,
                        clickOutsideToClose: false,
                        scope: $scope,
                        preserveScope: true,
                        fullscreen: $scope.customFullscreen // Only for -xs, -sm breakpoints.
                    }).then(function (answer) {
                        $scope.buscar();


                    }, function () {
                        $scope.status = 'You cancelled the dialog.';
                        //console.log($scope.status);
                    });
                }

            };


            $scope.obtenerAutorizaciones = function () {

                $scope.autorizacionesList = [];
                var param = {};
                param.pathModule =$scope.pathModule;
                CotizacionVehiculoService.getAutorizaciones(param).then(function (response) {
                    if (!response.data.error) {
                        if (response.data.dato.length > 0) {
                            var campos = response.data.dato;
                            for (var i = 0; i < campos.length; i++) {
                                $scope.autorizacionesList.push(campos[i]);

                            }
                        }
                        //console.log("Lista Autorizaciones: " + JSON.stringify($scope.autorizacionesList));
                    } else {
                        Message.error(response.data.mensaje);
                    }
                });
            };

            /**Este Watch se dispara cuando las promesas se resuelven o tiene error, y la condicion principal debe ser
             * que el valor del sinc sea mayor a 0, sino ocurre eso es porque hay un error en el buscar o viene vacio el modelo de buscar**/

            $scope.$watch('sinc', function (NewValue, OldValue) {
                if (NewValue == cantModeloSinc && NewValue > 0) {
                    $scope.cargando = false;
                    $scope.sinc = 0; //cantidad de modelos seteados una vez obtenida la promesa
                    cantModeloSinc = 0; //cantidad de modelos que necesitan llamadas de servicios
                }


            }, true);
            $scope.setearCantidadModelos = function (response) {
                //preguntar la cantidad de campos a ser seteados
               
                 if (response.data.dato.codigoBarrio && response.data.dato.codigoBarrio != "" ) {
                     $scope.valor.barrio = response.data.dato.codigoBarrio;
                     cantModeloSinc++;
                 } 

                // if (response.data.dato[0].COD_CONCESIONARIA != null && response.data.dato[0].COD_CONCESIONARIA != "") {
                //     /*variable auxiliar en caso que ocurra algun error, en la promesa de la concesionaria*/
                //     $scope.valorConcesionaria = response.data.dato[0].COD_CONCESIONARIA;
                //     cantModeloSinc++;
                // }//1

                // if (response.data.dato[0].COD_CUADRO_COM != null && response.data.dato[0].COD_CUADRO_COM != "") {

                //     $scope.valorComision = response.data.dato[0].COD_CUADRO_COM;
                //     cantModeloSinc++;
                // }
                // if (response.data.dato[0].COD_NIVEL3 != null && response.data.dato[0].COD_NIVEL3 != "") {
                //     $scope.valorOficina = response.data.dato[0].COD_NIVEL3;
                //     cantModeloSinc++;
                // }


                // if (response.data.dato[0].COD_REFERIDO != null && response.data.dato[0].COD_REFERIDO != "" && response.data.dato[0].COD_CONCESIONARIA != null && response.data.dato[0].COD_CONCESIONARIA != "") {
                //     $scope.valorReferido = response.data.dato[0].COD_REFERIDO;
                //     cantModeloSinc++;
                // }
                // if (response.data.dato[0].COD_ENTIDAD != null && response.data.dato[0].COD_ENTIDAD != "" && response.data.dato[0].COD_GESTOR != null && response.data.dato[0].COD_GESTOR != "") {
                //     $scope.valorEntidad = response.data.dato[0].COD_ENTIDAD;
                //     cantModeloSinc++;
                // }
                // if (response.data.dato[0].COD_ACREEDOR != null && response.data.dato[0].COD_ACREEDOR != "") {
                //     $scope.valorAcreedor = response.data.dato[0].COD_ACREEDOR;
                //     cantModeloSinc++;
                // }
                // if (response.data.dato[0].COD_TIP_ENVIO != null && response.data.dato[0].COD_TIP_ENVIO != "") {
                //     $scope.valorEnvio = response.data.dato[0].COD_TIP_ENVIO;
                //     cantModeloSinc++;
                // }
                // if (response.data.dato[0].TIP_GESTOR != null && response.data.dato[0].TIP_GESTOR != "" ) {
                //     $scope.valorTipoGestor = response.data.dato[0].TIP_GESTOR;
                //     cantModeloSinc++;
                // }//2
                // if (response.data.dato[0].COD_OFICINA != null && response.data.dato[0].COD_OFICINA != "" && response.data.dato[0].COD_ENTIDAD != null && response.data.dato[0].COD_ENTIDAD != "" && response.data.dato[0].COD_GESTOR != null && response.data.dato[0].COD_GESTOR != "") {
                //     $scope.valorSucursal = response.data.dato[0].COD_OFICINA;
                //     cantModeloSinc++;
                // }//3
                // if (response.data.dato[0].COD_TIP_TAR != null && response.data.dato[0].COD_TARJETA != null && response.data.dato[0].COD_TIP_TAR != "" && response.data.dato[0].COD_TARJETA != "") {
                //     $scope.valorCodTarjeta = response.data.dato[0].COD_TARJETA;
                //     cantModeloSinc++;
                // }//7
                // if (response.data.dato[0].COD_GESTOR != null && response.data.dato[0].COD_GESTOR != "" && response.data.dato[0].TIP_GESTOR != null && response.data.dato[0].TIP_GESTOR != "") {
                //     $scope.valorCodGestor = response.data.dato[0].COD_GESTOR;
                //     cantModeloSinc++;
                // }//8
                // if (response.data.dato[0].COD_EJECUTIVO != null && response.data.dato[0].COD_EJECUTIVO != "" && response.data.dato[0].COD_NIVEL3 != null && response.data.dato[0].COD_NIVEL3 != "") {
                //     $scope.valorEjecutivo = response.data.dato[0].COD_EJECUTIVO;
                //     cantModeloSinc++;
                // }//9
                /**Si no hay datos en el modelo que no necesitan promesas entonces se debe de ocultar el cargando*/
                if (cantModeloSinc == 0) {
                    $scope.cargando = false;
                }
            };
            $scope.$watch('cambiarTab', function (newValue, oldValue) {
                if (newValue != 0) {
                    if (newValue == 1) {
                        //hacer el redirect

                        var params={};
                        params.marcaFlota=$scope.subtipo=="Flota"?'S':'N';
                        params.numeroCotizacion=angular.isUndefined($scope.numeroCotizacionRoot)|| $scope.numeroCotizacionRoot==null?"":$scope.numeroCotizacionRoot;
                        params.tab=$rootScope.sigTab;
                        params.pathModule=$scope.pathModule;
                        $scope.service.getCamposEditablesList(params);
                        $timeout($location.url($rootScope.url_destino),1000);
                    } else {
                        newValue = 0; //para que vuelva a cambiar e intentar
                    }
                }

            }, true);
            $scope.eliminarPagina=function()
            {
                sessionStorage.removeItem("paginaAsegurado");
                sessionStorage.removeItem("paginaRiesgoPropuesta");
            };

             var promesaBarrios= $q.defer();
          $scope.cambiarBarrio=function(tag)
        {
 
             if(!angular.isUndefined($scope.riesgo.ciudad) && $scope.riesgo.ciudad !== ""){
                    if (tag=='S')
                    {
                        $scope.riesgo.barrio=undefined;
                    }
                    for(var i=0; i<$scope.ciudades.length; i++){
                        if ($scope.ciudades[i].id==$scope.riesgo.ciudad){
                            $scope.codigoEstado= $scope.ciudades[i].COD_ESTADO;
                            break;
                        }
                    }
                    if ($scope.riesgo.ciudad!=null && $scope.riesgo.ciudad!="")
                    {
                        var parametros = {};
                        parametros.codigo=$scope.riesgo.ciudad;
                        TomadorService.getBarrios(parametros).then(function(response) {
                            if (!response.data.error)
                            {
                                $scope.barrios=[];
                                if (response.data.dato!=null)
                                {
                                    if (response.data.dato.length > 0) {
                                        var data = response.data.dato;
                                        for (var i = 0; i < data.length; i++) {
                                            $scope.barrios.push(data[i]);
                                        }
                                        promesaBarrios.resolve();

                                    } else {

                                        Message.info("No se pudo obtener los barrios");
                                        promesaBarrios.resolve();
                                    }
                                }


                            }
                            else
                            {
                                promesaBarrios.resolve();
                                Message.error(response.data.mensaje);
                            }



                        }).catch(function(error){
                            Message.error("Ocurrió un error al obtener la lista de barrios ");
                            promesaBarrios.reject();
                            $scope.riesgo.barrio=$scope.valor.barrio;
                            $scope.incrementarSincronizador($scope.valor.barrio);
                        });
                        $scope.refrescarDatos();
                    }




            }
    };
     
    $scope.refrescarDatos=function()
    {
      //if ($scope.modelo.datosDomicilioParticular=="2")
     // {
         // $scope.desactivar=true;
          //hay que copiar lo que hay en datos particulares a datos laborales
          // $scope.riesgo.direccion=$scope.modelo.direccion1;
          // $scope.modelo.direccionLaboral2=$scope.modelo.direccion2;
          // $scope.modelo.direccionLaboral3=$scope.modelo.direccion3;
          // $scope.riesgo.ciudadLaboral=$scope.riesgo.ciudad;
          // $scope.barriosLaboral=$scope.barrios;
          // $scope.modelo.telefonoLaboral=$scope.modelo.telefono;
          // $scope.modelo.telefonoLaboralPrefijo=$scope.modelo.telefonoPrefijo;
          // $scope.modelo.telefonoLaboralPais=$scope.modelo.telefonoPais;
          // $scope.modelo.emailLaboral=$scope.modelo.email;
          // $scope.modelo.faxLaboral=$scope.modelo.fax;
          // $scope.riesgo.barrioLaboral=$scope.riesgo.barrio;
     // }
    };

     

        $scope.promesaTecho = $q.defer();
        $scope.cargarTechos = function () {
            PropuestaHogarService.getTecho().then(function (response) {
                   if (!response.data.error) {
                      if (response.data.dato.length > 0) {
                          $scope.listaTechos =[];
                          for (var i = 0; i < response.data.dato.length; i++) {
                               var objTecho = {
                                    idTecho: response.data.dato[i].codigoTecho,
                                    nombreTecho: response.data.dato[i].descripcionTecho
                                };
                                $scope.listaTechos.push(objTecho);
                          }
                          $scope.promesaTecho.resolve();
                        }

                   }else{
                        $scope.promesaTecho.resolve();
                        Message.error(response.data.mensaje);
                   }
                   
            }).catch(function (response) {
                     $scope.promesaTecho.reject();
                     
                    
                    Message.error("No se pudo obtener lista de techos.");
             });

        };

        $scope.promesaPared = $q.defer();
        $scope.cargarParedes = function () {
            PropuestaHogarService.getPared().then(function (response) {
                    if (!response.data.error) {
                        if (response.data.dato.length > 0) {
                             $scope.listaParedes =[];
                             for (var i = 0; i < response.data.dato.length; i++) {
                                var objParedes = {
                                    idPared: response.data.dato[i].codigoPared,
                                    nombrePared: response.data.dato[i].descripcionPared
                                };
                                $scope.listaParedes.push(objParedes);
                          }
                          $scope.promesaPared.resolve();
                        }

                   }else{
                       $scope.promesaPared.resolve();
                       Message.error(response.data.mensaje);
                   }

 
            }).catch(function (response) {
                    $scope.promesaPared.reject();
                    
                    Message.error("No se pudo obtener lista de paredes.");
             });
         

        };

        $scope.promesaPiso = $q.defer();
        $scope.cargarPisos = function () {
            PropuestaHogarService.getPiso().then(function (response) {
                    if (!response.data.error) {
                        if (response.data.dato.length > 0) {
                            $scope.listaPisos =[];
                            for (var i = 0; i < response.data.dato.length; i++) {
                                var objPisos = {
                                    idPiso: response.data.dato[i].codigoPiso,
                                    nombrePiso: response.data.dato[i].descripcionPiso
                                };
                                $scope.listaPisos.push(objPisos);
                            }
                            $scope.promesaPiso.resolve();
                        }

                   }else{
                        $scope.promesaPiso.resolve();
                       Message.error(response.data.mensaje);
                   }

                   
            }).catch(function (response) {
                     $scope.promesaPiso.reject();
                    
                    Message.error("No se pudo obtener lista de pisos.");
             });


        };

        $scope.promesaCieloRaso = $q.defer();
        $scope.cargarCieloRasos = function () {
            PropuestaHogarService.getCieloRaso().then(function (response) {
                    if (!response.data.error) {
                        if (response.data.dato.length > 0) {
                            $scope.listaCielosRasos =[];
                            for (var i = 0; i < response.data.dato.length; i++) {
                                 var objCieloRaso = {
                                    idCieloRaso: response.data.dato[i].codigoCieloraso,
                                    nombreCieloRaso: response.data.dato[i].descripcionCieloraso
                                };
                                $scope.listaCielosRasos.push(objCieloRaso);
                            }

                            $scope.promesaCieloRaso.resolve();
                        }

                   }else{
                        $scope.promesaCieloRaso.resolve();
                       Message.error(response.data.mensaje);
                   }

              
            }).catch(function (response) {
                     $scope.promesaCieloRaso.reject();
                 
                    Message.error("No se pudo obtener lista de cieloraso.");
             });


        };

        $scope.promesaEntrePiso = $q.defer();
        $scope.cargarEntrePisos = function () {

            PropuestaHogarService.getEntrePiso().then(function (response) {
                    if (!response.data.error) {
                        if (response.data.dato.length > 0) {
                           $scope.listaEntrePisos=[];
                           for (var i = 0; i < response.data.dato.length; i++) {
                                var objEntrePiso = {
                                    idEntrePiso: response.data.dato[i].codigoEntrepiso,
                                    nombreEntrepiso: response.data.dato[i].descripcionEntrepiso
                                };
                                $scope.listaEntrePisos.push(objEntrePiso);
                           }
                           $scope.promesaEntrePiso.resolve();
                        }

                   }else{
                       $scope.promesaEntrePiso.resolve();
                       Message.error(response.data.mensaje);
                   }


                    
            }).catch(function (response) {
                    $scope.promesaEntrePiso.reject();
                     
                    
                    Message.error("No se pudo obtener lista de entre pisos.");
             });

        };

         $scope.promesaTipoOcupacion = $q.defer();
         $scope.cargarTipoOcupacion = function () {

            PropuestaHogarService.getOcupacion().then(function (response) {
                    if (!response.data.error) {
                        if (response.data.dato.length > 0) {
                           $scope.listaOcupacion=[];
                           for (var i = 0; i < response.data.dato.length; i++) {
                                var objTipoOcupacion = {
                                    idOcupacion: response.data.dato[i].codigoOcupacion,
                                    descripcionOcupacion: response.data.dato[i].nombreOcupacion
                                };
                                $scope.listaOcupacion.push(objTipoOcupacion);
                           }
                           $scope.promesaTipoOcupacion.resolve();
                        }

                   }else{
                       $scope.promesaTipoOcupacion.resolve();
                       Message.error(response.data.mensaje);
                   }


                    
            }).catch(function (response) {
                    $scope.promesaEntrePiso.reject();
                     
                    
                    Message.error("No se pudo obtener lista de ocupacion.");
             });

        };

        var cargarCombos = function () {
        
            $scope.cargarTechos();
            $scope.cargarParedes();
            $scope.cargarPisos();
            $scope.cargarCieloRasos();
            $scope.cargarEntrePisos();
            $scope.cargarTipoOcupacion();

 
        };

        $scope.promesaAcreedores = $q.defer();
        $scope.obtenerAcreedores=function()
        {
            $scope.listaAcreedores=[];
            PropuestaHogarService.getAcreedores().then(function (response)
            {
                if (!response.data.error)
                {
                    if (response.data.dato !=null && response.data.dato.length>0)
                    {
                        var resultado=response.data.dato;
                        for (var i=0; i< resultado.length;i++)
                        {
                            var data={};
                            data.codigo=resultado[i].codigoAcreedor;
                            data.nombreAcreedor=resultado[i].nombreTercero;
                            $scope.listaAcreedores.push(data);
                        }

                      $scope.promesaAcreedores.resolve();
                    }
                }
                else
                {
                    $scope.promesaAcreedores.reject();
                    Message.error(response.data.mensaje);
                }
            })
        };
            $scope.removeOcupacion=function(data)
            {
                var confirm = confirmService.showConfirm('¿Está seguro eliminar la  Ocupación?')

                    .then(function(answer) {
                        var dataSave={}
                        dataSave.numeroCotizacion=$scope.numeroCotizacion;
                        dataSave.codigoOcupacion=data.idOcupacion;
                        dataSave.marcaModulo=$scope.pathModule.split("marcaModulo=")[1];
                        PropuestaHogarService.eliminarOcupacion(dataSave).then (function(response)
                        {
                            if (!response.data.error)
                            {
                                Message.ok(response.data.mensaje);
                                for (var i=0; i<$scope.ocupacionesPersisList.length;i++)
                                {
                                    if ($scope.ocupacionesPersisList[i].idOcupacion==data.idOcupacion)
                                    {
                                        $scope.ocupacionesPersisList.splice(i,1);
                                        break;
                                    }
                                }
                                $scope.cargando=false;

                            }
                            else
                            {
                                $scope.cargando=false;
                                Message.error(response.data.mensaje);
                            }

                        }).catch (function(error)  {
                            $scope.cargando=false;
                            Message.error("Algo inesperado ocurrió, intente nuevamente!");

                        });






                    }, function() {
                        return;
                    });


            };
            $scope.agregarOcupacion=function (data)
            {

                /**llamar a webservice**/
                var dataSave={}
                dataSave.numeroCotizacion=$scope.numeroCotizacion;
                dataSave.codigoOcupacion=data.idOcupacion;
                dataSave.tipoOcupacion=data.descripcionOcupacion;
                dataSave.marcaModulo=$scope.pathModule.split("marcaModulo=")[1];
                $scope.cargando=true;
                PropuestaHogarService.guardarOcupacion(dataSave).then (function(response)
                {
                    if (!response.data.error)
                    {
                        Message.ok(response.data.mensaje);
                        $scope.ocupacionesPersisList.push(data);
                        $scope.cargando=false;
                    }
                    else
                    {

                        Message.error(response.data.mensaje);
                        $scope.cargando=false;
                    }

                }).catch (function(error)  {
                    $scope.cargando=false;
                    Message.error("Algo inesperado ocurrió, intente nuevamente!");

                });

            };



        (function initialize() {
            $rootScope.currentPage = 'hogar';
            $rootScope.tabs = PropuestaHogarService.getTabInicial();
            $scope.bloquearBuscador=false;
           // $rootScope.llamarAsegurado=true;
            $scope.pathModule = UtilsService.retornarPath($location.path().split("/")[1]);
            $scope.agenteSelected=parseInt(sessionStorage.getItem("codigoAgente"));
            $scope.tieneIva='N';
            $scope.firmaDigital='N';
            $scope.imprimeGenera=undefined;
            $scope.subtipo=='Flota'?$scope.todo_concesionarias=false:$scope.todo_concesionarias=true;
        	//obtenerFormasPago();
        	//obtenerTiposTarjetas();

        	//obtenerAgentes();
        	$scope.obtenerAcreedores();
            cargarCombos();
           // obtenerAcrPrendarios();
          //  obtenerTiposEnvio();
            $scope.obtenerAutorizaciones();
           angular.extend(this, $controller('UtilsCtrl', {
                    "$scope": $scope
            }));

           TomadorService.getCiudades().then(function (response){
            if (response.data.dato.length>0)
            {
                var data=response.data.dato;
                for (var i=0; i<data.length;i++)
                {
                    $scope.ciudades.push(data[i]);
                     
                }
                //$scope.modelo.codigoPais= response.data.dato[0].COD_PAIS

            }
            
           });

           if (!angular.isUndefined($scope.numeroCotizacionRoot) && $scope.numeroCotizacionRoot!= null && $scope.numeroCotizacionRoot!=""){

             $scope.buscar();
            }
            else
            {
                PropuestaService.goToPropuestaOrigen($scope.pathModule.split("marcaModulo=")[1]);
            }
            $scope.eliminarPagina();


            
        })();
            


    }]);
;app.controller('RiesgoFormCtrl', ['$scope', '$q', '$controller', '$routeParams', '$location', 'SessionService', '$rootScope','$route', '$mdDialog', '$filter', 'ConfirmService', '$window', 'PropuestaService','CotizacionVehiculoPropuestaService','UtilsService','CotizacionVehiculoService','$log','$timeout','PropuestaHogarService','TomadorService','PropuestaMultiRiesgoService',
        function ($scope,$q, $controller, $routeParams, $location, sessionService, $rootScope,$route, $mdDialog,  $filter, confirmService, $window, PropuestaService,CotizacionVehiculoPropuestaService, UtilsService ,CotizacionVehiculoService, $log, $timeout,PropuestaHogarService, TomadorService,PropuestaMultiRiesgoService) {
            $scope.service = PropuestaService;
            $scope.controlPermisos = true;
            $scope.nombre = $route.current.$$route.subtipo;
            $rootScope.rootPathParent = $route.current.$$route.originalPath;
          
            $scope.subtipo = $scope.nombre;
            $scope.agenteSelected = undefined;
            $scope.comisionSelected = undefined;
          
            $scope.nroTarjeta = {};
            $scope.vtotarjeta = {};
            $scope.cargando = false;
            $scope.prop = {};
            $scope.prop.plataforma = null;
            $scope.nroPropuesta = null;
           
            $scope.todo_concesionarias = true;
            $scope.submitted = false;
            $scope.valorConcesionaria = undefined;
            $scope.valorComision = undefined;
            $scope.valorOficina = undefined;
            $scope.valorEjecutivo = undefined;
            $scope.valorAcreedor = undefined;
            $scope.valorTipoGestor = undefined;
            $scope.valorOficina = undefined;
            $scope.valorTipoTarjeta = undefined;
            $scope.valorEnvio = undefined;
            $scope.valorCodTarjeta = undefined;
            $scope.cambiarValores = true;
            $scope.permitirCambio = true;
            $scope.validCarga = false;
         
            $scope.tab = "MULTIRIESGO";
            $scope.sinc = 0;
            $scope.ciudades=[];
            $scope.barrios=[];
            $scope.listaFraccion = [];
            $scope.comercial={};
            $scope.comercial.fraccion=undefined;
            $scope.listaAcreedores = [];
            $scope.listaTechos = [];
            $scope.listaParedes = [];
            $scope.listaPisos = [];
            $scope.listaCielosRasos = [];
            $scope.listaEntrePisos = [];
            $scope.listaOcupacion=[];
            $scope.riesgo ={};
			$scope.riesgo.ciudad = null;
			$scope.riesgo.barrio = null;
			$scope.riesgo.direccion = null;
            $scope.riesgo.acreedorHipotecario =null;
            $scope.riesgo.importeCesion =null;
            $scope.riesgo.techo = null;
            $scope.riesgo.pared = undefined;
            $scope.riesgo.piso = null;
         
            $scope.riesgo.numeroInspeccion=null;
            $scope.riesgo.numero = null;
            $scope.riesgo.ctacatastral = null;
            $scope.riesgo.finca = null;
            $scope.riesgo.edificio = null;
           
            $scope.habilitarImpCesion=false;

            $scope.ocupacion =undefined;

            $scope.ocupacionesPersisList=[];
            $scope.valor={};
            $scope.valor.barrio = undefined;
            
            /**variable que almcena las promesas resueltas o fracasadas*/
            var cantModeloSinc = 0;
            /**variable que almacena la cantidad de datos que vienen en el buscar, que requieren otras llamadas de promesas**/
            $scope.pagoPreferencia = undefined;
            $scope.cambiarTab = 0; //valor inicial
            $scope.verificarCamposForm = function (listaCampo, campo) {
                return UtilsService.verificarCamposForm(listaCampo, campo);
            };

            /**Funcion que se encarga de incrementar la variable de sincronizacion cuando las promesas se resuelven o tienen error*/
            $scope.incrementarSincronizador = function (campo) {
                if (campo != null) {
                    $scope.sinc++;
                }
            }

            

  
            $scope.$watch('riesgo.acreedorHipotecario', function (newValue, oldValue) {
                if (!angular.isUndefined(newValue) && newValue != null) {
                    //$scope.sinc++;
                    $scope.habilitarImpCesion=true;
                    $scope.riesgo.importeCesion=0;
                }
                else
                {
                    $scope.habilitarImpCesion=false;
                    $scope.riesgo.importeCesion=null;
                }

            }, true);
            

 

            $scope.save = function (clickButton) {


                $scope.submitted = false;
                $scope.numeroCotizacion = $scope.numeroCotizacionRoot;

                var riesgo = {};
                riesgo.numeroCotizacion = $scope.numeroCotizacion;
                riesgo.codigoCiudad = angular.isUndefined($scope.riesgo.ciudad)?"":$scope.riesgo.ciudad;
                riesgo.codigoBarrio=angular.isUndefined($scope.riesgo.barrio)?"":$scope.riesgo.barrio;
                riesgo.direccion=$scope.riesgo.direccion;
                riesgo.numeroCasa=$scope.riesgo.numero;
                riesgo.numeroFinca=$scope.riesgo.finca;
                riesgo.acreedor=angular.isUndefined($scope.riesgo.acreedorHipotecario)?"":$scope.riesgo.acreedorHipotecario;
                riesgo.impCesion=$scope.riesgo.importeCesion;
                riesgo.tipoTecho=angular.isUndefined($scope.riesgo.techo)?"":$scope.riesgo.techo;
                riesgo.tipoPiso=angular.isUndefined($scope.riesgo.piso)?"":$scope.riesgo.piso;
                riesgo.tipoCieloraso=angular.isUndefined($scope.riesgo.cieloraso)?"":$scope.riesgo.cieloraso;
                riesgo.tipoPared=angular.isUndefined($scope.riesgo.pared)?"":$scope.riesgo.pared;
                riesgo.tipoEntrePiso=angular.isUndefined($scope.riesgo.entrepiso)?"":$scope.riesgo.entrepiso;
                riesgo.nombreEdificio =angular.isUndefined($scope.riesgo.edificio)?"":$scope.riesgo.edificio;
                riesgo.numeroInspeccion = angular.isUndefined($scope.riesgo.numeroInspeccion)?"":$scope.riesgo.numeroInspeccion;   
                riesgo.cuentaCorrienteCat = angular.isUndefined($scope.riesgo.ctacatastral)?"":$scope.riesgo.ctacatastral;      

                var param = JSON.stringify(riesgo);
                console.log(param)
                $scope.cargando = true;
                PropuestaMultiRiesgoService.guardarPropuestaMultiriesgo(riesgo).then(
                    //sucess
                    function (response) {

                        if (!response.data.error) {

                            if (clickButton == "S") {
                                var param = {};
                                param.numeroCotizacion = $scope.numeroCotizacion;
                                param.marcaFlota = $scope.subtipo == 'Flota' ? 'S' : 'N';
                                param.tab = $scope.tab;
                                param.pathModule=$scope.pathModule;
                                PropuestaHogarService.getTabs(param);
                            } else {
                                $scope.cambiarTab = 1; //exito
                            }


                            Message.ok(response.data.mensaje);
                        } else {
                            $scope.cambiarTab = 2; //error
                            Message.error(response.data.mensaje);

                        }
                        $scope.cargando = false;
                        //error
                    }).catch(function (response) {
                    $scope.cargando = false;
                    $scope.cambiarTab = 2; //error
                    Message.error(response.data.mensaje);

                });


            };


            $scope.buscar = function () {
                $scope.numeroCotizacion = $scope.numeroCotizacionRoot;
                if (!angular.isUndefined($scope.numeroCotizacion)) {
                    if ($scope.numeroCotizacion != null && $scope.numeroCotizacion != "") {
                        $scope.cargando = true;
                        var param = {};
                        param.numeroCotizacion = $scope.numeroCotizacion;
                        param.marcaFlota = $scope.subtipo == 'Flota' ? 'S' : 'N';
                        param.tab = $scope.tab;
                        param.pathModule=$scope.pathModule;
                        $scope.todo_concesionarias = false;
                       // $scope.agenteSelected = undefined;
                        $scope.sinc = 0;
                        cantModeloSinc = 0;
                        $scope.permitirCambio = false;


                        PropuestaMultiRiesgoService.getPropuestaMultiriesgo(param).then(
                            //sucess
                            function (response) {

                                if (!response.data.error) {
                                    PropuestaHogarService.getTabs(param)
                                    if (response.data.dato != null ) {


                                        $scope.bloquearBuscador = true;
                                        $scope.cambiarValores = false;
                                        $scope.cargarPlataforma();
                                      //  $scope.tieneIva = response.data.dato[0].MCA_IVA == null ? 'S' : response.data.dato[0].MCA_IVA;
                                       // $scope.firmaDigital = response.data.dato[0].MCA_FIRMA_ELECTRONICA == null ? 'N' : response.data.dato[0].MCA_FIRMA_ELECTRONICA;
                                        $scope.setearCantidadModelos(response);


                                        $scope.riesgo.ciudad = response.data.dato.codigoCiudad!=null? parseInt(response.data.dato.codigoCiudad):undefined;
                                        $scope.cambiarBarrio("N");
                                        promesaBarrios.promise.then(function () {
                                            $scope.riesgo.barrio=response.data.dato.codigoBarrio!=null?parseInt(response.data.dato.codigoBarrio):undefined;
                                            $scope.incrementarSincronizador($scope.riesgo.barrio);
                                        
                                        })


                                        $scope.riesgo.direccion =response.data.dato.direccion;
                                        $scope.riesgo.numeroInspeccion = response.data.dato.numeroInspeccion;
                                        $scope.riesgo.numero = response.data.dato.numeroCasa;
                                        $scope.riesgo.ctacatastral =  response.data.dato.cuentaCorrienteCat;
                                        $scope.riesgo.finca =  response.data.dato.numeroFinca;
                                        $scope.riesgo.edificio = response.data.dato.nombreEdificio;
                                        $scope.riesgo.importeCesion = response.data.dato.impCesion;
                                         


                                        $scope.promesaAcreedores.promise.then(
                                            function () {
                                                $scope.riesgo.acreedorHipotecario =  response.data.dato.acreedor==null?undefined:response.data.dato.acreedor==""?undefined:response.data.dato.acreedor;                                  
                                                
                                              //  $scope.incrementarSincronizador($scope.riesgo.acreedorHipotecario);

                                                
                                        });
                                     


                                        $scope.promesaTecho.promise.then(
                                            function () {
                                                                                      
                                                $scope.riesgo.techo=response.data.dato.tipoTecho==null?undefined:response.data.dato.tipoTecho==""?undefined:response.data.dato.tipoTecho;
                                               // $scope.incrementarSincronizador($scope.riesgo.techo);

                                                
                                        });

                                        $scope.promesaPared.promise.then(
                                            function () {
                                                
                                               $scope.riesgo.pared=response.data.dato.tipoPared==null?undefined:response.data.dato.tipoPared==""?undefined:response.data.dato.tipoPared;
                                              // $scope.incrementarSincronizador($scope.riesgo.pared);

                                        });
                                        

                                       
                                        $scope.promesaPiso.promise.then(function () {
                                            $scope.riesgo.piso = response.data.dato.tipoPiso==null?undefined :response.data.dato.tipoPiso==""?undefined:response.data.dato.tipoPiso;
                                            $scope.incrementarSincronizador($scope.riesgo.piso);

                                        });

                                        $scope.promesaCieloRaso.promise.then(function () {
                                            $scope.riesgo.cieloraso = response.data.dato.tipoCieloraso==null ?undefined:response.data.dato.tipoCieloraso==""?undefined:response.data.dato.tipoCieloraso;
                                           // $scope.incrementarSincronizador($scope.riesgo.cieloraso);

                                        });


                                       $scope.promesaEntrePiso.promise.then(
                                            function () {
                                                $scope.riesgo.entrepiso = response.data.dato.tipoEntrepiso ==null? undefined:response.data.dato.tipoEntrepiso==""?undefined:response.data.dato.tipoEntrepiso ;
                                               // $scope.incrementarSincronizador($scope.riesgo.entrepiso);
 

                                        });

 
                                        $rootScope.nroPropuesta = angular.isUndefined(response.data.dato.numeroPropuesta) ? null : response.data.dato.numeroPropuesta;
                                      


                                       
                                     $scope.cargando = false;

                                    } else {
                                        $scope.limpiar();
                                       // $rootScope.llamarAsegurado = true;
                                        Message.warning(response.data.mensaje);
                                        $scope.cargando = false;
                                    }


                                } else {
                                    $scope.limpiar();
                                   // $rootScope.llamarAsegurado = true;
                                    $scope.cargando = false;
                                    Message.error(response.data.mensaje);
                                }

                                //error
                            }).catch(function (response) {
                            $scope.limpiar();
                          //  $rootScope.llamarAsegurado = true;
                            $scope.cargando = false;
                            console.log(response);
                            Message.error("Ocurrió un error, intente nuevamente");

                        });

                    }

                }


            };
            $scope.$watch('numeroCotizacion', function (NewValue, OldValue) {
                if (!angular.isUndefined(NewValue) && NewValue != null) {
                    var param={};
                    param.numeroCotizacion=NewValue;
                    param.pathModule = $scope.pathModule;
                    $scope.ocupacionesPersisList=[];
                    PropuestaHogarService.recuperarOcupacion(param).then(function (response) {
                        if (!response.data.error) {
                            var result=response.data.dato
                            if (result!=null && result.length>0)
                            {
                                for (var i=0; i<result.length;i++)
                                {
                                     var data={};
                                     data.idOcupacion= result[i].codigoOcupacion;
                                     data.descripcionOcupacion=result[i].nombreOcupacion;
                                    $scope.ocupacionesPersisList.push(data);

                                }
                            }

                        } else {
                            Message.error(response.data.mensaje);
                        }
                    })
                }



            }, true);


            /**formato para el datepicker**/
            $scope.formatearFecha = function (fecha) {
                $scope.aplicarFormato(fecha);
            };


            $scope.cargarPlataforma = function () {

                var paramPla = {};
                paramPla.numeroCotizacion = $scope.numeroCotizacion;
                paramPla.marcaFlota = $scope.subtipo == 'Flota' ? 'S' : 'N';
                paramPla.pathModule = $scope.pathModule;
                CotizacionVehiculoPropuestaService.getPlataforma(paramPla).then(
                    function (response) {
                        if (!response.data.error) {
                            if (response.data.dato != null) {

                                $scope.mostrarPlataforma = true;

                                $scope.prop.plataforma = response.data.dato.mensaje;


                            }

                        }


                    }).catch(function (response) {

                    Message.error(response.data.mensaje);

                });
            };


            /**
             * Función creada para el salto de propuesta a cotizacion
             */
            $scope.goToCotizacion = function () {
                var path = $location.$$absUrl;
                var n = path.search("module");
                var url = path.substring(0, n);

                if (typeof $scope.numeroCotizacionRoot != 'undefined' && $scope.numeroCotizacionRoot != null) {
  var subtipo = 'flota';
                   if ($scope.subtipo == 'Vehiculos') {
                        subtipo = 'cotizacion-vehiculo';


                    }else if ($scope.subtipo== 'Flota'){
                          subtipo = 'flota';
                    }else if ($scope.subtipo== 'Propuesta Hogar'){
                           subtipo = 'cotizacion-hogar';
                    }


                    location.href = subtipo + '/' + $scope.numeroCotizacionRoot;

                } else {
                    Message.warning("Debe ingresar un número de cotización");
                }
            }


            $scope.limpiar = function () {

                $rootScope.camposRequeridosList = [];
                $rootScope.numeroCotizacionRoot = undefined;
                $rootScope.nroPropuesta = undefined;
                $scope.eliminarPagina();
                if (typeof $routeParams.numeroCotizacion != "undefined") {
                    $location.search('numeroCotizacion', undefined);
                    $rootScope.numeroCotizacionRoot = undefined;
                    if ($scope.subtipo == "Flota") {
                        $location.path('propuesta-flota/propuesta')
                    } else if ($scope.subtipo == "Vehiculos"){
                        $location.path('propuesta-vehiculo/propuesta')
                    } else if ($scope.subtipo == "Propuesta Hogar"){
                        $location.path('propuesta-hogar/hogar')
                    }


                } else {
                    $route.reload();
                }

            };
            $scope.recargar = function () {
                $scope.agenteSelected = undefined;
                $scope.bloquearBuscador = false;
                $scope.mostrarPlataforma = false;
                $scope.limpiar();

            };

            $scope.llamarModal = function (value) {

                if (!angular.isUndefined($rootScope.numeroCotizacionRoot) && $rootScope.numeroCotizacionRoot != null && $rootScope.numeroCotizacionRoot != "") {
                    $rootScope.numCotiza = $rootScope.numeroCotizacionRoot;
                    $rootScope.modalCotizadorVehFlota = value;
                    $rootScope.flagVehiculoFlota = false;
                    $rootScope.flagHogar=true;
                    $mdDialog.show({
                        //locals:{parent: $scope},
                        controller: 'ModalAutorizacionCtrl',
                        templateUrl: 'partials/ventanas-emergentes/modal-autorizacion-partial.html',
                        parent: angular.element(document.body),
                        multiple: true,
                        clickOutsideToClose: false,
                        scope: $scope,
                        preserveScope: true,
                        fullscreen: $scope.customFullscreen // Only for -xs, -sm breakpoints.
                    }).then(function (answer) {
                        $scope.buscar();


                    }, function () {
                        $scope.status = 'You cancelled the dialog.';
                        //console.log($scope.status);
                    });
                }

            };


            $scope.obtenerAutorizaciones = function () {

                $scope.autorizacionesList = [];
                var param = {};
                param.pathModule =$scope.pathModule;
                CotizacionVehiculoService.getAutorizaciones(param).then(function (response) {
                    if (!response.data.error) {
                        if (response.data.dato.length > 0) {
                            var campos = response.data.dato;
                            for (var i = 0; i < campos.length; i++) {
                                $scope.autorizacionesList.push(campos[i]);

                            }
                        }
                        //console.log("Lista Autorizaciones: " + JSON.stringify($scope.autorizacionesList));
                    } else {
                        Message.error(response.data.mensaje);
                    }
                });
            };

            /**Este Watch se dispara cuando las promesas se resuelven o tiene error, y la condicion principal debe ser
             * que el valor del sinc sea mayor a 0, sino ocurre eso es porque hay un error en el buscar o viene vacio el modelo de buscar**/

            $scope.$watch('sinc', function (NewValue, OldValue) {
                if (NewValue == cantModeloSinc && NewValue > 0) {
                    $scope.cargando = false;
                    $scope.sinc = 0; //cantidad de modelos seteados una vez obtenida la promesa
                    cantModeloSinc = 0; //cantidad de modelos que necesitan llamadas de servicios
                }


            }, true);
            $scope.setearCantidadModelos = function (response) {
                //preguntar la cantidad de campos a ser seteados
               
                 if (response.data.dato.codigoBarrio && response.data.dato.codigoBarrio != "" ) {
                     $scope.valor.barrio = response.data.dato.codigoBarrio;
                     cantModeloSinc++;
                 } 

               
                /**Si no hay datos en el modelo que no necesitan promesas entonces se debe de ocultar el cargando*/
                if (cantModeloSinc == 0) {
                    $scope.cargando = false;
                }
            };
            $scope.$watch('cambiarTab', function (newValue, oldValue) {
                if (newValue != 0) {
                    if (newValue == 1) {
                        //hacer el redirect

                        var params={};
                        params.marcaFlota=$scope.subtipo=="Flota"?'S':'N';
                        params.numeroCotizacion=angular.isUndefined($scope.numeroCotizacionRoot)|| $scope.numeroCotizacionRoot==null?"":$scope.numeroCotizacionRoot;
                        params.tab=$rootScope.sigTab;
                        params.pathModule=$scope.pathModule;
                        $scope.service.getCamposEditablesList(params);
                        $timeout($location.url($rootScope.url_destino),1000);
                    } else {
                        newValue = 0; //para que vuelva a cambiar e intentar
                    }
                }

            }, true);
            $scope.eliminarPagina=function()
            {
                sessionStorage.removeItem("paginaAsegurado");
                sessionStorage.removeItem("paginaRiesgoPropuesta");
            };

             var promesaBarrios= $q.defer();
          $scope.cambiarBarrio=function(tag)
        {
 
             if(!angular.isUndefined($scope.riesgo.ciudad) && $scope.riesgo.ciudad !== ""){
                    if (tag=='S')
                    {
                        $scope.riesgo.barrio=undefined;
                    }
                    for(var i=0; i<$scope.ciudades.length; i++){
                        if ($scope.ciudades[i].id==$scope.riesgo.ciudad){
                            $scope.codigoEstado= $scope.ciudades[i].COD_ESTADO;
                            break;
                        }
                    }
                    if ($scope.riesgo.ciudad!=null && $scope.riesgo.ciudad!="")
                    {
                        var parametros = {};
                        parametros.codigo=$scope.riesgo.ciudad;
                        TomadorService.getBarrios(parametros).then(function(response) {
                            if (!response.data.error)
                            {
                                $scope.barrios=[];
                                if (response.data.dato!=null)
                                {
                                    if (response.data.dato.length > 0) {
                                        var data = response.data.dato;
                                        for (var i = 0; i < data.length; i++) {
                                            $scope.barrios.push(data[i]);
                                        }
                                        promesaBarrios.resolve();

                                    } else {

                                        Message.info("No se pudo obtener los barrios");
                                        promesaBarrios.resolve();
                                    }
                                }


                            }
                            else
                            {
                                promesaBarrios.resolve();
                                Message.error(response.data.mensaje);
                            }



                        }).catch(function(error){
                            Message.error("Ocurrió un error al obtener la lista de barrios ");
                            promesaBarrios.reject();
                            $scope.riesgo.barrio=$scope.valor.barrio;
                            $scope.incrementarSincronizador($scope.valor.barrio);
                        });
                        $scope.refrescarDatos();
                    }




            }
    };
     
    $scope.refrescarDatos=function()
    {
      //if ($scope.modelo.datosDomicilioParticular=="2")
     // {
         // $scope.desactivar=true;
          //hay que copiar lo que hay en datos particulares a datos laborales
          // $scope.riesgo.direccion=$scope.modelo.direccion1;
          // $scope.modelo.direccionLaboral2=$scope.modelo.direccion2;
          // $scope.modelo.direccionLaboral3=$scope.modelo.direccion3;
          // $scope.riesgo.ciudadLaboral=$scope.riesgo.ciudad;
          // $scope.barriosLaboral=$scope.barrios;
          // $scope.modelo.telefonoLaboral=$scope.modelo.telefono;
          // $scope.modelo.telefonoLaboralPrefijo=$scope.modelo.telefonoPrefijo;
          // $scope.modelo.telefonoLaboralPais=$scope.modelo.telefonoPais;
          // $scope.modelo.emailLaboral=$scope.modelo.email;
          // $scope.modelo.faxLaboral=$scope.modelo.fax;
          // $scope.riesgo.barrioLaboral=$scope.riesgo.barrio;
     // }
    };

     

        $scope.promesaTecho = $q.defer();
        $scope.cargarTechos = function () {
            PropuestaHogarService.getTecho().then(function (response) {
                   if (!response.data.error) {
                      if (response.data.dato.length > 0) {
                          $scope.listaTechos =[];
                          for (var i = 0; i < response.data.dato.length; i++) {
                               var objTecho = {
                                    idTecho: response.data.dato[i].codigoTecho,
                                    nombreTecho: response.data.dato[i].descripcionTecho
                                };
                                $scope.listaTechos.push(objTecho);
                          }
                          $scope.promesaTecho.resolve();
                        }

                   }else{
                        $scope.promesaTecho.resolve();
                        Message.error(response.data.mensaje);
                   }
                   
            }).catch(function (response) {
                     $scope.promesaTecho.reject();
                     
                    
                    Message.error("No se pudo obtener lista de techos.");
             });

        };

        $scope.promesaPared = $q.defer();
        $scope.cargarParedes = function () {
            PropuestaHogarService.getPared().then(function (response) {
                    if (!response.data.error) {
                        if (response.data.dato.length > 0) {
                             $scope.listaParedes =[];
                             for (var i = 0; i < response.data.dato.length; i++) {
                                var objParedes = {
                                    idPared: response.data.dato[i].codigoPared,
                                    nombrePared: response.data.dato[i].descripcionPared
                                };
                                $scope.listaParedes.push(objParedes);
                          }
                          $scope.promesaPared.resolve();
                        }

                   }else{
                       $scope.promesaPared.resolve();
                       Message.error(response.data.mensaje);
                   }

 
            }).catch(function (response) {
                    $scope.promesaPared.reject();
                    
                    Message.error("No se pudo obtener lista de paredes.");
             });
         

        };

        $scope.promesaPiso = $q.defer();
        $scope.cargarPisos = function () {
            PropuestaHogarService.getPiso().then(function (response) {
                    if (!response.data.error) {
                        if (response.data.dato.length > 0) {
                            $scope.listaPisos =[];
                            for (var i = 0; i < response.data.dato.length; i++) {
                                var objPisos = {
                                    idPiso: response.data.dato[i].codigoPiso,
                                    nombrePiso: response.data.dato[i].descripcionPiso
                                };
                                $scope.listaPisos.push(objPisos);
                            }
                            $scope.promesaPiso.resolve();
                        }

                   }else{
                        $scope.promesaPiso.resolve();
                       Message.error(response.data.mensaje);
                   }

                   
            }).catch(function (response) {
                     $scope.promesaPiso.reject();
                    
                    Message.error("No se pudo obtener lista de pisos.");
             });


        };

        $scope.promesaCieloRaso = $q.defer();
        $scope.cargarCieloRasos = function () {
            PropuestaHogarService.getCieloRaso().then(function (response) {
                    if (!response.data.error) {
                        if (response.data.dato.length > 0) {
                            $scope.listaCielosRasos =[];
                            for (var i = 0; i < response.data.dato.length; i++) {
                                 var objCieloRaso = {
                                    idCieloRaso: response.data.dato[i].codigoCieloraso,
                                    nombreCieloRaso: response.data.dato[i].descripcionCieloraso
                                };
                                $scope.listaCielosRasos.push(objCieloRaso);
                            }

                            $scope.promesaCieloRaso.resolve();
                        }

                   }else{
                        $scope.promesaCieloRaso.resolve();
                       Message.error(response.data.mensaje);
                   }

              
            }).catch(function (response) {
                     $scope.promesaCieloRaso.reject();
                 
                    Message.error("No se pudo obtener lista de cieloraso.");
             });


        };

        $scope.promesaEntrePiso = $q.defer();
        $scope.cargarEntrePisos = function () {

            PropuestaHogarService.getEntrePiso().then(function (response) {
                    if (!response.data.error) {
                        if (response.data.dato.length > 0) {
                           $scope.listaEntrePisos=[];
                           for (var i = 0; i < response.data.dato.length; i++) {
                                var objEntrePiso = {
                                    idEntrePiso: response.data.dato[i].codigoEntrepiso,
                                    nombreEntrepiso: response.data.dato[i].descripcionEntrepiso
                                };
                                $scope.listaEntrePisos.push(objEntrePiso);
                           }
                           $scope.promesaEntrePiso.resolve();
                        }

                   }else{
                       $scope.promesaEntrePiso.resolve();
                       Message.error(response.data.mensaje);
                   }


                    
            }).catch(function (response) {
                    $scope.promesaEntrePiso.reject();
                     
                    
                    Message.error("No se pudo obtener lista de entre pisos.");
             });

        };

         $scope.promesaTipoOcupacion = $q.defer();
         $scope.cargarTipoOcupacion = function () {

            PropuestaHogarService.getOcupacion().then(function (response) {
                    if (!response.data.error) {
                        if (response.data.dato.length > 0) {
                           $scope.listaOcupacion=[];
                           for (var i = 0; i < response.data.dato.length; i++) {
                                var objTipoOcupacion = {
                                    idOcupacion: response.data.dato[i].codigoOcupacion,
                                    descripcionOcupacion: response.data.dato[i].nombreOcupacion
                                };
                                $scope.listaOcupacion.push(objTipoOcupacion);
                           }
                           $scope.promesaTipoOcupacion.resolve();
                        }

                   }else{
                       $scope.promesaTipoOcupacion.resolve();
                       Message.error(response.data.mensaje);
                   }


                    
            }).catch(function (response) {
                    $scope.promesaEntrePiso.reject();
                     
                    
                    Message.error("No se pudo obtener lista de ocupacion.");
             });

        };

        var cargarCombos = function () {
        
            $scope.cargarTechos();
            $scope.cargarParedes();
            $scope.cargarPisos();
            $scope.cargarCieloRasos();
            $scope.cargarEntrePisos();
            $scope.cargarTipoOcupacion();

 
        };

        $scope.promesaAcreedores = $q.defer();
        $scope.obtenerAcreedores=function()
        {
            $scope.listaAcreedores=[];
            PropuestaHogarService.getAcreedores().then(function (response)
            {
                if (!response.data.error)
                {
                    if (response.data.dato !=null && response.data.dato.length>0)
                    {
                        var resultado=response.data.dato;
                        for (var i=0; i< resultado.length;i++)
                        {
                            var data={};
                            data.codigo=resultado[i].codigoAcreedor;
                            data.nombreAcreedor=resultado[i].nombreTercero;
                            $scope.listaAcreedores.push(data);
                        }

                      $scope.promesaAcreedores.resolve();
                    }
                }
                else
                {
                    $scope.promesaAcreedores.reject();
                    Message.error(response.data.mensaje);
                }
            })
        };
            $scope.removeOcupacion=function(data)
            {
                var confirm = confirmService.showConfirm('¿Está seguro eliminar la  Ocupación?')

                    .then(function(answer) {
                        var dataSave={}
                        dataSave.numeroCotizacion=$scope.numeroCotizacion;
                        dataSave.codigoOcupacion=data.idOcupacion;
                        PropuestaHogarService.eliminarOcupacion(dataSave).then (function(response)
                        {
                            if (!response.data.error)
                            {
                                Message.ok(response.data.mensaje);
                                for (var i=0; i<$scope.ocupacionesPersisList.length;i++)
                                {
                                    if ($scope.ocupacionesPersisList[i].idOcupacion==data.idOcupacion)
                                    {
                                        $scope.ocupacionesPersisList.splice(i,1);
                                        break;
                                    }
                                }
                                $scope.cargando=false;

                            }
                            else
                            {
                                $scope.cargando=false;
                                Message.error(response.data.mensaje);
                            }

                        }).catch (function(error)  {
                            $scope.cargando=false;
                            Message.error("Algo inesperado ocurrió, intente nuevamente!");

                        });






                    }, function() {
                        return;
                    });


            };
            $scope.agregarOcupacion=function (data)
            {

                /**llamar a webservice**/
                var dataSave={}
                dataSave.numeroCotizacion=$scope.numeroCotizacion;
                dataSave.codigoOcupacion=data.idOcupacion;
                dataSave.tipoOcupacion=data.descripcionOcupacion;
                dataSave.marcaModulo=$scope.pathModule.split("marcaModulo=")[1];
                $scope.cargando=true;
                PropuestaHogarService.guardarOcupacion(dataSave).then (function(response)
                {
                    if (!response.data.error)
                    {
                        Message.ok(response.data.mensaje);
                        $scope.ocupacionesPersisList.push(data);
                        $scope.cargando=false;
                    }
                    else
                    {

                        Message.error(response.data.mensaje);
                        $scope.cargando=false;
                    }

                }).catch (function(error)  {
                    $scope.cargando=false;
                    Message.error("Algo inesperado ocurrió, intente nuevamente!");

                });

            };



        (function initialize() {
            $rootScope.currentPage = 'propuestaRiesgo';
            $rootScope.tabs = PropuestaHogarService.getTabInicial();
            $scope.bloquearBuscador=false;
           // $rootScope.llamarAsegurado=true;
            $scope.pathModule = UtilsService.retornarPath($location.path().split("/")[1]);
            $scope.agenteSelected=parseInt(sessionStorage.getItem("codigoAgente"));
            $scope.tieneIva='N';
            $scope.firmaDigital='N';
            $scope.imprimeGenera=undefined;
            $scope.subtipo=='Flota'?$scope.todo_concesionarias=false:$scope.todo_concesionarias=true;
        	 
        	$scope.obtenerAcreedores();
            cargarCombos();
           
            $scope.obtenerAutorizaciones();
           angular.extend(this, $controller('UtilsCtrl', {
                    "$scope": $scope
            }));

           TomadorService.getCiudades().then(function (response){
            if (response.data.dato.length>0)
            {
                var data=response.data.dato;
                for (var i=0; i<data.length;i++)
                {
                    $scope.ciudades.push(data[i]);
                     
                }
                

            }
            
           });

           if (!angular.isUndefined($scope.numeroCotizacionRoot) && $scope.numeroCotizacionRoot!= null && $scope.numeroCotizacionRoot!=""){

             $scope.buscar();
            }
            else
            {
                PropuestaService.goToPropuestaOrigen($scope.pathModule.split("marcaModulo=")[1]);
            }
            $scope.eliminarPagina();


            
        })();
            


    }]);
;app.controller('PropuestaMultiRiesgoFormCtrl', ['$scope', '$q', '$controller', '$routeParams', '$location', 'SessionService', '$rootScope','$route', '$mdDialog', '$filter', 'ConfirmService', '$window', 'PropuestaService','CotizacionVehiculoPropuestaService','UtilsService','CotizacionVehiculoService','$log','$timeout','PropuestaMultiRiesgoService',
        function ($scope,$q, $controller, $routeParams, $location, sessionService, $rootScope,$route, $mdDialog,  $filter, confirmService, $window, PropuestaService,CotizacionVehiculoPropuestaService, UtilsService ,CotizacionVehiculoService, $log, $timeout,PropuestaMultiRiesgoService) {
            $scope.service = PropuestaService;
            $scope.controlPermisos = true;
            $scope.nombre =  $route.current.$$route.subtipo;
            $rootScope.rootPathParent = $route.current.$$route.originalPath;
            $scope.listaComision = [];
            $scope.subtipo = $scope.nombre;
            $scope.agenteSelected = undefined;
            $scope.comisionSelected = undefined;
            $scope.oficinaSelected = undefined;
            $scope.sucursalSelected = undefined;
            $scope.tipoEnvioSelected = undefined;
            $scope.tipoTarjetaSelected = undefined;
        
            $scope.ejecutivoSelected = undefined;
            $scope.formaPagoSelected = undefined;
            $scope.nroCobroAnt = {};
            $scope.modelo = {};
            $scope.nroInterno = {};
            $scope.nroCuentaCte = {};
            $scope.nroCuentaCte.valor = undefined;
            $scope.nroTarjeta = {};
            $scope.vtotarjeta = {};
            $scope.cargando = false;
            $scope.prop = {};
            $scope.prop.plataforma = null;
            $scope.nroPropuesta = null;
            $scope.gestorSelected = undefined;
            $scope.entidadSelected = undefined;
            $scope.todo_concesionarias = true;
            $scope.submitted = false;
           // $scope.valorConcesionaria = undefined;
            $scope.valorComision = undefined;
            $scope.valorOficina = undefined;
            $scope.valorEjecutivo = undefined;
            $scope.valorAcreedor = undefined;
            $scope.valorTipoGestor = undefined;
            $scope.valorOficina = undefined;
            $scope.valorTipoTarjeta = undefined;
            $scope.valorEnvio = undefined;
            $scope.valorCodTarjeta = undefined;
            $scope.cambiarValores = true;
            $scope.permitirCambio = true;
            $scope.validCarga = false;
            $scope.cambiarGestor = true;
            $scope.tab = "PROPUESTA";
            $scope.sinc = 0;
            /**variable que almcena las promesas resueltas o fracasadas*/
            var cantModeloSinc = 0;
            /**variable que almacena la cantidad de datos que vienen en el buscar, que requieren otras llamadas de promesas**/
            $scope.pagoPreferencia = undefined;
            $scope.cambiarTab = 0; //valor inicial
            $scope.verificarCamposForm = function (listaCampo, campo) {
                return UtilsService.verificarCamposForm(listaCampo, campo);
            };
            var obtenerComision = function (codigoAgente) {
                 var params = {};
                 params.codigoAgente = codigoAgente;
                 params.pathModule=$scope.pathModule;
                PropuestaService.obtenerComision(params).then(function (response) {
                    if (!response.data.error) {
                        $scope.listaComision = response.data.dato;
                        $scope.promesaComision.resolve();
                    } else {
                        Message.error(response.data.error);
                        $scope.promesaComision.resolve();
                    }

                }).catch(function (response) {
                    $scope.promesaComision.reject();
                    Message.error("No se pudo obtener las comisiones");
                    $scope.comisionSelected = $scope.valorComision;
                    $scope.incrementarSincronizador($scope.comisionSelected);
                });
            };


            var obtenerOficina = function (codigoAgente) {
                PropuestaService.obtenerOficinas(codigoAgente).then(function (response) {
                    if (!response.data.error) {
                        $scope.listaOficina = response.data.dato;
                        if ($scope.permitirCambio)
                        {
                            //aca se pregunta si viene un solo elemento de oficinal
                            if ($scope.listaOficina!=null)
                            {
                                if ($scope.listaOficina.length==1) //se setea el que viene alli
                                {
                                    $scope.oficinaSelected=$scope.listaOficina[0].COD_NIVEL3;

                                }
                            }
                        }
                    } else {
                        Message.error(response.data.mensaje);
                    }
                    $scope.promesaOficina.resolve();
                }).catch(function (response) {
                    $scope.promesaOficina.reject();
                    $scope.oficinaSelected = $scope.valorOficina;
                    $scope.incrementarSincronizador($scope.oficinaSelected);
                    Message.error("No se pudo obtener las oficinas");
                });
            };
            /**Funcion que se encarga de incrementar la variable de sincronizacion cuando las promesas se resuelven o tienen error*/
            $scope.incrementarSincronizador = function (campo) {
                if (campo != null) {
                    $scope.sinc++;
                }
            }

            var promesaObtenerFormasPago = $q.defer();
            var obtenerFormasPago = function () {
                var preferencia;
                preferencia = "N";
                PropuestaService.obtenerFormasPago(preferencia).then(function (response) {
                    if (!response.data.error) {
                        $scope.listaFormasPago = response.data.dato;

                        //obtener las que son de preferencia y setear
                        if ($scope.subtipo != "Flota") {

                            preferencia = window.sessionStorage.getItem("preferencia_forma_pago");
                            if (preferencia == "S") {
                                PropuestaService.obtenerFormasPago(preferencia).then(function (response) {
                                    //$scope.formaPagoSelected.valor = response.data.dato[0].TIP_GESTOR;
                                    //$scope.formaPagoSelected = response.data.dato[0].TIP_GESTOR;
                                    if (!response.data.error) {
                                        if (response.data.dato.length > 0) {
                                            $scope.pagoPreferencia = response.data.dato[0].TIP_GESTOR;
                                        }
                                        promesaObtenerFormasPago.resolve();
                                    } else {
                                        promesaObtenerFormasPago.resolve();
                                        Message.error(response.data.error);
                                    }

                                }, function (response) {
                                    promesaObtenerFormasPago.reject();
                                    Message.error("No se pudo obtener las formas de pago de preferencia");

                                });
                            } else {
                                promesaObtenerFormasPago.resolve();
                                //$scope.formaPagoSelected.valor=undefined;
                                $scope.formaPagoSelected = undefined;
                            }

                        }
                        else
                        {
                            promesaObtenerFormasPago.resolve();
                        }

                    } else {
                        promesaObtenerFormasPago.resolve();
                        Message.error(response.data.mensaje);
                    }



                }).catch(function (response) {
                    promesaObtenerFormasPago.reject();
                    $scope.formaPagoSelected = $scope.valorTipoGestor;
                    $scope.incrementarSincronizador($scope.formaPagoSelected);
                    Message.error("No se pudo obtener las formas de pago");
                });


            };


            var obtenerEjecutivos = function (codNivel3) {
                PropuestaService.obtenerEjecutivos(codNivel3).then(function (response) {
                    if (!response.data.error) {
                        $scope.listaEjecutivos = response.data.dato;

                    } else {
                        Message.error(response.data.mensaje);
                    }

                    promesaEjecutivo.resolve();
                }).catch(function (response) {
                    promesaEjecutivo.reject();
                    Message.error("No se pudo obtener los ejecutivos");
                    $scope.ejecutivoSelected = $scope.valorEjecutivo;
                    $scope.incrementarSincronizador($scope.ejecutivoSelected);
                });
            };

            var promesaTipoEnvio = $q.defer();
            var obtenerTiposEnvio = function () {
                PropuestaService.obtenerTiposEnvio().then(function (response) {
                    $scope.listaTiposEnvio = response.data.dato;
                    promesaTipoEnvio.resolve();
                }).catch(function (response) {
                    promesaTipoEnvio.reject();
                    $scope.tipoEnvioSelected = $scope.valorEnvio;
                    $scope.incrementarSincronizador($scope.tipoEnvioSelected);
                    Message.error("No se pudo obtener los tipos de envio");
                });
            };


            var obtenerGestores = function (codigoFormaPago) {
                var param = {};
                param.codigoFormaPago = codigoFormaPago;
                param.pathModule = $scope.pathModule;
                PropuestaService.obtenerGestores(param).then(function (response) {
                    if (!response.data.error) {
                        $scope.listaGestores = response.data.dato;
                    } else {
                        Message.error(response.data.mensaje);
                    }

                    promesaGestores.resolve();

                }).catch(function (response) {
                    promesaGestores.reject();
                    $scope.gestorSelected = $scope.valorCodGestor;
                    $scope.incrementarSincronizador($scope.gestorSelected);
                    Message.error("No se pudo obtener los gestores");

                });
            };


            var obtenerEntidades = function (codigoGestor) {
                var param = {};
                param.codigoGestor = codigoGestor;
                PropuestaService.obtenerEntidades(param).then(function (response) {
                    if (!response.data.error) {
                        $scope.listaEntidades = response.data.dato;
                    } else {
                        Message.error(response.data.mensaje);
                    }
                    $scope.promesaEntidad.resolve();


                }).catch(function (response) {
                    $scope.promesaEntidad.reject();
                    $scope.entidadSelected = $scope.valorEntidad;
                    $scope.incrementarSincronizador($scope.entidadSelected);
                });
            };


            var obtenerSucursales = function (codigoEntidad) {
                var param = {};
                param.codigoEntidad = codigoEntidad;
                PropuestaService.obtenerSucursales(param).then(function (response) {
                    if (!response.data.error) {
                        $scope.listaSucursales = response.data.dato;
                    } else {
                        Message.error(response.data.mensaje);
                    }
                    $scope.promesaSucursal.resolve();
                }).catch(function (response) {
                    $scope.promesaSucursal.reject();
                    $scope.sucursalSelected = $scope.valorSucursal;
                    $scope.incrementarSincronizador($scope.sucursalSelected);
                    Message.error("No se pudo obtener sucursales");
                });
            };

            var promesaTipoTarjeta = $q.defer();
            var obtenerTiposTarjetas = function () {
                PropuestaService.obtenerTiposTarjetas().then(function (response) {
                    if (!response.data.error) {
                        $scope.listaTiposTarjeta = response.data.dato;
                    } else {
                        Message.error(response.data.error);
                    }

                    promesaTipoTarjeta.resolve();
                }).catch(function (response) {
                    promesaTipoTarjeta.reject();
                    $scope.tipoTarjetaSelected = $scope.valorTipoTarjeta;
                    $scope.incrementarSincronizador($scope.tipoTarjetaSelected);
                    Message.error("No se pudo obtener los tipos de tarjetas");
                });
            };

            var promesaCodigoTarjeta = $q.defer();
            var obtenerCodigosTarjetas = function (codigoAgente, tipotarjeta) {
                var param = {};
                if (!angular.isUndefined(codigoAgente)) {
                    param.codigoAgente = codigoAgente;
                } else {
                    param.codigoAgente = undefined;
                }

                param.tipotarjeta = tipotarjeta;
                PropuestaService.obtenerTarjetas(param).then(function (response) {
                    if (response.data.dato != null) {
                        $scope.listaCodigosTarjeta = response.data.dato;
                    } else {
                        $scope.listaCodigosTarjeta = [];
                        $scope.nroTarjeta.valor = undefined;
                    }

                    promesaCodigoTarjeta.resolve();
                }).catch(function (response) {
                    promesaCodigoTarjeta.reject();
                    $scope.codTarjetaSelected = $scope.valorCodTarjeta;
                    $scope.incrementarSincronizador($scope.codTarjetaSelected);
                    Message.error("No se pudo obtener las tarjetas");
                });
            };
            var promesaAgentes = $q.defer();
            var obtenerAgentes = function () {
                PropuestaService.obtenerAgentes().then(function (response) {
                    $scope.listaAgentes = response.data.dato;
                    promesaAgentes.resolve();
                }, function (response) {
                    promesaAgentes.reject();
                    Message.error("No se pudo obtener los agentes");

                });
            };


            

            //Al seleccionar agente...
            $scope.promesaOficina = $q.defer();
            $scope.promesaComision = $q.defer();
           // $scope.promesaConcesionaria = $q.defer();
            $scope.$watch('agenteSelected', function (newValue, oldValue) {
                if (!angular.isUndefined(newValue)) {
                   // $scope.concesionariaSelected = undefined;
                  //  $scope.referidoSelected = undefined;
                    $scope.comisionSelected = undefined;
                    $scope.oficinaSelected = undefined;
                   // obtenerConcesionarias(newValue);
                    obtenerComision(newValue);
                    obtenerOficina(newValue);
                } else {
                  //  $scope.concesionariaSelected = undefined;
                  //  $scope.referidoSelected = undefined;
                    $scope.comisionSelected = undefined;
                    //$scope.oficinaSelected = undefined;
                  //  $scope.listaConcesionarias = [];
                    //$scope.listaComision=[];
                    $scope.listaOficina = [];
                  //  $scope.listaReferidos = [];
                }
            }, true);
           
            var promesaEjecutivo = $q.defer();
            $scope.$watch('oficinaSelected', function (newValue, oldValue) {
                if (!angular.isUndefined(newValue) && newValue != null) {
                    if (newValue != oldValue) {
                        //obtenerEjecutivos(newValue.COD_NIVEL3);
                        obtenerEjecutivos(newValue);
                    }
                } else {
                    $scope.valorEjecutivo = undefined;
                    $scope.ejecutivoSelected = undefined;

                }

            }, true);
            $scope.promesaEntidad = $q.defer();
            $scope.$watch('gestorSelected', function (newValue, oldValue) {
                if (!angular.isUndefined(newValue) && newValue != null) {
                    //$scope.sinc++;
                    if (newValue != oldValue) {
                        if (!angular.isUndefined($scope.gestorSelected)) {

                            obtenerEntidades($scope.gestorSelected);
                        }

                    }
                }

            }, true);
            var promesaGestores = $q.defer();
            $scope.$watch('formaPagoSelected', function (newValue, oldValue) {

                if (!angular.isUndefined(newValue) && newValue != null) {

                    obtenerGestores(newValue)
                    //esta bandera sirve basicamente para no pisar los datos que se setean desde el buscar
                    if ($scope.cambiarGestor == true) //este es el caso en que se haya cambiado desde el HTML, o desde el initialize
                    {
                        $scope.gestorSelected = undefined;
                        $scope.limpiarDatosGestores(newValue);
                        //$scope.gestorSelected.valor=undefined;


                    } else //esto es en caso que sea desde el buscar
                    {
                        $scope.cambiarGestor = true;
                    }


                } else {
                    $scope.gestorSelected = undefined;
                    $scope.listaGestores = [];
                }


            }, true);
            $scope.limpiarDatosGestores = function (newValue) {
                if (newValue == "CO") {
                    if (!angular.isUndefined($scope.entidadSelected)) {
                        //$scope.entidadSelected.valor=undefined;
                        $scope.entidadSelected = undefined;
                    }
                    if (!angular.isUndefined($scope.sucursalSelected)) {
                        //$scope.sucursalSelected.valor=undefined;
                        $scope.sucursalSelected = undefined;
                    }
                    $scope.nroTarjeta.valor = undefined;
                    $scope.vtotarjeta.valor = undefined;
                    $scope.nroCuentaCte.valor = undefined;
                    if (!angular.isUndefined($scope.tipoTarjetaSelected)) {
                        $scope.tipoTarjetaSelected = undefined;
                        //$scope.tipoTarjetaSelected.valor=undefined;

                    }
                    if (!angular.isUndefined($scope.codTarjetaSelected)) {
                        $scope.codTarjetaSelected = undefined;
                        //$scope.codTarjetaSelected.valor=undefined;
                    }

                } else if (newValue == "DB") {
                    $scope.nroTarjeta.valor = undefined;
                    $scope.vtotarjeta.valor = undefined;
                    if (!angular.isUndefined($scope.tipoTarjetaSelected)) {
                        $scope.tipoTarjetaSelected = undefined;
                    }
                    if (!angular.isUndefined($scope.codTarjetaSelected)) {
                        $scope.codTarjetaSelected = undefined;
                    }
                } else if (newValue == "TA") {
                    $scope.nroCuentaCte.valor = undefined;
                    if (!angular.isUndefined($scope.entidadSelected)) {
                        $scope.entidadSelected = undefined;
                    }
                    if (!angular.isUndefined($scope.sucursalSelected)) {
                        $scope.sucursalSelected = undefined;
                    }
                } else {
                    $scope.entidadSelected = undefined;
                    $scope.sucursalSelected = undefined;
                    $scope.nroTarjeta.valor = undefined;
                    $scope.vtotarjeta.valor = undefined;
                    $scope.tipoTarjetaSelected = undefined;
                    $scope.codTarjetaSelected = undefined;
                    $scope.nroCuentaCte.valor = undefined;
                }

            };
            $scope.promesaSucursal = $q.defer();
            $scope.$watch('entidadSelected', function (newValue, oldValue) {
                if (!angular.isUndefined(newValue)) {
                    if (newValue != oldValue) {
                        if (newValue != null) {
                            //$scope.sinc++;
                            obtenerSucursales(newValue);
                        } else {
                            $scope.listaSucursales = [];
                            //$scope.sucursalSelected={};
                            //$scope.sucursalSelected.valor=null;
                            $scope.sucursalSelected = undefined;
                        }

                    }
                }


            }, true);
            $scope.$watch('tipoTarjetaSelected', function (newValue, oldValue) {
                if (!angular.isUndefined(newValue)) {
                    if (newValue != oldValue) {
                        if (newValue != null) {
                            obtenerCodigosTarjetas($scope.agenteSelected, newValue);
                        } else {
                            obtenerCodigosTarjetas($scope.agenteSelected, null);
                        }

                    }
                }
            }, true);

            $scope.save = function (clickButton) {


                $scope.submitted = false;
                $scope.numeroCotizacion = $scope.numeroCotizacionRoot;
                var propuesta = {};
                propuesta.numeroCotizacion = $scope.numeroCotizacion;//218631
                propuesta.codigoAgente = angular.isUndefined($scope.agenteSelected) ? null : $scope.agenteSelected;
                propuesta.cuadroComision = angular.isUndefined($scope.comisionSelected) ? null : $scope.comisionSelected != null ? $scope.comisionSelected : null;
                propuesta.codigoEjecutivo = angular.isUndefined($scope.ejecutivoSelected) ? null : $scope.ejecutivoSelected != null ? $scope.ejecutivoSelected : null;
                propuesta.codigoOficinaComercial = angular.isUndefined($scope.oficinaSelected) ? null : $scope.oficinaSelected != null ? $scope.oficinaSelected : null;
                propuesta.codigoTipoEnvio = angular.isUndefined($scope.tipoEnvioSelected) ? null : $scope.tipoEnvioSelected != null ? $scope.tipoEnvioSelected : null;
                propuesta.codigoTipoGestor = angular.isUndefined($scope.formaPagoSelected) ? null : $scope.formaPagoSelected != null ? $scope.formaPagoSelected : null;
                propuesta.codigoGestor = angular.isUndefined($scope.gestorSelected) ? null : $scope.gestorSelected != null ? $scope.gestorSelected : null;
                propuesta.numeroCobroAnticipado = angular.isUndefined($scope.nroCobroAnt) ? null : $scope.nroCobroAnt.valor;
                propuesta.fechaEfectoRecibo = angular.isUndefined($scope.modelo) ? null : angular.isUndefined($scope.modelo.fechaRecibo) ? null : $scope.modelo.fechaRecibo;
                propuesta.fechaPrimerVencimiento = angular.isUndefined($scope.modelo) ? null : angular.isUndefined($scope.modelo.fechaPrimerVencimiento) ? null : $scope.modelo.fechaPrimerVencimiento;
                propuesta.numeroInternoBanco = angular.isUndefined($scope.nroInterno) ? null : angular.isUndefined($scope.nroInterno.valor) ? null : $scope.nroInterno.valor;
                propuesta.codigoEntidad = angular.isUndefined($scope.entidadSelected) ? null : $scope.entidadSelected != null ? $scope.entidadSelected : null;

                propuesta.codigoSucursal = angular.isUndefined($scope.sucursalSelected) ? null : $scope.sucursalSelected != null ? $scope.sucursalSelected : null;

                propuesta.numeroCuentaCorriente = angular.isUndefined($scope.nroCuentaCte) ? null : $scope.nroCuentaCte.valor;
                propuesta.tipoTarjeta = angular.isUndefined($scope.tipoTarjetaSelected) ? null : $scope.tipoTarjetaSelected != null ? $scope.tipoTarjetaSelected : null;

                propuesta.codigoTarjeta = angular.isUndefined($scope.codTarjetaSelected) ? null : $scope.codTarjetaSelected != null ? $scope.codTarjetaSelected : null;

                propuesta.numeroTarjeta = angular.isUndefined($scope.nroTarjeta) ? null : $scope.nroTarjeta.valor;
                propuesta.fechaVencimientoTarjeta = angular.isUndefined($scope.vtotarjeta) ? null : !angular.isUndefined($scope.vtotarjeta.valor) && $scope.vtotarjeta.valor != null ? moment($scope.vtotarjeta.valor).format("DD/MM/YYYY") : null;
               
                //propuesta.fechaEfectoPoliza = angular.isUndefined($scope.fechaVigenciaDesde) ? null : $scope.fechaVigenciaDesde != null ? moment($scope.fechaVigenciaDesde).format("DD/MM/YYYY") : null;
                //propuesta.fechaVencimientoPoliza = angular.isUndefined($scope.fechaVigenciaHasta) ? null : moment($scope.fechaVigenciaHasta).format("DD/MM/YYYY");
                propuesta.marcaModulo=$scope.pathModule.split("marcaModulo=")[1];
                var param = JSON.stringify(propuesta);
                console.log (param);
                $scope.cargando = true;
                PropuestaService.guardarPropuesta(propuesta).then(
                    //sucess
                    function (response) {

                        if (!response.data.error) {

                            if (clickButton == "S") {
                                var param = {};
                                param.numeroCotizacion = $scope.numeroCotizacion;
                                param.marcaFlota = $scope.subtipo == 'Flota' ? 'S' : 'N';
                                param.tab = $scope.tab;
                                param.pathModule=$scope.pathModule;
                                PropuestaService.getTabs(param);
                            } else {
                                $scope.cambiarTab = 1; //exito
                            }


                            Message.ok(response.data.mensaje);
                        } else {
                            $scope.cambiarTab = 2; //error
                            Message.error(response.data.mensaje);

                        }
                        $scope.cargando = false;
                        //error
                    }).catch(function (response) {
                    $scope.cargando = false;
                    $scope.cambiarTab = 2; //error
                    Message.error(response.data.mensaje);

                });


            };


            $scope.buscar = function () {
                $scope.numeroCotizacion = $scope.numeroCotizacionRoot;
                if (!angular.isUndefined($scope.numeroCotizacion)) {
                    if ($scope.numeroCotizacion != null && $scope.numeroCotizacion != "") {

                        $scope.cargando = true;
                        var param = {};
                        param.numeroCotizacion = $scope.numeroCotizacion;
                        param.marcaFlota = $scope.subtipo == 'Flota' ? 'S' : 'N';
                        param.tab = $scope.tab;
                        param.pathModule=$scope.pathModule;
                        $scope.todo_concesionarias = false;
                        $scope.agenteSelected = undefined;
                        $scope.sinc = 0;
                        cantModeloSinc = 0;
                        $scope.permitirCambio = false;

                        $scope.cambiarGestor = false; //cuando no tiene preferencia se debe de volver a llamar a la lista de gestores
                        $scope.formaPagoSelected = undefined;
                        $scope.limpiarDatosGestores();
                        PropuestaService.getTabs(param);
                        PropuestaService.getCamposEditablesList(param);
                        PropuestaService.getPropuesta(param).then(
                            //sucess
                            function (response) {

                                if (!response.data.error) {
                                    if (response.data.dato != null && response.data.dato.length > 0) {


                                        $scope.bloquearBuscador = true;
                                        $scope.cambiarValores = false;
                                        $scope.cargarPlataforma();
                                        $scope.tieneIva = response.data.dato[0].MCA_IVA == null ? 'S' : response.data.dato[0].MCA_IVA;
                                        $scope.firmaDigital = response.data.dato[0].MCA_FIRMA_ELECTRONICA == null ? 'N' : response.data.dato[0].MCA_FIRMA_ELECTRONICA;
                                        $scope.setearCantidadModelos(response);

                                        $scope.promesaOficina.promise.$$state.status = 0;
                                      //  $scope.promesaConcesionaria.promise.$$state.status = 0;
                                        $scope.promesaComision.promise.$$state.status = 0;
                                        //promesaObtenerFormasPago.promise.$$state.status = 0;
                                        if (response.data.dato[0].COD_AGT == null) {

                                            $scope.agenteSelected = parseInt(sessionStorage.getItem("codigoAgente"));


                                        } else {

                                            $scope.agenteSelected = response.data.dato[0].COD_AGT;

                                        }

                                        $scope.promesaOficina.promise.then(
                                            function () {
                                                $scope.permitirCambio=true;
                                                $scope.oficinaSelected = response.data.dato[0].COD_NIVEL3;
                                                $scope.incrementarSincronizador($scope.oficinaSelected);
                                                if ($scope.oficinaSelected==null) //setear el que trae el agente si es que tiene una sola oficina comercial
                                                {
                                                    if ($scope.listaOficina.length==1)
                                                    {
                                                        $scope.oficinaSelected=$scope.listaOficina[0].COD_NIVEL3;
                                                    }
                                                }

                                                $scope.promesaOficina.promise.$$state.status = 0;
                                            });
                                        promesaEjecutivo.promise.then(
                                            function () {
                                                $scope.ejecutivoSelected = response.data.dato[0].COD_EJECUTIVO;
                                                $scope.incrementarSincronizador($scope.ejecutivoSelected);

                                            });
                                        $scope.promesaComision.promise.then(
                                            function () {
                                                $scope.comisionSelected = response.data.dato[0].COD_CUADRO_COM;
                                                $scope.incrementarSincronizador($scope.comisionSelected);
                                                var encontrado=false;
                                                for (var i=0; i< $scope.listaComision.length;i++)
                                                {
                                                    if ($scope.listaComision[i].COD_CUADRO_COM==parseInt($scope.comisionSelected))
                                                    {
                                                        encontrado=true;
                                                    }
                                                }
                                                if (!encontrado)
                                                {
                                                    $scope.comisionSelected=undefined;
                                                }


                                            });
                                       

                                        promesaTipoEnvio.promise.then(
                                            function () {

                                                $scope.tipoEnvioSelected = response.data.dato[0].COD_TIP_ENVIO ? response.data.dato[0].COD_TIP_ENVIO.toString() : response.data.dato[0].COD_TIP_ENVIO;
                                                $scope.incrementarSincronizador($scope.tipoEnvioSelected);


                                            });

                                        promesaObtenerFormasPago.promise.then(
                                            function () {
                                                if (response.data.dato[0].TIP_GESTOR == null) {
                                                    $scope.formaPagoSelected = $scope.pagoPreferencia;
                                                } else {
                                                    $scope.formaPagoSelected = response.data.dato[0].TIP_GESTOR;
                                                }

                                                $scope.incrementarSincronizador($scope.formaPagoSelected);


                                            });
                                        $scope.promesaEntidad.promise.then(function () {
                                            $scope.entidadSelected = response.data.dato[0].COD_ENTIDAD;
                                            $scope.incrementarSincronizador($scope.entidadSelected);

                                        });
                                       // $scope.fechaVigenciaDesde = angular.isUndefined(response.data.dato[0].FEC_EFEC_POL) ? undefined : response.data.dato[0].FEC_EFEC_POL != undefined ? $scope.convertirDate(response.data.dato[0].FEC_EFEC_POL) : undefined;
                                       // $scope.fechaVigenciaHasta = angular.isUndefined(response.data.dato[0].FEC_VCTO_POL) ? undefined : response.data.dato[0].FEC_VCTO_POL != undefined ? $scope.convertirDate(response.data.dato[0].FEC_VCTO_POL) : undefined;
                                        $scope.nroCobroAnt.valor = response.data.dato[0].NUM_COBRO_ANTICIPADO;
                                        $scope.modelo.fechaRecibo = angular.isUndefined(response.data.dato[0].FEC_EFEC_RECIBO) ? undefined : response.data.dato[0].FEC_EFEC_RECIBO != undefined ? $scope.convertirDate(response.data.dato[0].FEC_EFEC_RECIBO) : undefined;
                                        $rootScope.nroPropuesta = angular.isUndefined(response.data.dato[0].NUM_PROPUESTA) ? null : response.data.dato[0].NUM_PROPUESTA;
                                        $scope.gestorSelected = undefined;


                                        promesaGestores.promise.then(function () {
                                            $scope.gestorSelected = null;
                                            if (response.data.dato[0].TIP_GESTOR != null && response.data.dato[0].TIP_GESTOR != "")
                                            {
                                                $scope.gestorSelected=response.data.dato[0].COD_GESTOR;
                                            }
                                            $scope.incrementarSincronizador($scope.gestorSelected);

                                        })


                                        $scope.modelo.fechaPrimerVencimiento = angular.isUndefined(response.data.dato[0].FEC_PRIMER_VCTO) ? undefined : response.data.dato[0].FEC_PRIMER_VCTO != undefined ? $scope.convertirDate(response.data.dato[0].FEC_PRIMER_VCTO) : undefined;
                                        $scope.nroInterno.valor = response.data.dato[0].NUM_SOLICITUD_EE;

                                        $scope.promesaSucursal.promise.then(
                                            function () {
                                                $scope.sucursalSelected = response.data.dato[0].COD_OFICINA;
                                                $scope.incrementarSincronizador($scope.sucursalSelected);

                                            });

                                        $scope.nroCuentaCte.valor = response.data.dato[0].CTA_CTE;
                                        $scope.tipoTarjetaSelected = response.data.dato[0].COD_TIP_TAR;


                                        promesaCodigoTarjeta.promise.then(
                                            function () {
                                                $scope.codTarjetaSelected = response.data.dato[0].COD_TARJETA;
                                                $scope.incrementarSincronizador($scope.codTarjetaSelected);

                                            });

                                        $scope.nroTarjeta.valor = response.data.dato[0].NUM_TARJETA;
                                        $scope.vtotarjeta.valor = angular.isUndefined(response.data.dato[0].FEC_VCTO_TARJETA) ? undefined : response.data.dato[0].FEC_VCTO_TARJETA != undefined ? $scope.convertirDate(response.data.dato[0].FEC_VCTO_TARJETA) : undefined;

                                        if (response.data.dato[0].MCA_ASEGURADO === 'S') {

                                            $rootScope.llamarAsegurado = false;
                                        } else {
                                            $rootScope.llamarAsegurado = true;
                                        }


                                    } else {
                                        $scope.limpiar();
                                        $rootScope.llamarAsegurado = true;
                                        Message.warning(response.data.mensaje);
                                        $scope.cargando = false;
                                    }


                                } else {
                                    $scope.limpiar();
                                    $rootScope.llamarAsegurado = true;
                                    $scope.cargando = false;
                                    Message.error(response.data.mensaje);
                                }

                                //error
                            }).catch(function (response) {
                             
                            $scope.limpiar();
                            $rootScope.llamarAsegurado = true;
                            $scope.cargando = false;
                            Message.error("Ocurrió un error, intente nuevamente");

                        });

                    }

                }


            };
            // $scope.$watch('fechaVigenciaDesde', function (NewValue, OldValue) {
            //     if (!angular.isUndefined(NewValue) && NewValue != null) {
            //         if (NewValue != OldValue) {
            //             var dato = moment(NewValue).format("DD/MM/YYYY");
            //             var param={};
            //             param.fechaVigencia=dato;
            //             param.pathModule=$scope.pathModule;
            //             PropuestaService.obtenerFechaVigenciaHasta(param).then(function(response){
            //                 if (!response.data.error)
            //                 {
            //                     if (response.data.dato!=null)
            //                     {
            //                         $scope.fechaVigenciaHasta=$scope.convertirDate(response.data.dato.fechaVencimientoPoliza);
            //                     }
            //                 }
            //                 else
            //                 {
            //                     Message.error(response.data.mensaje);
            //                 }
            //             })
                       

            //         }

            //     } else if (NewValue == null) {
            //         $scope.fechaVigenciaHasta = undefined;

            //     }

            // }, true);


            /**formato para el datepicker**/
            $scope.formatearFecha = function (fecha) {
                $scope.aplicarFormato(fecha);
            };


            $scope.cargarPlataforma = function () {

                var paramPla = {};
                paramPla.numeroCotizacion = $scope.numeroCotizacion;
                paramPla.marcaFlota = $scope.subtipo == 'Flota' ? 'S' : 'N';
                paramPla.pathModule = $scope.pathModule;
                CotizacionVehiculoPropuestaService.getPlataforma(paramPla).then(
                    function (response) {
                        if (!response.data.error) {
                            if (response.data.dato != null) {

                                $scope.mostrarPlataforma = true;

                                $scope.prop.plataforma = response.data.dato.mensaje;


                            }

                        }


                    }).catch(function (response) {

                    Message.error(response.data.mensaje);

                });
            };


            /**
             * Función creada para el salto de propuesta a cotizacion
             */
            $scope.goToCotizacion = function () {
                var path = $location.$$absUrl;
                var n = path.search("module");
                var url = path.substring(0, n);

                if (typeof $scope.numeroCotizacionRoot != 'undefined' && $scope.numeroCotizacionRoot != null) {
                    var subtipo = 'cotizacion-multiriesgo';
                    
                    location.href = subtipo + '/' + $scope.numeroCotizacionRoot;

                } else {
                    Message.warning("Debe ingresar un número de cotización");
                }
            }


            $scope.limpiar = function () {

                $rootScope.camposRequeridosList = [];
                $rootScope.numeroCotizacionRoot = undefined;
                $rootScope.nroPropuesta = undefined;
                $scope.eliminarPagina();
                if (typeof $routeParams.numeroCotizacion != "undefined") {
                    $location.search('numeroCotizacion', undefined);
                    $rootScope.numeroCotizacionRoot = undefined;
                    if ($scope.subtipo == "Flota") {
                     $location.path('propuesta-flota/propuesta');
                    } else if  ($scope.subtipo == 'Vehiculos') {
                        $location.path('propuesta-vehiculo/propuesta');
                    }else if ($scope.subtipo == 'Propuesta Hogar'){
                         $location.path('propuesta-hogar');
                    }else if ($scope.subtipo == 'Multiriesgos'){
                         $location.path('propuesta-multiriesgo/propuesta');
                    }


                } else {
                    $route.reload();
                }

            };
            $scope.recargar = function () {
                $scope.agenteSelected = undefined;
                $scope.bloquearBuscador = false;
                $scope.mostrarPlataforma = false;
                $scope.limpiar();

            };
            $scope.generarConstancia = function () {
                if (!angular.isUndefined($scope.numeroCotizacion) || $scope.numeroCotizacion != null) {
                    $scope.cargando = true;
                    var datos = {};
                    datos.numeroCotizacion = $scope.numeroCotizacion;
                    datos.marcaModulo=$location.path().split("/")[1];
                    PropuestaService.enviarConstancia(datos).then(function (response) {
                        $scope.cargando = false;
                        if (!response.data.error) {
                            Message.ok(response.data.mensaje);
                        } else {
                            Message.error(response.data.mensaje);
                        }
                    }).catch(function (response) {
                        $scope.cargando = false;
                        Message.error("Ocurrió un error, intente nuevamente");

                    });
                } else {
                    Message.warning("Debe ingresar un numero de cotizacion válido!");
                }
            };

            $scope.llamarModal = function (value) {

                if (!angular.isUndefined($rootScope.numeroCotizacionRoot) && $rootScope.numeroCotizacionRoot != null && $rootScope.numeroCotizacionRoot != "") {
                    $rootScope.numCotiza = $rootScope.numeroCotizacionRoot;
                    $rootScope.modalCotizadorVehFlota = value;
                    $rootScope.flagVehiculoFlota = false;
                    $rootScope.flagHogar=true;
                    $mdDialog.show({
                        //locals:{parent: $scope},
                        controller: 'ModalAutorizacionCtrl',
                        templateUrl: 'partials/ventanas-emergentes/modal-autorizacion-partial.html',
                        parent: angular.element(document.body),
                        multiple: true,
                        clickOutsideToClose: false,
                        scope: $scope,
                        preserveScope: true,
                        fullscreen: $scope.customFullscreen // Only for -xs, -sm breakpoints.
                    }).then(function (answer) {
                        $scope.buscar();


                    }, function () {
                        $scope.status = 'You cancelled the dialog.';
                        //console.log($scope.status);
                    });
                }

            };


            $scope.obtenerAutorizaciones = function () {

                $scope.autorizacionesList = [];
                var param = {};
                param.pathModule =$scope.pathModule;
                CotizacionVehiculoService.getAutorizaciones(param).then(function (response) {
                    if (!response.data.error) {
                        if (response.data.dato.length > 0) {
                            var campos = response.data.dato;
                            for (var i = 0; i < campos.length; i++) {
                                $scope.autorizacionesList.push(campos[i]);

                            }
                        }
                        //console.log("Lista Autorizaciones: " + JSON.stringify($scope.autorizacionesList));
                    } else {
                        Message.error(response.data.mensaje);
                    }
                });
            };

            /**Este Watch se dispara cuando las promesas se resuelven o tiene error, y la condicion principal debe ser
             * que el valor del sinc sea mayor a 0, sino ocurre eso es porque hay un error en el buscar o viene vacio el modelo de buscar**/

            $scope.$watch('sinc', function (NewValue, OldValue) {
                
                if (NewValue == cantModeloSinc && NewValue > 0) {
                    $scope.cargando = false;
                    $scope.sinc = 0; //cantidad de modelos seteados una vez obtenida la promesa
                    cantModeloSinc = 0; //cantidad de modelos que necesitan llamadas de servicios
                }


            }, true);
            $scope.setearCantidadModelos = function (response) {
                //preguntar la cantidad de campos a ser seteados
                // if (response.data.dato[0].COD_CONCESIONARIA != null && response.data.dato[0].COD_CONCESIONARIA != "") {
                //     variable auxiliar en caso que ocurra algun error, en la promesa de la concesionaria
                //     $scope.valorConcesionaria = response.data.dato[0].COD_CONCESIONARIA;
                //     cantModeloSinc++;
                // }//1

                if (response.data.dato[0].COD_CUADRO_COM != null && response.data.dato[0].COD_CUADRO_COM != "") {

                    $scope.valorComision = response.data.dato[0].COD_CUADRO_COM;
                    cantModeloSinc++;
                }
                if (response.data.dato[0].COD_NIVEL3 != null && response.data.dato[0].COD_NIVEL3 != "") {
                    $scope.valorOficina = response.data.dato[0].COD_NIVEL3;
                    cantModeloSinc++;
                }


                if (response.data.dato[0].COD_REFERIDO != null && response.data.dato[0].COD_REFERIDO != "" && response.data.dato[0].COD_CONCESIONARIA != null && response.data.dato[0].COD_CONCESIONARIA != "") {
                    $scope.valorReferido = response.data.dato[0].COD_REFERIDO;
                    cantModeloSinc++;
                }
                if (response.data.dato[0].COD_ENTIDAD != null && response.data.dato[0].COD_ENTIDAD != "" && response.data.dato[0].COD_GESTOR != null && response.data.dato[0].COD_GESTOR != "") {
                    $scope.valorEntidad = response.data.dato[0].COD_ENTIDAD;
                    cantModeloSinc++;
                }
                if (response.data.dato[0].COD_ACREEDOR != null && response.data.dato[0].COD_ACREEDOR != "") {
                    $scope.valorAcreedor = response.data.dato[0].COD_ACREEDOR;
                    cantModeloSinc++;
                }
                if (response.data.dato[0].COD_TIP_ENVIO != null && response.data.dato[0].COD_TIP_ENVIO != "") {
                    $scope.valorEnvio = response.data.dato[0].COD_TIP_ENVIO;
                    cantModeloSinc++;
                }
                if (response.data.dato[0].TIP_GESTOR != null && response.data.dato[0].TIP_GESTOR != "" ) {
                    $scope.valorTipoGestor = response.data.dato[0].TIP_GESTOR;
                    cantModeloSinc++;
                }//2
                if (response.data.dato[0].COD_OFICINA != null && response.data.dato[0].COD_OFICINA != "" && response.data.dato[0].COD_ENTIDAD != null && response.data.dato[0].COD_ENTIDAD != "" && response.data.dato[0].COD_GESTOR != null && response.data.dato[0].COD_GESTOR != "") {
                    $scope.valorSucursal = response.data.dato[0].COD_OFICINA;
                    cantModeloSinc++;
                }//3
                if (response.data.dato[0].COD_TIP_TAR != null && response.data.dato[0].COD_TARJETA != null && response.data.dato[0].COD_TIP_TAR != "" && response.data.dato[0].COD_TARJETA != "") {
                    $scope.valorCodTarjeta = response.data.dato[0].COD_TARJETA;
                    cantModeloSinc++;
                }//7
                if (response.data.dato[0].COD_GESTOR != null && response.data.dato[0].COD_GESTOR != "" && response.data.dato[0].TIP_GESTOR != null && response.data.dato[0].TIP_GESTOR != "") {
                    $scope.valorCodGestor = response.data.dato[0].COD_GESTOR;
                    cantModeloSinc++;
                }//8
                if (response.data.dato[0].COD_EJECUTIVO != null && response.data.dato[0].COD_EJECUTIVO != "" && response.data.dato[0].COD_NIVEL3 != null && response.data.dato[0].COD_NIVEL3 != "") {
                    $scope.valorEjecutivo = response.data.dato[0].COD_EJECUTIVO;
                    cantModeloSinc++;
                }//9
                /**Si no hay datos en el modelo que no necesitan promesas entonces se debe de ocultar el cargando*/
                if (cantModeloSinc == 0) {
                    $scope.cargando = false;
                }
            };
            $scope.$watch('cambiarTab', function (newValue, oldValue) {
                if (newValue != 0) {
                    if (newValue == 1) {
                        //hacer el redirect

                        var params={};
                        params.marcaFlota=$scope.subtipo=="Flota"?'S':'N';
                        params.numeroCotizacion=angular.isUndefined($scope.numeroCotizacionRoot)|| $scope.numeroCotizacionRoot==null?"":$scope.numeroCotizacionRoot;
                        params.tab=$rootScope.sigTab;
                        params.pathModule=$scope.pathModule;
                        $scope.service.getCamposEditablesList(params);
                        $timeout($location.url($rootScope.url_destino),1000);
                    } else {
                        newValue = 0; //para que vuelva a cambiar e intentar
                    }
                }

            }, true);
            $scope.eliminarPagina=function()
            {
                sessionStorage.removeItem("paginaAsegurado");
                sessionStorage.removeItem("paginaRiesgoPropuesta");
            };




        (function initialize() {
            $rootScope.currentPage = 'propuestaMultiriesgo';
            $rootScope.tabs = PropuestaService.getTabInicial();
            $scope.bloquearBuscador=false;
            $rootScope.llamarAsegurado=true;
            $scope.pathModule = UtilsService.retornarPath($location.path().split("/")[1]);
            $scope.agenteSelected=parseInt(sessionStorage.getItem("codigoAgente"));
            $scope.tieneIva='N';
            $scope.firmaDigital='N';
            $scope.imprimeGenera=undefined;
            //$scope.subtipo=='Flota'?$scope.todo_concesionarias=false:$scope.todo_concesionarias=true;
        	obtenerFormasPago();
        	obtenerTiposTarjetas();
        	obtenerAgentes();
           // obtenerAcrPrendarios();
            obtenerTiposEnvio();
            $scope.obtenerAutorizaciones();
           angular.extend(this, $controller('UtilsCtrl', {
                    "$scope": $scope
            }));

            /**
             * Verifica si la ventana fue llamada desde cotizacion
             */
            if(typeof $routeParams.numeroCotizacion != "undefined"){
                
                $rootScope.numeroCotizacionRoot = $routeParams.numeroCotizacion;
                $scope.numeroCotizacion=$rootScope.numeroCotizacionRoot;
                $scope.buscar();
            }
            else if (!angular.isUndefined($scope.numeroCotizacionRoot) && $scope.numeroCotizacionRoot!= null && $scope.numeroCotizacionRoot!=""){

             $scope.buscar();
            }
            else
            {
                // var marcaFlota;
                // if ($scope.subtipo == "Flota")
                // {
                //     marcaFlota="S";
                // }
                // else
                // {
                //     marcaFlota="N";
                // }
                var params={};
              //  params.marcaFlota=marcaFlota;
                params.numeroCotizacion=angular.isUndefined($scope.numeroCotizacionRoot)|| $scope.numeroCotizacionRoot==null?"":$scope.numeroCotizacionRoot;
                params.tab=$scope.tab;
                params.pathModule=$scope.pathModule;
                $scope.service.getCamposEditablesList(params);
            }



            $scope.eliminarPagina();







            
        })();
            


    }]);
;app.controller('PropuestaVehiculoBCPCtrl', ['$scope', '$q', '$controller', '$routeParams', '$location', 'SessionService', '$rootScope','$route', '$mdDialog', '$filter', 'ConfirmService', '$window', 'PropuestaService','CotizacionVehiculoService','UtilsService','BaseService',
    function ($scope,$q, $controller, $routeParams, $location, sessionService, $rootScope,$route, $mdDialog,  $filter, confirmService, $window, PropuestaService,CotizacionVehiculoService,UtilsService, BaseService) {

 $scope.nombre = "BCP";

 $scope.itemsByPage =15;
 $scope.subtipo= $route.current.$$route.subtipo;
  $scope.titulo=$scope.subtipo;
$scope.service=BaseService;
$scope.buscar =function(){

	if(!angular.isUndefined($scope.numeroCotizacion)&& $scope.numeroCotizacion!=null && $scope.numeroCotizacion !=""){
               $scope.cargando= true;
              param ={};
              param.numeroCotizacion=$scope.numeroCotizacion;
              param.marcaFlota=$scope.subtipo=='Flota'?'S':'N';
              param.pathModule=$scope.pathModule;
              PropuestaService.getValidarTomadorBCP(param).then(                       
                function (response) {
                	$scope.rowCollection = [];
                    if(!response.data.error){
                        if(response.data.dato.length> 0){
                           for(var i=0; i<response.data.dato.length; i++){
                           var objeto ={
                               tipobeneficio : response.data.dato[i].TIP_BENEF,
                               terceroDocum  :response.data.dato[i].TERCERO_DOCUM,
                               terceroNombre :response.data.dato[i].TERCERO_NOMBRE,
                               terceroCodNaionalidad :response.data.dato[i].TERCERO_COD_NACIONALIDAD,
                               terceroFechaNacimiento :response.data.dato[i].TERCERO_FEC_NACIMIENTO,
                               bcpDocum       :response.data.dato[i].BCP_DOCUM,
                               bcpNombre      :response.data.dato[i].BCP_NOMBRE,
                               bcpCodNacionalidad :response.data.dato[i].BCP_COD_NACIONALIDAD,
                               bcpFechaNacimiento :response.data.dato[i].BCP_FEC_NACIMIENTO,
                               bcpRemplazar     :response.data.dato[i].MCA_REEMPLAZAR,
                               bcpMantener      :response.data.dato[i].MCA_MANTENER,
                               tipoDocumTercero   :response.data.dato[i].TIP_DOCUM_TERCERO,
                               codDocumTercero  :response.data.dato[i].COD_DOCUM_TERCERO,
                               mostrarReemplazar:response.data.dato[i].MCA_REEMPLAZAR==='S'?true:false,
                               mostrarMantener :response.data.dato[i].MCA_MANTENER==='S'?true:false,
                               tipoDocumentoBCP: response.data.dato[i].TIP_DOCUM_BCP,
                               codigoDocumentoBCP: response.data.dato[i].COD_DOCUM_BCP,
                               reemplazado :response.data.dato[i].MCA_REEMPLAZAR==='N'?true:false,
                               mantener:false,
                            };
                            /*if (response.data.dato[i].MCA_REEMPLAZAR==='S' ){
                                 $scope.mostrarReemplazar=true;
                            }*/
                                           
                            $scope.rowCollection.push(objeto);
                            $scope.cargando= false;
                        }
                       
                        }else{
                        	 $scope.cargando= false;
                        }

                       

                    }else{
                         $scope.cargando= false;

                    }
                        
                }).catch(function(response){    
                        $scope.cargando= false;           
                        Message.error(response.data.mensaje);               
                });
               }else{
                 Message.warning("Debe ingresar un número de cotización");
              } 
};

 $scope.editRow = function(row) {
       $scope.cargando= true;           
       var param ={};
       param.numeroCotizacion=$scope.numeroCotizacion;
       param.tipoDocumento=row.tipoDocumTercero;
       param.codigoDocumento=row.codDocumTercero;
       param.tipoBeneficiario=row.tipobeneficio;
       param.tipoDocumentoBcp=row.tipoDocumentoBCP;
       param.codigoDocumentoBcp=row.codigoDocumentoBCP;
       param.marcaModulo=$location.path().split("/")[1];
       PropuestaService.reemplazar(param).then(                       
       function (response) {
           if(!response.data.error){
               $rootScope.llamaReportePropuestaRoot=true;

               //$location.url($scope.pathVeh);
           	   Message.ok(response.data.mensaje);

               $scope.checkRow(row);

           }else{
               Message.error(response.data.mensaje);

           }
           $scope.cargando= false;

          

        }).catch(function(response){    
            $scope.cargando= false;           
            Message.error(response.data.mensaje);               
        });
   };

  $scope.cancelar = function() {
      $location.url($scope.pathVeh);
  } ;
    $scope.checkRow = function(row) {

        for(var i=0; i<$scope.rowCollection.length; i++){
            if(row.$$hashKey===$scope.rowCollection[i].$$hashKey){
                $scope.rowCollection[i].reemplazado = true;
                break;
            }
        }
        var deshabilitarContinuar=false;
        for(var i=0; i<$scope.rowCollection.length; i++){
            if( $scope.rowCollection[i].reemplazado==false){
                deshabilitarContinuar=true;
               break;
            }
        }
        $scope.habilitarContinuar = deshabilitarContinuar;

    };

   $scope.blockRow = function(row) {
      
      for(var i=0; i<$scope.rowCollection.length; i++){
          if(row.$$hashKey===$scope.rowCollection[i].$$hashKey){
            $scope.rowCollection[i].mantener = true;
            break;
          }
      }
      //$scope.habilitarContinuar = false;

   };

    $scope.continuar = function() {

        /*for(var i=0; i<$scope.rowCollection.length; i++){
          if( $scope.rowCollection[i].bloquear==false){
            
            Message.error("Todos los registros deben estar bloqueados para continuar la operacion.");
            return;
          }
      }*/
      
      $rootScope.redireccionarBCP = null;
      $rootScope.redireccionarBCP=$scope.pathVeh;
      if ($rootScope.tipoOperacionBCP.valor.split(':')[0]==="emisionAutomaticaPropuesta"){

          $scope.service.generacionAutomaticaPropuesta($scope.numeroCotizacion,$rootScope.tipoOperacionBCP.valor.split(':')[1],$scope.pathModule);

      }else if($rootScope.tipoOperacionBCP.valor==="generar"){
           $scope.service.generarPropuesta( $scope.numeroCotizacion,$scope.pathModule);

      }else if($rootScope.tipoOperacionBCP.valor==="emitirDocumento"){
              $scope.service.emisionValidacion( $scope.numeroCotizacion,$scope.pathModule);
      }else{
            $scope.descargarCartaPropuesta();
      }

      
      
     
      

    };

$scope.descargarCartaPropuesta=function()
    {
       //window.open(App.URL_BASE+'impresion/propuesta?numeroCotizacion='+$scope.datosGenerales.numeroCotizacion);
        $rootScope.cargando=true;
        var subtipo=$scope.subtipo=='Flota'?'Flota':'Vehiculo';
        var urlFinal=$scope.service.generarURL(subtipo,'cartaPropuesta');


        $scope.service.imprimir(urlFinal+"?"+$scope.pathModule, $scope.numeroCotizacion);
       //var url = App.URL_BASE+'impresion/propuesta?numeroCotizacion='+$scope.numeroCotizacion;
       //$scope.mostrarPDF(url);
    };






(function initialize() {
    $rootScope.llamaReportePropuestaRoot = undefined;
    var path=$location.$$path.split('/bcp')[0];
    $scope.pathModule = UtilsService.retornarPath($location.path().split("/")[1]);
    $scope.pathVeh=path.substring(1);
    $scope.mostrarReemplazar=false;
    $scope.cargando= false;
    $scope.habilitarContinuar = true;
    $rootScope.numCotizacionBcp=undefined;
	if(typeof $routeParams.numeroCotizacion != "undefined"){
        $scope.numeroCotizacion = $routeParams.numeroCotizacion ;
         //$scope.pathVeh= $scope.pathVeh+'?numeroCotizacion='+$scope.numeroCotizacion;
         $rootScope.numCotizacionBcp = $routeParams.numeroCotizacion;
        $scope.buscar();

    }

 })();


 }]);
;app.controller('PropuestaVehiculoFormCtrl', ['$scope', '$q', '$controller', '$routeParams', '$location', 'SessionService', '$rootScope','$route', '$mdDialog', '$filter', 'ConfirmService', '$window', 'PropuestaService','CotizacionVehiculoPropuestaService','UtilsService','CotizacionVehiculoService','$log','$timeout',
        function ($scope,$q, $controller, $routeParams, $location, sessionService, $rootScope,$route, $mdDialog,  $filter, confirmService, $window, PropuestaService,CotizacionVehiculoPropuestaService, UtilsService ,CotizacionVehiculoService, $log, $timeout) {
            $scope.service = PropuestaService;
            $scope.controlPermisos = true;
            $scope.nombre = $route.current.$$route.subtipo;
            $rootScope.rootPathParent = $route.current.$$route.originalPath;
            $scope.listaComision = [];
            $scope.subtipo = $scope.nombre;
            $scope.agenteSelected = undefined;
            $scope.comisionSelected = undefined;
            $scope.concesionariaSelected = undefined;
            $scope.acrPrendarioSelected = undefined;
            $scope.oficinaSelected = undefined;
            $scope.sucursalSelected = undefined;
            $scope.tipoEnvioSelected = undefined;
            $scope.tipoTarjetaSelected = undefined;
            $scope.referidoSelected = undefined;
            $scope.ejecutivoSelected = undefined;
            $scope.formaPagoSelected = undefined;
            $scope.nroCobroAnt = {};
            $scope.modelo = {};
            $scope.nroInterno = {};
            $scope.nroCuentaCte = {};
            $scope.nroCuentaCte.valor = undefined;
            $scope.nroTarjeta = {};
            $scope.vtotarjeta = {};
            $scope.cargando = false;
            $scope.prop = {};
            $scope.prop.plataforma = null;
            $scope.nroPropuesta = null;
            $scope.gestorSelected = undefined;
            $scope.entidadSelected = undefined;
            $scope.todo_concesionarias = true;
            $scope.submitted = false;
            $scope.valorConcesionaria = undefined;
            $scope.valorComision = undefined;
            $scope.valorOficina = undefined;
            $scope.valorEjecutivo = undefined;
            $scope.valorAcreedor = undefined;
            $scope.valorTipoGestor = undefined;
            $scope.valorOficina = undefined;
            $scope.valorTipoTarjeta = undefined;
            $scope.valorEnvio = undefined;
            $scope.valorCodTarjeta = undefined;
            $scope.cambiarValores = true;
            $scope.permitirCambio = true;
            $scope.validCarga = false;
            $scope.cambiarGestor = true;
            $scope.tab = "PROPUESTA";
            $scope.sinc = 0;
            /**variable que almcena las promesas resueltas o fracasadas*/
            var cantModeloSinc = 0;
            /**variable que almacena la cantidad de datos que vienen en el buscar, que requieren otras llamadas de promesas**/
            $scope.pagoPreferencia = undefined;
            $scope.cambiarTab = 0; //valor inicial
            $scope.verificarCamposForm = function (listaCampo, campo) {
                return UtilsService.verificarCamposForm(listaCampo, campo);
            };
            var obtenerComision = function (codigoAgente) {
                 var params = {};
                 params.codigoAgente=codigoAgente;
                 params.pathModule=$scope.pathModule;
                PropuestaService.obtenerComision(params).then(function (response) {
                    if (!response.data.error) {
                        $scope.listaComision = response.data.dato;
                        $scope.promesaComision.resolve();
                    } else {
                        Message.error(response.data.error);
                        $scope.promesaComision.resolve();
                    }

                }).catch(function (response) {
                    $scope.promesaComision.reject();
                    Message.error("No se pudo obtener las comisiones");
                    $scope.comisionSelected = $scope.valorComision;
                    $scope.incrementarSincronizador($scope.comisionSelected);
                });
            };


            var obtenerOficina = function (codigoAgente) {
                PropuestaService.obtenerOficinas(codigoAgente).then(function (response) {
                    if (!response.data.error) {
                        $scope.listaOficina = response.data.dato;
                        if ($scope.permitirCambio)
                        {
                            //aca se pregunta si viene un solo elemento de oficinal
                            if ($scope.listaOficina!=null)
                            {
                                if ($scope.listaOficina.length==1) //se setea el que viene alli
                                {
                                    $scope.oficinaSelected=$scope.listaOficina[0].COD_NIVEL3;

                                }
                            }
                        }
                    } else {
                        Message.error(response.data.mensaje);
                    }
                    $scope.promesaOficina.resolve();
                }).catch(function (response) {
                    $scope.promesaOficina.reject();
                    $scope.oficinaSelected = $scope.valorOficina;
                    $scope.incrementarSincronizador($scope.oficinaSelected);
                    Message.error("No se pudo obtener las oficinas");
                });
            };
            /**Funcion que se encarga de incrementar la variable de sincronizacion cuando las promesas se resuelven o tienen error*/
            $scope.incrementarSincronizador = function (campo) {
                if (campo != null) {
                    $scope.sinc++;
                }
            }

            var promesaObtenerFormasPago = $q.defer();
            var obtenerFormasPago = function () {
                var preferencia;
                preferencia = "N";
                PropuestaService.obtenerFormasPago(preferencia).then(function (response) {
                    if (!response.data.error) {
                        $scope.listaFormasPago = response.data.dato;

                        //obtener las que son de preferencia y setear
                        if ($scope.subtipo != "Flota") {

                            preferencia = window.sessionStorage.getItem("preferencia_forma_pago");
                            if (preferencia == "S") {
                                PropuestaService.obtenerFormasPago(preferencia).then(function (response) {
                                    //$scope.formaPagoSelected.valor = response.data.dato[0].TIP_GESTOR;
                                    //$scope.formaPagoSelected = response.data.dato[0].TIP_GESTOR;
                                    if (!response.data.error) {
                                        if (response.data.dato.length > 0) {
                                            $scope.pagoPreferencia = response.data.dato[0].TIP_GESTOR;
                                        }
                                        promesaObtenerFormasPago.resolve();
                                    } else {
                                        promesaObtenerFormasPago.resolve();
                                        Message.error(response.data.error);
                                    }

                                }, function (response) {
                                    promesaObtenerFormasPago.reject();
                                    Message.error("No se pudo obtener las formas de pago de preferencia");

                                });
                            } else {
                                promesaObtenerFormasPago.resolve();
                                //$scope.formaPagoSelected.valor=undefined;
                                $scope.formaPagoSelected = undefined;
                            }

                        }
                        else
                        {
                            promesaObtenerFormasPago.resolve();
                        }

                    } else {
                        promesaObtenerFormasPago.resolve();
                        Message.error(response.data.mensaje);
                    }



                }).catch(function (response) {
                    promesaObtenerFormasPago.reject();
                    $scope.formaPagoSelected = $scope.valorTipoGestor;
                    $scope.incrementarSincronizador($scope.formaPagoSelected);
                    Message.error("No se pudo obtener las formas de pago");
                });


            };


            var obtenerEjecutivos = function (codNivel3) {
                PropuestaService.obtenerEjecutivos(codNivel3).then(function (response) {
                    if (!response.data.error) {
                        $scope.listaEjecutivos = response.data.dato;

                    } else {
                        Message.error(response.data.mensaje);
                    }

                    promesaEjecutivo.resolve();
                }).catch(function (response) {
                    promesaEjecutivo.reject();
                    Message.error("No se pudo obtener los ejecutivos");
                    $scope.ejecutivoSelected = $scope.valorEjecutivo;
                    $scope.incrementarSincronizador($scope.ejecutivoSelected);
                });
            };

            var promesaTipoEnvio = $q.defer();
            var obtenerTiposEnvio = function () {
                PropuestaService.obtenerTiposEnvio().then(function (response) {
                    $scope.listaTiposEnvio = response.data.dato;
                    promesaTipoEnvio.resolve();
                }).catch(function (response) {
                    promesaTipoEnvio.reject();
                    $scope.tipoEnvioSelected = $scope.valorEnvio;
                    $scope.incrementarSincronizador($scope.tipoEnvioSelected);
                    Message.error("No se pudo obtener los tipos de envio");
                });
            };


            var obtenerGestores = function (codigoFormaPago) {
                var param = {};
                param.codigoFormaPago = codigoFormaPago;
                param.pathModule = $scope.pathModule;
                PropuestaService.obtenerGestores(param).then(function (response) {
                    if (!response.data.error) {
                        $scope.listaGestores = response.data.dato;
                    } else {
                        Message.error(response.data.mensaje);
                    }

                    promesaGestores.resolve();

                }).catch(function (response) {
                    promesaGestores.reject();
                    $scope.gestorSelected = $scope.valorCodGestor;
                    $scope.incrementarSincronizador($scope.gestorSelected);
                    Message.error("No se pudo obtener los gestores");

                });
            };


            var obtenerEntidades = function (codigoGestor) {
                var param = {};
                param.codigoGestor = codigoGestor;
                PropuestaService.obtenerEntidades(param).then(function (response) {
                    if (!response.data.error) {
                        $scope.listaEntidades = response.data.dato;
                    } else {
                        Message.error(response.data.mensaje);
                    }
                    $scope.promesaEntidad.resolve();


                }).catch(function (response) {
                    $scope.promesaEntidad.reject();
                    $scope.entidadSelected = $scope.valorEntidad;
                    $scope.incrementarSincronizador($scope.entidadSelected);
                });
            };


            var obtenerSucursales = function (codigoEntidad) {
                var param = {};
                param.codigoEntidad = codigoEntidad;
                PropuestaService.obtenerSucursales(param).then(function (response) {
                    if (!response.data.error) {
                        $scope.listaSucursales = response.data.dato;
                    } else {
                        Message.error(response.data.mensaje);
                    }
                    $scope.promesaSucursal.resolve();
                }).catch(function (response) {
                    $scope.promesaSucursal.reject();
                    $scope.sucursalSelected = $scope.valorSucursal;
                    $scope.incrementarSincronizador($scope.sucursalSelected);
                    Message.error("No se pudo obtener sucursales");
                });
            };

            var promesaTipoTarjeta = $q.defer();
            var obtenerTiposTarjetas = function () {
                PropuestaService.obtenerTiposTarjetas().then(function (response) {
                    if (!response.data.error) {
                        $scope.listaTiposTarjeta = response.data.dato;
                    } else {
                        Message.error(response.data.error);
                    }

                    promesaTipoTarjeta.resolve();
                }).catch(function (response) {
                    promesaTipoTarjeta.reject();
                    $scope.tipoTarjetaSelected = $scope.valorTipoTarjeta;
                    $scope.incrementarSincronizador($scope.tipoTarjetaSelected);
                    Message.error("No se pudo obtener los tipos de tarjetas");
                });
            };

            var promesaCodigoTarjeta = $q.defer();
            var obtenerCodigosTarjetas = function (codigoAgente, tipotarjeta) {
                var param = {};
                if (!angular.isUndefined(codigoAgente)) {
                    param.codigoAgente = codigoAgente;
                } else {
                    param.codigoAgente = undefined;
                }

                param.tipotarjeta = tipotarjeta;
                PropuestaService.obtenerTarjetas(param).then(function (response) {
                    if (response.data.dato != null) {
                        $scope.listaCodigosTarjeta = response.data.dato;
                    } else {
                        $scope.listaCodigosTarjeta = [];
                        $scope.nroTarjeta.valor = undefined;
                    }

                    promesaCodigoTarjeta.resolve();
                }).catch(function (response) {
                    promesaCodigoTarjeta.reject();
                    $scope.codTarjetaSelected = $scope.valorCodTarjeta;
                    $scope.incrementarSincronizador($scope.codTarjetaSelected);
                    Message.error("No se pudo obtener las tarjetas");
                });
            };
            var promesaAgentes = $q.defer();
            var obtenerAgentes = function () {
                PropuestaService.obtenerAgentes().then(function (response) {
                    $scope.listaAgentes = response.data.dato;
                    promesaAgentes.resolve();
                }, function (response) {
                    promesaAgentes.reject();
                    Message.error("No se pudo obtener los agentes");

                });
            };


            var obtenerConcesionarias = function (codigoAgente) {
                var parametros = {};
                if (!angular.isUndefined(codigoAgente)) {
                    if ($scope.subtipo !== "Flota") {
                        parametros.codigoAgente = codigoAgente;
                        parametros.preferencia = sessionStorage.getItem("preferencia_concesionarias");
                        if ($scope.todo_concesionarias == false) {
                            parametros.preferencia = "N";
                        }
                    } else {
                        parametros.preferencia = "N";
                        parametros.codigoAgente = codigoAgente;

                    }

                    PropuestaService.obtenerConcesionarias(parametros).then(function (response) {
                        if (!response.data.error) {
                            $scope.listaConcesionarias = response.data.dato;
                            //console.log($scope.listaConcesionarias);
                        } else {
                            Message.error(response.data.error);
                        }
                        $scope.promesaConcesionaria.resolve();

                    }).catch(function (response) {
                        $scope.promesaConcesionaria.reject();
                        $scope.concesionariaSelected = $scope.valorConcesionaria;
                        $scope.incrementarSincronizador($scope.concesionariaSelected);


                        Message.error("No se pudo obtener la lista de Concesionarias");
                    });

                }

            };

            var obtenerReferidos = function (codigoAgente, codigoConcesionaria) {
                PropuestaService.obtenerReferidos(codigoAgente, codigoConcesionaria).then(function (response) {
                    if (!response.data.error) {
                        $scope.listaReferidos = response.data.dato;
                    } else {
                        Message.error(response.data.mensaje);
                    }
                    $scope.promesaReferido.resolve();
                }).catch(function (response) {
                    $scope.promesaReferido.reject();
                    $scope.referidoSelected = $scope.valorReferido;
                    $scope.incrementarSincronizador($scope.referidoSelected);
                    Message.error("No se pudo obtener la lista de Referidos");
                });
            };

            var promesaAcrePrendario = $q.defer();
            var obtenerAcrPrendarios = function () {
                PropuestaService.obtenerAcrPrendarios().then(function (response) {
                    if (!response.data.error) {
                        $scope.listaAcrPrendarios = response.data.dato;
                    } else {
                        Message.error(response.data.error);
                    }

                    promesaAcrePrendario.resolve();
                }).catch(function (response) {
                    promesaAcrePrendario.reject();
                    $scope.acrPrendarioSelected = $scope.valorAcreedor;
                    $scope.incrementarSincronizador($scope.acrPrendarioSelected);
                    Message.error("No se pudo obtener la lista de Acreedores Prendarios");
                });
            };

            //Al seleccionar agente...
            $scope.promesaOficina = $q.defer();
            $scope.promesaComision = $q.defer();
            $scope.promesaConcesionaria = $q.defer();
            $scope.$watch('agenteSelected', function (newValue, oldValue) {
                if (!angular.isUndefined(newValue)) {
                    $scope.concesionariaSelected = undefined;
                    $scope.referidoSelected = undefined;
                    $scope.comisionSelected = undefined;
                    $scope.oficinaSelected = undefined;
                    obtenerConcesionarias(newValue);
                    obtenerComision(newValue);
                    obtenerOficina(newValue);
                } else {
                    $scope.concesionariaSelected = undefined;
                    $scope.referidoSelected = undefined;
                    $scope.comisionSelected = undefined;
                    //$scope.oficinaSelected = undefined;
                    $scope.listaConcesionarias = [];
                    //$scope.listaComision=[];
                    $scope.listaOficina = [];
                    $scope.listaReferidos = [];
                }
            }, true);
            $scope.promesaReferido = $q.defer();
            $scope.$watch('concesionariaSelected', function (newValue, oldValue) {
                if (!angular.isUndefined(newValue)) {
                    if (newValue !== "todos") {
                        if (newValue != oldValue) {
                            if (newValue != null && newValue != "") {
                                if ($scope.cambiarValores) {
                                    $scope.referidoSelected = undefined;
                                }
                                obtenerReferidos($scope.agenteSelected, newValue);
                            } else {
                                $scope.listaReferidos = [];
                                $scope.referidoSelected = undefined;
                            }

                        }
                    } else {
                        $scope.concesionariaSelected = undefined;
                        $scope.todo_concesionarias = false;
                        obtenerConcesionarias($scope.agenteSelected);
                    }

                }

            }, true);
            var promesaEjecutivo = $q.defer();
            $scope.$watch('oficinaSelected', function (newValue, oldValue) {
                if (!angular.isUndefined(newValue) && newValue != null) {
                    if (newValue != oldValue) {
                        //obtenerEjecutivos(newValue.COD_NIVEL3);
                        obtenerEjecutivos(newValue);
                    }
                } else {
                    $scope.valorEjecutivo = undefined;
                    $scope.ejecutivoSelected = undefined;

                }

            }, true);
            $scope.promesaEntidad = $q.defer();
            $scope.$watch('gestorSelected', function (newValue, oldValue) {
                if (!angular.isUndefined(newValue) && newValue != null) {
                    //$scope.sinc++;
                    if (newValue != oldValue) {
                        if (!angular.isUndefined($scope.gestorSelected)) {

                            obtenerEntidades($scope.gestorSelected);
                        }

                    }
                }

            }, true);
            var promesaGestores = $q.defer();
            $scope.$watch('formaPagoSelected', function (newValue, oldValue) {

                if (!angular.isUndefined(newValue) && newValue != null) {

                    obtenerGestores(newValue)
                    //esta bandera sirve basicamente para no pisar los datos que se setean desde el buscar
                    if ($scope.cambiarGestor == true) //este es el caso en que se haya cambiado desde el HTML, o desde el initialize
                    {
                        $scope.gestorSelected = undefined;
                        $scope.limpiarDatosGestores(newValue);
                        //$scope.gestorSelected.valor=undefined;


                    } else //esto es en caso que sea desde el buscar
                    {
                        $scope.cambiarGestor = true;
                    }


                } else {
                    $scope.gestorSelected = undefined;
                    $scope.listaGestores = [];
                }


            }, true);
            $scope.limpiarDatosGestores = function (newValue) {
                if (newValue == "CO") {
                    if (!angular.isUndefined($scope.entidadSelected)) {
                        //$scope.entidadSelected.valor=undefined;
                        $scope.entidadSelected = undefined;
                    }
                    if (!angular.isUndefined($scope.sucursalSelected)) {
                        //$scope.sucursalSelected.valor=undefined;
                        $scope.sucursalSelected = undefined;
                    }
                    $scope.nroTarjeta.valor = undefined;
                    $scope.vtotarjeta.valor = undefined;
                    $scope.nroCuentaCte.valor = undefined;
                    if (!angular.isUndefined($scope.tipoTarjetaSelected)) {
                        $scope.tipoTarjetaSelected = undefined;
                        //$scope.tipoTarjetaSelected.valor=undefined;

                    }
                    if (!angular.isUndefined($scope.codTarjetaSelected)) {
                        $scope.codTarjetaSelected = undefined;
                        //$scope.codTarjetaSelected.valor=undefined;
                    }

                } else if (newValue == "DB") {
                    $scope.nroTarjeta.valor = undefined;
                    $scope.vtotarjeta.valor = undefined;
                    if (!angular.isUndefined($scope.tipoTarjetaSelected)) {
                        $scope.tipoTarjetaSelected = undefined;
                    }
                    if (!angular.isUndefined($scope.codTarjetaSelected)) {
                        $scope.codTarjetaSelected = undefined;
                    }
                } else if (newValue == "TA") {
                    $scope.nroCuentaCte.valor = undefined;
                    if (!angular.isUndefined($scope.entidadSelected)) {
                        $scope.entidadSelected = undefined;
                    }
                    if (!angular.isUndefined($scope.sucursalSelected)) {
                        $scope.sucursalSelected = undefined;
                    }
                } else {
                    $scope.entidadSelected = undefined;
                    $scope.sucursalSelected = undefined;
                    $scope.nroTarjeta.valor = undefined;
                    $scope.vtotarjeta.valor = undefined;
                    $scope.tipoTarjetaSelected = undefined;
                    $scope.codTarjetaSelected = undefined;
                    $scope.nroCuentaCte.valor = undefined;
                }

            };
            $scope.promesaSucursal = $q.defer();
            $scope.$watch('entidadSelected', function (newValue, oldValue) {
                if (!angular.isUndefined(newValue)) {
                    if (newValue != oldValue) {
                        if (newValue != null) {
                            //$scope.sinc++;
                            obtenerSucursales(newValue);
                        } else {
                            $scope.listaSucursales = [];
                            //$scope.sucursalSelected={};
                            //$scope.sucursalSelected.valor=null;
                            $scope.sucursalSelected = undefined;
                        }

                    }
                }


            }, true);
            $scope.$watch('tipoTarjetaSelected', function (newValue, oldValue) {
                if (!angular.isUndefined(newValue)) {
                    if (newValue != oldValue) {
                        if (newValue != null) {
                            obtenerCodigosTarjetas($scope.agenteSelected, newValue);
                        } else {
                            obtenerCodigosTarjetas($scope.agenteSelected, null);
                        }

                    }
                }
            }, true);

            $scope.save = function (clickButton) {


                $scope.submitted = false;
                $scope.numeroCotizacion = $scope.numeroCotizacionRoot;
                var propuesta = {};
                propuesta.numeroCotizacion = $scope.numeroCotizacion;//218631
                propuesta.codigoAgente = angular.isUndefined($scope.agenteSelected) ? null : $scope.agenteSelected;
                propuesta.cuadroComision = angular.isUndefined($scope.comisionSelected) ? null : $scope.comisionSelected != null ? $scope.comisionSelected : null;
                propuesta.codigoEjecutivo = angular.isUndefined($scope.ejecutivoSelected) ? null : $scope.ejecutivoSelected != null ? $scope.ejecutivoSelected : null;
                propuesta.codigoOficinaComercial = angular.isUndefined($scope.oficinaSelected) ? null : $scope.oficinaSelected != null ? $scope.oficinaSelected : null;
                propuesta.codigoTipoEnvio = angular.isUndefined($scope.tipoEnvioSelected) ? null : $scope.tipoEnvioSelected != null ? $scope.tipoEnvioSelected : null;
                propuesta.codigoTipoGestor = angular.isUndefined($scope.formaPagoSelected) ? null : $scope.formaPagoSelected != null ? $scope.formaPagoSelected : null;
                propuesta.codigoGestor = angular.isUndefined($scope.gestorSelected) ? null : $scope.gestorSelected != null ? $scope.gestorSelected : null;
                propuesta.numeroCobroAnticipado = angular.isUndefined($scope.nroCobroAnt) ? null : $scope.nroCobroAnt.valor;
                propuesta.fechaEfectoRecibo = angular.isUndefined($scope.modelo) ? null : angular.isUndefined($scope.modelo.fechaRecibo) ? null : $scope.modelo.fechaRecibo;
                propuesta.fechaPrimerVencimiento = angular.isUndefined($scope.modelo) ? null : angular.isUndefined($scope.modelo.fechaPrimerVencimiento) ? null : $scope.modelo.fechaPrimerVencimiento;
                propuesta.numeroInternoBanco = angular.isUndefined($scope.nroInterno) ? null : angular.isUndefined($scope.nroInterno.valor) ? null : $scope.nroInterno.valor;
                propuesta.codigoEntidad = angular.isUndefined($scope.entidadSelected) ? null : $scope.entidadSelected != null ? $scope.entidadSelected : null;

                propuesta.codigoSucursal = angular.isUndefined($scope.sucursalSelected) ? null : $scope.sucursalSelected != null ? $scope.sucursalSelected : null;

                propuesta.numeroCuentaCorriente = angular.isUndefined($scope.nroCuentaCte) ? null : $scope.nroCuentaCte.valor;
                propuesta.tipoTarjeta = angular.isUndefined($scope.tipoTarjetaSelected) ? null : $scope.tipoTarjetaSelected != null ? $scope.tipoTarjetaSelected : null;

                propuesta.codigoTarjeta = angular.isUndefined($scope.codTarjetaSelected) ? null : $scope.codTarjetaSelected != null ? $scope.codTarjetaSelected : null;

                propuesta.numeroTarjeta = angular.isUndefined($scope.nroTarjeta) ? null : $scope.nroTarjeta.valor;
                propuesta.fechaVencimientoTarjeta = angular.isUndefined($scope.vtotarjeta) ? null : !angular.isUndefined($scope.vtotarjeta.valor) && $scope.vtotarjeta.valor != null ? moment($scope.vtotarjeta.valor).format("DD/MM/YYYY") : null;
                propuesta.codigoReferido = angular.isUndefined($scope.referidoSelected) ? null : $scope.referidoSelected != null ? $scope.referidoSelected : null;
                if (propuesta.codigoReferido != null) {
                    for (var i = 0; i < $scope.listaReferidos.length; i++) {
                        if ($scope.listaReferidos[i].DOCUMENTO == propuesta.codigoReferido) {

                            propuesta.tipoReferido = $scope.listaReferidos[i].REFERIDO;
                            break;

                        }
                    }
                } else {
                    propuesta.tipoReferido = null;
                }
                propuesta.codigoAcreedor = angular.isUndefined($scope.acrPrendarioSelected) ? null : $scope.acrPrendarioSelected != null ? $scope.acrPrendarioSelected : null;
                if (propuesta.codigoAcreedor != null) {
                    for (var i = 0; i < $scope.listaAcrPrendarios.length; i++) {
                        if ($scope.listaAcrPrendarios[i].DOCUMENTO == propuesta.codigoAcreedor) {

                            propuesta.tipoAcreedor = $scope.listaAcrPrendarios[i].ACREEDOR;
                            break;

                        }
                    }
                } else {
                    propuesta.tipoAcreedor = null;
                }

                propuesta.codigoConcesionaria = angular.isUndefined($scope.concesionariaSelected) ? null : $scope.concesionariaSelected != null && $scope.concesionariaSelected != "" ? $scope.concesionariaSelected : null;
                propuesta.fechaEfectoPoliza = angular.isUndefined($scope.fechaVigenciaDesde) ? null : $scope.fechaVigenciaDesde != null ? moment($scope.fechaVigenciaDesde).format("DD/MM/YYYY") : null;
                propuesta.fechaVencimientoPoliza = angular.isUndefined($scope.fechaVigenciaHasta) ? null : moment($scope.fechaVigenciaHasta).format("DD/MM/YYYY");
                propuesta.marcaModulo=$scope.pathModule.split("marcaModulo=")[1];
                var param = JSON.stringify(propuesta);
                $scope.cargando = true;
                PropuestaService.guardarPropuesta(propuesta).then(
                    //sucess
                    function (response) {

                        if (!response.data.error) {

                            if (clickButton == "S") {
                                var param = {};
                                param.numeroCotizacion = $scope.numeroCotizacion;
                                param.marcaFlota = $scope.subtipo == 'Flota' ? 'S' : 'N';
                                param.tab = $scope.tab;
                                param.pathModule=$scope.pathModule;
                                PropuestaService.getTabs(param);
                            } else {
                                $scope.cambiarTab = 1; //exito
                            }


                            Message.ok(response.data.mensaje);
                        } else {
                            $scope.cambiarTab = 2; //error
                            Message.error(response.data.mensaje);

                        }
                        $scope.cargando = false;
                        //error
                    }).catch(function (response) {
                    $scope.cargando = false;
                    $scope.cambiarTab = 2; //error
                    Message.error(response.data.mensaje);

                });


            };


            $scope.buscar = function () {
                $scope.numeroCotizacion = $scope.numeroCotizacionRoot;
                if (!angular.isUndefined($scope.numeroCotizacion)) {
                    if ($scope.numeroCotizacion != null && $scope.numeroCotizacion != "") {
                        id = "propuestaTab"
                        $scope.cargando = true;
                        var param = {};
                        param.numeroCotizacion = $scope.numeroCotizacion;
                        param.marcaFlota = $scope.subtipo == 'Flota' ? 'S' : 'N';
                        param.tab = $scope.tab;
                        param.pathModule=$scope.pathModule;
                        $scope.todo_concesionarias = false;
                        $scope.agenteSelected = undefined;
                        $scope.sinc = 0;
                        cantModeloSinc = 0;
                        $scope.permitirCambio = false;

                        $scope.cambiarGestor = false; //cuando no tiene preferencia se debe de volver a llamar a la lista de gestores
                        $scope.formaPagoSelected = undefined;
                        $scope.limpiarDatosGestores();
                        PropuestaService.getTabs(param);
                        PropuestaService.getCamposEditablesList(param);
                        PropuestaService.getPropuesta(param).then(
                            //sucess
                            function (response) {

                                if (!response.data.error) {
                                    if (response.data.dato != null && response.data.dato.length > 0) {


                                        $scope.bloquearBuscador = true;
                                        $scope.cambiarValores = false;
                                        $scope.cargarPlataforma();
                                        $scope.tieneIva = response.data.dato[0].MCA_IVA == null ? 'S' : response.data.dato[0].MCA_IVA;
                                        $scope.firmaDigital = response.data.dato[0].MCA_FIRMA_ELECTRONICA == null ? 'N' : response.data.dato[0].MCA_FIRMA_ELECTRONICA;
                                       

                                        //  $q.all( [
                                        //     promesaEjecutivo.promise.then()
                                        // ] ).then(function(sucess){
                                              $scope.setearCantidadModelos(response);
                                        // });

                                       

                                        $scope.promesaOficina.promise.$$state.status = 0;
                                        $scope.promesaConcesionaria.promise.$$state.status = 0;
                                        $scope.promesaComision.promise.$$state.status = 0;
                                        if (response.data.dato[0].COD_AGT == null) {

                                            $scope.agenteSelected = parseInt(sessionStorage.getItem("codigoAgente"));


                                        } else {

                                            $scope.agenteSelected = response.data.dato[0].COD_AGT;

                                        }

                                        $scope.promesaOficina.promise.then(
                                            function () {
                                                $scope.permitirCambio=true;
                                                $scope.oficinaSelected = response.data.dato[0].COD_NIVEL3;
                                                $scope.incrementarSincronizador($scope.oficinaSelected);
                                                if ($scope.oficinaSelected==null) //setear el que trae el agente si es que tiene una sola oficina comercial
                                                {
                                                    if ($scope.listaOficina.length==1)
                                                    {
                                                        $scope.oficinaSelected=$scope.listaOficina[0].COD_NIVEL3;
                                                    }


                                                }
                                                else
                                                {
                                                    /**se espera un rato para que  el watch anterior se ejecute para el tema de la sincronidad de los modelos y las llamadas asincronas, y en caso que no se encuentre en la lista entonces se limpia**/
                                                    $timeout(function(){
                                                        if ($scope.listaOficina.map(function(e){return e.COD_NIVEL3}).indexOf($scope.oficinaSelected)<0)

                                                        $scope.oficinaSelected=undefined;
                                                    },1000);
                                                }

                                                $scope.promesaOficina.promise.$$state.status = 0;
                                            });
                                            promesaEjecutivo.promise.then(
                                            function () {

                                               $scope.ejecutivoSelected = undefined;
                                               for (var i=0; i < $scope.listaEjecutivos.length ;i++){
    
                                                   if ( $scope.listaEjecutivos[i].COD_TERCERO==response.data.dato[0].COD_EJECUTIVO){
                                                       $scope.ejecutivoSelected = response.data.dato[0].COD_EJECUTIVO;
                                                       break;
                                                   }

                                               }
                                                
                                                if (angular.isUndefined($scope.ejecutivoSelected) ){
                                                    $scope.incrementarSincronizador(1);
                                                }else{
                                                     $scope.incrementarSincronizador($scope.ejecutivoSelected);
                                                }
                                                

                                            });
                                        $scope.promesaComision.promise.then(
                                            function () {
                                                $scope.comisionSelected = response.data.dato[0].COD_CUADRO_COM;
                                                $scope.incrementarSincronizador($scope.comisionSelected);
                                                var encontrado=false;
                                                for (var i=0; i< $scope.listaComision.length;i++)
                                                {
                                                    if ($scope.listaComision[i].COD_CUADRO_COM==parseInt($scope.comisionSelected))
                                                    {
                                                        encontrado=true;
                                                    }
                                                }
                                                if (!encontrado)
                                                {
                                                    $scope.comisionSelected=undefined;
                                                }


                                            });
                                        $scope.promesaReferido.promise.then(function () {
                                            $scope.referidoSelected = response.data.dato[0].COD_REFERIDO;
                                            $scope.incrementarSincronizador($scope.referidoSelected);

                                        });
                                        $scope.promesaConcesionaria.promise.then(function () {
                                            $scope.concesionariaSelected = response.data.dato[0].COD_CONCESIONARIA;
                                            $scope.incrementarSincronizador($scope.concesionariaSelected);

                                        });


                                        promesaAcrePrendario.promise.then(
                                            function () {
                                                $scope.acrPrendarioSelected = response.data.dato[0].COD_ACREEDOR;
                                                $scope.incrementarSincronizador($scope.acrPrendarioSelected);


                                            });


                                        promesaTipoEnvio.promise.then(
                                            function () {
                                                $scope.tipoEnvioSelected = response.data.dato[0].COD_TIP_ENVIO ? response.data.dato[0].COD_TIP_ENVIO.toString() : response.data.dato[0].COD_TIP_ENVIO;
                                                $scope.incrementarSincronizador($scope.tipoEnvioSelected);


                                            });

                                        promesaObtenerFormasPago.promise.then(
                                            function () {
                                                if (response.data.dato[0].TIP_GESTOR == null) {
                                                    $scope.formaPagoSelected = $scope.pagoPreferencia;
                                                } else {
                                                    $scope.formaPagoSelected = response.data.dato[0].TIP_GESTOR;
                                                }

                                                $scope.incrementarSincronizador($scope.formaPagoSelected);


                                            });
                                        $scope.promesaEntidad.promise.then(function () {
                                            $scope.entidadSelected = response.data.dato[0].COD_ENTIDAD;
                                            $scope.incrementarSincronizador($scope.entidadSelected);

                                        });
                                        $scope.fechaVigenciaDesde = angular.isUndefined(response.data.dato[0].FEC_EFEC_POL) ? undefined : response.data.dato[0].FEC_EFEC_POL != undefined ? $scope.convertirDate(response.data.dato[0].FEC_EFEC_POL) : undefined;
                                        $scope.fechaVigenciaHasta = angular.isUndefined(response.data.dato[0].FEC_VCTO_POL) ? undefined : response.data.dato[0].FEC_VCTO_POL != undefined ? $scope.convertirDate(response.data.dato[0].FEC_VCTO_POL) : undefined;
                                        $scope.nroCobroAnt.valor = response.data.dato[0].NUM_COBRO_ANTICIPADO;
                                        $scope.modelo.fechaRecibo = angular.isUndefined(response.data.dato[0].FEC_EFEC_RECIBO) ? undefined : response.data.dato[0].FEC_EFEC_RECIBO != undefined ? $scope.convertirDate(response.data.dato[0].FEC_EFEC_RECIBO) : undefined;
                                        $rootScope.nroPropuesta = angular.isUndefined(response.data.dato[0].NUM_PROPUESTA) ? null : response.data.dato[0].NUM_PROPUESTA;
                                        $scope.gestorSelected = undefined;


                                        promesaGestores.promise.then(function () {
                                            $scope.gestorSelected = null;
                                            if (response.data.dato[0].TIP_GESTOR != null && response.data.dato[0].TIP_GESTOR != "")
                                            {
                                                $scope.gestorSelected=response.data.dato[0].COD_GESTOR;
                                            }
                                            $scope.incrementarSincronizador($scope.gestorSelected);

                                        })


                                        $scope.modelo.fechaPrimerVencimiento = angular.isUndefined(response.data.dato[0].FEC_PRIMER_VCTO) ? undefined : response.data.dato[0].FEC_PRIMER_VCTO != undefined ? $scope.convertirDate(response.data.dato[0].FEC_PRIMER_VCTO) : undefined;
                                        $scope.nroInterno.valor = response.data.dato[0].NUM_SOLICITUD_EE;

                                        $scope.promesaSucursal.promise.then(
                                            function () {
                                                $scope.sucursalSelected = response.data.dato[0].COD_OFICINA;
                                                $scope.incrementarSincronizador($scope.sucursalSelected);

                                            });

                                        $scope.nroCuentaCte.valor = response.data.dato[0].CTA_CTE;
                                        $scope.tipoTarjetaSelected = response.data.dato[0].COD_TIP_TAR;


                                        promesaCodigoTarjeta.promise.then(
                                            function () {
                                                $scope.codTarjetaSelected = response.data.dato[0].COD_TARJETA;
                                                $scope.incrementarSincronizador($scope.codTarjetaSelected);

                                            });

                                        $scope.nroTarjeta.valor = response.data.dato[0].NUM_TARJETA;
                                        $scope.vtotarjeta.valor = angular.isUndefined(response.data.dato[0].FEC_VCTO_TARJETA) ? undefined : response.data.dato[0].FEC_VCTO_TARJETA != undefined ? $scope.convertirDate(response.data.dato[0].FEC_VCTO_TARJETA) : undefined;

                                        if (response.data.dato[0].MCA_ASEGURADO === 'S') {

                                            $rootScope.llamarAsegurado = false;
                                        } else {
                                            $rootScope.llamarAsegurado = true;
                                        }


                                    } else {
                                        $scope.limpiar();
                                        $rootScope.llamarAsegurado = true;
                                        Message.warning(response.data.mensaje);
                                        $scope.cargando = false;
                                    }


                                } else {
                                    $scope.limpiar();
                                    $rootScope.llamarAsegurado = true;
                                    $scope.cargando = false;
                                    Message.error(response.data.mensaje);
                                }

                                //error
                            }).catch(function (response) {
                            $scope.limpiar();
                            $rootScope.llamarAsegurado = true;
                            $scope.cargando = false;
                            Message.error("Ocurrió un error, intente nuevamente");

                        });

                    }

                }


            };
            $scope.$watch('fechaVigenciaDesde', function (NewValue, OldValue) {
                if (!angular.isUndefined(NewValue) && NewValue != null) {
                    if (NewValue != OldValue) {
                        var dato = moment(NewValue).format("DD/MM/YYYY");
                        var param={};
                        param.fechaVigencia=dato;
                        param.pathModule = $scope.pathModule;
                        PropuestaService.obtenerFechaVigenciaHasta(param).then(function(response){
                            if (!response.data.error)
                            {
                                if (response.data.dato!=null)
                                {
                                    $scope.fechaVigenciaHasta=$scope.convertirDate(response.data.dato.fechaVencimientoPoliza);
                                }
                            }
                            else
                            {
                                Message.error(response.data.mensaje);
                            }
                        })
                       /* var dato = moment(NewValue).format("DD/MM/YYYY");
                        var dataSplit = dato.split('/');
                        var anho = parseInt(dataSplit[2]) + 1;
                        var fecha = dataSplit[0] + "/" + dataSplit[1] + "/" + anho;
                        $scope.fechaVigenciaHasta = $scope.convertirDate(fecha);*/

                    }

                } else if (NewValue == null) {
                    $scope.fechaVigenciaHasta = undefined;

                }

            }, true);


            /**formato para el datepicker**/
            $scope.formatearFecha = function (fecha) {
                $scope.aplicarFormato(fecha);
            };


            $scope.cargarPlataforma = function () {

                var paramPla = {};
                paramPla.numeroCotizacion = $scope.numeroCotizacion;
                paramPla.marcaFlota = $scope.subtipo == 'Flota' ? 'S' : 'N';
                paramPla.pathModule = $scope.pathModule;
                CotizacionVehiculoPropuestaService.getPlataforma(paramPla).then(
                    function (response) {
                        if (!response.data.error) {
                            if (response.data.dato != null) {

                                $scope.mostrarPlataforma = true;

                                $scope.prop.plataforma = response.data.dato.mensaje;


                            }

                        }


                    }).catch(function (response) {

                    Message.error(response.data.mensaje);

                });
            };


            /**
             * Función creada para el salto de propuesta a cotizacion
             */
            $scope.goToCotizacion = function () {
                var path = $location.$$absUrl;
                var n = path.search("module");
                var url = path.substring(0, n);

                if (typeof $scope.numeroCotizacionRoot != 'undefined' && $scope.numeroCotizacionRoot != null) {
                    var subtipo = 'flota';
                    if ($scope.subtipo == 'Vehiculos') {
                        subtipo = 'cotizacion-vehiculo';


                    }
                    location.href = subtipo + '/' + $scope.numeroCotizacionRoot;

                } else {
                    Message.warning("Debe ingresar un número de cotización");
                }
            }


            $scope.limpiar = function () {

                $rootScope.camposRequeridosList = [];
                $rootScope.numeroCotizacionRoot = undefined;
                $rootScope.nroPropuesta = undefined;
                $scope.eliminarPagina();
                if (typeof $routeParams.numeroCotizacion != "undefined") {
                    $location.search('numeroCotizacion', undefined);
                    $rootScope.numeroCotizacionRoot = undefined;
                    if ($scope.subtipo == "Flota") {
                        $location.path('propuesta-flota/propuesta')
                    } else {
                        $location.path('propuesta-vehiculo/propuesta')
                    }


                } else {
                    $route.reload();
                }

            };
            $scope.recargar = function () {
                $scope.agenteSelected = undefined;
                $scope.bloquearBuscador = false;
                $scope.mostrarPlataforma = false;
                $scope.limpiar();

            };
            $scope.generarConstancia = function () {
                if (!angular.isUndefined($scope.numeroCotizacion) || $scope.numeroCotizacion != null) {
                    $scope.cargando = true;
                    var datos = {};
                    datos.numeroCotizacion = $scope.numeroCotizacion;
                    datos.marcaModulo=$location.path().split("/")[1];
                    PropuestaService.enviarConstancia(datos).then(function (response) {
                        $scope.cargando = false;
                        if (!response.data.error) {
                            Message.ok(response.data.mensaje);
                        } else {
                            Message.error(response.data.mensaje);
                        }
                    }).catch(function (response) {
                        $scope.cargando = false;
                        Message.error("Ocurrió un error, intente nuevamente");

                    });
                } else {
                    Message.warning("Debe ingresar un numero de cotizacion válido!");
                }
            };

            $scope.llamarModal = function (value) {

                if (!angular.isUndefined($rootScope.numeroCotizacionRoot) && $rootScope.numeroCotizacionRoot != null && $rootScope.numeroCotizacionRoot != "") {
                    $rootScope.numCotiza = $rootScope.numeroCotizacionRoot;
                    $rootScope.modalCotizadorVehFlota = value;
                    $scope.subtipo == 'Flota' ? $rootScope.flagVehiculoFlota = false : $rootScope.flagVehiculoFlota = true;
                    $mdDialog.show({
                        //locals:{parent: $scope},
                        controller: 'ModalAutorizacionCtrl',
                        templateUrl: 'partials/ventanas-emergentes/modal-autorizacion-partial.html',
                        parent: angular.element(document.body),
                        multiple: true,
                        clickOutsideToClose: false,
                        scope: $scope,
                        preserveScope: true,
                        fullscreen: $scope.customFullscreen // Only for -xs, -sm breakpoints.
                    }).then(function (answer) {
                        $scope.buscar();


                    }, function () {
                        $scope.status = 'You cancelled the dialog.';
                        //console.log($scope.status);
                    });
                }

            };


            $scope.obtenerAutorizaciones = function () {

                $scope.autorizacionesList = [];
                var param = {};
                param.pathModule =$scope.pathModule;
                CotizacionVehiculoService.getAutorizaciones(param).then(function (response) {
                    if (!response.data.error) {
                        if (response.data.dato.length > 0) {
                            var campos = response.data.dato;
                            for (var i = 0; i < campos.length; i++) {
                                $scope.autorizacionesList.push(campos[i]);

                            }
                        }
                        //console.log("Lista Autorizaciones: " + JSON.stringify($scope.autorizacionesList));
                    } else {
                        Message.error(response.data.mensaje);
                    }
                });
            };

            /**Este Watch se dispara cuando las promesas se resuelven o tiene error, y la condicion principal debe ser
             * que el valor del sinc sea mayor a 0, sino ocurre eso es porque hay un error en el buscar o viene vacio el modelo de buscar**/

            $scope.$watch('sinc', function (NewValue, OldValue) {
                if (NewValue == cantModeloSinc && NewValue > 0) {
                    $scope.cargando = false;
                    $scope.sinc = 0; //cantidad de modelos seteados una vez obtenida la promesa
                    cantModeloSinc = 0; //cantidad de modelos que necesitan llamadas de servicios
                }


            }, true);
            $scope.setearCantidadModelos = function (response) {
                //preguntar la cantidad de campos a ser seteados
                if (response.data.dato[0].COD_CONCESIONARIA != null && response.data.dato[0].COD_CONCESIONARIA != "") {
                    /*variable auxiliar en caso que ocurra algun error, en la promesa de la concesionaria*/
                    $scope.valorConcesionaria = response.data.dato[0].COD_CONCESIONARIA;
                    cantModeloSinc++;
                }//1

                if (response.data.dato[0].COD_CUADRO_COM != null && response.data.dato[0].COD_CUADRO_COM != "") {

                    $scope.valorComision = response.data.dato[0].COD_CUADRO_COM;
                    cantModeloSinc++;
                }
                if (response.data.dato[0].COD_NIVEL3 != null && response.data.dato[0].COD_NIVEL3 != "") {
                    $scope.valorOficina = response.data.dato[0].COD_NIVEL3;
                    cantModeloSinc++;
                }


                if (response.data.dato[0].COD_REFERIDO != null && response.data.dato[0].COD_REFERIDO != "" && response.data.dato[0].COD_CONCESIONARIA != null && response.data.dato[0].COD_CONCESIONARIA != "") {
                    $scope.valorReferido = response.data.dato[0].COD_REFERIDO;
                    cantModeloSinc++;
                }
                if (response.data.dato[0].COD_ENTIDAD != null && response.data.dato[0].COD_ENTIDAD != "" && response.data.dato[0].COD_GESTOR != null && response.data.dato[0].COD_GESTOR != "") {
                    $scope.valorEntidad = response.data.dato[0].COD_ENTIDAD;
                    cantModeloSinc++;
                }
                if (response.data.dato[0].COD_ACREEDOR != null && response.data.dato[0].COD_ACREEDOR != "") {
                    $scope.valorAcreedor = response.data.dato[0].COD_ACREEDOR;
                    cantModeloSinc++;
                }
                if (response.data.dato[0].COD_TIP_ENVIO != null && response.data.dato[0].COD_TIP_ENVIO != "") {
                    $scope.valorEnvio = response.data.dato[0].COD_TIP_ENVIO;
                    cantModeloSinc++;
                }
                if (response.data.dato[0].TIP_GESTOR != null && response.data.dato[0].TIP_GESTOR != "" ) {
                    $scope.valorTipoGestor = response.data.dato[0].TIP_GESTOR;
                    cantModeloSinc++;
                }//2
                if (response.data.dato[0].COD_OFICINA != null && response.data.dato[0].COD_OFICINA != "" && response.data.dato[0].COD_ENTIDAD != null && response.data.dato[0].COD_ENTIDAD != "" && response.data.dato[0].COD_GESTOR != null && response.data.dato[0].COD_GESTOR != "") {
                    $scope.valorSucursal = response.data.dato[0].COD_OFICINA;
                    cantModeloSinc++;
                }//3
                if (response.data.dato[0].COD_TIP_TAR != null && response.data.dato[0].COD_TARJETA != null && response.data.dato[0].COD_TIP_TAR != "" && response.data.dato[0].COD_TARJETA != "") {
                    $scope.valorCodTarjeta = response.data.dato[0].COD_TARJETA;
                    cantModeloSinc++;
                }//7
                if (response.data.dato[0].COD_GESTOR != null && response.data.dato[0].COD_GESTOR != "" && response.data.dato[0].TIP_GESTOR != null && response.data.dato[0].TIP_GESTOR != "") {
                    $scope.valorCodGestor = response.data.dato[0].COD_GESTOR;
                    cantModeloSinc++;
                }//8
                if (response.data.dato[0].COD_EJECUTIVO != null && response.data.dato[0].COD_EJECUTIVO != "" && response.data.dato[0].COD_NIVEL3 != null && response.data.dato[0].COD_NIVEL3 != "") {
                  // for (var i=0; i< $scope.listaEjecutivos.length;i++){
                     //  if ($scope.listaEjecutivos[i].COD_TERCERO==response.data.dato[0].COD_EJECUTIVO){
                            $scope.valorEjecutivo = response.data.dato[0].COD_EJECUTIVO;
                            cantModeloSinc++;                   
                      //  }

                   // }
                   
                }//9
                /**Si no hay datos en el modelo que no necesitan promesas entonces se debe de ocultar el cargando*/
                if (cantModeloSinc == 0) {
                    $scope.cargando = false;
                }
            };
            $scope.$watch('cambiarTab', function (newValue, oldValue) {
                if (newValue != 0) {
                    if (newValue == 1) {
                        //hacer el redirect

                        var params={};
                        params.marcaFlota=$scope.subtipo=="Flota"?'S':'N';
                        params.numeroCotizacion=angular.isUndefined($scope.numeroCotizacionRoot)|| $scope.numeroCotizacionRoot==null?"":$scope.numeroCotizacionRoot;
                        params.tab=$rootScope.sigTab;
                        params.pathModule=$scope.pathModule;
                        $scope.service.getCamposEditablesList(params);
                        $timeout($location.url($rootScope.url_destino),1000);
                    } else {
                        newValue = 0; //para que vuelva a cambiar e intentar
                    }
                }

            }, true);
            $scope.eliminarPagina=function()
            {
                sessionStorage.removeItem("paginaAsegurado");
                sessionStorage.removeItem("paginaRiesgoPropuesta");
            };




        (function initialize() {
            $rootScope.currentPage = 'propuesta';
            $rootScope.tabs = PropuestaService.getTabInicial();
            $scope.bloquearBuscador=false;
            $rootScope.llamarAsegurado=true;
            $scope.pathModule = UtilsService.retornarPath($location.path().split("/")[1]);
            $scope.agenteSelected=parseInt(sessionStorage.getItem("codigoAgente"));
            $scope.tieneIva='N';
            $scope.firmaDigital='N';
            $scope.imprimeGenera=undefined;
            $scope.subtipo=='Flota'?$scope.todo_concesionarias=false:$scope.todo_concesionarias=true;
        	obtenerFormasPago();
        	obtenerTiposTarjetas();
        	obtenerAgentes();
            obtenerAcrPrendarios();
            obtenerTiposEnvio();
            $scope.obtenerAutorizaciones();
           angular.extend(this, $controller('UtilsCtrl', {
                    "$scope": $scope
            }));

            /**
             * Verifica si la ventana fue llamada desde cotizacion
             */
            if(typeof $routeParams.numeroCotizacion != "undefined"){
                
                $rootScope.numeroCotizacionRoot = $routeParams.numeroCotizacion;
                $scope.numeroCotizacion=$rootScope.numeroCotizacionRoot;
                $scope.buscar();
            }
            else if (!angular.isUndefined($scope.numeroCotizacionRoot) && $scope.numeroCotizacionRoot!= null && $scope.numeroCotizacionRoot!=""){

             $scope.buscar();
            }
            else
            {
                var marcaFlota;
                if ($scope.subtipo == "Flota")
                {
                    marcaFlota="S";
                }
                else
                {
                    marcaFlota="N";
                }
                var params={};
                params.marcaFlota=marcaFlota;
                params.numeroCotizacion=angular.isUndefined($scope.numeroCotizacionRoot)|| $scope.numeroCotizacionRoot==null?"":$scope.numeroCotizacionRoot;
                params.tab=$scope.tab;
                params.pathModule=$scope.pathModule;
                $scope.service.getCamposEditablesList(params);
            }

            if ($window.sessionStorage["rolesAsignados"]!=undefined && $window.sessionStorage["rolesAsignados"]!=null){
                var listaRoles = $window.sessionStorage["rolesAsignados"].split(",");
                $scope.controlPermisos = listaRoles.indexOf("rol_1")>-1? true:false;
            }

            $scope.eliminarPagina();







            
        })();
            


    }]);
;app.controller('PropuestaVehiculoMainFormCtrl', ['$scope', '$q', '$controller', '$routeParams', '$location', 'SessionService', '$rootScope','$route', '$mdDialog', '$filter', 'ConfirmService', '$window',
    function ($scope,$q, $controller, $routeParams, $location, sessionService, $rootScope,$route, $mdDialog,  $filter, confirmService, $window) {


        $scope.nombre = "Propuesta Vehiculos Menú Principal";

        (function initialize() {

        

        })();


    }]);;app.controller('SidebarVehiculoCtrl', ['$scope','$controller','$window', '$rootScope','$args', 'Navigator',
    function ($scope,$controller,$window, $rootScope,$args, Navigator) {
        
        $scope.verificarOpcionesMenu=function()
        {            
            if($window.sessionStorage.getItem("asegurado_Vehiculos")==null)
            {
                $scope.aseguradoVehiculo=false;
            }
            else
            {
                if ($window.sessionStorage["asegurado_Vehiculos"]=="true")
                {
                $scope.aseguradoVehiculo=true;

                }
                else
                {
                    $scope.aseguradoVehiculo=false;
                }
            }
        };
        $scope.$on("cambiarMenuVehiculo", function (event, data) {
            $scope.verificarOpcionesMenu();            
              });

        
        $scope.irA = function() {
         

        /* Navigator.goTo('propuesta-vehiculo/vehiculo/', {
         numeroCotizacion: $scope.numeroCotizacion
        });*/

         
        };


        (function initialize() {
            $scope.verificarOpcionesMenu();
        })();
        
    }]);
;app.controller('TomadorVehiculoFormCtrl', ['$scope', '$q', '$controller', '$routeParams', '$location', 'SessionService', '$rootScope','$route', '$mdDialog', '$filter', 'ConfirmService', '$window',
    function ($scope,$q, $controller, $routeParams, $location, sessionService, $rootScope,$route, $mdDialog,  $filter, confirmService, $window) {


        $scope.nombre = "Tomador Vehiculos";

        (function initialize() {

        

        })();


    }]);;app.controller('VehiculoFormCtrl', ['$scope', '$q', '$controller', '$routeParams', '$location', 'SessionService', '$rootScope','$route', '$mdDialog', '$filter', 'ConfirmService', '$window', 'VehiculoService','CotizacionVehiculoPropuestaService', 'UtilsService','PropuestaService','$log','$timeout',
    function ($scope,$q, $controller, $routeParams, $location, sessionService, $rootScope,$route, $mdDialog,  $filter, confirmService, $window, VehiculoService,CotizacionVehiculoPropuestaService, UtilsService,PropuestaService, $log, $timeout ) {
    $scope.service = PropuestaService;
    $scope.controlPermisos = true;
    $scope.nombre = "Vehiculos";
    $scope.subtipo = $route.current.$$route.subtipo;
    $rootScope.rootPathParent =$route.current.$$route.originalPath;
    $scope.nombre = $scope.subtipo;
    $scope.cambiarTab=0;
    $scope.imagenesList=[];
    $scope.showImg=false;
    $scope.formatearFecha=function(fecha)
    {
       $scope.aplicarFormato(fecha);
    };
        $scope.cargando=false;
        $scope.nroInspeccion = {};
        $scope.numChapa = {};
        $scope.numChasis = {};
        $scope.usoSelected=undefined;
        $scope.anhonac ={};
        $scope.marcaCeroKm ={};
        $scope.conductor1 ={};
        $scope.conductor2={};
        $scope.fechaCert={};
        $scope.fechaEntrega={};
        $scope.fechaCert={};
        //$scope.fechaCert.valor='';
        $scope.fechaEntrega={};
        $scope.veh={};
        $scope.veh.plataforma=null;

        $rootScope.nroPropuesta=undefined;

        $scope.camposEditablesList = [];
        $scope.camposRequeridosList = [];

        $scope.submitted = false;
        $scope.pantalla="VEHICULO";
        $scope.sinc=0; /**variable que almcena las promesas resueltas o fracasadas*/
        var cantModeloSinc=0; /**variable que almacena la cantidad de datos que vienen en el buscar, que requieren otras llamadas de promesas**/
        $scope.valorUso=undefined;
        $scope.buscarImgInspe=false;


        $scope.obtenerCamposRequeridos=function()
        {
            var subtipo = "Flota";
            if ($scope.subtipo == "Vehiculos") subtipo = "Vehiculo";
            $scope.camposRequeridosList = [];
            CotizacionVehiculoPropuestaService.getCamposRequeridos(subtipo).then(function(response){
                //console.log("RESPONSE: " + JSON.stringify(response));
               if (!response.data.error)
               {
                    //console.log("LENGTH RESPONSE: " + response.data.dato.length);
                   if (response.data.dato.length>0)
                   {
                       var campos=response.data.dato;
                       for (var i=0; i< campos.length; i++)
                       {
                           $scope.camposRequeridosList.push(campos[i]);
                       }
                   }

               }
               else
                   {
                   Message.error(response.data.mensaje);
               }
            });
        };

        $scope.verificarCamposForm=function(listaCampo, campo)
        {
            return UtilsService.verificarCamposForm(listaCampo, campo);
        };

        var obtenerColores = function(){
        	VehiculoService.obtenerColores().then(function(response){
        		$scope.listaColores = response.data.dato;

        	}, function(response){
        		Message.error("No se pudo obtener los colores");
        	});
        };

        var obtenerUsos = function(){
            var param={};
            param.codTipoVehiculo=angular.isUndefined($scope.codigoTipoVehiculo)?1: $scope.codigoTipoVehiculo;
        	VehiculoService.obtenerUsos(param).then(function(response){
        	    if (!response.data.error)
                {
                    $scope.listaUsos = response.data.dato;

                }
                else
                {
                    Message.error(response.data.mensaje);
                }
                $scope.promesaUsos.resolve();

        	}).catch(function(error)
            {
                $scope.promesaUsos.reject();
                Message.error("No se pudo obtener la lista de usos");
                $scope.usoSelected=$scope.valorUso;
                $scope.incrementarSincronizador($scope.usoSelected);
            });
        };

        $scope.save = function(clickButton) {
            $scope.numeroCotizacion = $scope.numeroCotizacionRoot;
             var vehiculo ={};
             vehiculo.numeroCotizacion=$scope.numeroCotizacion;//218631;
             vehiculo.numeroInspeccion=angular.isUndefined($scope.nroInspeccion)?null:$scope.nroInspeccion.valor;
             vehiculo.numeroMatricula=angular.isUndefined($scope.numChapa)?null:$scope.numChapa.valor;
             vehiculo.numeroChassis=angular.isUndefined($scope.numChasis)?null:$scope.numChasis.valor;
             vehiculo.anioNacionalizacion=angular.isUndefined($scope.anhonac)?null:$scope.anhonac.valor;
             vehiculo.marcaCeroKm=angular.isUndefined($scope.marcaCeroKm)?"N":$scope.marcaCeroKm.valor==null?"N":$scope.marcaCeroKm.valor;
             vehiculo.fechaCertificado=angular.isUndefined($scope.fechaCert)?null: $scope.fechaCert.valor != null?moment($scope.fechaCert.valor).format("DD/MM/YYYY"):null;
             vehiculo.fechaEntrega=angular.isUndefined($scope.fechaEntrega)?null:$scope.fechaEntrega.valor !=null? moment($scope.fechaEntrega.valor).format("DD/MM/YYYY"):null;
             vehiculo.codigoColor=angular.isUndefined($scope.colorSelected)?null:!angular.isUndefined($scope.colorSelected.valor) && $scope.colorSelected.valor!=null ?$scope.colorSelected.valor.COD_COLOR:null;
             //vehiculo.codigoUsoVehiculo=angular.isUndefined($scope.usoSelected)?null:angular.isUndefined($scope.usoSelected.valor)?null:$scope.usoSelected.valor;
            vehiculo.codigoUsoVehiculo=angular.isUndefined($scope.usoSelected)?null:$scope.usoSelected!=null?$scope.usoSelected:null;
             vehiculo.ConductorUno=angular.isUndefined($scope.conductor1)?null:$scope.conductor1.valor;
             vehiculo.ConductorDos=angular.isUndefined($scope.conductor2)?null:$scope.conductor2.valor;
             vehiculo.codigoTipoVehiculo= angular.isUndefined($scope.codigoTipoVehiculo)?null:$scope.codigoTipoVehiculo;
             vehiculo.marcaModulo=  angular.isUndefined($scope.pathModule)?null:$scope.pathModule.split("marcaModulo=")[1];
            var param = JSON.stringify(vehiculo);
             $scope.cargando=true;
             VehiculoService.guardarPropuestaVehiculo(vehiculo).then(
            //sucess
            function (response) {

                if(!response.data.error){
                    if (clickButton=="S")
                    {
                        var param ={};
                        param.numeroCotizacion=$scope.numeroCotizacion;
                        param.marcaFlota=$scope.subtipo=='Flota'?'S':'N';
                        param.tab=$scope.tab;
                        param.pathModule=$scope.pathModule;
                        PropuestaService.getTabs(param);
                    }
                    else
                    {
                        $scope.cambiarTab=1;
                    }
                   Message.ok(response.data.mensaje);
                }else{
                    $scope.cambiarTab=2; //error
                   Message.error(response.data.mensaje);
                   //
                }
                $scope.cargando=false;
            //error
            }).catch(function(response){
                 $scope.cambiarTab=2; //error
                $scope.cargando=false;
                Message.error(response.data.mensaje);
                
            });




        };




        $scope.buscar = function() {
            $scope.numeroCotizacion = $scope.numeroCotizacionRoot;

           if(!angular.isUndefined($scope.numeroCotizacion)){
              if($scope.numeroCotizacion!=null && $scope.numeroCotizacion!=""){
                  var param ={};
                   param.numeroCotizacion=$scope.numeroCotizacion;
                   param.marcaFlota=$scope.subtipo=='Flota'?'S':'N';
                   param.tab="VEHICULO";
                   $scope.cargando=true;
                   $scope.sinc=0;
                   cantModeloSinc=0;
                   param.pathModule=$scope.pathModule;
                   VehiculoService.getPropuestaVehiculo(param).then(
                    //sucess
                    function (response) {//218631

                        if(!response.data.error){

                           if(response.data.dato.length > 0){
                               $scope.buscarImgInspe=true;
                            /*var param ={};
                            param.numeroCotizacion=$scope.numeroCotizacion;
                            param.marcaFlota=$scope.subtipo=='Flota'?'S':'N';*/
                            VehiculoService.getTabs(param);
                               $scope.bloquearBuscador=true;
                               $scope.cargarPlataforma();
                               $scope.numChapa.valor=response.data.dato[0].NUM_MATRICULA;
                               $scope.numChasis.valor=response.data.dato[0].NUM_CHASSIS;
                               $scope.anhonac.valor=response.data.dato[0].ANIO_NACIONALIZACION;
                               $scope.marcaCeroKm.valor=String(response.data.dato[0].MCA_CERO_KM);
                               $rootScope.nroPropuesta=response.data.dato[0].NUM_PROPUESTA;
                               $scope.codigoTipoVehiculo = response.data.dato[0].COD_TIP_VEHICULO;
                               $scope.setearCantidadModelos(response);

                               if (response.data.dato[0].FEC_CERTIFICADO!= null)
                              {
                                  $scope.fechaCert.valor= $scope.convertirDate(response.data.dato[0].FEC_CERTIFICADO);
                              }
                              else
                              {
                                  $scope.fechaCert.valor=undefined;
                              }
                              if (response.data.dato[0].FEC_ENTREGA != null)
                              {
                                  $scope.fechaEntrega.valor=$scope.convertirDate(response.data.dato[0].FEC_ENTREGA);
                              }
                              else
                              {
                                  $scope.fechaEntrega.valor=undefined;
                              }
                               for(var i=0;i< $scope.listaColores.length;i++){
                                   if ( $scope.listaColores[i].COD_COLOR==response.data.dato[0].COD_COLOR){
                                        $scope.colorSelected ={};
                                        $scope.colorSelected.valor=null;
                                        $scope.colorSelected.valor= $scope.listaColores[i];
                                        break;

                                    }
                                }

                                $scope.conductor1.valor=response.data.dato[0].NOM_CONDUCTOR1;
                                $scope.conductor2.valor=response.data.dato[0].NOM_CONDUCTOR2;
                               $scope.promesaUsos.promise.then(
                                   function () {
                                       $scope.usoSelected = response.data.dato[0].COD_USO_VEHICULO!=null?parseInt(response.data.dato[0].COD_USO_VEHICULO):null;
                                       $scope.incrementarSincronizador($scope.usoSelected);

                                   });
                               $scope.nroInspeccion.valor=response.data.dato[0].NUM_INSPECCION;


                           }else{
                                $scope.limpiarDatos();
                                $scope.cargando=false;

                           }



                        }else{
                           $scope.limpiarDatos();
                           $scope.cargando=false;
                           Message.error(response.data.mensaje);
                           //
                        }

                    //error
                    }).catch(function(response){
                        $scope.cargando=false;
                        Message.error("Ocurrio un error, intente nuevamente");
                        //
                    });
              }

           }
       };
	    $scope.cargarPlataforma = function(){

        var paramPla={};
        paramPla.numeroCotizacion=$scope.numeroCotizacion;
        paramPla.marcaFlota='N';
        paramPla.pathModule=$scope.pathModule;
        CotizacionVehiculoPropuestaService.getPlataforma(paramPla).then(


                        function (response) {
                          if(!response.data.error){
                             if(response.data.dato!=null  )  {

                                $scope.mostrarPlataforma=true;

                                   $scope.veh.plataforma=response.data.dato.mensaje;


                            }

                          }


                        }).catch(function(response){

                            Message.error(response.data.mensaje);

                        });
          };

          $scope.limpiarDatos=function(){
              $scope.nroInspeccion.valor=undefined;
              $scope.numChapa.valor=undefined;
              $scope.numChasis.valor=undefined;
              $scope.anhonac.valor=undefined;
              $scope.marcaCeroKm.valor=undefined;
              $scope.fechaCert.valor=undefined;
              $scope.fechaEntrega.valor=undefined;
              if( !angular.isUndefined($scope.colorSelected)){
                 $scope.colorSelected.valor=undefined;
              }
             if( !angular.isUndefined($scope.usoSelected)){
                $scope.usoSelected=undefined;
              }
              $scope.conductor1.valor=undefined;
              $scope.conductor2.valor=undefined;
              $rootScope.numeroCotizacionRoot=undefined;
              $rootScope.nroPropuesta=undefined;
          };

         $scope.recargar = function() {
          $scope.bloquearBuscador=false;
          $scope.limpiarDatos();

        };
        /**
         * Función creada para el salto de propuesta a cotizacion
         */
        $scope.goToCotizacion = function() {
            var path = $location.$$absUrl;
            var n = path.search("module");
            var url =  path.substring(0 , n);

            if(typeof $scope.numeroCotizacionRoot != 'undefined' && $scope.numeroCotizacionRoot != null){
                var subtipo = 'cotizacion-vehiculo';

                location.href =subtipo+'/'+$scope.numeroCotizacionRoot;

            }
            else
            {
                Message.warning("Debe ingresar un número de cotización");
            }
        };
        $scope.promesaUsos=$q.defer();
        $scope.$watch('codigoTipoVehiculo', function(NewValue, OldValue) {
            if(!angular.isUndefined(NewValue) && NewValue!=null ){
                obtenerUsos();

            }

        },true);
        /**Funcion que se encarga de incrementar la variable de sincronizacion cuando las promesas se resuelven o tienen error*/
        $scope.incrementarSincronizador=function(campo)
        {
            if(campo!=null)
            {
                $scope.sinc++;
            }
        };
        /**Este Watch se dispara cuando las promesas se resuelven o tiene error, y la condicion principal debe ser
         * que el valor del sinc sea mayor a 0, sino ocurre eso es porque hay un error en el buscar o viene vacio el modelo de buscar**/

        $scope.$watch('sinc', function(NewValue, OldValue) {

            if (NewValue==cantModeloSinc && NewValue>0)
            {
                $scope.cargando=false;
                $scope.sinc=0; //cantidad de modelos seteados una vez obtenida la promesa
                cantModeloSinc=0; //cantidad de modelos que necesitan llamadas de servicios
            }


        },true);
        $scope.setearCantidadModelos=function(response)
        {
            if (response.data.dato[0].COD_USO_VEHICULO != null && response.data.dato[0].COD_USO_VEHICULO != "") {

                $scope.valorUso = response.data.dato[0].COD_USO_VEHICULO;
                cantModeloSinc++;
            }
            /**Si no hay datos en el modelo que necesitan promesas entonces se debe de ocultar el cargando*/
            if (cantModeloSinc == 0)
            {
                $scope.cargando = false;
            }
        };
        $scope.$watch('cambiarTab', function(newValue, oldValue) {
            if (newValue!=0)
            {
                if (newValue==1)
                {
                    //hacer el redirect
                    var params={};
                    params.marcaFlota=$scope.subtipo=="Flota"?'S':'N';
                    params.numeroCotizacion=angular.isUndefined($scope.numeroCotizacionRoot)|| $scope.numeroCotizacionRoot==null?"":$scope.numeroCotizacionRoot;
                    params.tab=$rootScope.sigTab;
                    params.pathModule=$scope.pathModule;
                    $scope.service.getCamposEditablesList(params);
                    $timeout($location.url($rootScope.url_destino),1000);
                }
                else
                {
                    newValue=0; //para que vuelva a cambiar e intentar
                }
            }


        },true);
        $scope.$watch('nroInspeccion.valor', function(NewValue, OldValue) {
            if(!angular.isUndefined(NewValue) && NewValue!=null  && NewValue!=""){
                //obtengamos la lista de imagenes
                if ($scope.buscarImgInspe)
                {
                    $scope.obtenerListadoImg(NewValue);
                    $scope.buscarImgInspe=false;
                }

            }
            else
            {
                $scope.showImg=false;
                $scope.imagenesList=[];
                $scope.imagenesLoad=[];
                $scope.buscarImgInspe=false;
            }

        },true);
        $scope.obtenerListadoImg=function(inspeccion)
        {
            var param={};
            param.inspeccion=inspeccion;
            $scope.imagenesList=[];
            $scope.imagenesLoad=[];
            $scope.cargando=true;
            VehiculoService.listadoImagenes(param).then(function(response)
            {
                if (!response.data.error)
                {

                    if (response.data.dato !=null)
                    {
                        if (response.data.dato.length>0)
                        {

                            $scope.imagenesList=response.data.dato;
                            $scope.cargarImagenes(inspeccion, $scope.imagenesList);
                        }
                        else
                        {

                            $scope.cargando=false;
                        }
                    }
                    else
                    {
                        $scope.cargando=false;
                    }
                }
                else
                {
                    $scope.cargando=false;
                    Message.error(response.data.mensaje);
                }
            }).catch(function(error){
                $scope.cargando=false;
                Message.error("Ocurrio un error al intentar recuperar las fotos de inspeccion");
            })
        };
        $scope.cargarImagenes=function(inspeccion,imagenesList)
        {

            for (var i=0; i<imagenesList.length; i++)
            {
                $scope.obtenerImagen(inspeccion,imagenesList[i]);
            }
            $scope.cargando=false;

        };
        $scope.obtenerImagen=function(inspeccion, detalleImg)
        {
            $scope.imagenesLoad=[];
            var params={};
            params.inspeccion=inspeccion;
            params.item=detalleImg.NUM_ITEM;
            VehiculoService.obtenerImagen(params).then(function(response) {
                $scope.showImg=true;
                var nuevaImagen={};
                var nombreFichero=detalleImg.NOM_FICHERO;
                var pos=nombreFichero.toLowerCase().indexOf(".");
                var tipo=nombreFichero.substring(pos+1, nombreFichero.length);
                nuevaImagen.caption=detalleImg.NOM_FICHERO.toLowerCase();
                nuevaImagen.data="data:image/"+tipo+";base64,"+response.data;
                nuevaImagen.tipo=tipo;

                $scope.imagenesLoad.push(nuevaImagen);
                $log.debug($scope.imagenesLoad);
            }).catch(function(error){
                $scope.cargando=false;
                console.log(error);
                Message.error("Ocurrio un error, al intentar obtener una imagen");
            });
        };
        $scope.descargarImgInspeccion=function(file)
        {
            download("data:application/octet-stream;base64,"+file.data.substring(22, file.data.lenght), file.caption , "application/octet-stream;base64");
        }
        $scope.abrirImagen=function(imagen)
        {
            $scope.viewImg=imagen;
           /*var modalOpen= Lightbox.openModal($scope.imagenesLoad, indice);
            modalOpen.opened.then(function() {
                alert("OPENED!");
                $('a:contains("Previous")').text('Anterior');
                $('a:contains("Next")').text('Siguiente');
            });*/
           /* $scope.nameImg=$scope.imagenesLoad[indice].caption;
            $scope.urlImg=$scope.imagenesLoad[indice].url;
          */
            $('#imgModal').modal('show');


        };

        (function initialize() {
            $rootScope.currentPage = 'vehiculo';
            $scope.pathModule = UtilsService.retornarPath($location.path().split("/")[1]);
            $rootScope.tabs = VehiculoService.getTabInicial();
           //$scope.obtenerCamposRequeridos();
            if ($window.sessionStorage["rolesAsignados"]!=undefined && $window.sessionStorage["rolesAsignados"]!=null){
                var listaRoles = $window.sessionStorage["rolesAsignados"].split(",");
                $scope.controlPermisos = listaRoles.indexOf("rol_1")>-1? true:false;
            }

          $scope.bloquearBuscador=false;
        	obtenerColores();

           angular.extend(this, $controller('UtilsCtrl', {
                    "$scope": $scope
            }));


        })();

          if (!angular.isUndefined($scope.numeroCotizacionRoot) && $scope.numeroCotizacionRoot!= null && $scope.numeroCotizacionRoot!=""){
             $scope.buscar();
          }else{
            VehiculoService.goToPropuestaOrigen($scope.pathModule.split("marcaModulo=")[1]);
         }

    }]);
;app.controller('SuplementoAnulacionCtrl', ['$scope', '$controller','$mdDateLocale','SuplementosListServices','$filter','$locale','$location','$routeParams','$log',
    function ($scope, $controller,$mdDateLocale, SuplementosListServices,$filter, $locale, $location,$routeParams, $log ) {

        $scope.numPropuesta=undefined;
        $scope.codigoResponsable=undefined;
        $scope.anulacion={};
        $scope.anulacion.motivo=undefined;
        $scope.anulacion.cobroAnticipado=undefined;
        $scope.anulacion.comentario="";
        $scope.cotizacion=undefined;
        $scope.obtenerMotivos=function(){

            $scope.cargando=true;
              SuplementosListServices.getMotivosAnulacion().then (function (response){
                      if (!response.data.error){
                          $scope.motivos=[];
                          if (response.data.dato!=null && response.data.dato.length>0){
                              $scope.motivos=response.data.dato;
                             $scope.cargando=false;
                          }else{
                              $scope.cargando=false;
                          }   
                     }else{
                          $scope.cargando=false; 
                          Message.error(response.data.mensaje);
                      }
                  });
        };
        $scope.guardarAnulacion=function()
        {
            var datos={};
            datos.motivoAnulacion=$scope.anulacion.motivo;
            datos.comentarioMotivo=$scope.anulacion.comentario;
            datos.numeroPropuesta=$scope.numPropuesta;
            datos.cobroAnticipado=$scope.anulacion.cobroAnticipado;
            datos.numeroCotizacion=$scope.cotizacion;
            $scope.cargando=true;
            SuplementosListServices.guardarAnulacion(datos).then(function(response){
                if(!response.data.error){

                    Message.ok(response.data.mensaje);
                }else{
                    Message.error(response.data.mensaje);
                }
                $scope.cargando=false;
            }).catch(function(response){
                $scope.cargando=false;
                Message.error(response.data.mensaje);
            });
        };
        $scope.emitirAnulacion=function()
        {
            var data ={};
            data.numeroPropuesta=$scope.numPropuesta;
            data.codigoResponsable=$scope.codigoResponsable;
            $scope.cargando=true;
            SuplementosListServices.emitirAnulacionVehiculo(data).then(
                //sucess
                function (response) {

                    if(!response.data.error){

                        Message.ok(response.data.mensaje);
                    }else{
                        Message.error(response.data.mensaje);
                    }
                    $scope.cargando=false;
                    //error
                }).catch(function(response){
                $scope.cargando=false;
                Message.error(response.data.mensaje);
            });

        };
        $scope.datosTomador=function(params){

            $scope.cargando=true;
            SuplementosListServices.getDatosTomador(params).then (function (response){
                if (!response.data.error){

                    $scope.dato=[];
                    if (response.data.dato!=null && response.data.dato.length>0){
                        $scope.dato=response.data.dato;
                        $scope.datosRiesgo.poliza=$scope.dato[0].NUM_POLIZA;
                        $scope.datosRiesgo.tomador=$scope.dato[0].TOMADOR;


                        $scope.cargando=false;
                    }else{
                        $scope.cargando=false;
                    }
                }else{
                    $scope.cargando=false;
                    Message.error(response.data.mensaje);
                }
            });
        };
        $scope.establecerDatosAnulado=function(anulado){
            $scope.anulacion={};
            $scope.anulacion.tomador=anulado.TOMADOR;
            $scope.anulacion.motivo=(anulado.MOTIVO_ANULACION).toString();
            $scope.anulacion.cobroAnticipado=anulado.NUM_COBRO_ANTICIPADO;
            $scope.anulacion.comentario=anulado.TXT_OBS_ANULACION;
            $scope.anulacion.numPoliza=anulado.NUM_POLIZA;
        };
        $scope.recuperaAnulado=function(){
            $scope.cargando=true;
            var param ={};
            param.numeroPropuesta=$scope.numPropuesta;
            SuplementosListServices.getAnulado(param).then(function(response){
                if(!response.data.error){
                    if(response.data.dato!=null){
                        if(response.data.dato.length>0){
                            $scope.establecerDatosAnulado(response.data.dato[0]);
                        }
                    }else{
                        $scope.cargando=false;
                        Message.error(response.data.mensaje);
                    }
                }else{
                    $scope.cargando=false;
                    Message.error(response.data.mensaje);
                }
            });
        };



        (function initialize() {
            $scope.obtenerMotivos();
            $scope.cotizacion = $routeParams.cotizacion;
            $scope.codigoResponsable=sessionStorage.getItem('codigoResponsable');
       //     $scope.datosTomador($scope.cotizacion);
            $scope.numPropuesta=$location.search().propuesta;
            $scope.recuperaAnulado();
            window.sessionStorage.setItem("propuesta_anulacion", $scope.numPropuesta);
        })();

}]) 
;app.controller('SuplementoCambioAutoCtrl', ['$scope', '$controller','$mdDateLocale','SuplementosListServices','$filter','$locale','$location','$routeParams','VehiculoService',
    function ($scope, $controller,$mdDateLocale, SuplementosListServices,$filter, $locale, $location,$routeParams,VehiculoService ) {

        $scope.datosRiesgo={};
       $scope.datosRiesgo.marca="";
       $scope.datosRiesgo.modelo="";
       $scope.datosRiesgo.submodelo="";
       $scope.datosRiesgo.anio="";
       $scope.datosRiesgo.riesgo="";
       $scope.datosRiesgo.ocupantes="";
       $scope.datosRiesgo.sumaAsegurada="";
       $scope.datosRiesgo.esCero="";
       $scope.coloresList=[];
       $scope.datosRiesgo.color="";
       $scope.datosRiesgo.uso="";
       $scope.datosRiesgo.inspeccion="";
       $scope.datosRiesgo.nacionalizacion="";
       $scope.datosRiesgo.chapa="";
       $scope.datosRiesgo.chasis="";
       $scope.datosRiesgo.conductor1="";
       $scope.datosRiesgo.conductor2="";
       $scope.datosRiesgo.codigoTipoVehiculo="";
       $scope.datosRiesgo.fechaEntrega=undefined;
       $scope.datosRiesgo.fechaCertificacion=undefined;
       $scope.datosRiesgo.poliza=undefined;
       $scope.listaUsos=[];
       $scope.numeroCotizacion=undefined;
       $scope.numPropuesta=undefined;
       $scope.datosRiesgo.tomador=undefined;
       
       
        $scope.datosAuto=function(params){

          $scope.cargando=true;
            SuplementosListServices.getDatosVehiculos(params).then (function (response){
                    if (!response.data.error){

                        $scope.dato=[];
                        if (response.data.dato!=null && response.data.dato.length>0){
                            $scope.dato=response.data.dato;
                            $scope.datosRiesgo.marca=$scope.dato[0].MARCA;
                            $scope.datosRiesgo.modelo=$scope.dato[0].MODELO;
                            $scope.datosRiesgo.submodelo=$scope.dato[0].NOM_SUB_MODELO;
                            $scope.datosRiesgo.anio=$scope.dato[0].ANIO_SUB_MODELO;
                            $scope.datosRiesgo.riesgo=1;
                            $scope.datosRiesgo.cobroAnticipado=$scope.dato[0].NRO_COBRO_ANTICIPADO
                            $scope.datosRiesgo.codigoTipoVehiculo=$scope.dato[0].TIPO_VEHICULO;
                            $scope.datosRiesgo.ocupantes=$scope.dato[0].OCUPANTES;
                            $scope.datosRiesgo.sumaAsegurada=$scope.dato[0].SUMA_ASEGURADA;
                            $scope.datosRiesgo.color=parseInt($scope.dato[0].COLOR);
                            $scope.datosRiesgo.uso=parseInt($scope.dato[0].USO);
                            $scope.datosRiesgo.inspeccion=$scope.dato[0].INSPECCION;
                            $scope.datosRiesgo.nacionalizacion=parseInt($scope.dato[0].ANIO_NACIONALIZACION);
                            $scope.datosRiesgo.chapa=$scope.dato[0].CHAPA;
                            $scope.datosRiesgo.chasis=$scope.dato[0].CHASIS;
                            $scope.datosRiesgo.conductor1=$scope.dato[0].CONDUCTOR1;
                            $scope.datosRiesgo.conductor2=$scope.dato[0].CONDUCTOR2;
                            $scope.datosRiesgo.poliza=$scope.dato[0].NUM_POLIZA
                            $scope.datosRiesgo.tomador=$scope.dato[0].TOMADOR;
                            $scope.obtenerUsos();
                            if ($scope.dato[0].FECHA_ENTREGA!=null)
                            {
                                $scope.datosRiesgo.fechaEntrega=$scope.convertirDate($scope.dato[0].FECHA_ENTREGA);
                            }
                            if ($scope.dato[0].FECHA_CERTIFICACION!=null)
                            {
                                $scope.datosRiesgo.fechaCertificacion=$scope.convertirDate($scope.dato[0].FECHA_CERTIFICACION);
                            }

                            if ($scope.dato[0].MCA_O_KM== null)
                            {
                                $scope.datosRiesgo.esCero="N";
                            }
                            else
                            {
                                $scope.datosRiesgo.esCero=$scope.dato[0].MCA_O_KM;
                            }


                           $scope.cargando=false;
                        }else{
                            $scope.cargando=false; 
                        }    
                   }else{
                        $scope.cargando=false; 
                        Message.error(response.data.mensaje);
                    }
                });
        };
        $scope.emitirCambio=function()
        {
            var data ={};
            data.numeroPropuesta=$scope.numPropuesta;
            data.numeroCotizacion=$scope.numeroCotizacion,
            data.codigoResponsable = $scope.responsable;
            var param = JSON.stringify(data);
            $scope.cargando=true;
            SuplementosListServices.emitirCambioVehiculo(param).then(
                //sucess
                function (response) {

                    if(!response.data.error){

                        Message.ok(response.data.mensaje);
                    }else{
                        Message.error(response.data.mensaje);
                    }
                    $scope.cargando=false;
                    //error
                }).catch(function(response){
                $scope.cargando=false;
                Message.error(response.data.mensaje);
            });

        };
        $scope.imprimirPropuesta=function()
        {
            var data={};
            data.numeroCotizacion=$scope.numeroCotizacion;
            $scope.cargando=true;
            SuplementosListServices.imprimirProp(data).then(
                //sucess
                function (response) {
                        var base64str = response.data;
                        var binary = atob(base64str.replace(/\s/g, ''));
                        var len = binary.length;
                        var buffer = new ArrayBuffer(len);
                        var view = new Uint8Array(buffer);
                        for (var i = 0; i < len; i++) {
                        view[i] = binary.charCodeAt(i); 
                        }               
                        var blob = new Blob([view], {
                        type: "application/pdf"
                            });
                        saveAs(blob, "IMPRESION_PROPUESTA.pdf");
                        var url = URL.createObjectURL(blob);
                        Message.ok("Se ejecuto correctamente");
                    $scope.cargando=false;
                    //error
                }).catch(function(response){
                $scope.cargando=false;
                Message.error("Ocurrió un error");
            });

        }
        $scope.guardarCambio=function()
        {
            
            var vehiculo ={};
            vehiculo.numeroRiesgo=$scope.datosRiesgo.riesgo; 
            vehiculo.numeroCotizacion=$scope.numeroCotizacion;  //218631;
            vehiculo.codigoTipoVehiculo=$scope.datosRiesgo.codigoTipoVehiculo;
            vehiculo.numeroInspeccion=$scope.datosRiesgo.inspeccion;
            vehiculo.numeroChassis=$scope.datosRiesgo.chasis;
            vehiculo.anioNacionalizacion=$scope.datosRiesgo.nacionalizacion;
            vehiculo.marcaCeroKm=$scope.datosRiesgo.esCero;
            vehiculo.fechaCertificado=angular.isUndefined($scope.datosRiesgo.fechaCertificacion)?null:moment($scope.datosRiesgo.fechaCertificacion).format("DD/MM/YYYY");
            vehiculo.fechaEntrega=angular.isUndefined($scope.datosRiesgo.fechaEntrega)?null:moment($scope.datosRiesgo.fechaEntrega).format("DD/MM/YYYY");
            vehiculo.codigoColor=$scope.datosRiesgo.color
            vehiculo.codigoUsoVehiculo=$scope.datosRiesgo.uso;
            vehiculo.conductorUno=$scope.datosRiesgo.conductor1;
            vehiculo.conductorDos=$scope.datosRiesgo.conductor2;
            vehiculo.cobroAnticipado=$scope.datosRiesgo.cobroAnticipado;
            vehiculo.numeroMatricula=$scope.datosRiesgo.chapa;
            var param = JSON.stringify(vehiculo);
            $scope.cargando=true;
            VehiculoService.guardarSuplementoVehiculo(vehiculo).then(
                //sucess
                function (response) {

                    if(!response.data.error){

                        Message.ok(response.data.mensaje);
                    }else{
                        Message.error(response.data.mensaje);
                    }
                    $scope.cargando=false;
                    //error
                }).catch(function(response){
                $scope.cargando=false;
                Message.error(response.data.mensaje);
            });
        };
        $scope.obtenerColores=function()
        {
            VehiculoService.obtenerColores().then(function(response){

              if (!response.data.error)
              {
                  var datos=response.data.dato;
                  for (var i=0; i< datos.length;i++)
                  {
                      $scope.coloresList.push(datos[i]);
                  }
              }
              else
              {
                  Message.error(response.data.mensaje);
              }
          });
        };
        $scope.obtenerUsos = function(){
            var params={};
            params.codTipoVehiculo=$scope.datosRiesgo.codigoTipoVehiculo;
            VehiculoService.obtenerUsos(params).then(function(response){
                $scope.listaUsos = response.data.dato;
            }, function(response){
                Message.error("No se pudo obtener los usos de vehiculos");
            });
        };
        (function initialize() {
            $scope.responsable=sessionStorage.getItem('codigoResponsable');
            $scope.numeroCotizacion= $routeParams.cotizacion;
            $scope.datosAuto($scope.numeroCotizacion);
            $scope.obtenerColores();
            $scope.numPropuesta=$location.search().propuesta;
            window.sessionStorage.setItem("propuesta_cambio", $scope.numPropuesta);
            angular.extend(this, $controller('UtilsCtrl', {
                "$scope": $scope
            }));
        })();

}]) 
;app.controller('SuplementoDocumentosCtrl', ['$scope', '$controller','$mdDateLocale','SuplementosListServices','$filter','$locale','$location','$routeParams','DocumentosService','Upload','$rootScope','$route','UtilsService',
    function ($scope, $controller,$mdDateLocale, SuplementosListServices,$filter, $locale, $location,$routeParams,DocumentosService, Upload ,$rootScope,$route,UtilsService) {
        $scope.numeroCotizacion=undefined;
        $scope.habilitarCargaTomador = false;
        $scope.showTomador = false;
        $scope.showCotProp = false;
        $scope.cargando=false;
        $scope.cargaTomador = false;
        $scope.cargaCotPro = false;
        $scope.datosTomador=undefined;
        $scope.path=undefined;
        $scope.adjuntar=false;
        $rootScope.rootPathParent =$route.current.$$route.originalPath;
        $scope.tipoDocumento=undefined;
        $scope.esAnulacion=false;
        $scope.numeroCotizacionRoot=undefined;
        $scope.listaDocumentosCotizacionPropuesta=[];
        $scope.listaDocumentosTomadorAsegurado = [];
        $rootScope.listaDocumentosCotizacionPropuestaTemp = [];
        $rootScope.listaDocumentosTomadorAseguradoTemp = [];


        
        $scope.listarTipoDocumentos= function () {  
            var param = {};
            param.pathModule =$scope.pathModule;
            DocumentosService.listarTipoDocumentos(param).then(function(response){
                $scope.listaTipoDocumentos = response.data.dato;    
            }, function(response){
                Message.error("No se pudo obtener la lista de los tipos de documentos");
            });
        };
        
        $scope.descargarCotProp= function (file) {  
            
            download("data:application/octet-stream;base64,"+file.BASE64.substring(22, file.BASE64.lenght), file.NOM_FICHERO , "application/octet-stream;base64"); 
        };

        $scope.descargarTomador=function(file){
            download("data:application/octet-stream;base64,"+file.BASE64.substring(22, file.BASE64.lenght), file.NOM_FICHERO , "application/octet-stream;base64"); 
        };
        $scope.obtenerDocumentosCotizacionPropuesta = function () {
            if(typeof $scope.numeroCotizacion != 'undefined' && $scope.numeroCotizacionRoot != null){               
                $scope.cargaCotPro = false;  
                DocumentosService.obtenerDocumentosCotizacionPropuesta($scope.numeroCotizacionRoot, 'N').then(function(response){
                    $scope.listaDocumentosCotizacionPropuestaTemp = response.data.dato;
                    if(typeof $scope.listaDocumentosCotizacionPropuestaTemp != 'undefined' && $scope.listaDocumentosCotizacionPropuestaTemp.length > 0){
                            
                    for(var doc in $scope.listaDocumentosCotizacionPropuestaTemp){
                        DocumentosService.descargarCotProp($scope.numeroCotizacionRoot, $scope.listaDocumentosCotizacionPropuestaTemp[doc].NUM_ITEM, doc , $scope.listaDocumentosCotizacionPropuestaTemp[doc]) ;
                    }
                    $scope.listaDocumentosCotizacionPropuesta = $scope.listaDocumentosCotizacionPropuestaTemp;
                        $scope.showCotProp = true;
                    }else{
                        $scope.showCotProp = false;

                    }
                    $scope.cargaCotPro = true;
                    $scope.verificarCarga();

                }, function(response){
                    $scope.cargaCotPro = true;
                    $scope.verificarCarga();
                    Message.error("No se pudo obtener los documentos de Cotización/Propuesta");
                });
            }
            else
            {
                $scope.cargando=false;
            }
        };
        $scope.obtenerDocumentosTomadorAsegurado= function () {  
            $scope.cargaTomador = false;               
            $scope.cargando=true;
            if($scope.datosTomador!=null){
                DocumentosService.obtenerDocumentosTomadorAsegurado($scope.datosTomador.TIP_DOCUM, $scope.datosTomador.COD_DOCUM,  $scope.pathModule).then(function(response){
                    $scope.listaDocumentosTomadorAseguradoTemp = response.data.dato; 
                    $scope.cargando=false;
                    if(typeof $scope.listaDocumentosTomadorAseguradoTemp != 'undefined' && $scope.listaDocumentosTomadorAseguradoTemp.length > 0){
                        $scope.showTomador = true;
                        $scope.habilitarCargaTomador = true;
                        for(var docTom in $scope.listaDocumentosTomadorAseguradoTemp){
                            DocumentosService.descargarTomador($scope.datosTomador.TIP_DOCUM, $scope.datosTomador.COD_DOCUM, $scope.listaDocumentosTomadorAseguradoTemp[docTom].NUM_ITEM, docTom , $scope.listaDocumentosTomadorAseguradoTemp[docTom]) ;
                        }
                        $scope.listaDocumentosTomadorAsegurado = $scope.listaDocumentosTomadorAseguradoTemp;
                        
                    }else{
                        $scope.showTomador = false;
                    }
                    $scope.cargaTomador = true;
                    $scope.verificarCarga();

            }, function(response){
                $scope.cargaTomador = true;
                $scope.cargando=false;
                $scope.verificarCarga();
                Message.error("No se pudo obtener los documentos de Cotización/Propuesta");
            });
            
        }else{
                Message.error("Esta cotización aun no tiene datos terceros");
                $scope.cargando=false;
                $scope.adjuntar=true;
            }
        };

        $scope.verificarCarga = function(){                
            $scope.cargando=true;
            if($scope.cargaTomador && $scope.cargaCotPro){                
                $scope.cargando=false;
            }
        };
      
        $scope.mostrarArchivo = function(file){  
            if(!angular.isUndefined(file)){
                if (file.NOM_FICHERO.indexOf("png")!=-1 || file.NOM_FICHERO.indexOf("jpg")!=-1)
                    {
                        return true;
                    }
                return false;
            }
        };
        $scope.obtenerIcono = function(file){
            if(!angular.isUndefined(file)){
                switch(true){
                    case file.NOM_FICHERO.indexOf("xlsx")!=-1:
                    return 'xlsx_logo.png';
    
                    case file.NOM_FICHERO.indexOf("pdf")!=-1:
                    return 'pdf_logo.png';
                }

            }
           
        };
         /**
         * UPLOAD DE ARCHIVOS PARA COTIZACION / PROPUESTA
         */
        $scope.$watch('fileCotizador', function() {
            var file = $scope.fileCotizador;
            if (!file) {
              return;
            }
            
            if($scope.tipoDocumento != null && typeof $scope.tipoDocumento != 'undefined'){
                                   
                    Upload.upload({
                        url: App.URL_BASE+ 'documentos/propuesta/subiradjunto?numeroPropuesta=0&numeroCotizacion='+ $scope.numeroCotizacion+'&tipoDocumento='+$scope.tipoDocumento,
                        file: file
                    }).success(function(data, status, headers, config) {
                      
                        $scope.obtenerDocumentosCotizacionPropuesta();
                        $scope.tipoDocumento = null;
                    }).error(function(data, status, headers, config) {
                        Message.error("Error al subir el archivo");
                    })
                
            }else{
                Message.warning("Debe seleccionar un tipo de documento");
            }
          });
          /**
         * UPLOAD DE ARCHIVOS PARA TOMADOR
         */
        $scope.$watch('file', function() {
            var file = $scope.file;
            if (!file) {
              return;
            }
            if($scope.habilitarCargaTomador){
                Upload.upload({
                  url: App.URL_BASE+ 'documentos/terceros/subiradjunto?tipoDocumento='+$scope.datosTomador.TIP_DOCUM+'&codigoDocumento='+$scope.datosTomador.COD_DOCUM,
                  file: file
                }).success(function(data, status, headers, config) {
                    var param ={};
                    param.numeroCotizacion=$scope.numeroCotizacionRoot;  
                    param.marcaFlota=$scope.subtipo=='Flota'?'S':'N';
                  //  DocumentosService.getTabs(param);
                    $scope.obtenerDocumentosTomadorAsegurado();
                }).error(function(data, status, headers, config) {
                    Message.error("Error al subir el archivo");
                })
            }else{
                Message.warning("No se cuentan con datos del tomador");
            }
          });

        $scope.submit = function() {
        if ($scope.file) {
            $scope.uploadFileTomador($scope.file);
        }
        };
        (function initialize()
        {
            $scope.pathModule = UtilsService.retornarPath($location.path().split("/")[1]);
            $scope.numeroCotizacion=$routeParams.cotizacion;
            $scope.numeroCotizacionRoot=$scope.numeroCotizacion;

            if(typeof $scope.numeroCotizacion != 'undefined' && $scope.numeroCotizacion != null){  
                if(sessionStorage.getItem('datosTomador')){
                    $scope.datosTomador=JSON.parse(sessionStorage.getItem('datosTomador'));
                    $scope.habilitarCargaTomador = true;
                    $scope.cargando=false;
                }else{
                    $scope.cargaTomador = true;
                    $scope.verificarCarga();
                    Message.error("No se pudo obtener los datos del Tomador");

                }
            }
            $scope.obtenerDocumentosCotizacionPropuesta();
            $scope.obtenerDocumentosTomadorAsegurado();
           // $scope.obtenerTomadorSuplemento();
            $scope.listarTipoDocumentos();
            $scope.path=$location.path();
            if ($scope.path.indexOf("anulacion")>=0)
            {
                $scope.esAnulacion=true;
                $scope.propuesta_anulacion=sessionStorage.getItem("propuesta_anulacion");
            }
            else
            {
                $scope.propuesta_cambio=sessionStorage.getItem("propuesta_cambio");
            }
            
        })();
    }
]);
;app.controller('SuplementoHojasAnexasCtrl', ['$scope', '$controller','$mdDateLocale','SuplementosListServices','$filter','$locale','$location','$routeParams','HojaAnexaService','UtilsService',
    function ($scope, $controller,$mdDateLocale, SuplementosListServices,$filter, $locale, $location,$routeParams,HojaAnexaService ,UtilsService) {
        $scope.panel1=false;
        $scope.panel2=false;
        $scope.mostrarDPrevios=false;
        $scope.numeroCotizacion=undefined;
        $scope.hojasAnexas={};
        $scope.hojasAnexas.accesoriosDetalle=undefined;
        $scope.hojasAnexas.danhoDetalle=undefined;
        $scope.submitted=false;
        $scope.cargando=false;
        $scope.obtenerHojasAnexas = function () {
            if(typeof $scope.numeroCotizacion != 'undefined' && $scope.numeroCotizacion != null){

                HojaAnexaService.obtenerHojasAnexas($scope.numeroCotizacion,$scope.pathModule).then(function(response){
                    if (!response.data.error)
                    {
                        //PROCESAR LA RESPUESTA DEL SERVICIO DE HOJAS ANEXAS
                        var accesorios = response.data.dato.listaAccesorios;
                        var unformat = "";
                        var format = "";
                        for (var i in accesorios)
                        {
                            format += accesorios[i] +'\n';
                            unformat += accesorios[i];
                        }
                        $scope.hojasAnexas.accesoriosDetalleFormat = format;
                        $scope.hojasAnexas.accesoriosDetalle = unformat;


                        var daniosPrevios = response.data.dato.listaDaniosPrevios;
                        var unformat = "";
                        var format = "";
                        for (var i in daniosPrevios)
                        {
                            format += daniosPrevios[i] +'\n';
                            unformat += daniosPrevios[i];
                        }
                        $scope.hojasAnexas.danhoDetalleFormat = format;
                        $scope.hojasAnexas.danhoDetalle = unformat;

                    }
                    else
                    {
                        Message.info(response.data.mensaje);

                    }


                }, function(response){
                    Message.error("No se pudo obtener los comentarios");

                });

            }
        }


        $scope.guardarHojasAnexas = function(){
            
            $scope.submitted=true;
            if (!angular.isUndefined($scope.hojasAnexas.accesoriosDetalle) && !angular.isUndefined($scope.hojasAnexas.danhoDetalle))
            { 
                var param = {
                    "numeroCotizacion": $scope.numeroCotizacion,
                    "accesorios": $scope.hojasAnexas.accesoriosDetalle,
                    "daniosPrevios": $scope.hojasAnexas.danhoDetalle
                }
                $scope.cargando=true;
                HojaAnexaService.guardarHojasAnexas(param).then(function (response) {
                    $scope.submitted=false;

                    //PROCESAR LA RESPUESTA DEL SERVICIO DE HOJAS ANEXAS
                    var accesorios = response.data.dato.listaAccesorios;
                    var unformat = "";
                    var format = "";
                    for (var i in accesorios) {
                        format += accesorios[i] + '\n';
                        unformat += accesorios[i];
                    }
                    $scope.hojasAnexas.accesoriosDetalleFormat = format;
                    $scope.hojasAnexas.accesoriosDetalle = unformat;


                    var daniosPrevios = response.data.dato.listaDaniosPrevios;
                    var unformat = "";
                    var format = "";
                    for (var i in daniosPrevios) {
                        format += daniosPrevios[i] + '\n';
                        unformat += daniosPrevios[i];
                    }
                    $scope.hojasAnexas.danhoDetalleFormat = format;
                    $scope.hojasAnexas.danhoDetalle = unformat;
                    $scope.cargando=false;
                }, function (response) {
                    $scope.cargando=false;
                    Message.error("No se pudo guardar el comentario");
                });

            }
            else
            {
                Message.error("Faltan campos que tienen que ser completados");//faltan campos que tienen que ser completados

            }

        };
        $scope.limpiarDatos = function() {
            $scope.hojasAnexas.accesoriosDetalle=undefined;
            $scope.hojasAnexas.danhoDetalle=undefined;
            $scope.hojasAnexas.accesoriosDetalleFormat=undefined;
            $scope.hojasAnexas.danhoDetalleFormat=undefined;
        };


        $scope.recargar = function() {
            $scope.limpiarDatos();

        };
        (function initialize()
        {
            $scope.pathModule = UtilsService.retornarPath($location.path().split("/")[1]);
            $scope.numeroCotizacion=$routeParams.cotizacion;
            $scope.obtenerHojasAnexas();
            $scope.propuesta=sessionStorage.getItem("propuesta_cambio");
        })();

    }
]);
;app.controller('SuplementoListCtrl', ['$scope', '$controller','$mdDateLocale','SuplementosListServices','$filter','$locale','$location',
    function ($scope, $controller,$mdDateLocale, SuplementosListServices,$filter, $locale, $location ) {
        $locale.NUMBER_FORMATS.GROUP_SEP = '.';
        $locale.NUMBER_FORMATS.DECIMAL_SEP=',';
        $scope.obtenerSuplementos=function(){

          $scope.cargando=true;
            SuplementosListServices.getSuplementosList().then (function (response){
                    if (!response.data.error){
                     
                        $scope.suplementos=[];
                        if (response.data.dato!=null && response.data.dato.length>0){
                            $scope.suplementos=response.data.dato;
                           $scope.cargando=false;
                        }else{
                            $scope.cargando=false;
                        }   
                   }else{
                        $scope.cargando=false; 
                        Message.error(response.data.mensaje);
                    }
                }) 
        };  

        $scope.cambiarVehiculo=function(i){
            var datosTomador={};
            datosTomador.TIP_DOCUM=$scope.suplementos[i].TIP_DOCUM_TOMADOR;
            datosTomador.COD_DOCUM=$scope.suplementos[i].COD_DOCUM_TOMADOR;
            sessionStorage.setItem('datosTomador',JSON.stringify(datosTomador));
            sessionStorage.setItem('codigoResponsable',$scope.suplementos[i].RESPONSABLE);
            $location.path('suplemento/'+$scope.suplementos[i].NUM_COTIZACION+'/cambiar-auto').search({propuesta:$scope.suplementos[i].NUM_PROPUESTA});
        };

        $scope.anulacion=function(i){
            sessionStorage.setItem('codigoResponsable',$scope.suplementos[i].RESPONSABLE);
            $location.path('suplemento/'+$scope.suplementos[i].NUM_COTIZACION+'/anulacion').search({propuesta:$scope.suplementos[i].NUM_PROPUESTA});
        };


        (function initialize() {
            $scope.obtenerSuplementos();
            window.sessionStorage.removeItem("propuesta_cambio");
            window.sessionStorage.removeItem("propuesta_anulacion");
        })();

}]) ;app.controller('BuscadorCotizacionCtrl', ['$scope', 'BuscadorCotizacionService', '$controller', '$rootScope','$mdDialog','$location','$log',
    function ($scope, BuscadorCotizacionService, $controller, $rootScope, $mdDialog, $location, $log) {



        /**
         * Service utilizdo para recuperar los datos y realizar las operaciones.
         * @field
         * @type {Object}
         */


        $scope.titulo="Búsqueda de cotizaciones y propuestas";


        $scope.datos={};
        $scope.datos.numeroCotizacion=undefined;
        $scope.datos.numeroCotizacionInt=undefined;
        $scope.datos.idMarca=undefined;
        $scope.datos.chasis=undefined;
        $scope.datos.nombreAsegurado=undefined;
        $scope.datos.apellidoAsegurado=undefined;
        $scope.datos.apellidoAsegurado2=undefined;
        $scope.datos.tipoDocumentoAsegurado =undefined;
        $scope.datos.documentoAsegurado=undefined;
        $scope.datos.nombreTomador=undefined;
        $scope.datos.apellidoTomador=undefined;
        $scope.datos.apellidoTomador2=undefined;
        $scope.datos.documentoTomador=undefined;
        $scope.datos.tipoDocumentoTomador =undefined;
        $scope.datos.numeroPropuesta=undefined;
        $scope.datos.numeroSolicitud=undefined;
       
        $scope.datos.modeloId=undefined;
        $scope.datos.subModeloId=undefined;
        $scope.datos.anho=undefined;
        $scope.datos.numeroMotor=undefined;
        $scope.datos.numeroChapa=undefined;
        $scope.subtipo=undefined;

        $scope.datosBuscador={};
        $scope.datosBuscador.numeroCotizacion= $rootScope.codCoti;
        $scope.datosBuscador.numeroPropuesta=4;
        $scope.datosBuscador.numeroCotizacionInt=0;
        $scope.datosBuscador.nombreTomador=" ";
        $scope.datosBuscador.codigoMarca=3;
        $scope.datosBuscador.codigoSubmodelo=3
        $scope.datosBuscador.subModelo=1;
        $scope.datosBuscador.codigoAnioSubmodelo=1;
        $scope.datosBuscador.numeroChasis="456";
        $scope.datosBuscador.numeroChapa="456";
        $scope.datosBuscador.tipoDocumentoTomador =1;
        $scope.datosBuscador.tipoDocumentoAsegurado =1;
        $scope.datosBuscador.codigoDocumentoAseg =1;
        $scope.sinResultados=false;


        $scope.listaTipoDocumentoAsegurado = [{id: 1,tipoDocumento: "CRP"},{id: 2, tipoDocumento: "CRC"},{id: 3, tipoDocumento: "RUC"},{id: 4, tipoDocumento: "CIP"}];
        $scope.listaTipoDocumentoTomador = [{id: 1,tipoDocumento: "CRP"},{id: 2, tipoDocumento: "CRC"},{id: 3, tipoDocumento: "RUC"},{id: 4, tipoDocumento: "CIP"}];

        $scope.listadoMarcas = [];
        $scope.listaSubModelos =[];
        $scope.years = [];

        $scope.listaModelos =[];

        $scope.itemsByPage=5;

        $scope.rowCollection = [];
         


        $scope.buscarCotizacion = function() {
             $scope.cargando=true;//218631  218631
                if ($scope.subtipo=="Vehiculo")
                {
                    var  datos={};
                    datos.numeroCotizacion=angular.isUndefined($scope.datos.numeroCotizacion) ?"": $scope.datos.numeroCotizacion;
                    datos.numeroPropuesta=angular.isUndefined($scope.datos.numeroPropuesta)?"":$scope.datos.numeroPropuesta;
                    datos.numeroCotizacionInterno=angular.isUndefined($scope.datos.numeroCotizacionInt)?"":$scope.datos.numeroCotizacionInt;
                    datos.nombreTomador=angular.isUndefined($scope.datos.nombreTomador)?"":$scope.datos.nombreTomador;
                    datos.codigoMarca=angular.isUndefined($scope.datos.idMarca)?"":$scope.datos.idMarca;
                    datos.codigoModelo=angular.isUndefined($scope.datos.modeloId)?"":$scope.datos.modeloId;
                    datos.codigoSubmodelo=angular.isUndefined($scope.datos.subModeloId)?"":$scope.datos.subModeloId;
                    datos.codigoAnioSubmodelo=angular.isUndefined($scope.datos.anho)?"":$scope.datos.anho;
                    datos.numeroChasis=angular.isUndefined($scope.datos.chasis)?"":$scope.datos.chasis;
                    datos.numeroChapa=angular.isUndefined($scope.datos.numeroChapa)?"":$scope.datos.numeroChapa;
                    datos.tipoDocumentoTomador=angular.isUndefined($scope.datos.tipoDocumentoTomador)?"":$scope.datos.tipoDocumentoTomador;
                    datos.codigoDocumentoTomador=angular.isUndefined($scope.datos.documentoTomador)?"":$scope.datos.documentoTomador;
                    datos.tipoDocumentoAseg=angular.isUndefined($scope.datos.tipoDocumentoAsegurado)?"":$scope.datos.tipoDocumentoAsegurado;//angular.isUndefined()?null:;
                    datos.codigoDocumentoAseg=angular.isUndefined($scope.datos.documentoAsegurado)?"":$scope.datos.documentoAsegurado;//angular.isUndefined()?null:;
                    datos.nombreAsegurado=angular.isUndefined($scope.datos.nombreAsegurado)?"":$scope.datos.nombreAsegurado;
                    BuscadorCotizacionService.getCotizacion(datos).then(
                        //success
                        function (response) {
                            $scope.rowCollection=[];
                            if (!response.data.error)
                            {

                                if (response.data.dato!=null && response.data.dato.length >0)
                                {
                                    $scope.sinResultados=false;

                                    for(var i=0; i<response.data.dato.length; i++)
                                    {
                                        var objeto ={
                                            numeroCotizacion :  response.data.dato[i].NUM_COTIZACION,
                                            numeroPropuesta:response.data.dato[i].NUM_PROPUESTA,
                                            riesgo : response.data.dato[i].RIESGO,
                                            docTomador : response.data.dato[i].DOC_TOMADOR? response.data.dato[i].DOC_TOMADOR:"",
                                            nombretomador : response.data.dato[i].NOM_TOMADOR? response.data.dato[i].NOM_TOMADOR:"",
                                            docAsegurado : response.data.dato[i].DOC_ASEGURADO? response.data.dato[i].DOC_ASEGURADO:"",
                                            nombreAsegurado : response.data.dato[i].NOM_ASEGURADO? response.data.dato[i].NOM_ASEGURADO:""

                                        };
                                        $scope.rowCollection.push(objeto);

                                    }


                                }
                                else
                                {
                                    $scope.sinResultados=true;
                                }

                                $scope.cargando=false;
                            }
                            else
                            {
                                $scope.cargando=false;
                                //mostrar que hubo un error
                                Message.error(response.data.mensaje);
                            }
                        }).catch(function(response){
                        $scope.cargando=false;
                        Message.error("Ocurrio un error al buscar");
                    });
                }
                else
                {
                    var  datos={};
                    datos.numeroCotizacion=angular.isUndefined($scope.datos.numeroCotizacion) ?"": $scope.datos.numeroCotizacion;
                    datos.numeroPropuesta=angular.isUndefined($scope.datos.numeroPropuesta)?"":$scope.datos.numeroPropuesta;
                    datos.tipoDocumentoTomador=angular.isUndefined($scope.datos.tipoDocumentoTomador)?"":$scope.datos.tipoDocumentoTomador;
                    datos.codigoDocumentoTomador=angular.isUndefined($scope.datos.documentoTomador)?"":$scope.datos.documentoTomador;
                    datos.nombre=angular.isUndefined($scope.datos.nombreTomador)?"":$scope.datos.nombreTomador;
                    datos.primerApellido=angular.isUndefined($scope.datos.apellidoAsegurado)?"":$scope.datos.apellidoTomador;
                    datos.segundoApellido=angular.isUndefined($scope.datos.apellidoAsegurado2)?"":$scope.datos.apellidoTomador2;
                    datos.numeroPoliza =angular.isUndefined($scope.datos.numeroPoliza)?"":$scope.datos.numeroPoliza;

                   if ($scope.subtipo=="Flota"){
                       BuscadorCotizacionService.getCotizacionFlota(datos).then(
                        //success
                        function (response) {
                            $scope.rowCollection=[];
                            if (!response.data.error)
                            {

                                if (response.data.dato!=null && response.data.dato.length >0)
                                {
                                    $scope.sinResultados=false;

                                    for(var i=0; i<response.data.dato.length; i++)
                                    {
                                        var objeto ={
                                            numeroCotizacion :  response.data.dato[i].NUM_COTIZACION,
                                            numeroPropuesta:response.data.dato[i].NUM_PROPUESTA,
                                            riesgo : response.data.dato[i].RIESGO,
                                            docTomador : response.data.dato[i].COD_DOCUM && response.data.dato[i].TIP_DOCUM? response.data.dato[i].TIP_DOCUM+"-"+response.data.dato[i].COD_DOCUM:"",
                                            nombretomador : response.data.dato[i].NOM_TOMADOR? response.data.dato[i].NOM_TOMADOR:"",
                                            docAsegurado : response.data.dato[i].DOC_ASEGURADO? response.data.dato[i].DOC_ASEGURADO:"",
                                            nombreAsegurado : response.data.dato[i].NOM_ASEGURADO? response.data.dato[i].NOM_ASEGURADO:"",
                                            producto: response.data.dato[i].PRODUCTO?response.data.dato[i].PRODUCTO:"",
                                            formaPago: response.data.dato[i].FORMA_PAGO?response.data.dato[i].FORMA_PAGO:"",
                                            numPoliza: response.data.dato[i].NUM_POLIZA?response.data.dato[i].NUM_POLIZA:""

                                        };
                                        $scope.rowCollection.push(objeto);

                                    }


                                }
                                else
                                {
                                    $scope.sinResultados=true;
                                }

                                $scope.cargando=false;
                            }
                            else
                            {
                                $scope.cargando=false;
                                //mostrar que hubo un error
                                Message.error(response.data.mensaje);
                            }
                        }).catch(function(response){
                        $scope.cargando=false;
                        Message.error("Ocurrio un error al buscar");
                    });

                   } else if($scope.subtipo=="Hogar"){

                    BuscadorCotizacionService.getCotizacionHogar(datos).then(
                        //success
                        function (response) {
                            $scope.rowCollection=[];
                            if (!response.data.error)
                            {

                                if (response.data.dato!=null && response.data.dato.length >0)
                                {
                                    $scope.sinResultados=false;

                                    for(var i=0; i<response.data.dato.length; i++)
                                    {
                                        var objeto ={
                                            numeroCotizacion :  response.data.dato[i].numeroCotizacion,
                                            numeroPropuesta:response.data.dato[i].numeroPropuesta,
                                            riesgo : response.data.dato[i].RIESGO,
                                            docTomador : response.data.dato[i].documentoTomador ? response.data.dato[i].documentoTomador :"",
                                            nombretomador : response.data.dato[i].nombreTomador? response.data.dato[i].nombreTomador:"",
                                            docAsegurado : response.data.dato[i].DOC_ASEGURADO? response.data.dato[i].DOC_ASEGURADO:"",
                                            nombreAsegurado : response.data.dato[i].NOM_ASEGURADO? response.data.dato[i].NOM_ASEGURADO:"",
                                            producto: response.data.dato[i].producto?response.data.dato[i].producto:"",
                                            formaPago: response.data.dato[i].formaPago?response.data.dato[i].formaPago:"",
                                            numPoliza: response.data.dato[i].NUM_POLIZA?response.data.dato[i].NUM_POLIZA:""

                                        };
                                        $scope.rowCollection.push(objeto);

                                    }


                                }
                                else
                                {
                                    $scope.sinResultados=true;
                                }

                                $scope.cargando=false;
                            }
                            else
                            {
                                $scope.cargando=false;
                                //mostrar que hubo un error
                                Message.error(response.data.mensaje);
                            }
                        }).catch(function(response){
                        $scope.cargando=false;
                        Message.error("Ocurrio un error al buscar");
                    });
                   }else if($scope.subtipo=="Multiriesgo"){
                       BuscadorCotizacionService.getCotizacionMultiriesgoAvanzado(datos).then(
                        //success
                        function (response) {
                            $scope.rowCollection=[];
                            if (!response.data.error)
                            {

                                if (response.data.dato!=null && response.data.dato.length >0)
                                {
                                    $scope.sinResultados=false;

                                    for(var i=0; i<response.data.dato.length; i++)
                                    {
                                        var objeto ={
                                            numeroCotizacion :  response.data.dato[i].numeroCotizacion,
                                            numeroPropuesta:response.data.dato[i].numeroPropuesta,
                                            riesgo : response.data.dato[i].RIESGO,
                                            docTomador : response.data.dato[i].documentoTomador ? response.data.dato[i].documentoTomador :"",
                                            nombretomador : response.data.dato[i].nombreTomador? response.data.dato[i].nombreTomador:"",
                                            docAsegurado : response.data.dato[i].DOC_ASEGURADO? response.data.dato[i].DOC_ASEGURADO:"",
                                            nombreAsegurado : response.data.dato[i].NOM_ASEGURADO? response.data.dato[i].NOM_ASEGURADO:"",
                                            producto: response.data.dato[i].producto?response.data.dato[i].producto:"",
                                            formaPago: response.data.dato[i].formaPago?response.data.dato[i].formaPago:"",
                                            numPoliza: response.data.dato[i].NUM_POLIZA?response.data.dato[i].NUM_POLIZA:""

                                        };
                                        $scope.rowCollection.push(objeto);

                                    }


                                }
                                else
                                {
                                    $scope.sinResultados=true;
                                }

                                $scope.cargando=false;
                            }
                            else
                            {
                                $scope.cargando=false;
                                //mostrar que hubo un error
                                Message.error(response.data.mensaje);
                            }
                        }).catch(function(response){
                        $scope.cargando=false;
                        Message.error("Ocurrio un error al buscar");
                    });




                   }
                   

                    





                }


             
             
        };



        $scope.$watch('datos.idMarca', function(NewValue, OldValue) {
            if(!angular.isUndefined(NewValue)){
                $scope.listaModelos =[];
                $scope.listaSubModelos =[];
                $scope.years =[];
                var param = {}
                param.codigoMarca=$scope.datos.idMarca;
                param.esNuevo='S';
                BuscadorCotizacionService.getModelos(param).then(
                    //success
                    function(response){
                        for(var i=0; i<response.data.dato.length; i++){
                            var obj = {
                                id:response.data.dato[i].COD_MODELO,
                                nombreModelo:response.data.dato[i].NOM_MODELO
                            };
                            $scope.listaModelos.push(obj);
                        }
                        // promesaModelo.resolve();

                    },
                    //error
                    function(response){
                        // promesaModelo.reject(response);
                        Message.error("No se pudo obtener la lista de modelos");

                    }
                );

            }else{
                $scope.listaModelos =[];
                $scope.listaSubModelos =[];
                $scope.years =[];
            }

        },true);

        $scope.$watch('datos.modeloId', function(NewValue, OldValue) {
            if(!angular.isUndefined(NewValue)){
                $scope.listaSubModelos =[];
                $scope.years =[];
                var param = {}
                param.codigoMarca=$scope.datos.idMarca;
                param.esNuevo='S';
                param.codigoModelo=$scope.datos.modeloId;
                BuscadorCotizacionService.getSubModelos(param).then(
                    //success
                    function(response){
                        for(var i=0; i<response.data.dato.length; i++){
                            var obj = {
                                id:response.data.dato[i].COD_SUB_MODELO,
                                nombreSubModelo:response.data.dato[i].NOM_SUB_MODELO
                            };
                            $scope.listaSubModelos.push(obj);
                        }
                        // promesaModelo.resolve();

                    },
                    //error
                    function(response){
                        // promesaModelo.reject(response);
                        Message.error("No se pudo obtener la lista de sub modelos");
                    }
                );

            }else{
                $scope.listaSubModelos =[];
                $scope.years =[];
            }

        },true);

        $scope.$watch('datos.subModeloId', function(NewValue, OldValue) {
            if(!angular.isUndefined(NewValue)){

                $scope.years =[];
                var param ={};
                param.codigoMarca=$scope.datos.idMarca;
                param.esNuevo='S';
                param.codigoModelo=$scope.datos.modeloId;
                param.codigoSubModelo=$scope.datos.subModeloId;
                param.codigoMoneda= $rootScope.monedaAbuscar;
                BuscadorCotizacionService.getAnhosSubModelos(param).then(
                    //success
                    function(response){
                        for(var i=0; i<response.data.dato.length; i++){
                            var obj = {
                                id:response.data.dato[i].ANIO_SUB_MODELO,
                                value:response.data.dato[i].ANIO_SUB_MODELO
                            };
                            $scope.years.push(obj);
                        }
                        

                    },
                    //error
                    function(response){
                        
                        Message.error("No se pudo obtener la lista de anhos sub modelos");
                    }
                );

            }else{

                $scope.years =[];
            }

        },true);


        $scope.cargarMarcas = function() {

            var parametros = {};


            BuscadorCotizacionService.getMarcas(parametros).then(

                function (response) {

                    for(var i=0; i<response.data.dato.length; i++){
                        var obj = {
                            id:response.data.dato[i].COD_MARCA,
                            nombreMarca:response.data.dato[i].NOM_MARCA
                        };
                        $scope.listadoMarcas.push(obj);

                    }
                  

            },
                function(response){
                Message.error("No se pudo obtener las marcas");

            });

        };


        (function initialize() {

            var path=$location.$$path;
            if (path.indexOf("flota")>=0) {
                $scope.subtipo="Flota";
            }
            else if(path.indexOf("vehiculo")>=0){
                $scope.subtipo="Vehiculo";
            }else if(path.indexOf("hogar")>=0){
                $scope.subtipo="Hogar";
            }else if (path.indexOf("multiriesgo")>=0){
                 $scope.subtipo="Multiriesgo";

            }
           if(!angular.isUndefined($rootScope.codCoti) && $rootScope.codCoti!=null){

                 $scope.datos.numeroCotizacion = $rootScope.codCoti;

            }

            if($rootScope.mostrarBuscadorCotizacion==true){
                $scope.mostrarDatosBuscadorCotizacion=true;
            }else{
                $scope.mostrarDatosBuscadorCotizacion=false;
            }

           // $scope.buscarCotizacion();
            // se hereda del controller base
            angular.extend(this, $controller('BaseListCtrl', {
                "$scope": $scope
            }));

           $scope.cargarMarcas();
            if(  !angular.isUndefined($rootScope.codCoti) && $rootScope.codCoti!=null    ){
                $scope.datos.numeroCotizacion = $rootScope.codCoti;
            }


        })();

        $scope.hide = function() {
            $mdDialog.hide();
        };

        $scope.cancelar = function() {
            $mdDialog.cancel();
        };

        $scope.answer = function(answer) {
            $mdDialog.hide(answer);
        };
    }

    
]);


;app.controller('BuscadorOrdenesComprasCtrl', ['$scope', 'OrdenesComprasService', '$controller', '$location', '$mdDialog',
    function ($scope, service, $controller, $location, $mdDialog ) {



        /**
         * Service utilizdo para recuperar los datos y realizar las operaciones.
         * @field
         * @type {Object}
         */
        $scope.service = service;

        $scope.uri = "/ordenes-compras/";
        $scope.nombre= 'OrdenesCompras';

        /**
         * Configuraciones de la cabecera de la grilla.
         * @private
         * @type {Array}
         */
        var header = [
            {
                "key": "id",
                "name": "Nro. Orden"
            },{
                "key": "estadoOrdenCompra",
                "name": "Estado"
            },{
                "key": "fechaCreacion",
                "name": "Fecha de creación"
            }, {
                "key": "usuarioCreacion",
                "name": "Usuario creación"
            },
            {
                "key": "acciones",
                "name": "Acciones"
            }
        ];

        /**
         * Constructor / Entrypoint
         * @constructor
         */
        (function initialize() {
            // se hereda del controller base
            angular.extend(this, $controller('BaseListCtrl', {
                "$scope": $scope
            }));
            $scope.config.header = header;
            $scope.config.recurso = 'ordenes-compras';
            $scope.init = {
                'count': 5,
                'page': 1,
                'sortBy': "id",
                'sortOrder': 'DESC',
                'filterBase': 1
            };
        })();

        $scope.hide = function() {
            $mdDialog.hide();
        };

        $scope.cancel = function() {
            $mdDialog.cancel();
        };

        $scope.answer = function(answer) {
            $mdDialog.hide(answer);
        };
    }
]);
;app.controller('BuscadorProductosCtrl', ['$scope', 'ProductosService', '$controller', '$mdDialog',
    function ($scope, service, $controller, $mdDialog) {



        /**
         * Service utilizdo para recuperar los datos y realizar las operaciones.
         * @field
         * @type {Object}
         */
        $scope.service = service;

        $scope.uri = "/productos/";
        $scope.nombre= 'Productos';

        /**
         * Configuraciones de la cabecera de la grilla.
         * @private
         * @type {Array}
         */
        var header = [
            {
                "key": "descripcion",
                "name": "Producto"
            },
            {
                "key": "precioVenta",
                "name": "Precio Venta"
            },
            {
                "key": "idTipoProducto",
                "name": "Tipo Producto"
            },
            {
                "key": "tipoIva",
                "name": "Tipo Iva"
            },
            {
                "key": "acciones",
                "name": "Acciones"
            }
        ];

        /**
         * Constructor / Entrypoint
         * @constructor
         */
        (function initialize() {
            // se hereda del controller base
            angular.extend(this, $controller('BaseListCtrl', {
                "$scope": $scope
            }));
            $scope.config.header = header;
            $scope.config.recurso = 'productos';
            $scope.init = {
                'count': 5,
                'page': 1,
                'sortBy': "id",
                'sortOrder': 'DESC',
                'filterBase': 1
            };
        })();

        $scope.hide = function() {
            $mdDialog.hide();
        };

        $scope.cancel = function() {
            $mdDialog.cancel();
        };

        $scope.answer = function(answer) {
            $mdDialog.hide(answer);
        };
    }
]);
;app.controller('ConfirmCtrl', ['$scope', '$controller', '$mdDialog','locals',
    function ($scope, $controller, $mdDialog, locals) {
        $scope.data = locals;

        $scope.hide = function() {
            $mdDialog.hide();
        };

        $scope.cancel = function() {
            $mdDialog.cancel();
        };

        $scope.answer = function(answer) {
            $mdDialog.hide(true);
        };
    }
]);
;app.controller('DialogCtrl', ['$scope', '$controller', '$mdDialog','locals',
    function ($scope, $controller, $mdDialog, locals) {
        $scope.data = locals;

        $scope.cancel = function() {
            $mdDialog.cancel();
        };
        $scope.hide = function() {
            $mdDialog.hide();
        };

    }
]);
;app.controller('EmisionAutomaticaCtrl', ['$scope', 'PropuestaService', '$controller', '$mdDialog', '$window','$location','UtilsService','$http','$rootScope',
    function ($scope, PropuestaService, $controller, $mdDialog, $window, $location, UtilsService,$http,$rootScope) {

        /**
         * Service utilizdo para recuperar los datos y realizar las operaciones.
         * @field
         * @type {Object}
         */
        $scope.service = PropuestaService;
        $scope.verificado = {
            valor: 'N'
        };
        $scope.emision= {
            valor: 'N'
        };
        $scope.habilitar = true;
        $scope.mensaje=undefined;
        $scope.estado=undefined;
        $scope.cargando=false;

      
        $scope.nombre="Nombre Modal";

        $scope.verificar = function(){
            $scope.cargando=true;
            PropuestaService.verificar($scope.numeroCotizacion, $scope.numeroPropuesta, $scope.verificado.valor,$scope.pathModule).then(function(response){
                if (!response.data.error)
                {
                    $scope.cargando=false;
                    if (response.data.dato !=null)
                    {
                        $scope.verificado.valor=response.data.dato.marcaVerificado;
                        $scope.verificado.verificadopor= sessionStorage.getItem("usuarioLogueado");


                    }

                    /*if ($scope.verificado.valor == "N"){
                        $scope.verificado = {
                            valor: 'S',
                            verificadopor: sessionStorage.getItem("usuarioLogueado")
                        };
                        if ($scope.emision.valor == "S") $scope.habilitar = true;
                    }*/
                }
                else
                {
                    $scope.cargando=false;
                    Message.error(response.data.mensaje);
                }

            });
        };
        $scope.borrar = function(){
            PropuestaService.borrar($scope.numeroCotizacion, $scope.numeroPropuesta).then(function(response){

                $scope.verificado = {
                  valor: 'N'
                };
                $scope.habilitar = false;
               /*if (!response.data.error){
                   $scope.verificarRespuesta = response.data;
               }else{
                   Message.error("No se pudo verificar.");
               }*/
            });
        };

        $scope.emisionNocturna = function(){
            $scope.cargando=true;
            PropuestaService.emisionNocturna($scope.numeroCotizacion, $scope.numeroPropuesta, $scope.emision.valor, $scope.pathModule).then(function(response){
                if (!response.data.error)
                {
                    $scope.cargando=false;
                    if (response.data.dato !=null)
                    {
                        $scope.emision.valor=response.data.dato.marcaEmisNocturna;
                    }
                    if ($scope.emision.valor=="S")
                    {
                        $scope.habilitar=false;
                    }
                    else
                    {
                        $scope.habilitar=true;
                    }
                    /*if ($scope.emision.valor == "N"){
                        $scope.emision = {
                            valor: 'S',
                            versionCotizador: sessionStorage.getItem("usuarioLogueado")
                        };
                    }else{
                        $scope.habilitar = false;
                    }*/
                }
                else
                {
                    $scope.cargando=false;
                    Message.error(response.data.mensaje);
                }

                
               /*if (!response.data.error){
                   $scope.emisionNocturnaRespuesta = response.data;
                   //console.log("descripcion: " + JSON.stringify($scope.confirmacion));
               }else{
                   Message.error("No se pudo obtener emision nocturna.");
               }*/
            });
        };
        $scope.quitarEmisionNocturna = function(){
            PropuestaService.quitarEmisionNocturna($scope.numeroCotizacion, $scope.numeroPropuesta).then(function(response){
                $scope.emision = {
                    valor: 'N'
                };
                $scope.habilitar=false;
               /*if (!response.data.error){
                   $scope.emisionNocturnaRespuesta = response.data;
                   //console.log("descripcion: " + JSON.stringify($scope.confirmacion));
               }else{
                   Message.error("No se pudo obtener emision nocturna.");
               }*/
            });
        };

        $scope.emisionAutomatica = function(){
            $scope.cargando=true;
            PropuestaService.emisionAutomatica($scope.numeroCotizacion, $scope.numeroPropuesta, $scope.pathModule).then(function(response){
                if (!response.data.error)
                {
                    $scope.cargando=false;
                    
                    Message.ok(response.data.mensaje);
                    //$scope.hide();
                    $scope.obtenerEmisionAutomatica();
                  
                }
                else {
                    $scope.cargando=false;
                    Message.error(response.data.mensaje);
                    $scope.obtenerEmisionAutomatica();
                     


                }
               // console.log("descripcion: " + JSON.stringify(response));
               

                    //console.log("EMISION AUTOMATICA EXITOSA.");
                    //$scope.hide();

            });
        };
        $scope.obtenerEmisionAutomatica=function()
        {
          PropuestaService.getEmisionAutomatica($scope.numeroPropuesta,  $scope.pathModule).then(function(response)
          {
              if (!response.data.error)
              {

                  if (response.data.dato !=null)
                  {
                      $scope.emision.valor=response.data.dato.marcaEmisNocturna ==null?"N":response.data.dato.marcaEmisNocturna;
                      if ($scope.emision.valor=="S")
                      {
                          $scope.habilitar=false;
                      }
                      $scope.verificado.valor=response.data.dato.marcaVerificado==null?"N":response.data.dato.marcaVerificado;
                      $scope.estado=response.data.dato.estadoEmision;
                      $scope.mensaje=response.data.dato.resultado==null || response.data.dato.resultado=="NULL"?undefined:response.data.dato.resultado;
                      $scope.verificado.verificadopor=response.data.dato.codigoUsuario;
                  }
              }
              else
              {
                  Message.error(response.data.mensaje);
              }
          });
        };
        $scope.verificarCamposForm=function(listaCampo, campo)
        {
            //console.log("LISTA: " + listaCampo);
            return UtilsService.verificarCamposForm(listaCampo, campo);
        };

        /**
         * Configuraciones de la cabecera de la grilla.
         * @private
         * @type {Array}
         */
        

        /**
         * Constructor / Entrypoint
         * @constructor
         */
        (function initialize() {
            // se hereda del controller base
            angular.extend(this, $controller('BaseListCtrl', {
                "$scope": $scope
            }));
            $scope.pathModule = UtilsService.retornarPath($location.path().split("/")[1]);
            $scope.numeroCotizacion = localStorage.getItem('numeroCotizacion');
            $scope.numeroPropuesta = localStorage.getItem('numeroPropuesta');
           // $scope.marcaFlota = localStorage.getItem('marcaFlota');
            $scope.obtenerEmisionAutomatica();
            //$scope.obtenerValidacion();
            //$scope.obtenerDescripcion();
             
        })();

        $scope.hide = function() {
            $mdDialog.hide();
        };

        $scope.cancelar = function() {
            $mdDialog.cancel();
        };

        $scope.answer = function(answer) {
            $mdDialog.hide(answer);
        };
    }
]);

;app.controller('EmisionValidacionCtrl', ['$scope', 'PropuestaService', '$controller', '$mdDialog','$location','UtilsService','$http','$rootScope',
    function ($scope, PropuestaService, $controller, $mdDialog, $location,UtilsService,$http,$rootScope) {

        $scope.estado = "VALIDACION";

        /**
         * Service utilizdo para recuperar los datos y realizar las operaciones.
         * @field
         * @type {Object}
         */
        $scope.service = PropuestaService;

      
        $scope.nombre="Nombre Modal";

        $scope.obtenerValidacion = function(){
            $scope.cargando=true;
            PropuestaService.getValidacionEmision($scope.numeroCotizacion, $scope.pathModule).then(function(response){
                
               if (!response.data.error){
                   $scope.validacion = response.data.dato;
               }else{
                   Message.error(response.data.mensaje);
               }
               $scope.cargando=false;
            });
        };

        

        $scope.emitir = function(){
            $scope.estado = "CONFIRMACION";
            PropuestaService.getDescripcionEmision($scope.numeroCotizacion, $scope.pathModule).then(function(response){
                
               if (!response.data.error){
                   $scope.confirmacion = response.data.dato[0];
                   //console.log("descripcion: " + JSON.stringify($scope.confirmacion));
               }else{
                   Message.error(response.data.mensaje);
               }
            });
        };

        $scope.aceptar = function(){
            $scope.cargando=true;
            PropuestaService.emision($scope.numeroCotizacion,$scope.pathModule).then(function(response){
               // console.log("descripcion: " + JSON.stringify(response));
                $scope.cargando=false;
               if (!response.data.error){
                   Message.ok(response.data.mensaje);
                   $scope.hide();
                   // $location.url('propuesta-vehiculo/propuesta/'+$scope.numeroCotizacion);

               }else{
                   Message.error(response.data.mensaje);
                   
               }
            });
        };

        /**
         * Configuraciones de la cabecera de la grilla.
         * @private
         * @type {Array}
         */
        

        /**
         * Constructor / Entrypoint
         * @constructor
         */
        (function initialize() {
            // se hereda del controller base
            angular.extend(this, $controller('BaseListCtrl', {
                "$scope": $scope
            }));
            $scope.pathModule = UtilsService.retornarPath($location.path().split("/")[1]);
            $scope.numeroCotizacion = localStorage.getItem('numeroCotizacion');
            $scope.obtenerValidacion();
            //$scope.obtenerDescripcion();
             
        })();

        $scope.hide = function() {
            $mdDialog.hide();
        };

        $scope.cancelar = function() {
            $scope.estado = "VALIDACION";
            //$mdDialog.cancel();
        };
         $scope.close = function() {
           
            $mdDialog.cancel();
        };

        $scope.answer = function(answer) {
            $mdDialog.hide(answer);
        };
    }
]);

;app.controller('ModalAutorizacionCtrl', ['$scope', 'ModalAutorizacionService', '$controller', '$rootScope','$mdDialog','CotizacionVehiculoService','ConfirmService','$location','UtilsService',
    function ($scope, ModalAutorizacionService, $controller, $rootScope, $mdDialog,CotizacionVehiculoService,ConfirmService,$location , UtilsService) {
$scope.mostrarDescComercial=undefined;
$scope.mostarSumaAsegurada=undefined;
$scope.mostarBonus=undefined;
$scope.mostarMalus=undefined;
$scope.mostarCartaVerde=undefined;
$scope.mostarDescEspecial=undefined;
$scope.titulo="Autorizacion de ";
$scope.codigoCampo=null;
$scope.valorCampo=undefined;
$scope.valor=undefined;
$scope.listaDesctEspc=[];
$scope.itemsByPage=5;
$scope.datosDescuentoEspecial=[];
$scope.mostrarConfirmar=true;
$scope.habDescEspecial=true;

$scope.guardarAutorizacion=function(){
        $scope.pathModule = UtilsService.retornarPath($location.path().split("/")[1]);
        $scope.visible=true;
        $scope.cargandoAutorizacion=true;
        var param ={};
        param.numeroCotizacion=$rootScope.numCotiza;
        param.codigoCampo=$scope.codigoCampo;
        param.valorCampo=$scope.valorCampo;
        if( $scope.mostrarFlotaSumaAsegurada==true){
            param.numeroRiesgo=$rootScope.numeroRiesgoFlota;
        }
        if( $scope.mostarDescEspecial==true){
            param.codigoDescuento =$scope.valorCampo;
            param.valorCampo=$scope.desctEspecialPorct;
        }
        param.marcaModulo=$scope.pathModule.split("marcaModulo=")[1];
        if ($rootScope.flagVehiculoFlota==true){
          
          ModalAutorizacionService.guardarAutorizacionVehiculo(param).then(

                function (response) {

                      if (!response.data.error) {
                          $scope.cargandoAutorizacion=false;

                          Message.ok(response.data.mensaje);
                         // $scope.buscaCancela();
                         $scope.answer('');

                      }else{
                          $scope.cargandoAutorizacion=false;
                          $scope.mostrarConfirmar=true;
                          Message.error(response.data.mensaje);
                          
                      }


                },
                function(response){
                   $scope.cargandoAutorizacion=false;
                   Message.error(response.data.mensaje);
                   
                });


        }else if ($rootScope.flagHogar==true) {

                ModalAutorizacionService.guardarAutorizacionHogar(param).then(

                function (response) {

                      if (!response.data.error) {
                          $scope.cargandoAutorizacion=false;

                          Message.ok(response.data.mensaje);
                         // $scope.buscaCancela();
                         $scope.answer('');

                      }else{
                          $scope.cargandoAutorizacion=false;
                          $scope.mostrarConfirmar=true;
                          Message.error(response.data.mensaje);
                          
                      }


                },
                function(response){
                   $scope.cargandoAutorizacion=false;
                   Message.error(response.data.mensaje);
                   
                });

        

      }else if ($scope.pathModule.indexOf("multiriesgo")>0) {

                ModalAutorizacionService.guardarAutorizacionMultiriesgos(param).then(

                function (response) {

                      if (!response.data.error) {
                          $scope.cargandoAutorizacion=false;

                          Message.ok(response.data.mensaje);
                         // $scope.buscaCancela();
                         $scope.answer('');

                      }else{
                          $scope.cargandoAutorizacion=false;
                          $scope.mostrarConfirmar=true;
                          Message.error(response.data.mensaje);
                          
                      }


                },
                function(response){
                   $scope.cargandoAutorizacion=false;
                   Message.error(response.data.mensaje);
                   
                });


        }else{

              ModalAutorizacionService.guardarAutorizacionFlota(param).then(

                function (response) {

                      if (!response.data.error) {
                          $scope.cargandoAutorizacion=false;

                          Message.ok(response.data.mensaje);
                         // $scope.buscaCancela();
                         if($scope.mostrarFlotaSumaAsegurada==true){
                              $scope.answer($scope.valorCampo);
                         }else{
                              $scope.answer('');
                         }
                        

                      }else{
                          $scope.cargandoAutorizacion=false;
                          $scope.mostrarConfirmar=true;
                          Message.error(response.data.mensaje);
                          
                      }


                },
                function(response){
                   $scope.cargandoAutorizacion=false;
                   Message.error(response.data.mensaje);
                   
                });
        }

        




};

$scope.cargarDescuentoEspecial = function() {
        var parametros = {};
        parametros.numeroCotizacion=$rootScope.numCotiza;
        parametros.esNuevo= $rootScope.autEsNuevo;
        parametros.pathModule = $scope.pathModule;
        CotizacionVehiculoService.getDescuentosEspeciales(parametros).then(
            function (response) {
                if (response.data.error== false && response.data.dato != null)
                {
                    for(var i=0; i<response.data.dato.length; i++){

                        var objDatos = {
                            id:response.data.dato[i].COD_VALOR,
                            desct:response.data.dato[i].PCT_DESCUENTO,
                            editable:response.data.dato[i].MCA_EDITABLE
                        };

                        var obj = {
                            id:response.data.dato[i].COD_VALOR,
                            desct:response.data.dato[i].NOM_VALOR
                        };
                        $scope.listaDesctEspc.push(obj);
                        $scope.datosDescuentoEspecial.push(objDatos);

                    }
                }
                else
                {
                    Message.error(response.data.mensaje);
                }


            },
            function(response){
                Message.error(response.data.mensaje);
                
            });

};

$scope.recuperarAutorizaciones = function() {

      $scope.cargandoAutorizacion=true;
      var param ={};
      param.numeroCotizacion=$rootScope.numCotiza;
      $scope.pathModule = $scope.pathModule;
      ModalAutorizacionService.getRecuperarAutorizaciones(param, $scope.pathModule).then(

      function (response) {
           $scope.rowCollection=[];
           if(!response.data.error){
              if(!angular.isUndefined(response.data.dato) && response.data.dato != null){
                if(response.data.dato.length >0){

                  for(var i=0; i<response.data.dato.length; i++){
                                var objeto ={
                                numeroCotizacion :  response.data.dato[i].NUM_COTIZACION,
                                codCia:response.data.dato[i].COD_CIA,
                                codRamo : response.data.dato[i].COD_RAMO,
                                codUsuario : response.data.dato[i].COD_USR!=null? response.data.dato[i].COD_USR:"",
                                codUsuarioAut : response.data.dato[i].COD_USR_AUTORIZ!=null? response.data.dato[i].COD_USR_AUTORIZ:"",
                                codCampo : response.data.dato[i].COD_CAMPO!=null? response.data.dato[i].COD_CAMPO:"",
                                fechaActu : response.data.dato[i].FEC_ACTU!=null? response.data.dato[i].FEC_ACTU:"",
                                fechaAutorizacion : response.data.dato[i].FEC_AUTORIZ!=null? response.data.dato[i].FEC_AUTORIZ:"",
                                numeroRiesgo : response.data.dato[i].NUM_RIESGO!=null? response.data.dato[i].NUM_RIESGO:"",
                                valorCampo : response.data.dato[i].VAL_CAMPO!=null? response.data.dato[i].VAL_CAMPO:""

                                };
                                $scope.rowCollection.push(objeto);

                            }



                   $scope.cargandoAutorizacion=false;
                }else{
                  $scope.cargandoAutorizacion=false;
                }
              }else{
                $scope.cargandoAutorizacion=false;
              }
            }else{
                 $scope.cargandoAutorizacion=false;
            }


           // Message.ok(response.data.mensaje);

      },
      function(response){
         $scope.cargandoAutorizacion=false;
         Message.error(response.data.mensaje);
         
      });
};

$scope.eliminarAutorizacion=function(row){

          $scope.cargandoAutorizacion=true;//221367
          var param ={};
          param.numeroCotizacion=row.numeroCotizacion;
          param.codigoCampo=row.codCampo;
          param.numeroRiesgo = row.numeroRiesgo;
          param.marcaModulo=$location.path().split("/")[1];
          ModalAutorizacionService.eliminarAutorizacion(param).then(
          function (response) {
              if(!response.data.error){
                $scope.recuperarAutorizaciones();
                $scope.cargandoAutorizacion=false;
                Message.ok(response.data.mensaje);
                $scope.answer('');
                //$scope.cancelar();

               }else{
                 $scope.cargandoAutorizacion=false;
                 Message.error(response.data.mensaje);

               }
                
          },
          function(response){
             $scope.cargandoAutorizacion=false;
             Message.error(response.data.mensaje);
             
          });




};

$scope.confirmacion=function(){
   if( !angular.isUndefined($scope.valorCampo) && $scope.valorCampo!=null && $scope.valorCampo!="" ){
            $scope.visible=false;
            $scope.mostrarConfirmar=false;

      }else{
            $scope.visible=true;
            Message.error("No ha ingresado ningun valor.");
     }



};
$scope.cargarPorcentaje= function() {

      if(!angular.isUndefined($scope.valorCampo)&& $scope.valorCampo!=null && $scope.valorCampo!=""){

          for(var i=0; i<$scope.datosDescuentoEspecial.length; i++){
              if ($scope.datosDescuentoEspecial[i].id==$scope.valorCampo){
                  $scope.desctEspecialPorct=$scope.datosDescuentoEspecial[i].desct;
                  $scope.habDescEspecial=$scope.datosDescuentoEspecial[i].editable=="S"?true:false;
                   break;
              }
          }
          for(var i=0; i<$scope.listaDesctEspc.length; i++){
              if ($scope.listaDesctEspc[i].id==$scope.valorCampo){
                  $scope.nombreDescEspecial=$scope.listaDesctEspc[i].desct;
                  break;
              }
          }



      }else{
          $scope.desctEspecialPorct=null;
      }
};

(function initialize() {

 $scope.pathModule = UtilsService.retornarPath($location.path().split("/")[1]);
  $scope.codigoCampo=null;
  $scope.cargandoAutorizacion=false;
  $scope.visible=true;
	//vehiculos
	$scope.mostrarDescComercial=false;
	$scope.mostarSumaAsegurada=false;
	$scope.mostarBonus=false;
	//$scope.mostarMalus=false;
	$scope.mostarCartaVerde=false;
	$scope.mostarDescEspecial=false;
  $scope.mostarGrid=false;
  $scope.mostrarGuardar= true;
  //flota
  $scope.mostrarTasaFlota= false;
  $scope.mostrarFlotaSumaAsegurada= false;
  $scope.mostrarIva = false;
  $scope.mostrarCambio=false;
  $scope.mostrarEliminar=false;

  if (!angular.isUndefined($rootScope.botonEliminar)) {
      if ($rootScope.botonEliminar==true){
         $scope.mostrarEliminar=true;
      }else{
         $scope.mostrarEliminar=false;
      }
  }

  if(!angular.isUndefined($rootScope.modalCotizadorVehFlota) && $rootScope.modalCotizadorVehFlota!=null){
     var valor = $rootScope.modalCotizadorVehFlota;
      $scope.valorCampo=undefined;
    //pantalla cotizador vehiculos
    switch(valor) {
      case "descuentoComercial":
             $scope.mostrarDescComercial=true;
             $scope.codigoCampo=valor;
             $scope.titulo+= "Descuento Comercial";
             break;
	    case "sumaAsegurada":
	        $scope.mostarSumaAsegurada=true;
	        $scope.codigoCampo=valor;
            $scope.titulo+= "Suma Asegurada";
	        break;
	    case "bonusMalus":
	        $scope.mostarBonus=true;
	        $scope.codigoCampo=valor
          $scope.titulo+= "Bonus/Malus";
	        break;
        /*case "malus":
	       $scope.mostarMalus=true;
	       $scope.codigoCampo=valor;
            $scope.titulo+= "Malus";
	        break;*/
	    case "cartaVerde":
	        $scope.mostarCartaVerde=true;
	        $scope.codigoCampo=valor;
            $scope.titulo+= "Carta Verde";
	        break;
	    case "descuentoEspecial":
	       $scope.mostarDescEspecial=true;
	       $scope.codigoCampo=valor;
            $scope.titulo+= "Decuento Especial";
         $scope.cargarDescuentoEspecial();
	        break;
      case "listadoAutorizaciones":
         $scope.mostarGrid=true;
         $scope.mostrarGuardar= false;
         $scope.mostrarConfirmar=false;
         $scope.titulo= "Listado de Autorizaciones";
         $scope.recuperarAutorizaciones();
          break;
       //pantalla cotizacion flota    
      case "tasa":
          $scope.mostrarTasaFlota= true;
          $scope.codigoCampo=valor;
          $scope.titulo+= "Tasa";
          break;
	     case "FlotasumaAsegurada":
          $scope.mostrarFlotaSumaAsegurada= true;
          $scope.codigoCampo=valor;
          $scope.titulo+= "Suma Asegurada";
          break;

       case "iva":
          $scope.mostrarIva = true;
          $scope.codigoCampo=valor;
          $scope.valorCampo='N';
          $scope.titulo+= "Iva";
          break;
      case "cambio":
          $scope.mostrarCambio = true;
          $scope.codigoCampo=valor;
          $scope.titulo+= "Cambio";
          break;
     
}

}

 })();
  $scope.hide = function() {
       $mdDialog.hide();
  };

  $scope.cancelar = function() {
      
        $mdDialog.cancel();
  };
  $scope.buscaCancela=function()
  {   
      $scope.buscarCotizacion();

      //$scope.$parent.buscar();
      $mdDialog.cancel();
  }

  $scope.answer = function(answer) {
        $mdDialog.hide(answer);
  };

 }]);
;app.controller('ModaltFlotaCtrl', ['$scope', 'ModalFlotaService', '$controller', '$mdDialog',
    function ($scope, ModalFlotaService, $controller, $mdDialog) {



        /**
         * Service utilizdo para recuperar los datos y realizar las operaciones.
         * @field
         * @type {Object}
         */
        $scope.service = ModalFlotaService;

      
        $scope.nombre="Nombre Modal";

        /**
         * Configuraciones de la cabecera de la grilla.
         * @private
         * @type {Array}
         */
        

        /**
         * Constructor / Entrypoint
         * @constructor
         */
        (function initialize() {
            // se hereda del controller base
            angular.extend(this, $controller('BaseListCtrl', {
                "$scope": $scope
            }));
             
        })();

        $scope.hide = function() {
            $mdDialog.hide();
        };

        $scope.cancelar = function() {
            $mdDialog.cancel();
        };

        $scope.answer = function(answer) {
            $mdDialog.hide(answer);
        };
    }
]);

;    app.controller('ModalInformacionCotizacionCtrl', ['$scope', 'PropuestaService', '$controller', '$mdDialog', '$window','$location','UtilsService','$http','$rootScope',
    function ($scope, PropuestaService, $controller, $mdDialog, $window, $location, UtilsService,$http,$rootScope) {

        /**
         * Service utilizdo para recuperar los datos y realizar las operaciones.
         * @field
         * @type {Object}
         */
        $scope.service = PropuestaService;
        $scope.verificado = {
            valor: 'N'
        };
        $scope.emision= {
            valor: 'N'
        };
        $scope.habilitar = true;
        $scope.mensaje=undefined;
        $scope.estado=undefined;
        $scope.cargando=false;




        /**
         * Configuraciones de la cabecera de la grilla.
         * @private
         * @type {Array}
         */


        /**
         * Constructor / Entrypoint
         * @constructor
         */
        (function initialize() {
            // se hereda del controller base
            angular.extend(this, $controller('BaseListCtrl', {
                "$scope": $scope
            }));
            $scope.pathModule = UtilsService.retornarPath($location.path().split("/")[1]);
            $scope.numeroCotizacion = localStorage.getItem('numeroCotizacion');

        })();

        $scope.hide = function() {
            $mdDialog.hide();
        };

        $scope.cancelar = function() {
            $mdDialog.cancel();
        };

        $scope.answer = function(answer) {
            $mdDialog.hide(answer);
        };
    }
]);

;app.controller('RechazarCtrl', ['$scope', '$controller', '$mdDialog',
    function ($scope, $controller, $mdDialog ) {

        $scope.status = '  ';
        $scope.customFullscreen = false;
        $scope.recurso = {};

        $scope.hide = function() {
            $mdDialog.hide();
        };

        $scope.cancel = function() {
            $mdDialog.cancel();
        };

        $scope.answer = function(answer) {
            $mdDialog.hide($scope.recurso);
        };
    }
]);
;app.controller('ShowPdfCtrl', ['$scope', '$controller', '$mdDialog','locals',
    function ($scope, $controller, $mdDialog, locals) {
        console.log(locals);
        $scope.pdf = locals.pdf;
        $scope.hide = function() {
            $mdDialog.hide();
        };

        $scope.cancel = function() {
            $mdDialog.cancel();
        };

        $scope.answer = function(answer) {
            $mdDialog.hide(true);
        };
        $scope.init = function(){

            

        }
        $scope.init();
    }
]);
